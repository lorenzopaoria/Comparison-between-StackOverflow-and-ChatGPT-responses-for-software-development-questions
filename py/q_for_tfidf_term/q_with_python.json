[
    {
        "ID": "724",
        "Question": "When learning a new programming language you sometimes come across a language feature which  makes you wish you had it in your other programming languages that you know. What are some language feature which were at the time of learning very new to you and that you wish your other programming languages had.   An example of this is generators in Python or C#. Other examples may include list comprehensions in Python, template in C++ or LINQ in .NET or lazy evaluation in Haskell. What other semi-unique language features have you come across which were completely new and enlightening to you?  Are there other features of older programming languages which were unique and have fallen out of fashion? ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "come": 0.19757311837191735,
                    "completely": 0.11835800453061854,
                    "evaluation": 0.16738221827521255,
                    "example": 0.07845879042821755,
                    "examples": 0.1120265239866043,
                    "fallen": 0.18781235800753227,
                    "fashion": 0.1775972881413724,
                    "feature": 0.21293409673948696,
                    "features": 0.19831411590804915,
                    "generators": 0.1647278221087927,
                    "haskell": 0.13109452322471,
                    "include": 0.11835800453061854,
                    "know": 0.06513391048358275,
                    "language": 0.30564277764142056,
                    "languages": 0.25720160149884735,
                    "lazy": 0.15811795793472394,
                    "learning": 0.1869960066112542,
                    "linq": 0.15288680345124372,
                    "list": 0.10109597303316928,
                    "makes": 0.0929086556787962,
                    "net": 0.09364751984048987,
                    "new": 0.21748410575085753,
                    "older": 0.13878814426293826,
                    "programming": 0.27848425026610213,
                    "python": 0.21293409673948696,
                    "semi": 0.15625092154108253,
                    "template": 0.15288680345124372,
                    "time": 0.05898577358137643,
                    "unique": 0.28534346717016773,
                    "wish": 0.30577360690248745
                },
                "Max term": "wish",
                "Max score": 0.30577360690248745
            }
        ],
        "Best answer": "Practically anything in Haskell  Monads. Yes - the big scary word that makes increadibly easy parsers, IO, operations on Lists and other things so easy (once you notice common pattern) Arrows. The same for advanced users ;) Standard stuff like lambdas etc.  Currying functions Algebraic data types Pattern matching  And many more. PS. Yes. I am Haskell fanboy if anyone asked. ",
        "Best answer TF-IDF scores": [
            {
                "Scores": {
                    "advanced": 0.17233693628811037,
                    "asked": 0.13012886705762006,
                    "big": 0.12052929144399273,
                    "common": 0.12254952628273356,
                    "currying": 0.2316821307311474,
                    "data": 0.10964068209615122,
                    "easy": 0.2401952849412704,
                    "functions": 0.13897101089769065,
                    "haskell": 0.32343194867578007,
                    "io": 0.19505162381117436,
                    "like": 0.06690349826689108,
                    "lists": 0.17120669440596573,
                    "makes": 0.11461053755667532,
                    "matching": 0.21908099427097616,
                    "monads": 0.21429026453101227,
                    "notice": 0.16517266981640522,
                    "operations": 0.16906251832027847,
                    "parsers": 0.21908099427097616,
                    "pattern": 0.3157485436361116,
                    "practically": 0.192748479468489,
                    "ps": 0.192748479468489,
                    "scary": 0.21908099427097616,
                    "standard": 0.13072654367916453,
                    "stuff": 0.11967190668313607,
                    "things": 0.08895253494699298,
                    "types": 0.14317717995911192,
                    "users": 0.12254952628273356,
                    "word": 0.1564613818601072,
                    "yes": 0.26915237497198535
                },
                "Max term": "haskell",
                "Max score": 0.32343194867578007
            }
        ]
    },
    {
        "ID": "1750",
        "Question": "I work for a company that supports several languages: COBOL, VB6, C#, and Java. I use those languages for my primary work, but I often find myself coding some minor programs (e.g. scripts) in Python because I find it to be the best tool for that type of task. For example: an analyst gives me a complex CSV file to populate some DB tables, so I use Python to parse it and create a DB script. What's the problem? The main problem I see is that a few parts of these quick and dirty scripts are slowly gaining importance and:  My company does not support Python They're not version controlled (I back them up in another way) My coworkers do not know Python  The analysts have even started to reference them in emails (\"launch the script that exports...\"), so they are needed more often than I initially thought. I should add that these scripts are just utilities that are not part of the main project; they simply help to get trivial tasks done in less time. For my own small tasks they help a lot. In short, if I were a lottery winner to be in a accident, my coworkers would need to keep the project alive without those scripts; they would spend more time fixing CSV errors by hand, for example. Is this a common scenario? Am I doing something wrong? What should I do? ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "accident": 0.12065508815337664,
                    "add": 0.0692386975259538,
                    "analyst": 0.12065508815337664,
                    "analysts": 0.12065508815337664,
                    "best": 0.05392743632892542,
                    "cobol": 0.11573117976572854,
                    "coding": 0.06341919096328764,
                    "common": 0.06749204305011064,
                    "company": 0.12059722386555441,
                    "complex": 0.07836331231363655,
                    "controlled": 0.12065508815337664,
                    "coworkers": 0.21484265162945063,
                    "create": 0.0655614580992383,
                    "csv": 0.2551898944949422,
                    "db": 0.19245770431363585,
                    "dirty": 0.10615290869519672,
                    "emails": 0.10004813222040194,
                    "errors": 0.08336776578410124,
                    "example": 0.10660582010676121,
                    "file": 0.07010917994797007,
                    "fixing": 0.09368852525403834,
                    "gaining": 0.11191189970214452,
                    "gives": 0.08579222749329667,
                    "hand": 0.0718300233694976,
                    "help": 0.11649082493245502,
                    "importance": 0.10879132067163406,
                    "initially": 0.10004813222040194,
                    "java": 0.05964023082061611,
                    "know": 0.04425032495380811,
                    "languages": 0.11649082493245502,
                    "launch": 0.11573117976572854,
                    "lot": 0.05302639679366057,
                    "main": 0.14823103956141673,
                    "minor": 0.09555755833298274,
                    "need": 0.04671983861432228,
                    "needed": 0.07374342254978239,
                    "parse": 0.11191189970214452,
                    "parts": 0.08369379085124018,
                    "primary": 0.09254704912561941,
                    "problem": 0.11012586349227674,
                    "programs": 0.07548551463761712,
                    "project": 0.09885593761473781,
                    "python": 0.28932403734128204,
                    "quick": 0.08906229043042209,
                    "reference": 0.08402614689626234,
                    "scenario": 0.09555755833298274,
                    "script": 0.193855106379783,
                    "scripts": 0.40370423164865865,
                    "short": 0.07430464655047045,
                    "simply": 0.07134328539844924,
                    "slowly": 0.10386741228398597,
                    "small": 0.06467212567695532,
                    "spend": 0.07449588651222386,
                    "started": 0.07071511219831608,
                    "support": 0.06801074330591358,
                    "supports": 0.09491160248344514,
                    "tables": 0.10092605791216466,
                    "task": 0.07267333671678095,
                    "tasks": 0.1526411945138336,
                    "thought": 0.0733792428850955,
                    "time": 0.0801468737021571,
                    "tool": 0.07430464655047045,
                    "trivial": 0.08906229043042209,
                    "type": 0.07040946481699016,
                    "use": 0.0793330083946315,
                    "utilities": 0.1180166761769393,
                    "vb6": 0.1180166761769393,
                    "version": 0.06814291229095865,
                    "way": 0.04547583582441225,
                    "winner": 0.12377566718388709,
                    "work": 0.08465174688320003,
                    "wrong": 0.0696684054134957
                },
                "Max term": "scripts",
                "Max score": 0.40370423164865865
            }
        ],
        "Best answer": "You need to get the situation formalised as it shouldn't really have got to this point. However, these things happen so you need to explain to your boss that you created these scripts for personal use, but they've \"escaped\" into wider circulation. Admit (if necessary) that you were at fault for not bringing this to his attention sooner. At the very least the scripts should be put under source control \"just in case\" - then at least if you aren't available (for what ever reason) your co-workers will have access to the scripts. Then you either need to convince your boss that Python is the way to go for these or accept that you are going to have to re-write them in a supported language. If the cost of documenting the scripts and educating your co-workers in Python is lower than that of the re-write you might even win the argument. ",
        "Best answer TF-IDF scores": [
            {
                "Scores": {
                    "accept": 0.12310218192714056,
                    "access": 0.10140866977087491,
                    "admit": 0.149604978050475,
                    "argument": 0.12966222686287268,
                    "attention": 0.13429217417844405,
                    "available": 0.09788915874098644,
                    "boss": 0.2425344203871233,
                    "bringing": 0.1459767514292135,
                    "case": 0.08639485644470327,
                    "control": 0.09352534463836713,
                    "convince": 0.14283383857253765,
                    "cost": 0.10297837689533106,
                    "created": 0.11601510638092648,
                    "documenting": 0.15389625932624332,
                    "explain": 0.10192036130767818,
                    "fault": 0.15389625932624332,
                    "going": 0.07748397846117624,
                    "got": 0.09444847800195048,
                    "happen": 0.11293110940904617,
                    "language": 0.07138636261765198,
                    "lower": 0.1323296309472673,
                    "necessary": 0.10743254382938988,
                    "need": 0.19274112274582897,
                    "personal": 0.10647172129252301,
                    "point": 0.08030206027636455,
                    "python": 0.19893276406930843,
                    "really": 0.0660918881658763,
                    "reason": 0.09298835822144387,
                    "scripts": 0.555156076255162,
                    "situation": 0.1091265757185631,
                    "sooner": 0.149604978050475,
                    "source": 0.07969067827419539,
                    "supported": 0.14006159296207155,
                    "things": 0.06736759801562243,
                    "use": 0.05454760961759141,
                    "way": 0.06253634369301395,
                    "wider": 0.15914836313887848,
                    "win": 0.13429217417844405,
                    "workers": 0.30779251865248664,
                    "write": 0.1478425189811358
                },
                "Max term": "scripts",
                "Max score": 0.555156076255162
            }
        ]
    },
    {
        "ID": "4507",
        "Question": "Considering the fact that you don't have to get involved in setting up/buying a server or even buying a domain, do you think that fact alone is enough to choose one over the other? I don't necessarily want to work on Google App Engine, I just find it convenient when it comes to hosting/environment/etc. and wondering if that's a good enough reason to learn python. In any case, I'm not looking for a debate between python and ruby but more on Google App Engine and whether its value is enough to dictate the language you should learn. ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "app": 0.23984918109670178,
                    "buying": 0.39391995434155846,
                    "case": 0.1088166736837533,
                    "choose": 0.13880593248672238,
                    "comes": 0.13039352687714204,
                    "considering": 0.15505054943979768,
                    "convenient": 0.19101102501888662,
                    "debate": 0.1838616924591344,
                    "dictate": 0.22100028382185566,
                    "domain": 0.14276451679156774,
                    "engine": 0.32454562063238657,
                    "environment": 0.12557559701881138,
                    "fact": 0.25056123204038466,
                    "good": 0.07530848601498602,
                    "google": 0.2567429394421501,
                    "hosting": 0.174808547867882,
                    "involved": 0.13572884064872434,
                    "language": 0.0899130671211546,
                    "learn": 0.19949160784521325,
                    "looking": 0.10798621753885447,
                    "necessarily": 0.14859606148004076,
                    "python": 0.25056123204038466,
                    "reason": 0.1171213686713774,
                    "ruby": 0.14172422248240996,
                    "server": 0.12017061142722865,
                    "setting": 0.16029572145963233,
                    "think": 0.0759129533019374,
                    "value": 0.12617451326262977,
                    "want": 0.08303202006450736,
                    "wondering": 0.1374478929517372,
                    "work": 0.07331034845337059
                },
                "Max term": "buying",
                "Max score": 0.39391995434155846
            }
        ],
        "Best answer": "No. Google App Engine does provide a free/cheap infrastructure for hosting Python applications, but Ruby has virtually the same thing with Heroku (and Heroku has a lot less restrictions that GAE). Before using GAE, make sure to read very closely about the restrictions that Google puts on the platform, many of which can be significant barriers to the goal you're trying to achieve. Carlos Ble's blog post goes into much more depth about the many restrictions he's run into, but I'll give you a quick overview:  Python 2.7 only with no compiled extensions (major performance hit) 30 second request timeout (so much for easy large file uploads) and 10 second outside request timeout (so you can't query slow API's from your app) BigTable is stone age; no \"LIKE\" operators in your query and no single query can return more than 1,000 records Memcache has a 1 MB max value size Both BigTable and Memcache tend to die at a significant enough rate that it's productive to put code in your application to work around their failures  For a very small project, GAE is just fine; but if you're build something at a medium or large size, just be aware of the restrictions that may hamper you progress. For more information about what sort of quotas and limitations you may have to deal with, see the GAE docs:  http://code.google.com/appengine/docs/quotas.html http://code.google.com/appengine/docs/billing.html  Also see this response on Stack Overflow: https://stackoverflow.com/a/3068371/189079 ",
        "Best answer TF-IDF scores": [
            {
                "Scores": {
                    "000": 0.08087502668774224,
                    "10": 0.05784415147898885,
                    "30": 0.07071980120725369,
                    "achieve": 0.08087502668774224,
                    "age": 0.07877999893160954,
                    "api": 0.0684219222439949,
                    "app": 0.10995780371738668,
                    "application": 0.047166277011402004,
                    "applications": 0.055788804856362666,
                    "aware": 0.06474052072185588,
                    "barriers": 0.10131660954128027,
                    "billing": 0.10131660954128027,
                    "blog": 0.06726456132723285,
                    "build": 0.0537963495008518,
                    "cheap": 0.08087502668774224,
                    "closely": 0.08638561319038926,
                    "code": 0.08797605153729558,
                    "com": 0.1838981740770291,
                    "compiled": 0.07877999893160954,
                    "deal": 0.06077323099646977,
                    "depth": 0.0781477556999868,
                    "die": 0.09189619969303628,
                    "docs": 0.25005875578465775,
                    "easy": 0.052519742936694994,
                    "engine": 0.07439325722868631,
                    "extensions": 0.09371099528250056,
                    "failures": 0.08529777047415868,
                    "file": 0.05567010734579557,
                    "fine": 0.06363497014830428,
                    "free": 0.05464604982877768,
                    "gae": 0.3931356597831077,
                    "goal": 0.06698999080554162,
                    "goes": 0.06147940430289459,
                    "google": 0.23540534607556388,
                    "hit": 0.07587736062591469,
                    "hosting": 0.08014021105549768,
                    "html": 0.12769800516143706,
                    "http": 0.12562206867446837,
                    "https": 0.08247578984479227,
                    "information": 0.056151247097338465,
                    "infrastructure": 0.08087502668774224,
                    "large": 0.10800769266784671,
                    "like": 0.02925748131485494,
                    "limitations": 0.08335291859488592,
                    "lot": 0.042105544578535686,
                    "major": 0.06406645967702167,
                    "make": 0.03633607827586086,
                    "max": 0.09580602303863325,
                    "mb": 0.09580602303863325,
                    "medium": 0.08014021105549768,
                    "operators": 0.08247578984479227,
                    "outside": 0.06569465125623947,
                    "overflow": 0.07263716919733978,
                    "overview": 0.08335291859488592,
                    "performance": 0.059619381455149334,
                    "platform": 0.060602275552800955,
                    "post": 0.0622242909089762,
                    "productive": 0.06872734585174281,
                    "progress": 0.07263716919733978,
                    "project": 0.03924821730097177,
                    "provide": 0.05870280194129892,
                    "puts": 0.09189619969303628,
                    "python": 0.11486869642792398,
                    "query": 0.23444326709996044,
                    "quick": 0.07071980120725369,
                    "rate": 0.07263716919733978,
                    "read": 0.04788003798634318,
                    "records": 0.08638561319038926,
                    "request": 0.1429092336789965,
                    "response": 0.07487017558601256,
                    "restrictions": 0.3502726621929232,
                    "return": 0.06474052072185588,
                    "ruby": 0.06497284738044232,
                    "run": 0.051097187682519196,
                    "second": 0.12562206867446837,
                    "significant": 0.1550872432755738,
                    "single": 0.053899701927219025,
                    "size": 0.1362464235790858,
                    "slow": 0.07108224344822947,
                    "small": 0.051352821148225786,
                    "sort": 0.05798354530167663,
                    "stack": 0.0618467450043924,
                    "stackoverflow": 0.0684219222439949,
                    "sure": 0.04835457721393535,
                    "tend": 0.059619381455149334,
                    "thing": 0.044900745339983755,
                    "trying": 0.05152595442677968,
                    "using": 0.038360061549404065,
                    "value": 0.05784415147898885,
                    "virtually": 0.08638561319038926,
                    "work": 0.03360880728810542
                },
                "Max term": "gae",
                "Max score": 0.3931356597831077
            }
        ]
    },
    {
        "ID": "5427",
        "Question": "Other than being annoyed at whitespace as syntax, I'm not a hater, I just don't get the fascination with Python. I appreciate the poetry of Perl, and have programmed beautiful web services in bash & korn, and shebang gnuplot.  I write documents in troff and don't mind REXX.  Didn't find tcl any more useful years ago, but what's the big stink about Python?  I see job listings and many candidates with this as a prize & trophy on their resumes.  I guess in reality, I'm trying to personally become sold on this, I just can't find a reason. ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "ago": 0.1626613437771884,
                    "annoyed": 0.2656646494611722,
                    "appreciate": 0.2033289423483812,
                    "bash": 0.2512152118203014,
                    "beautiful": 0.23301107329305584,
                    "big": 0.13820820734089945,
                    "candidates": 0.20491305639037843,
                    "documents": 0.20491305639037843,
                    "guess": 0.1679901610345499,
                    "job": 0.12607532721169165,
                    "mind": 0.1509545435234447,
                    "perl": 0.2065708761423789,
                    "personally": 0.160734566536589,
                    "programmed": 0.22366127721244058,
                    "python": 0.3011998931740073,
                    "reality": 0.21206429737868318,
                    "reason": 0.14079170765941385,
                    "resumes": 0.23676577417943057,
                    "services": 0.17161736018175494,
                    "sold": 0.2210203137832497,
                    "syntax": 0.1697576322517776,
                    "trying": 0.13510740916932765,
                    "useful": 0.14243677040462582,
                    "web": 0.1220556682417031,
                    "whitespace": 0.23301107329305584,
                    "write": 0.11192261649815485,
                    "years": 0.12941871786591286
                },
                "Max term": "python",
                "Max score": 0.3011998931740073
            }
        ],
        "Best answer": "I've found Python to be the most natural programming language that I've ever written code in. I've coded in a lot of languages before and after Python, and to a greater or lesser extent, you have to fight the language to get it to do what you want. Python reduces this struggle massively. Eric S Raymond said it much better than I can in Why Python? As a related point, Python maintains its cleanness even while evolving rapidly. In most languages I've worked with, introduction of new language features introduces a lot of wrinkles. But with Python, even major language features (decorators come to mind) are added all the time, without feeling like ugly hacks. ",
        "Best answer TF-IDF scores": [
            {
                "Scores": {
                    "added": 0.11406505199473559,
                    "better": 0.06913249876051185,
                    "code": 0.049522656861278457,
                    "coded": 0.1341580945250957,
                    "come": 0.08999431304502357,
                    "eric": 0.15248479017549416,
                    "evolving": 0.17109659734617338,
                    "extent": 0.13303830257606195,
                    "features": 0.18066367302742156,
                    "feeling": 0.12409962574075571,
                    "fight": 0.14234420616140156,
                    "greater": 0.13533533627191857,
                    "hacks": 0.16179069376083377,
                    "introduces": 0.16179069376083377,
                    "introduction": 0.14076073819512214,
                    "language": 0.27843982053504096,
                    "languages": 0.15620668527990525,
                    "lesser": 0.14787916047510657,
                    "like": 0.04940804397773842,
                    "lot": 0.14220995825684124,
                    "major": 0.10819107848538964,
                    "massively": 0.15825275341676762,
                    "mind": 0.097219591704018,
                    "natural": 0.1264356589060355,
                    "new": 0.06604249558018029,
                    "point": 0.07830379092048079,
                    "programming": 0.06342461718243181,
                    "python": 0.5819473190839658,
                    "rapidly": 0.16179069376083377,
                    "raymond": 0.17109659734617338,
                    "reduces": 0.15825275341676762,
                    "related": 0.10321822203496867,
                    "said": 0.09421233817584683,
                    "struggle": 0.1440450717352245,
                    "time": 0.053735895010702986,
                    "ugly": 0.1341580945250957,
                    "want": 0.06428270524425211,
                    "worked": 0.09246837177765188,
                    "written": 0.09209818339367243
                },
                "Max term": "python",
                "Max score": 0.5819473190839658
            }
        ]
    },
    {
        "ID": "7166",
        "Question": "Thoughts on these?  Python is one example, and no this is not a stab against Python I like the language.   What languages have a indentation requirement? ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "example": 0.19377951731977358,
                    "indentation": 0.40091843865649845,
                    "language": 0.1887210776522766,
                    "languages": 0.2117476869929516,
                    "like": 0.13395123278347934,
                    "python": 0.5259100511478172,
                    "requirement": 0.3427824907597199,
                    "stab": 0.46386374149733284,
                    "thoughts": 0.3067041812652606
                },
                "Max term": "python",
                "Max score": 0.5259100511478172
            }
        ],
        "Best answer": "In Makefiles, it's annoying. In python, I find it very apropos and it makes the syntax a lot cleaner. I think the thing that makes it better in python is that no special characters are required, the only requirement is that you be consistent. You should be doing it anyway, so you get no cost added by following it. ",
        "Best answer TF-IDF scores": [
            {
                "Scores": {
                    "added": 0.22977172477618746,
                    "annoying": 0.26584054352309766,
                    "better": 0.13925995035730637,
                    "characters": 0.26584054352309766,
                    "cleaner": 0.3022930381415893,
                    "consistent": 0.27261841462009967,
                    "cost": 0.20227682304212355,
                    "following": 0.19228024986758752,
                    "lot": 0.14323329897106482,
                    "makes": 0.34099448939773247,
                    "python": 0.39075666880852183,
                    "required": 0.2116726087321836,
                    "requirement": 0.25469097600020646,
                    "special": 0.240572364777264,
                    "syntax": 0.22023223907720538,
                    "thing": 0.1527419237936668,
                    "think": 0.11838819800702793
                },
                "Max term": "python",
                "Max score": 0.39075666880852183
            }
        ]
    },
    {
        "ID": "7705",
        "Question": "When dealing with complicated algorithms in languages with support for nested functions (such as Python and D) I often write huge functions (because the algorithm is complicated) but mitigate this by using nested functions to structure the complicated code.  Are huge (100+ line) functions still considered evil even if they're well-structured internally via the use of nested functions? Edit:  For those of you not familiar with Python or D, nested functions in these languages also allow access to the outer function scope.  In D this access allows mutation of variables in the outer scope.  In Python it only allows reading.  In D you can explicitly disable access to the outer scope in a nested function by declaring it static. ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "100": 0.07957691732943495,
                    "access": 0.2143728873223607,
                    "algorithm": 0.08504141798283442,
                    "algorithms": 0.08277627621450079,
                    "allow": 0.07689605229101559,
                    "allows": 0.16219914016622652,
                    "code": 0.0357866753028025,
                    "complicated": 0.2504924652717876,
                    "considered": 0.08277627621450079,
                    "dealing": 0.08719838389100411,
                    "declaring": 0.12363994104341718,
                    "disable": 0.11214390970645109,
                    "edit": 0.06655312929432816,
                    "evil": 0.10541916246721064,
                    "explicitly": 0.09779769590564148,
                    "familiar": 0.07987046954849093,
                    "function": 0.14186213691262484,
                    "functions": 0.44498125616965134,
                    "huge": 0.15583401281395218,
                    "internally": 0.10064787836948502,
                    "languages": 0.11288000847567442,
                    "line": 0.07042071226899062,
                    "mitigate": 0.11435856355938916,
                    "mutation": 0.11993904557634227,
                    "nested": 0.5509522328246813,
                    "python": 0.21026698759046197,
                    "reading": 0.07042071226899062,
                    "scope": 0.26903522305098027,
                    "static": 0.08208512340142898,
                    "structure": 0.08109957008311326,
                    "structured": 0.09964240280565104,
                    "support": 0.06590264327907228,
                    "use": 0.038436978470962,
                    "using": 0.046812025884637995,
                    "variables": 0.08242709979327849,
                    "write": 0.05208862275550644
                },
                "Max term": "nested",
                "Max score": 0.5509522328246813
            }
        ],
        "Best answer": "Always remember the rule, a functions does one thing and does it well! If you can do so, avoid nested functions. It hinders readability and testing. ",
        "Best answer TF-IDF scores": [
            {
                "Scores": {
                    "avoid": 0.2826712065998847,
                    "functions": 0.5604898239245145,
                    "nested": 0.41638129564134857,
                    "readability": 0.3695522851695883,
                    "remember": 0.2896418784961262,
                    "rule": 0.33126572679581623,
                    "testing": 0.24393858619644057,
                    "thing": 0.2070517762265169
                },
                "Max term": "functions",
                "Max score": 0.5604898239245145
            }
        ]
    },
    {
        "ID": "10656",
        "Question": "I have always been fascinated with the newest and best technologies available.  I graduate from college this year, and over the course of the past few years, I have spent a lot of time learning new programming languages, web frameworks, Linux distributions, IDEs, etc., in an effort to find the best of each. I have installed and played around with Ubuntu, Gentoo, Debian, Arch Linux, SUSE, VectorLinux, Puppy Linux, Slackware, and Fedora, I have spend a good amount of time in Vim and Emacs, and have played around with Visual Studio, Eclipse, NetBeans, gedit, and several more obscure ones. I have played with all sorts of languages - I started with the common ones like C, Java, Visual Basic, but always heard that they were \"bad\" (for relative definitions of bad). I then discovered the scripting languages and have quite a bit of experience in PHP, Perl, Python, and Ruby. Then I heard that functional languages are where it's at, so I played around with Scheme, Lisp, Haskell, Erlang, and OCaml. I've played around with obscure languages like Forth and J. When I do web development, I go back and forth between frameworks and languages. Should I use plain PHP, Ruby on Rails, Django, CakePHP, CodeIgniter, Yii, Kohana, or make my own? I have a very broad and shallow knowledge of computer science. As soon as I have learned a useful amount of one technology, I see something else shiny and go after it. My progression often goes like this: \"Perl is better than PHP, but wait, Python is better than Perl. Oh, but now I see that Ruby has the power of Perl and it is cooler than Python. Well, now that I have seen a little of Ruby, it is too complicated. Python is cleaner. Oh, but it is too hard to deploy Python, so I should use PHP if I want to do real web development.\" And so on and so forth. What  technology should I use for projects? Should I just pick one language/framework/IDE and sort of forget about the other things that are available for a while? I don't have all that much in the way of completed projects, because I never stay with something long enough to finish it. ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "available": 0.09673197127558135,
                    "bad": 0.08803057324832927,
                    "basic": 0.05156884032152295,
                    "best": 0.0732819492293363,
                    "better": 0.07005862290629684,
                    "bit": 0.04534804630064572,
                    "broad": 0.07132321016911428,
                    "cakephp": 0.07726376599563003,
                    "cleaner": 0.07603849459956842,
                    "codeigniter": 0.0840993265753635,
                    "college": 0.06635232594825399,
                    "common": 0.045857441117866535,
                    "completed": 0.06686926982274537,
                    "complicated": 0.05854709376286505,
                    "computer": 0.047839682147247264,
                    "cooler": 0.08669433485653834,
                    "course": 0.044939958032034384,
                    "definitions": 0.06857416887690276,
                    "deploy": 0.06635232594825399,
                    "development": 0.07033387635114267,
                    "discovered": 0.07212555050920579,
                    "django": 0.07212555050920579,
                    "eclipse": 0.06215398539229122,
                    "effort": 0.05600388655761563,
                    "emacs": 0.07132321016911428,
                    "erlang": 0.07212555050920579,
                    "experience": 0.0391284390058593,
                    "fascinated": 0.08669433485653834,
                    "fedora": 0.08669433485653834,
                    "finish": 0.06797766262377335,
                    "forget": 0.05907579036429599,
                    "forth": 0.22479030539562134,
                    "framework": 0.04629967395804677,
                    "frameworks": 0.11040309243504824,
                    "functional": 0.05260653793634928,
                    "goes": 0.05260653793634928,
                    "good": 0.029542129952126645,
                    "graduate": 0.08018638248500086,
                    "hard": 0.04526527497388132,
                    "haskell": 0.06051333690110769,
                    "heard": 0.1081863068329923,
                    "ide": 0.05600388655761563,
                    "ides": 0.07132321016911428,
                    "installed": 0.06920293401983496,
                    "java": 0.04052253050158464,
                    "knowledge": 0.04568515171011834,
                    "language": 0.035271237729554934,
                    "languages": 0.2374489304381636,
                    "learned": 0.0527626385662583,
                    "learning": 0.04315875319914082,
                    "like": 0.07510489820927627,
                    "linux": 0.16993258335952435,
                    "lisp": 0.0632623781933192,
                    "little": 0.043941449409026015,
                    "long": 0.03988222260602548,
                    "lot": 0.036028763670000206,
                    "make": 0.03109196164067635,
                    "netbeans": 0.06857416887690276,
                    "new": 0.03346361245867088,
                    "newest": 0.08669433485653834,
                    "obscure": 0.1459747520072693,
                    "ocaml": 0.08197905042608418,
                    "oh": 0.14425110101841157,
                    "ones": 0.1004613239933277,
                    "past": 0.055595798289004295,
                    "perl": 0.26964106431500656,
                    "php": 0.1934639425511627,
                    "pick": 0.05324392058417148,
                    "plain": 0.06920293401983496,
                    "played": 0.40989525213042094,
                    "power": 0.0632623781933192,
                    "programming": 0.032137138233301485,
                    "progression": 0.08197905042608418,
                    "projects": 0.07894826867482829,
                    "python": 0.24572637393178434,
                    "quite": 0.04657331769670734,
                    "rails": 0.06448764958938083,
                    "real": 0.043941449409026015,
                    "relative": 0.06986764763750357,
                    "ruby": 0.22238319315601718,
                    "scheme": 0.06797766262377335,
                    "science": 0.05854709376286505,
                    "scripting": 0.06797766262377335,
                    "seen": 0.04858336247737971,
                    "shallow": 0.07863350288074326,
                    "shiny": 0.08669433485653834,
                    "soon": 0.056644194453174784,
                    "sort": 0.04961521033236593,
                    "sorts": 0.06920293401983496,
                    "spend": 0.05061619970106939,
                    "spent": 0.0568657120520445,
                    "started": 0.04804735413580415,
                    "stay": 0.05907579036429599,
                    "studio": 0.05854709376286505,
                    "technologies": 0.0553970016136439,
                    "technology": 0.10648784116834296,
                    "things": 0.0332856091520561,
                    "time": 0.054455760642020304,
                    "ubuntu": 0.08018638248500086,
                    "use": 0.08085417028624226,
                    "useful": 0.04648138581624602,
                    "vim": 0.07298737600363465,
                    "visual": 0.11119159657800859,
                    "wait": 0.06635232594825399,
                    "want": 0.032571929894396494,
                    "way": 0.03089853809960094,
                    "web": 0.11949126459030018,
                    "year": 0.05308127006824481,
                    "years": 0.0422332052312106
                },
                "Max term": "played",
                "Max score": 0.40989525213042094
            }
        ],
        "Best answer": "Stop bikeshedding and start programming. This might sound cliche, but it's true: good tools don't make bad programmers good, and bad tools don't make good programmers bad (despite what Dijkstra says). You can spend 90% of your time bikeshedding over technology X vs. technology Y and get nowhere. Or you can choose X (or Y, it doesn't matter) and use it to do real work and get useful experience.  Just pick a set of tools and master them, even if they have some drawbacks. Once you really master your tools (that is, do more than half a dozen projects in them), you can play with others to try them out. In fact, it's recommended that you do so; you don't want to be a zealot who sees all other opinions as wrong. And sometimes, you might decide that another tool is indeed worth it over your current tool. If you can't decide what to choose on your own, a good way to end your inner debate is to let others choose for you. For example: Python, Django, jQuery, Vim and Debian. Now go and learn them. ",
        "Best answer TF-IDF scores": [
            {
                "Scores": {
                    "90": 0.12089606799193643,
                    "bad": 0.2458751731241644,
                    "choose": 0.30417047776514566,
                    "current": 0.09151065363199036,
                    "debate": 0.1343009332912885,
                    "decide": 0.20278031851009712,
                    "despite": 0.12768810518357154,
                    "dijkstra": 0.14641902557817066,
                    "django": 0.1343009332912885,
                    "dozen": 0.14641902557817066,
                    "drawbacks": 0.1415870065280572,
                    "end": 0.07817185797162904,
                    "example": 0.06743697045424943,
                    "experience": 0.07285886679017359,
                    "fact": 0.09151065363199036,
                    "good": 0.22003495826221736,
                    "half": 0.11325596549547794,
                    "inner": 0.14386851551986993,
                    "jquery": 0.11853143295800372,
                    "learn": 0.07285886679017359,
                    "let": 0.0870680332195729,
                    "make": 0.1157891880677378,
                    "master": 0.23017399433424388,
                    "matter": 0.0926100931720445,
                    "opinions": 0.11639978136275593,
                    "pick": 0.09914251157956558,
                    "play": 0.11853143295800372,
                    "programmers": 0.15050279575223877,
                    "programming": 0.05984075861566781,
                    "projects": 0.07350256663488162,
                    "python": 0.09151065363199036,
                    "real": 0.08182090291360626,
                    "really": 0.06080558840196459,
                    "recommended": 0.12552086720828443,
                    "says": 0.10352181085029635,
                    "sees": 0.14931055539899588,
                    "set": 0.08398092879644355,
                    "sound": 0.1314094034704633,
                    "spend": 0.09424958023223984,
                    "start": 0.07435933230343676,
                    "stop": 0.10588644588422907,
                    "technology": 0.19828502315913116,
                    "time": 0.05069950541574643,
                    "tool": 0.18801526029326873,
                    "tools": 0.338381106370704,
                    "true": 0.10007737505941455,
                    "try": 0.07618179762405704,
                    "use": 0.05018466850869597,
                    "useful": 0.08655037572292133,
                    "vim": 0.13590569009964382,
                    "vs": 0.1027876962296384,
                    "want": 0.060650359727341493,
                    "way": 0.05753443093073088,
                    "work": 0.053549209112091475,
                    "worth": 0.09306599016621984,
                    "wrong": 0.08814202062813281
                },
                "Max term": "tools",
                "Max score": 0.338381106370704
            }
        ]
    },
    {
        "ID": "12189",
        "Question": "I am looking into learning Python for web development. Assuming I already have some basic web development experience with Java (JSP/Servlets), I'm already familiar with web design (HTML, CSS, JS), basic programming concepts and that I am completely new to Python, how do I go about learning Python in a structured manner that will eventually lead me to web development with Python and Django? I'm not in a hurry to make web applications in Python so I really want to learn it thoroughly so as not to leave any gaps in my knowledge of the technologies involving web development in Python. Are there any books, resource or techniques to help me in my endeavor? In what order should I do/read them? UPDATE: When I say learning in a structured manner, I mean starting out from the basics then learning the advanced stuff without leaving some of the important details/features that Python has to offer. I want to know how to apply the things that I already know in programming to Python. ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "advanced": 0.09348106579843243,
                    "applications": 0.06919970379644579,
                    "apply": 0.08643895932101799,
                    "assuming": 0.0881694849794463,
                    "basic": 0.14950801233850422,
                    "basics": 0.099404869516444,
                    "books": 0.0733730617389632,
                    "completely": 0.0791974676220424,
                    "concepts": 0.08211122133451716,
                    "css": 0.09411728560395136,
                    "design": 0.05788855363094582,
                    "details": 0.07867061774518945,
                    "development": 0.20391147033284543,
                    "django": 0.10455293960674128,
                    "endeavor": 0.1256717971995978,
                    "eventually": 0.08603272703850892,
                    "experience": 0.056720444993532654,
                    "familiar": 0.08118303330320957,
                    "features": 0.06634944478790465,
                    "gaps": 0.11623789275850714,
                    "help": 0.05736751980519939,
                    "html": 0.0791974676220424,
                    "hurry": 0.11623789275850714,
                    "important": 0.06266282073497721,
                    "involving": 0.11623789275850714,
                    "java": 0.05874131503098546,
                    "js": 0.09771768019027477,
                    "jsp": 0.1256717971995978,
                    "know": 0.08716674105951312,
                    "knowledge": 0.06622503223823799,
                    "lead": 0.08059147001112912,
                    "learn": 0.056720444993532654,
                    "learning": 0.25025109603321966,
                    "leave": 0.08059147001112912,
                    "leaving": 0.09286798645497543,
                    "looking": 0.06140635566709844,
                    "make": 0.04507079619805244,
                    "manner": 0.19543536038054954,
                    "mean": 0.06995578674559512,
                    "new": 0.048508732726667385,
                    "offer": 0.0881694849794463,
                    "order": 0.07356354765231762,
                    "programming": 0.09317176088412682,
                    "python": 0.5699265140210026,
                    "read": 0.05938977282177148,
                    "really": 0.04733699800994122,
                    "resource": 0.09477846148207399,
                    "say": 0.05472704393041403,
                    "starting": 0.07790998539000384,
                    "structured": 0.20255978338707112,
                    "stuff": 0.06491386944565239,
                    "techniques": 0.08603272703850892,
                    "technologies": 0.08030329506277536,
                    "things": 0.0482506997711488,
                    "thoroughly": 0.11200127836666479,
                    "update": 0.0733730617389632,
                    "want": 0.09443230575243058,
                    "web": 0.34642821807365554
                },
                "Max term": "python",
                "Max score": 0.5699265140210026
            }
        ],
        "Best answer": "First learn Python well Here are some online resources for learning Python  The Python Tutorial Wiki-Book Byte of Python Building Skills in Python Version 2.5 Python Free Online Ebooks  Python Bibliotheca Think Python Data Structures and Algorithms in Python How to Think Like a Computer Scientist: Learning with Python Python for Fun Invent Your Own Computer Games With Python Learn Python The Hard Way Thinking in Python Snake Wrangling For Kids  For Django you can refer  The Django book  What I suggest is   The Python Tutorial Wiki-Book The Django Book  Also check out this video ",
        "Best answer TF-IDF scores": [
            {
                "Scores": {
                    "algorithms": 0.06509194368308492,
                    "book": 0.2164840751979256,
                    "building": 0.06127080879858401,
                    "byte": 0.08185348516698578,
                    "check": 0.057993168766017435,
                    "computer": 0.10730197268190642,
                    "data": 0.046010752283423835,
                    "django": 0.2426609094073459,
                    "ebooks": 0.09722549077374666,
                    "free": 0.052439467107165766,
                    "fun": 0.06752539568068164,
                    "games": 0.07184695183370497,
                    "hard": 0.0507638541967808,
                    "invent": 0.09193741925618618,
                    "kids": 0.0866493477386257,
                    "learn": 0.08776309759687533,
                    "learning": 0.0968028872454752,
                    "like": 0.02807607748146671,
                    "online": 0.12909689766230117,
                    "python": 0.8267276290119359,
                    "refer": 0.07998716552501735,
                    "resources": 0.062126327841297936,
                    "scientist": 0.09431525501132149,
                    "skills": 0.054608626584975666,
                    "snake": 0.09722549077374666,
                    "structures": 0.0709471475562737,
                    "suggest": 0.06190712958753004,
                    "think": 0.06679334535891188,
                    "thinking": 0.05104433789070558,
                    "tutorial": 0.16177393960489725,
                    "version": 0.051923906339262485,
                    "video": 0.07281346719824212,
                    "way": 0.03465192432580783,
                    "wiki": 0.14562693439648425
                },
                "Max term": "python",
                "Max score": 0.8267276290119359
            }
        ]
    },
    {
        "ID": "12861",
        "Question": "I know python is not suitable for things like microcontrolers, make drivers etc, but besides that, you can do everything using python, companys get stuck with speed optimizations for real hard time system but does forget other factors which one you can just upgrade your hardware for speed proposes in order to get your python program fit in it, if you think how much cust can the company have to maintain  a system written in C, the comparison is like that: for example: 10 programmers to mantain a system written in c and just one programmer to mantain a system written in python, with python you can buy some better hardware to fit your python program, I think that low level languages tend to get more cost, since programmers aren't so cheaply than a hardware upgrade, then, this is my point, why should a system be written in c instead of python? ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "10": 0.08687585597133832,
                    "better": 0.061483866637168004,
                    "buy": 0.10789237100560074,
                    "company": 0.07191080131091017,
                    "comparison": 0.12036220179837921,
                    "cost": 0.08930608678088942,
                    "drivers": 0.1356142866443269,
                    "example": 0.06356788077336141,
                    "factors": 0.10568352335708875,
                    "fit": 0.1996227565427212,
                    "forget": 0.10369053417169603,
                    "hard": 0.07945015229634822,
                    "hardware": 0.30307297414307677,
                    "instead": 0.07805152824127996,
                    "know": 0.052771966446656916,
                    "languages": 0.06946220068548742,
                    "level": 0.07712655782349366,
                    "like": 0.08788334404790171,
                    "low": 0.10144520407255755,
                    "maintain": 0.09758241043818183,
                    "make": 0.054572983130431164,
                    "optimizations": 0.13151821132004604,
                    "order": 0.08907280509098425,
                    "point": 0.06964047191202499,
                    "program": 0.1529812417077183,
                    "programmer": 0.06946220068548742,
                    "programmers": 0.141867935525461,
                    "python": 0.6038226207777287,
                    "real": 0.07712655782349366,
                    "speed": 0.2113670467141775,
                    "stuck": 0.1139598470143812,
                    "suitable": 0.12146581790130631,
                    "tend": 0.08954206542867543,
                    "things": 0.058423299492459044,
                    "think": 0.10453779653091551,
                    "time": 0.04779070135902697,
                    "upgrade": 0.2452650623945288,
                    "using": 0.05761279398191556,
                    "written": 0.32763476089114946
                },
                "Max term": "python",
                "Max score": 0.6038226207777287
            }
        ],
        "Best answer": "The main reason is because the software was already written in C (or C++ or whatever) before Python became a legitimate choice. If it's a question of rewriting your million lines of C code into Python or continuing with the C code, then the choice is clear. If you spend 12 month rewriting the code in Python, then that's 12 months where you're not adding new features and you'll basically spend 12 months getting back to exactly where you were. Not to mention that fact that you'll probably have missed all those corner-case bugs that had been fixed over the years in the C version, but not really called out in the code so when your Python dev comes along to port it and says \"why does the code do this? That seems wierd... I'll just do it this other way\" he's actually forgetting about that customer from 6 years ago who lost 12 months worth of payroll because of this obscure bug in their RAID controller that was worked around with just that specific piece of code. It's basically the same answer people get when they ask \"Why doesn't Microsoft rewrite Windows or Office or (insert-product-here) in .NET? I thought .NET was the poster-child for all Microsoft development these days?\" Now, when it comes to developing new products, then Python (and all the other possible choices) become a more viable option. But  you've still to weigh the benefit of going with Python (or whatever) over C or C++, particularly when your new product may be interfacing with lots of existing code that you've already got written in C or C++. ",
        "Best answer TF-IDF scores": [
            {
                "Scores": {
                    "12": 0.36015921661025924,
                    "actually": 0.05412676666803614,
                    "adding": 0.07718411870290093,
                    "ago": 0.07147419395760259,
                    "answer": 0.056034101916043466,
                    "ask": 0.05977360825046269,
                    "basically": 0.14972003740781767,
                    "benefit": 0.07815302195556048,
                    "bug": 0.06664652137336208,
                    "bugs": 0.06664652137336208,
                    "called": 0.0716932036856611,
                    "case": 0.05747795320079428,
                    "child": 0.10588040243268777,
                    "choice": 0.14251641029967668,
                    "choices": 0.09407713478189363,
                    "clear": 0.06943769978695696,
                    "code": 0.23651532347097062,
                    "comes": 0.13775008519948673,
                    "continuing": 0.11324016120230804,
                    "controller": 0.10588040243268777,
                    "corner": 0.10588040243268777,
                    "customer": 0.07331855148091725,
                    "days": 0.0674665485320394,
                    "dev": 0.08067831025053751,
                    "developing": 0.06982435993328066,
                    "development": 0.047352457030968645,
                    "exactly": 0.0740703249778506,
                    "existing": 0.06982435993328066,
                    "fact": 0.0661743567488813,
                    "features": 0.06163084848968026,
                    "fixed": 0.08107476029420838,
                    "forgetting": 0.10403604490937311,
                    "getting": 0.05946756058743173,
                    "going": 0.05154960226889624,
                    "got": 0.06283597683800751,
                    "insert": 0.09953124851240203,
                    "legitimate": 0.10588040243268777,
                    "lines": 0.07540951158576809,
                    "lost": 0.0851831066475086,
                    "lots": 0.06780697368483128,
                    "main": 0.06780697368483128,
                    "mention": 0.08276927035538835,
                    "microsoft": 0.14251641029967668,
                    "million": 0.10238621088505119,
                    "missed": 0.08934373665638229,
                    "month": 0.07848978633912544,
                    "months": 0.21313546516979517,
                    "net": 0.11641281469645098,
                    "new": 0.13517676146320826,
                    "obscure": 0.09827786453175097,
                    "office": 0.084669652769582,
                    "option": 0.07459233799252857,
                    "particularly": 0.07991430798273917,
                    "payroll": 0.11038519882965886,
                    "people": 0.04330877260147282,
                    "piece": 0.08232814427485942,
                    "port": 0.10238621088505119,
                    "possible": 0.05652863586725697,
                    "probably": 0.05463782639561839,
                    "product": 0.13054141129726607,
                    "products": 0.07991430798273917,
                    "python": 0.39704614049328774,
                    "question": 0.04618534842171727,
                    "really": 0.043970516432095624,
                    "reason": 0.06186456835531353,
                    "rewrite": 0.08934373665638229,
                    "rewriting": 0.19655572906350194,
                    "says": 0.07486001870390883,
                    "software": 0.04563287260046491,
                    "specific": 0.05946756058743173,
                    "spend": 0.13630992891389965,
                    "thought": 0.06713336702008295,
                    "version": 0.06234274109109725,
                    "viable": 0.09711741222028177,
                    "way": 0.04160503511498355,
                    "weigh": 0.11673435274994462,
                    "windows": 0.06602008022709419,
                    "worked": 0.06308854586667122,
                    "worth": 0.06729907163830363,
                    "written": 0.12567195367601502,
                    "years": 0.11373444148061602
                },
                "Max term": "python",
                "Max score": 0.39704614049328774
            }
        ]
    },
    {
        "ID": "15468",
        "Question": "Python seems all the rage these days, and not undeservingly - for it is truly a language with which one almost enjoys being given a new problem to solve. But, as a wise man once said (calling him a wise man only because I've no idea as to who actually said it; not sure whether he was that wise at all), to really know a language one does not only know its syntax, design, etc., advantages but also its drawbacks. No language is perfect, some are just better than others. So, what would be in your opinion, objective drawbacks of Python. Note: I'm not asking for a language comparison here (i.e. C# is better than Python because ... yadda yadda yadda) - more of an objective (to some level) opinion which language features are badly designed, whether, what are maybe some you're missing in it and so on. If must use another language as a comparison, but only to illustrate a point which would be hard to elaborate on otherwise (i.e. for ease of understanding) ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "actually": 0.07275383070077968,
                    "advantages": 0.11125330133970612,
                    "asking": 0.09333383398892624,
                    "badly": 0.13053918055195318,
                    "better": 0.12679827273719052,
                    "calling": 0.11449782983728626,
                    "comparison": 0.24822315390381924,
                    "days": 0.09068433516396522,
                    "design": 0.07227653648711206,
                    "designed": 0.11249176282005902,
                    "drawbacks": 0.2752423435344141,
                    "ease": 0.13561510474997981,
                    "elaborate": 0.1483729134751268,
                    "features": 0.08284035040303815,
                    "given": 0.08894745139994129,
                    "hard": 0.08192508564347271,
                    "idea": 0.07620859609604384,
                    "illustrate": 0.1483729134751268,
                    "know": 0.1088317075740974,
                    "language": 0.38302197524425674,
                    "level": 0.07952910941577127,
                    "man": 0.22761535418777198,
                    "maybe": 0.08621520608404729,
                    "missing": 0.11186342443202928,
                    "new": 0.06056539628221591,
                    "note": 0.09333383398892624,
                    "objective": 0.23667058510992,
                    "opinion": 0.19912144083687228,
                    "perfect": 0.11125330133970612,
                    "point": 0.0718098261708019,
                    "problem": 0.06771241671359186,
                    "python": 0.26684235419982383,
                    "really": 0.05910243129700333,
                    "said": 0.1727980611927907,
                    "solve": 0.09727422000643578,
                    "sure": 0.07488578769412531,
                    "syntax": 0.10026237782070459,
                    "truly": 0.12772864212826718,
                    "understanding": 0.0952119506250392,
                    "use": 0.04877900207281375,
                    "wise": 0.3872611027886392
                },
                "Max term": "wise",
                "Max score": 0.3872611027886392
            }
        ],
        "Best answer": "I use Python somewhat regularly, and overall I consider it to be a very good language.  Nonetheless, no language is perfect.  Here are the drawbacks in order of importance to me personally:  It's slow.  I mean really, really slow.  A lot of times this doesn't matter, but it definitely means you'll need another language for those performance-critical bits. Nested functions kind of suck in that you can't modify variables in the outer scope.  Edit:  I still use Python 2 due to library support, and this design flaw irritates the heck out of me, but apparently it's fixed in Python 3 due to the nonlocal statement.  Can't wait for the libs I use to be ported so this flaw can be sent to the ash heap of history for good. It's missing a few features that can be useful to library/generic code and IMHO are simplicity taken to unhealthy extremes.  The most important ones I can think of are user-defined value types (I'm guessing these can be created with metaclass magic, but I've never tried), and ref function parameter. It's far from the metal.  Need to write threading primitives or kernel code or something?  Good luck. While I don't mind the lack of ability to catch semantic errors upfront as a tradeoff for the dynamism that Python offers, I wish there were a way to catch syntactic errors and silly things like mistyping variable names without having to actually run the code. The documentation isn't as good as languages like PHP and Java that have strong corporate backings.  ",
        "Best answer TF-IDF scores": [
            {
                "Scores": {
                    "ability": 0.08005881389282288,
                    "actually": 0.05681432752123685,
                    "apparently": 0.09527518218880716,
                    "bits": 0.093080399467729,
                    "catch": 0.1956177457907426,
                    "code": 0.10639673079640743,
                    "consider": 0.06662694570355575,
                    "corporate": 0.09692019944796415,
                    "created": 0.08101654817697133,
                    "critical": 0.08835192604008671,
                    "defined": 0.08203356046352824,
                    "definitely": 0.07944998669906032,
                    "design": 0.05644160282044646,
                    "documentation": 0.0734981052794592,
                    "drawbacks": 0.10747000194114459,
                    "edit": 0.06595597682910587,
                    "errors": 0.16011762778564576,
                    "far": 0.06622108668878449,
                    "features": 0.06469101014253256,
                    "fixed": 0.08510037211923578,
                    "flaw": 0.22227538174540454,
                    "function": 0.07029463463511344,
                    "functions": 0.0734981052794592,
                    "generic": 0.09377992865338484,
                    "good": 0.1670150246934855,
                    "guessing": 0.10747000194114459,
                    "heap": 0.11333247359378044,
                    "heck": 0.11886288435745236,
                    "history": 0.08687901982960719,
                    "imho": 0.0978088728953713,
                    "importance": 0.10447328188403679,
                    "important": 0.06109653493988384,
                    "java": 0.057273049060207325,
                    "kernel": 0.10920175531167907,
                    "kind": 0.06444929321327615,
                    "lack": 0.07975158149039804,
                    "language": 0.14955319699148892,
                    "languages": 0.05593359247290382,
                    "library": 0.1427108382623961,
                    "libs": 0.11586616430034456,
                    "like": 0.07076699417267877,
                    "lot": 0.05092172487031245,
                    "luck": 0.0997448084563945,
                    "magic": 0.09692019944796415,
                    "matter": 0.07029463463511344,
                    "mean": 0.06820720993754463,
                    "means": 0.06263377178028666,
                    "metal": 0.11886288435745236,
                    "mind": 0.06962366576066355,
                    "missing": 0.0873554721739254,
                    "modify": 0.09114446390670582,
                    "names": 0.08037189869159349,
                    "need": 0.08973096087073147,
                    "nested": 0.10920175531167907,
                    "nonetheless": 0.11886288435745236,
                    "offers": 0.10315766352420905,
                    "ones": 0.0709941638207693,
                    "order": 0.07172479321431026,
                    "overall": 0.08388229977249939,
                    "parameter": 0.09874835459023319,
                    "perfect": 0.08687901982960719,
                    "performance": 0.07210265939524166,
                    "personally": 0.0741344346153486,
                    "php": 0.06835869907409026,
                    "ported": 0.11333247359378044,
                    "primitives": 0.11333247359378044,
                    "python": 0.27784047038289655,
                    "really": 0.09230757629297892,
                    "ref": 0.12253057328901006,
                    "regularly": 0.09377992865338484,
                    "run": 0.061796064125539674,
                    "scope": 0.08887376209008209,
                    "semantic": 0.11333247359378044,
                    "sent": 0.10315766352420905,
                    "silly": 0.10315766352420905,
                    "simplicity": 0.1008055929524791,
                    "slow": 0.17193129694755235,
                    "somewhat": 0.08784614905826033,
                    "statement": 0.08510037211923578,
                    "strong": 0.08349554181154943,
                    "suck": 0.10590344046323359,
                    "support": 0.06531132734372802,
                    "syntactic": 0.10920175531167907,
                    "taken": 0.08687901982960719,
                    "things": 0.04704465151528595,
                    "think": 0.042088894761991055,
                    "threading": 0.11333247359378044,
                    "times": 0.06820720993754463,
                    "tried": 0.07774814499276539,
                    "types": 0.07572263724841158,
                    "upfront": 0.11886288435745236,
                    "use": 0.11427630022624631,
                    "useful": 0.06569507524057956,
                    "user": 0.05916059937886064,
                    "value": 0.06995572664962749,
                    "variable": 0.08274830154750583,
                    "variables": 0.08168751705142123,
                    "wait": 0.09377992865338484,
                    "way": 0.043670853388534735,
                    "wish": 0.0997448084563945,
                    "write": 0.05162125405596829
                },
                "Max term": "python",
                "Max score": 0.27784047038289655
            }
        ]
    },
    {
        "ID": "15610",
        "Question": "In the Java world, we often talk about the JVM, and when Java was new it had the supposedly killer feature of \"Write Once, Run Anywhere.\" From the way people talk and write, this seems different from the way that Python, for example, works.  Yet I've not been aware of any way that Python code that I've written would work differently on another machine.  (Though I haven't written that much Python.) So what am I missing?  How is the JVM different from a Python interpreter?  Is there a way that Python lacks Java's platform independence?  Or is this just a cultural difference? ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "aware": 0.12206953011824906,
                    "code": 0.05529352741824678,
                    "cultural": 0.17025382846587103,
                    "difference": 0.11732512912327749,
                    "different": 0.1621770426342631,
                    "differently": 0.13940120503416314,
                    "example": 0.07980482983707494,
                    "feature": 0.10829359759473461,
                    "interpreter": 0.1651115051686775,
                    "java": 0.2678790970689945,
                    "jvm": 0.31101946046246276,
                    "killer": 0.18531626223949568,
                    "lacks": 0.18064414812276863,
                    "machine": 0.12250758662028792,
                    "missing": 0.13619381421668456,
                    "new": 0.07373842139288384,
                    "people": 0.07087432387478482,
                    "platform": 0.11426678714262588,
                    "python": 0.541467987973673,
                    "run": 0.09634475628589442,
                    "supposedly": 0.17327209900544882,
                    "talk": 0.23762218421979203,
                    "way": 0.2723447058354972,
                    "work": 0.06337006974534272,
                    "works": 0.10085819694615047,
                    "world": 0.10066907666824966,
                    "write": 0.16096290958242546,
                    "written": 0.20566075212456936
                },
                "Max term": "python",
                "Max score": 0.541467987973673
            }
        ],
        "Best answer": "Java does a very good job on isolating you from the underlying OS and gives you the same exact tools on most platforms it works on to talk to things in the underlying OS.   Python on the other hand does not do as good of a job in isolating you from the underlying OS, It does not have a standard way of handling between process communications (look at the differences in the sys module and os module between a windows and *nix implementation of Python for example.)   I have written code in python that would only work on a *NIX box or Windows box using just Python available API calls, where in Java it would be very difficult to write code that was just Java API that would not work the same on both a Windows box or *NIX box ",
        "Best answer TF-IDF scores": [
            {
                "Scores": {
                    "api": 0.1835862792677601,
                    "available": 0.0758306755782287,
                    "box": 0.3920370826832699,
                    "calls": 0.09220288830731706,
                    "code": 0.07868431362687671,
                    "communications": 0.11921705594130341,
                    "differences": 0.09690389899351783,
                    "difficult": 0.07998387106521831,
                    "exact": 0.10251028247469686,
                    "example": 0.05678230846389939,
                    "gives": 0.09139239715900725,
                    "good": 0.09263533629051954,
                    "hand": 0.076518796813369,
                    "handling": 0.09980413330482384,
                    "implementation": 0.08426571274782031,
                    "java": 0.19059991170780002,
                    "job": 0.12900957130145374,
                    "look": 0.0631082718681487,
                    "module": 0.2008879100903408,
                    "nix": 0.3698569294866374,
                    "os": 0.38344690741915644,
                    "platforms": 0.09800927067081748,
                    "process": 0.06723998569091216,
                    "python": 0.30820994046818434,
                    "standard": 0.07669496290480897,
                    "sys": 0.13592382940790995,
                    "talk": 0.08453583692728728,
                    "things": 0.05218688703949639,
                    "tools": 0.07122969875007976,
                    "underlying": 0.31452322365904367,
                    "using": 0.05146289918035327,
                    "way": 0.04844431448206929,
                    "windows": 0.23061854315087219,
                    "work": 0.09017747058680416,
                    "works": 0.07176208835731963,
                    "write": 0.057263737055861304,
                    "written": 0.0731653227623928
                },
                "Max term": "box",
                "Max score": 0.3920370826832699
            }
        ]
    },
    {
        "ID": "19457",
        "Question": "Today I was looking at some blogs on Ruby and Python. A Python loyalist wrote a few lines of code with a loop to show how Python is faster than Ruby, with a similar code. I also found a blog of a Ruby disciple who says that it is wrong and he too submitted a code sample and benchmarking results. I am wondering whether background programs or background processes may sometime hinder the results and we may not get exact benchmarking scenario. Please correct me if I am wrong. ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "background": 0.25238506413693385,
                    "benchmarking": 0.3977572275346209,
                    "blog": 0.13203642298132579,
                    "blogs": 0.14793601423520086,
                    "code": 0.17269187405378028,
                    "correct": 0.12176954152367647,
                    "exact": 0.14998917382088353,
                    "faster": 0.12895478078986167,
                    "hinder": 0.19887861376731045,
                    "lines": 0.1284740847552659,
                    "looking": 0.09717702112733094,
                    "loop": 0.14998917382088353,
                    "processes": 0.13614884065726418,
                    "programs": 0.11765712384773806,
                    "python": 0.33822085856814466,
                    "results": 0.26861651033903045,
                    "ruby": 0.38261376524663304,
                    "sample": 0.1654575183743181,
                    "says": 0.12753792174887768,
                    "scenario": 0.14894284723824888,
                    "similar": 0.1046072482033259,
                    "submitted": 0.17189121757260126,
                    "today": 0.12491174652920603,
                    "wondering": 0.12368964393509006,
                    "wrong": 0.21718032243302055,
                    "wrote": 0.13149745701135743
                },
                "Max term": "benchmarking",
                "Max score": 0.3977572275346209
            }
        ],
        "Best answer": "It's possible.   But if that's the case, running the benchmark again would almost certainly produce different results.  That's why benchmarks are always run multiple times, to make sure that there are no background processes that are skewing the results. ",
        "Best answer TF-IDF scores": [
            {
                "Scores": {
                    "background": 0.24391597515965108,
                    "benchmarks": 0.3635020289674653,
                    "case": 0.18927675839609037,
                    "certainly": 0.25627480092061466,
                    "different": 0.16317075494035174,
                    "make": 0.13786438220768138,
                    "multiple": 0.22329055683104093,
                    "possible": 0.18615062572129848,
                    "processes": 0.26316040015549225,
                    "produce": 0.259602755366612,
                    "results": 0.519205510733224,
                    "run": 0.19387018485922614,
                    "running": 0.23123939779055247,
                    "sure": 0.18346432061000637,
                    "times": 0.21398360213460182
                },
                "Max term": "results",
                "Max score": 0.519205510733224
            }
        ]
    },
    {
        "ID": "20427",
        "Question": "I have a question that can be best answered here, given the vast experience some of you guys have! I am going to finish my bachelor's degree in CS and let's face it, I am just comfortable with C++ and Python. C++ - I have no experience to show for and I can't quote the C++ standard like some of the guys on SO do but yet I am comfortable with the language basics and the stuff that mostly matters. With Python, I have demonstrated work experience with a good company, so I can safely put that. I have never touched C, though I have been meaning to do it now. So I cannot write C on my resume because I have not done it ever. Sure I can finish K & R and get a sense of the language in a month, but I don't feel like writing it cause that would be being unfaithful to myself. So the big question is, are two languages on a a resume considered OK or that is usually a bad sign? Most resumes I have seen mention lots of languages and hence my question. Under the language section of my resume, I just mention: C++ and Python and that kinda looks empty! What are your views on this and what do you feel about such a situation? PS: I really don't want to write every single library or API I am familiar with. Or should I? ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "answered": 0.12644554615127046,
                    "api": 0.10015148364802286,
                    "bachelor": 0.13451157814672943,
                    "bad": 0.07529316957145142,
                    "basics": 0.11730393964162848,
                    "best": 0.0626785675277382,
                    "big": 0.07715122554621,
                    "cause": 0.09845741529787314,
                    "comfortable": 0.21030190520166447,
                    "company": 0.07008363232409508,
                    "considered": 0.09928642202565884,
                    "cs": 0.11106426117176763,
                    "degree": 0.10059854252117179,
                    "demonstrated": 0.14386149318421917,
                    "experience": 0.20080097750745515,
                    "face": 0.11265657337863126,
                    "familiar": 0.09580103756334249,
                    "feel": 0.15109643029996997,
                    "finish": 0.23256709527788155,
                    "given": 0.08406859961450885,
                    "going": 0.0654891575278407,
                    "good": 0.05053518380966673,
                    "guys": 0.20702993373797857,
                    "kinda": 0.13716795588126007,
                    "language": 0.18100642892837845,
                    "languages": 0.13539449552832664,
                    "let": 0.07998727288513442,
                    "library": 0.08636251087538367,
                    "like": 0.08565033151328039,
                    "looks": 0.09223335778102384,
                    "lots": 0.08614269336101989,
                    "matters": 0.11730393964162848,
                    "meaning": 0.10959001033598167,
                    "mention": 0.21030190520166447,
                    "month": 0.09971425104459114,
                    "ok": 0.09580103756334249,
                    "ps": 0.12337898310862087,
                    "python": 0.25220579884352656,
                    "question": 0.17602305886808234,
                    "quote": 0.11106426117176763,
                    "really": 0.055860607074741546,
                    "resume": 0.3266757863785027,
                    "resumes": 0.13216848692845068,
                    "safely": 0.1483005509193686,
                    "section": 0.11031348216035256,
                    "seen": 0.08310738450019273,
                    "sense": 0.08571021366231467,
                    "sign": 0.10693363260145103,
                    "single": 0.07889481819799285,
                    "situation": 0.09223335778102384,
                    "standard": 0.08367852275107998,
                    "stuff": 0.07660241052977498,
                    "sure": 0.07077823145451799,
                    "touched": 0.14023451892390965,
                    "usually": 0.0774314172575607,
                    "vast": 0.12337898310862087,
                    "views": 0.11730393964162848,
                    "want": 0.05571800228745569,
                    "work": 0.04919434887463509,
                    "write": 0.12495592259398036,
                    "writing": 0.07077823145451799
                },
                "Max term": "resume",
                "Max score": 0.3266757863785027
            }
        ],
        "Best answer": "As long as you know how to think the problems through, it does not matter how many languages you are proficient in. But since you are proficient with C++, you could invest a few months time to gain some skill in C# or Java (or Ruby, for that matter). ",
        "Best answer TF-IDF scores": [
            {
                "Scores": {
                    "gain": 0.25128135746039115,
                    "invest": 0.3068955761124743,
                    "java": 0.16095753531509852,
                    "know": 0.11942313340268149,
                    "languages": 0.15719318830561235,
                    "long": 0.15841420005354645,
                    "matter": 0.3951055975682068,
                    "months": 0.2095758620013673,
                    "problems": 0.17034817499847993,
                    "proficient": 0.6246724802332961,
                    "ruby": 0.220829315339119,
                    "skill": 0.24285951363792702,
                    "think": 0.11828468845625865,
                    "time": 0.10815051414799695
                },
                "Max term": "proficient",
                "Max score": 0.6246724802332961
            }
        ]
    },
    {
        "ID": "20988",
        "Question": "In Python's tutorial one can read that Python's original implementation is in C;  On the other hand, the Python implementation, written in C, (...)  I'm very curious why was Python written in C and not C++?  I'd like to know the reasoning behind this decision and the answer should be supported by historical references (and not opinion based). ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "answer": 0.1275902496238076,
                    "based": 0.13405409984348435,
                    "curious": 0.19396284528966834,
                    "decision": 0.17435062708727472,
                    "hand": 0.14963606607837063,
                    "historical": 0.23313449771056657,
                    "implementation": 0.32957104099866924,
                    "know": 0.0921821299530466,
                    "like": 0.0767573617890564,
                    "opinion": 0.1686589225218694,
                    "original": 0.1723507249245273,
                    "python": 0.6027188735127911,
                    "read": 0.1256138680784364,
                    "reasoning": 0.21024882858644905,
                    "references": 0.2019191568312423,
                    "supported": 0.2121766264281523,
                    "tutorial": 0.22113738677510889,
                    "written": 0.28615638320141257
                },
                "Max term": "python",
                "Max score": 0.6027188735127911
            }
        ],
        "Best answer": "From everything I've seen, it's a combination of practical and historical reasons. The (mostly) historical reason is that CPython 1.0 was released in 1989. At that time, C was just recently standardized. C++ was almost unknown and decidedly non-portable, because almost nobody had a C++ compiler. Although C++ is much more widespread and easily available today, it would still take a fair amount of work to rewrite CPython into the subset of C that's compatible with C++. By itself, that work would provide little or no real benefit. It's a bit like Joel's blog post about starting over and doing a complete rewrite being the worst mistake a software company can make. I'd counter that by pointing to Microsoft's conversion from the Windows 3.0 core to the Windows NT core, and Apple's conversion from MacOS 9 to Mac OS/X. Neither one killed the company -- but both were definitely large, expensive, long-term projects. Both also point to something that's crucial to success: maintaining both code bases for long enough that (most) users can switch to the new code base at their leisure, based on (at least perceived) benefits. For a development team the size of Python's, however, that kind of change is much more difficult. Even the change from Python 2 to 3 has taken quite a bit of work, and required a similar overlap. At least in that case, however, there are direct benefits to the changes, which rewriting into C++ (by itself) wouldn't (at least immediately) provide. Linus Torvalds's rant against C++ was brought up, so I'll mention that as well. Nothing I've seen from Guido indicates that he has that sort of strong, negative feelings toward C++. About the worst I've seen him say is that teaching C++ is often a disaster -- but he immediately went on to say that this is largely because the teachers didn't/don't know C++.  I also think that while it's possible to convert a lot of C code to C++ with relative ease, that getting much real advantage from C++ requires not only quite a bit more rewriting than that, but also requires substantial re-education of most developers involved. Most well-written C++ is substantially different from well-written C to do the same things. It's not just a matter of changing malloc to new and printf to cout, by any stretch of the imagination. ",
        "Best answer TF-IDF scores": [
            {
                "Scores": {
                    "advantage": 0.07218382141595629,
                    "apple": 0.0868920769202888,
                    "available": 0.05826812987483662,
                    "base": 0.06516784155328209,
                    "based": 0.05267421906783263,
                    "bases": 0.09876291973073192,
                    "benefit": 0.06992441664232678,
                    "benefits": 0.13925890683046144,
                    "bit": 0.16389695050594832,
                    "blog": 0.06934057233964863,
                    "brought": 0.08905176429223152,
                    "case": 0.051426192446478336,
                    "change": 0.10145495269643139,
                    "changes": 0.05667573602303011,
                    "changing": 0.07084850332347914,
                    "code": 0.09069128892555073,
                    "combination": 0.09027081420047994,
                    "company": 0.09871555458350996,
                    "compatible": 0.09473242606242857,
                    "compiler": 0.06824116650430068,
                    "complete": 0.06264889768215556,
                    "conversion": 0.1932064647175784,
                    "convert": 0.08417190537745324,
                    "core": 0.1381150552929696,
                    "counter": 0.08502127062392817,
                    "crucial": 0.09473242606242857,
                    "definitely": 0.06772220955400765,
                    "developers": 0.04779947991769836,
                    "development": 0.04236679339609015,
                    "different": 0.04433323307259794,
                    "difficult": 0.06145943645606105,
                    "direct": 0.07668928381696506,
                    "disaster": 0.09473242606242857,
                    "ease": 0.09027081420047994,
                    "easily": 0.06434347227381652,
                    "education": 0.08502127062392817,
                    "expensive": 0.07668928381696506,
                    "fair": 0.07446074993895284,
                    "feelings": 0.0916061322929571,
                    "getting": 0.05320631728844536,
                    "historical": 0.1832122645859142,
                    "imagination": 0.10444358150092899,
                    "immediately": 0.15337856763393012,
                    "indicates": 0.1013172877314575,
                    "involved": 0.0641447421929497,
                    "joel": 0.07531011518542777,
                    "killed": 0.0966032323587892,
                    "kind": 0.05493579951283732,
                    "know": 0.0362213592344837,
                    "large": 0.05567058699928833,
                    "largely": 0.09473242606242857,
                    "like": 0.030160465772148905,
                    "linus": 0.0966032323587892,
                    "little": 0.05293774224365517,
                    "long": 0.09609491033257439,
                    "lot": 0.04340506356006236,
                    "mac": 0.07821919164576062,
                    "macos": 0.0966032323587892,
                    "maintaining": 0.0787686830849852,
                    "make": 0.03745753208690577,
                    "malloc": 0.1013172877314575,
                    "matter": 0.05991829797673031,
                    "mention": 0.07405462771231693,
                    "microsoft": 0.06375554394959874,
                    "mistake": 0.08592547052276003,
                    "negative": 0.0818949768544567,
                    "new": 0.08062947921398357,
                    "non": 0.05267421906783263,
                    "os": 0.07365994708353406,
                    "overlap": 0.1013172877314575,
                    "perceived": 0.1013172877314575,
                    "point": 0.04779947991769836,
                    "pointing": 0.09473242606242857,
                    "portable": 0.0916061322929571,
                    "possible": 0.0505768272000034,
                    "post": 0.0641447421929497,
                    "practical": 0.07446074993895284,
                    "printf": 0.09308225796053488,
                    "projects": 0.04755581750146386,
                    "provide": 0.12102913641994481,
                    "python": 0.1184139314530377,
                    "quite": 0.11221688500578778,
                    "rant": 0.10444358150092899,
                    "real": 0.10587548448731034,
                    "reason": 0.05535094798425604,
                    "reasons": 0.061956893533550585,
                    "recently": 0.06454506187827574,
                    "relative": 0.08417190537745324,
                    "released": 0.07487899699178249,
                    "required": 0.0641447421929497,
                    "requires": 0.13701607241452043,
                    "rewrite": 0.1598737581739464,
                    "rewriting": 0.17586069416852204,
                    "say": 0.09096533351827343,
                    "seen": 0.1755900331974008,
                    "similar": 0.05493579951283732,
                    "size": 0.0702257236484728,
                    "software": 0.04082826122981546,
                    "sort": 0.059773112886895616,
                    "standardized": 0.09876291973073192,
                    "starting": 0.06474959450045242,
                    "stretch": 0.1013172877314575,
                    "strong": 0.07117059189456146,
                    "subset": 0.09473242606242857,
                    "substantial": 0.09308225796053488,
                    "substantially": 0.1013172877314575,
                    "success": 0.07769044075183743,
                    "switch": 0.07531011518542777,
                    "taken": 0.07405462771231693,
                    "teaching": 0.0799368790869732,
                    "team": 0.04922109098033826,
                    "term": 0.06650315964575923,
                    "things": 0.040100293035683285,
                    "think": 0.035876065804323724,
                    "time": 0.03280234333778375,
                    "today": 0.06559895974692737,
                    "torvalds": 0.09876291973073192,
                    "unknown": 0.08592547052276003,
                    "users": 0.055246001907086874,
                    "went": 0.0702257236484728,
                    "widespread": 0.0966032323587892,
                    "windows": 0.11813786546051078,
                    "work": 0.10393826498055249,
                    "worst": 0.15538088150367485,
                    "written": 0.11244015687702584
                },
                "Max term": "conversion",
                "Max score": 0.1932064647175784
            }
        ]
    },
    {
        "ID": "21917",
        "Question": "I am going to interview within two weeks for an internship that would involve Python programming. Can anyone suggest what possible areas should I polish? I am looking for commonly asked stuff in interviews for Python openings. Apart from the fact that I have already been doing the language for over a year now, I fail to perceive what they can ask me.  Like for a C or C++ interview, there are lots of questions ranging from reversing of strings to building linked lists, but for a Python interview, I am clueless. Personal experiences and/ or suggestions are welcomed. ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "apart": 0.17160417365596498,
                    "areas": 0.15774748042962045,
                    "ask": 0.11392073479941965,
                    "asked": 0.12496059784157303,
                    "building": 0.14020563007190273,
                    "clueless": 0.22248051658325987,
                    "commonly": 0.18730484689935425,
                    "experiences": 0.1537623820132297,
                    "fact": 0.1261197302013826,
                    "fail": 0.1477058344094291,
                    "going": 0.09824684741271297,
                    "interview": 0.4178187962429314,
                    "interviews": 0.1654923083224238,
                    "involve": 0.18110807707995374,
                    "language": 0.09051529380308208,
                    "like": 0.06424632235844702,
                    "linked": 0.17299251265995014,
                    "lists": 0.16440695574469144,
                    "looking": 0.10870949596283143,
                    "lots": 0.1292312860607858,
                    "perceive": 0.22248051658325987,
                    "personal": 0.13500224386176435,
                    "possible": 0.10773623884679731,
                    "programming": 0.08247236832123078,
                    "python": 0.3783591906041478,
                    "questions": 0.11257705225543577,
                    "ranging": 0.20179429683160682,
                    "strings": 0.17027755940335304,
                    "stuff": 0.11491895182138169,
                    "suggest": 0.14166171917683534,
                    "suggestions": 0.15529317430272577,
                    "weeks": 0.1471029066981587,
                    "year": 0.13622053165551198
                },
                "Max term": "interview",
                "Max score": 0.4178187962429314
            }
        ],
        "Best answer": "How about something involving Python list comprehensions? To me, those were one of the big selling points over C++, after I read about them in Dive into Python. \"Write a list comprehension that builds a list of the even numbers from 1 to 10 (inclusive)\". Where the answer is anything like this (note the range values avoid a fencepost error): foo = [x for x in range(1, 11) if (x % 2) == 0] print foo [2, 4, 6, 8, 10]  For that matter, if you understand all the concepts listed in Dive into Python, that should cover most of the important features. ",
        "Best answer TF-IDF scores": [
            {
                "Scores": {
                    "10": 0.2279756000833404,
                    "11": 0.1702316613011416,
                    "answer": 0.09583702004398134,
                    "avoid": 0.12079670262679816,
                    "big": 0.10386748838459141,
                    "builds": 0.1539981229333283,
                    "comprehension": 0.1996547124299404,
                    "concepts": 0.13045005043396224,
                    "cover": 0.1448133713600585,
                    "dive": 0.34512400266268345,
                    "error": 0.11748607176623795,
                    "features": 0.10540932503715086,
                    "foo": 0.3033355658062563,
                    "important": 0.09955238750998636,
                    "involving": 0.18466707383282543,
                    "like": 0.057654850915256,
                    "list": 0.322411490456122,
                    "listed": 0.1702316613011416,
                    "matter": 0.11454002610710132,
                    "note": 0.11876164690319065,
                    "numbers": 0.14233942768658409,
                    "points": 0.12498396547679698,
                    "print": 0.15524402270402662,
                    "python": 0.3395407227357188,
                    "range": 0.31048804540805325,
                    "read": 0.09435249815977186,
                    "selling": 0.15655072162752043,
                    "understand": 0.09515202067573068,
                    "values": 0.13483237616594965,
                    "write": 0.08411310220109483
                },
                "Max term": "dive",
                "Max score": 0.34512400266268345
            }
        ]
    },
    {
        "ID": "22526",
        "Question": "I'm used to program with Python and GTK using pygtk library. I feel like my programs are not well separated according to MVC model. I think following a framework it would help me to design better desktop applications. I'd like to know which Python MVC framework for desktop apps you're using and why. ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "according": 0.2090310341469899,
                    "applications": 0.15261785664216837,
                    "apps": 0.18039885590430507,
                    "better": 0.11199014894900036,
                    "design": 0.1276714565897309,
                    "desktop": 0.3594332910839736,
                    "feel": 0.14119534681006518,
                    "following": 0.15462804465585794,
                    "framework": 0.296043922518253,
                    "gtk": 0.25635916167486167,
                    "help": 0.12652233222414982,
                    "know": 0.09612180732823498,
                    "library": 0.1614066546804481,
                    "like": 0.160075631679792,
                    "model": 0.17350567130032754,
                    "mvc": 0.40206663495174766,
                    "program": 0.1393242892997688,
                    "programs": 0.16397176973601574,
                    "python": 0.3142389282087347,
                    "separated": 0.25635916167486167,
                    "think": 0.09520549084351443,
                    "used": 0.11254096526926581,
                    "using": 0.20987832198251552
                },
                "Max term": "mvc",
                "Max score": 0.40206663495174766
            }
        ],
        "Best answer": "first, I think Qt, and even it's Python bindings are way better structured than GTK; so you could first try it. second, it seems you're slightly confused by the MVC buzzword.  It was originally defined as a modular architecture for GUI applications; unfortunately, there's a completely different layered architecture for Web apps also called MVC. Maybe you feel your desktop apps are not very MVC because there not very web MVC, but they might be very GUI MVC nonetheless. ",
        "Best answer TF-IDF scores": [
            {
                "Scores": {
                    "applications": 0.09936408753259526,
                    "apps": 0.2349026267730021,
                    "architecture": 0.22900164666612516,
                    "better": 0.07291282427748522,
                    "buzzword": 0.1750510976684695,
                    "called": 0.11082617568976355,
                    "completely": 0.11371991025141766,
                    "confused": 0.135143327095594,
                    "defined": 0.12081201699269586,
                    "desktop": 0.11700715035310207,
                    "different": 0.07659681073500373,
                    "feel": 0.09192729545747032,
                    "gtk": 0.1669063813428338,
                    "gui": 0.2650000530442626,
                    "maybe": 0.09915267827476555,
                    "modular": 0.16367409292458263,
                    "mvc": 0.654428406810737,
                    "nonetheless": 0.1750510976684695,
                    "originally": 0.135143327095594,
                    "python": 0.1022949249047913,
                    "qt": 0.16082301248173042,
                    "second": 0.11187121018216228,
                    "slightly": 0.13609271176379242,
                    "structured": 0.14542813728120493,
                    "think": 0.06198492715003089,
                    "try": 0.08515960664432012,
                    "unfortunately": 0.1316793985732401,
                    "way": 0.06431470061581515,
                    "web": 0.16581248134475257
                },
                "Max term": "mvc",
                "Max score": 0.654428406810737
            }
        ]
    },
    {
        "ID": "23351",
        "Question": "This is a fairly general question. I know a bit of Perl and Python and I am looking to learn programming in more depth so that once I get the hang of it I can start developing applications and then websites.  I would like to know of an algorithm (sequence of steps :)) that could describe my approach towards learning programming in general. I have posted small questions on Perl/Python and I have recieved great help from everyone.  Note:- I am not in a hurry to learn. I know it takes time and that's fine. Please give any suggestions you think are valid. Also, please don't push me to learn Lisp, Haskell etc - I am a beginner. ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "algorithm": 0.1495689575403484,
                    "applications": 0.11973915049690574,
                    "approach": 0.11848703552689689,
                    "beginner": 0.16772802186474778,
                    "bit": 0.11374639085487809,
                    "depth": 0.16772802186474778,
                    "developing": 0.1300702714739047,
                    "fairly": 0.13945080147763717,
                    "fine": 0.13657932424026292,
                    "general": 0.230048209195867,
                    "great": 0.11134752197573375,
                    "hang": 0.18307405226105986,
                    "haskell": 0.15178545125081389,
                    "help": 0.09926542616128657,
                    "hurry": 0.2011313021713966,
                    "know": 0.2262424032207909,
                    "learn": 0.2944372964070795,
                    "learning": 0.10825499245661636,
                    "like": 0.06279514263371568,
                    "lisp": 0.15868086463261677,
                    "looking": 0.10625399328756768,
                    "note": 0.1293499929028083,
                    "perl": 0.3381700028349769,
                    "posted": 0.17889982927015685,
                    "programming": 0.161219006534811,
                    "push": 0.15102775150715173,
                    "python": 0.2465419390929631,
                    "question": 0.0860350286500276,
                    "questions": 0.11003419019413944,
                    "sequence": 0.17050820074898485,
                    "small": 0.11021822739776455,
                    "start": 0.10016699284802483,
                    "steps": 0.1495689575403484,
                    "suggestions": 0.15178545125081389,
                    "takes": 0.12599344356518488,
                    "think": 0.07469522143120952,
                    "time": 0.06829562395280885,
                    "valid": 0.1495689575403484,
                    "websites": 0.15966976611517725
                },
                "Max term": "perl",
                "Max score": 0.3381700028349769
            }
        ],
        "Best answer": "The 11 step algorithm for learning a new programming language I'm currently in the process of learning Lisp, and I'd recommend the following algorithm:  Ask around if the language is worth learning and where good resources can be found. If positive responses to the language are given by experts then proceed to step 2. Create an initial programming environment. Keep it simple: text editor and compiler/interpreter. The bare minimum. Consider a specific user account on your machine with a special colour scheme to cue the change of mindset. Create the \"Hello, World!\" application.  Learn general syntax and control statements (if-then-else, repeat-until etc). Create sandbox to verify simple control cases (true/false evaluations etc). Try out every primitive type (int, double, string etc). Perform currency calculations. The number guessing game (as suggested by @Jeremy) is good for this. Create class (if applicable) with several methods/functions. Make calls between functions. Apply control statements. Learn arrays and collections. Create suitably complex examples that create arrays and collections of each of the classes/functions/primitives that are available to you Learn file IO. Create examples of reading, manipulating and writing binary and character based files. Ask more questions about idiomatic programming within the language (pointers, macros, monads, closures, support frameworks, build environments etc).  Choose (or adapt your existing) IDE to work in the recomended idiom. Write a variety of applications that please you (or your boss).  After 1 year return to step 1 for another language while maintaining your interest in the one you've just been learning.  ",
        "Best answer TF-IDF scores": [
            {
                "Scores": {
                    "11": 0.08717199542061074,
                    "account": 0.07066011324901787,
                    "adapt": 0.08836531274412388,
                    "algorithm": 0.14064293294433414,
                    "applicable": 0.0860742498959179,
                    "application": 0.04759563927136218,
                    "applications": 0.056296659384033235,
                    "apply": 0.07032146647216707,
                    "arrays": 0.17673062548824775,
                    "ask": 0.1047024885663612,
                    "available": 0.05703816416200874,
                    "bare": 0.09456406165252346,
                    "based": 0.051562333659075116,
                    "binary": 0.07824951378661704,
                    "boss": 0.07066011324901787,
                    "build": 0.054286066384669214,
                    "calculations": 0.09917860934424834,
                    "calls": 0.06935298201397022,
                    "cases": 0.058942236255928766,
                    "change": 0.04965668418892353,
                    "character": 0.08086974037841106,
                    "choose": 0.06421424958960445,
                    "class": 0.05470808422452764,
                    "classes": 0.06222315125966376,
                    "closures": 0.09456406165252346,
                    "collections": 0.17934488795834302,
                    "colour": 0.10223891104991174,
                    "compiler": 0.06680068274098162,
                    "complex": 0.06279072870864902,
                    "consider": 0.055593197619716865,
                    "control": 0.16348635628507208,
                    "create": 0.36773027139837416,
                    "currency": 0.10223891104991174,
                    "currently": 0.06203906127913028,
                    "double": 0.07824951378661704,
                    "editor": 0.0755517309223698,
                    "environment": 0.05809364617827764,
                    "environments": 0.07507047109998223,
                    "examples": 0.12196715852572276,
                    "existing": 0.061153947883941046,
                    "experts": 0.07949714602322244,
                    "false": 0.07949714602322244,
                    "file": 0.05617688135079999,
                    "files": 0.06000355547068124,
                    "following": 0.05703816416200874,
                    "frameworks": 0.06509936298479368,
                    "functions": 0.18397937868811845,
                    "game": 0.06999098065814563,
                    "general": 0.05407982945119199,
                    "given": 0.05795718238937348,
                    "good": 0.06967825986319612,
                    "guessing": 0.08967244397917151,
                    "hello": 0.08836531274412388,
                    "ide": 0.06604556555729299,
                    "idiom": 0.10223891104991174,
                    "idiomatic": 0.09667816078568757,
                    "initial": 0.07656808453084107,
                    "int": 0.0724914292167064,
                    "interpreter": 0.08836531274412388,
                    "io": 0.0860742498959179,
                    "language": 0.2079774268306929,
                    "learn": 0.1384328861278612,
                    "learning": 0.20358903204708165,
                    "lisp": 0.07460552834987051,
                    "machine": 0.0655643057349054,
                    "macros": 0.09273274568483493,
                    "maintaining": 0.07710597690843128,
                    "make": 0.036666851482379616,
                    "methods": 0.058942236255928766,
                    "mindset": 0.08411169371494734,
                    "minimum": 0.0832265803197581,
                    "monads": 0.09456406165252346,
                    "new": 0.03946374700529516,
                    "number": 0.05367643279223923,
                    "perform": 0.07507047109998223,
                    "pointers": 0.08086974037841106,
                    "positive": 0.0801662786140947,
                    "primitive": 0.10223891104991174,
                    "primitives": 0.09456406165252346,
                    "proceed": 0.09917860934424834,
                    "process": 0.05057643642028268,
                    "programming": 0.11369829491178439,
                    "questions": 0.051733767111680616,
                    "reading": 0.058231481485521853,
                    "recommend": 0.06464966703739747,
                    "repeat": 0.07766583005553392,
                    "resources": 0.06532986416911195,
                    "responses": 0.08239514408753291,
                    "return": 0.06532986416911195,
                    "scheme": 0.0801662786140947,
                    "simple": 0.10295482779556912,
                    "special": 0.07136357501333425,
                    "specific": 0.052083199966657244,
                    "statements": 0.15649902757323408,
                    "step": 0.20534520486301677,
                    "string": 0.06680068274098162,
                    "suggested": 0.08161124515638656,
                    "support": 0.05449545209502402,
                    "syntax": 0.06532986416911195,
                    "text": 0.06338281335737926,
                    "true": 0.06338281335737926,
                    "try": 0.04824883403635001,
                    "type": 0.05641749274392856,
                    "user": 0.04936331476462044,
                    "variety": 0.0832265803197581,
                    "verify": 0.08411169371494734,
                    "work": 0.033914753705040095,
                    "world": 0.05387664799230245,
                    "worth": 0.058942236255928766,
                    "write": 0.04307252190246957,
                    "writing": 0.04879475676312841,
                    "year": 0.06259891442623292
                },
                "Max term": "create",
                "Max score": 0.36773027139837416
            }
        ]
    },
    {
        "ID": "24558",
        "Question": "This is just a wondering I had while reading about interpreted and compiled languages.    Ruby is no doubt an interpreted language since the source code is processed by an interpreter at the point of execution. On the contrary C is a compiled language, as one have to compile the source code first according to the machine and then execute. This results is much faster execution. Now coming to Python:    A python code (somefile.py) when imported creates a file (somefile.pyc) in the same directory. Let us say the import is done in a python shell or django module. After the import I change the code a bit and execute the imported functions again to find that it is still running the old code. This suggests that *.pyc files are compiled python files similar to executable created after compilation of a C file, though I can't execute *.pyc file directly. When the python file (somefile.py) is executed directly ( ./somefile.py or python somefile.py ) no .pyc file is created and the code is executed as is indicating interpreted behavior.   These suggest that a python code is compiled every time it is imported in a new process to create a .pyc while it is interpreted when directly executed.  So which type of language should I consider it as? Interpreted or Compiled? And how does its efficiency compare to interpreted and compiled languages? According to wiki's Interpreted Languages page, it is listed as a language compiled to Virtual Machine Code, what is meant by that? ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "according": 0.12010185016060704,
                    "behavior": 0.05530123968548564,
                    "bit": 0.041650070011978395,
                    "change": 0.0386731345808197,
                    "code": 0.18437431674306393,
                    "coming": 0.05377278081738377,
                    "compare": 0.06243431941389925,
                    "compilation": 0.06983781842950906,
                    "compile": 0.05775332230284722,
                    "compiled": 0.4333923446590209,
                    "consider": 0.043296552084421874,
                    "contrary": 0.0736474604080134,
                    "create": 0.04091315775082614,
                    "created": 0.1052948521293874,
                    "creates": 0.06005092508030352,
                    "directly": 0.15925033630088226,
                    "directory": 0.0670355079993532,
                    "django": 0.06624396139240359,
                    "doubt": 0.06243431941389925,
                    "efficiency": 0.0670355079993532,
                    "executable": 0.07096317318219914,
                    "execute": 0.18894654793731838,
                    "executed": 0.2095134552885272,
                    "execution": 0.1283403653767913,
                    "faster": 0.05162941886196817,
                    "file": 0.2187556547820038,
                    "files": 0.09346276796157703,
                    "functions": 0.047761675246184944,
                    "import": 0.12963542749498996,
                    "imported": 0.22588182744137064,
                    "indicating": 0.07529394248045687,
                    "interpreted": 0.4752331042539294,
                    "interpreter": 0.06881981122678354,
                    "language": 0.12957996127159982,
                    "languages": 0.10904289582237284,
                    "let": 0.04294632427162758,
                    "listed": 0.06789044346484706,
                    "machine": 0.10212430655809249,
                    "meant": 0.058840462376793766,
                    "module": 0.058840462376793766,
                    "new": 0.030734770634154283,
                    "old": 0.04556926157969126,
                    "page": 0.04968204389730617,
                    "point": 0.03644091630068561,
                    "process": 0.039389447045200796,
                    "processed": 0.07529394248045687,
                    "python": 0.3159635335616154,
                    "reading": 0.045351274599048426,
                    "results": 0.05377278081738377,
                    "ruby": 0.05106215327904624,
                    "running": 0.04789774066987582,
                    "say": 0.03467464615421459,
                    "shell": 0.07096317318219914,
                    "similar": 0.04188143627096908,
                    "source": 0.07232694471201655,
                    "suggest": 0.05070005110003169,
                    "suggests": 0.0722212127631048,
                    "time": 0.02500754087903659,
                    "type": 0.04393852157541062,
                    "virtual": 0.06048694444923724,
                    "wiki": 0.059632008983743386,
                    "wondering": 0.04952142445977877
                },
                "Max term": "interpreted",
                "Max score": 0.4752331042539294
            }
        ],
        "Best answer": "Python will fall under byte code interpreted. .py source code is first compiled to byte code as .pyc. This byte code can be interpreted (official CPython), or JIT compiled (PyPy). Python source code (.py) can be compiled to different byte code also like IronPython (.Net) or Jython (JVM). There are multiple implementations of Python language. The official one is a byte code interpreted one. There are byte code JIT compiled implementations too. For speed comparisons of various implementations of languages you can try here. ",
        "Best answer TF-IDF scores": [
            {
                "Scores": {
                    "byte": 0.6219539417295694,
                    "code": 0.285103463508601,
                    "comparisons": 0.11388324801332225,
                    "compiled": 0.38295280632850637,
                    "different": 0.0522633917516088,
                    "fall": 0.09573820158212659,
                    "implementations": 0.30068864816794083,
                    "interpreted": 0.3149430069146154,
                    "ironpython": 0.12312604873606749,
                    "jvm": 0.10022954938931361,
                    "jython": 0.11944053552892238,
                    "language": 0.05009333242889603,
                    "languages": 0.05620541916961542,
                    "like": 0.03555545420022839,
                    "multiple": 0.07151969021876246,
                    "net": 0.06139345256199579,
                    "official": 0.20731798057652312,
                    "python": 0.20939304195040065,
                    "source": 0.1118412955049866,
                    "speed": 0.08551394385706589,
                    "try": 0.05810594254195346,
                    "various": 0.07385529219146302
                },
                "Max term": "byte",
                "Max score": 0.6219539417295694
            }
        ]
    }
]