[
    {
        "ID": "724",
        "Question": "When learning a new programming language you sometimes come across a language feature which  makes you wish you had it in your other programming languages that you know. What are some language feature which were at the time of learning very new to you and that you wish your other programming languages had.   An example of this is generators in Python or C#. Other examples may include list comprehensions in Python, template in C++ or LINQ in .NET or lazy evaluation in Haskell. What other semi-unique language features have you come across which were completely new and enlightening to you?  Are there other features of older programming languages which were unique and have fallen out of fashion? ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "come": 0.22161957815216562,
                    "completely": 0.12336654390654452,
                    "example": 0.08877623309998496,
                    "examples": 0.12206305156841789,
                    "fashion": 0.16636475928993869,
                    "feature": 0.2083770508411909,
                    "features": 0.20969644100385176,
                    "generators": 0.16636475928993869,
                    "haskell": 0.13701391111739122,
                    "include": 0.1261813863494624,
                    "know": 0.07254928126439911,
                    "language": 0.31324885908918537,
                    "languages": 0.2732028140070532,
                    "learning": 0.2046037715596999,
                    "linq": 0.16040319071578177,
                    "list": 0.11165799661346344,
                    "makes": 0.0935740940543396,
                    "net": 0.10170149437068687,
                    "new": 0.23643479784307764,
                    "older": 0.14784643588532007,
                    "programming": 0.2825056645424262,
                    "python": 0.22506803827723137,
                    "semi": 0.16040319071578177,
                    "template": 0.14784643588532007,
                    "time": 0.06557057136074648,
                    "unique": 0.29569287177064013,
                    "wish": 0.33272951857987737
                },
                "Max term": "wish",
                "Max score": 0.33272951857987737
            }
        ],
        "Best answer": "Practically anything in Haskell  Monads. Yes - the big scary word that makes increadibly easy parsers, IO, operations on Lists and other things so easy (once you notice common pattern) Arrows. The same for advanced users ;) Standard stuff like lambdas etc.  Currying functions Algebraic data types Pattern matching  And many more. PS. Yes. I am Haskell fanboy if anyone asked. ",
        "Best answer TF-IDF scores": [
            {
                "Scores": {
                    "advanced": 0.2049746654271033,
                    "asked": 0.15248719848660588,
                    "big": 0.14355466795681127,
                    "common": 0.14018511556163757,
                    "data": 0.14099920405411565,
                    "easy": 0.2945234255170006,
                    "functions": 0.18169129276186227,
                    "haskell": 0.3799128524400862,
                    "io": 0.23064851492778976,
                    "like": 0.0822187557334258,
                    "lists": 0.2006120365136694,
                    "makes": 0.12973135609647118,
                    "notice": 0.18699168151924564,
                    "operations": 0.1899564262200431,
                    "pattern": 0.3684935133291158,
                    "practically": 0.23064851492778976,
                    "standard": 0.15138145860256672,
                    "stuff": 0.14536183296754948,
                    "things": 0.10961568499794395,
                    "types": 0.16922851745749776,
                    "users": 0.14926433751229648,
                    "word": 0.1899564262200431,
                    "yes": 0.30061554741138113
                },
                "Max term": "haskell",
                "Max score": 0.3799128524400862
            }
        ]
    },
    {
        "ID": "1750",
        "Question": "I work for a company that supports several languages: COBOL, VB6, C#, and Java. I use those languages for my primary work, but I often find myself coding some minor programs (e.g. scripts) in Python because I find it to be the best tool for that type of task. For example: an analyst gives me a complex CSV file to populate some DB tables, so I use Python to parse it and create a DB script. What's the problem? The main problem I see is that a few parts of these quick and dirty scripts are slowly gaining importance and:  My company does not support Python They're not version controlled (I back them up in another way) My coworkers do not know Python  The analysts have even started to reference them in emails (\"launch the script that exports...\"), so they are needed more often than I initially thought. I should add that these scripts are just utilities that are not part of the main project; they simply help to get trivial tasks done in less time. For my own small tasks they help a lot. In short, if I were a lottery winner to be in a accident, my coworkers would need to keep the project alive without those scripts; they would spend more time fixing CSV errors by hand, for example. Is this a common scenario? Am I doing something wrong? What should I do? ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "accident": 0.11219030912178694,
                    "add": 0.07809660830363645,
                    "best": 0.06133992510684024,
                    "cobol": 0.11219030912178694,
                    "coding": 0.06607116759899567,
                    "common": 0.07072206270630374,
                    "company": 0.13758790459722056,
                    "complex": 0.08537418380956226,
                    "coworkers": 0.2243806182435739,
                    "create": 0.07479046433931634,
                    "db": 0.2068155536122581,
                    "dirty": 0.1163599906486993,
                    "emails": 0.10590295705135758,
                    "errors": 0.08628588143664642,
                    "example": 0.12418497399846545,
                    "file": 0.07750334912098852,
                    "fixing": 0.09923809527921668,
                    "gives": 0.09433553179293598,
                    "hand": 0.08287900356433373,
                    "help": 0.12629100661415732,
                    "initially": 0.10340777680612905,
                    "java": 0.07072206270630374,
                    "know": 0.0507429201083566,
                    "languages": 0.1273902679018537,
                    "launch": 0.11219030912178694,
                    "lot": 0.059693544364216956,
                    "main": 0.17650931601535777,
                    "minor": 0.09745712023550059,
                    "need": 0.05477367092331332,
                    "needed": 0.08067809860845383,
                    "parts": 0.09583121740690397,
                    "primary": 0.09295074320878731,
                    "problem": 0.12123300413354492,
                    "programs": 0.08067809860845383,
                    "project": 0.10989499262668899,
                    "python": 0.31483728814968537,
                    "quick": 0.10120687185024915,
                    "reference": 0.09745712023550059,
                    "scenario": 0.10340777680612905,
                    "script": 0.2243806182435739,
                    "scripts": 0.4487612364871478,
                    "short": 0.083674276548874,
                    "simply": 0.07809660830363645,
                    "slowly": 0.10340777680612905,
                    "small": 0.06954149576887533,
                    "spend": 0.08138331795036574,
                    "started": 0.07582884783930469,
                    "support": 0.07692834699370525,
                    "supports": 0.10590295705135758,
                    "tables": 0.10878343124947422,
                    "task": 0.07692834699370525,
                    "tasks": 0.1707483676191245,
                    "thought": 0.08067809860845383,
                    "time": 0.09172364511487933,
                    "tool": 0.08138331795036574,
                    "trivial": 0.10120687185024915,
                    "type": 0.08138331795036574,
                    "use": 0.08765744403387249,
                    "utilities": 0.1163599906486993,
                    "vb6": 0.11219030912178694,
                    "version": 0.083674276548874,
                    "way": 0.051166019572674415,
                    "work": 0.09853740085950476,
                    "wrong": 0.07530244416510863
                },
                "Max term": "scripts",
                "Max score": 0.4487612364871478
            }
        ],
        "Best answer": "You need to get the situation formalised as it shouldn't really have got to this point. However, these things happen so you need to explain to your boss that you created these scripts for personal use, but they've \"escaped\" into wider circulation. Admit (if necessary) that you were at fault for not bringing this to his attention sooner. At the very least the scripts should be put under source control \"just in case\" - then at least if you aren't available (for what ever reason) your co-workers will have access to the scripts. Then you either need to convince your boss that Python is the way to go for these or accept that you are going to have to re-write them in a supported language. If the cost of documenting the scripts and educating your co-workers in Python is lower than that of the re-write you might even win the argument. ",
        "Best answer TF-IDF scores": [
            {
                "Scores": {
                    "accept": 0.12517408927875776,
                    "access": 0.10275024577843501,
                    "admit": 0.14409742188448582,
                    "argument": 0.13972162221053494,
                    "attention": 0.1360219363018098,
                    "available": 0.10362308565707384,
                    "boss": 0.22165146272222205,
                    "bringing": 0.13972162221053494,
                    "case": 0.09739469980649905,
                    "control": 0.10030741516417792,
                    "convince": 0.14409742188448582,
                    "cost": 0.10853824401707036,
                    "created": 0.11773023097691157,
                    "explain": 0.09671858604127329,
                    "fault": 0.14945296785642181,
                    "going": 0.07725589474949959,
                    "got": 0.0960609982912168,
                    "happen": 0.11335443130296069,
                    "language": 0.07035139513369905,
                    "lower": 0.12746157662279844,
                    "necessary": 0.10362308565707384,
                    "need": 0.21105418540109713,
                    "personal": 0.10965474539423557,
                    "point": 0.08568960267571035,
                    "python": 0.20218877143044833,
                    "really": 0.06969380738364252,
                    "reason": 0.09301890013254817,
                    "scripts": 0.5763896875379433,
                    "situation": 0.10965474539423557,
                    "sooner": 0.14409742188448582,
                    "source": 0.08883434012748766,
                    "supported": 0.14945296785642181,
                    "things": 0.0710275088989248,
                    "use": 0.05629368433486068,
                    "way": 0.06571772166622666,
                    "wider": 0.14945296785642181,
                    "win": 0.1360219363018098,
                    "workers": 0.29890593571284363,
                    "write": 0.14736706497861227
                },
                "Max term": "scripts",
                "Max score": 0.5763896875379433
            }
        ]
    },
    {
        "ID": "4507",
        "Question": "Considering the fact that you don't have to get involved in setting up/buying a server or even buying a domain, do you think that fact alone is enough to choose one over the other? I don't necessarily want to work on Google App Engine, I just find it convenient when it comes to hosting/environment/etc. and wondering if that's a good enough reason to learn python. In any case, I'm not looking for a debate between python and ruby but more on Google App Engine and whether its value is enough to dictate the language you should learn. ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "app": 0.2507832283658987,
                    "buying": 0.3710388422695551,
                    "case": 0.12539161418294936,
                    "choose": 0.14593910288863604,
                    "comes": 0.14770527388821159,
                    "considering": 0.16115641959704147,
                    "convenient": 0.1798857615460315,
                    "debate": 0.1798857615460315,
                    "domain": 0.15846780456474663,
                    "engine": 0.31693560912949326,
                    "environment": 0.12628731690692668,
                    "fact": 0.2603096109921944,
                    "good": 0.08414064149033249,
                    "google": 0.27672984361541164,
                    "hosting": 0.19241446322214206,
                    "involved": 0.13973846261575656,
                    "language": 0.09057448724995573,
                    "learn": 0.20883652630062072,
                    "looking": 0.11375861523081611,
                    "necessarily": 0.14426844844216066,
                    "python": 0.2603096109921944,
                    "reason": 0.11975795459420335,
                    "ruby": 0.1537046132515988,
                    "server": 0.13704984758346175,
                    "setting": 0.15846780456474663,
                    "think": 0.08168523194478139,
                    "value": 0.14593910288863604,
                    "want": 0.0908619272792198,
                    "wondering": 0.14957854925957229,
                    "work": 0.08147139316523565
                },
                "Max term": "buying",
                "Max score": 0.3710388422695551
            }
        ],
        "Best answer": "If you want to develop for Google App Engine, you'd definitely want to learn Python (Java is also an option, but the people behind GAE seem to be Pythonistas). One thing to keep in mind is that writing something in Python doesn't mean you get Google App Engine for free. There are several people, including people at Google, who have had to \"port\" their projects to GAE (RSSmeme is another example) even though they're written in Python. This is because GAE has its own restrictions and specialized environment: for example, you don't access to things like MySQL, threading, or local file storage. The General FAQ for GAE touches upon several of these \"quirks\". ",
        "Best answer TF-IDF scores": [
            {
                "Scores": {
                    "access": 0.12851116061614767,
                    "app": 0.24362580965468364,
                    "definitely": 0.1371467142576797,
                    "develop": 0.13861128268307193,
                    "engine": 0.3078901842268196,
                    "environment": 0.12268304396208689,
                    "example": 0.1994931065116352,
                    "file": 0.12450285556602741,
                    "free": 0.11934430641017078,
                    "general": 0.13191302689426607,
                    "google": 0.4032478526118983,
                    "including": 0.14348972686793726,
                    "java": 0.11360926796478239,
                    "learn": 0.10143813870046402,
                    "like": 0.06663198595961299,
                    "local": 0.15655697337182037,
                    "mean": 0.12450285556602741,
                    "mind": 0.12644015341875356,
                    "mysql": 0.18022464849477268,
                    "option": 0.1625806457549418,
                    "people": 0.2508042158812784,
                    "projects": 0.1087961506789227,
                    "python": 0.3793204602562607,
                    "restrictions": 0.18692290428357855,
                    "thing": 0.10665111706116208,
                    "things": 0.08883509265717308,
                    "threading": 0.18022464849477268,
                    "want": 0.17653740837794385,
                    "writing": 0.10416890208751095,
                    "written": 0.12745779996701245
                },
                "Max term": "google",
                "Max score": 0.4032478526118983
            }
        ]
    },
    {
        "ID": "5427",
        "Question": "Other than being annoyed at whitespace as syntax, I'm not a hater, I just don't get the fascination with Python. I appreciate the poetry of Perl, and have programmed beautiful web services in bash & korn, and shebang gnuplot.  I write documents in troff and don't mind REXX.  Didn't find tcl any more useful years ago, but what's the big stink about Python?  I see job listings and many candidates with this as a prize & trophy on their resumes.  I guess in reality, I'm trying to personally become sold on this, I just can't find a reason. ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "ago": 0.18581062351854577,
                    "annoyed": 0.25585404845624177,
                    "appreciate": 0.24668569176004213,
                    "beautiful": 0.25585404845624177,
                    "big": 0.1592424862698146,
                    "documents": 0.23286097011542012,
                    "guess": 0.20742634635786625,
                    "job": 0.1419359798961488,
                    "mind": 0.1730672079144366,
                    "perl": 0.22737453131621854,
                    "personally": 0.18972665747999562,
                    "programmed": 0.25585404845624177,
                    "python": 0.3461344158288732,
                    "reality": 0.22253514932512372,
                    "reason": 0.1592424862698146,
                    "services": 0.2107150817506595,
                    "sold": 0.23286097011542012,
                    "syntax": 0.20154672505445984,
                    "trying": 0.15827568264844588,
                    "useful": 0.16557611504507722,
                    "web": 0.15126514798410887,
                    "write": 0.12614155718912973,
                    "years": 0.15046731207781977
                },
                "Max term": "python",
                "Max score": 0.3461344158288732
            }
        ],
        "Best answer": "I've found Python to be the most natural programming language that I've ever written code in. I've coded in a lot of languages before and after Python, and to a greater or lesser extent, you have to fight the language to get it to do what you want. Python reduces this struggle massively. Eric S Raymond said it much better than I can in Why Python? As a related point, Python maintains its cleanness even while evolving rapidly. In most languages I've worked with, introduction of new language features introduces a lot of wrinkles. But with Python, even major language features (decorators come to mind) are added all the time, without feeling like ugly hacks. ",
        "Best answer TF-IDF scores": [
            {
                "Scores": {
                    "added": 0.1296796746140635,
                    "better": 0.07997871526547537,
                    "code": 0.05598921142377918,
                    "coded": 0.14215096468864846,
                    "come": 0.10654107635255376,
                    "eric": 0.15422399710110046,
                    "extent": 0.13641905293305312,
                    "features": 0.20161832919391687,
                    "feeling": 0.13397081036977576,
                    "fight": 0.15995590885669578,
                    "greater": 0.15422399710110046,
                    "introduction": 0.15422399710110046,
                    "language": 0.30118160942131667,
                    "languages": 0.1751188356765887,
                    "like": 0.05701912194199107,
                    "lot": 0.16411715209711644,
                    "major": 0.1243460205206011,
                    "mind": 0.10819888409926423,
                    "natural": 0.1391254595252127,
                    "new": 0.07577554913222903,
                    "point": 0.09171151615222639,
                    "programming": 0.06790568285302337,
                    "python": 0.6491933045955854,
                    "reduces": 0.15995590885669578,
                    "related": 0.11993168498601528,
                    "said": 0.10145950578027461,
                    "struggle": 0.14558099954566195,
                    "time": 0.06304460380327279,
                    "ugly": 0.15995590885669578,
                    "want": 0.07553435388918371,
                    "worked": 0.10498380534731269,
                    "written": 0.10906971680510899
                },
                "Max term": "python",
                "Max score": 0.6491933045955854
            }
        ]
    },
    {
        "ID": "7166",
        "Question": "Thoughts on these?  Python is one example, and no this is not a stab against Python I like the language.   What languages have a indentation requirement? ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "example": 0.23573638982095513,
                    "indentation": 0.441764945177078,
                    "language": 0.20795023785828481,
                    "languages": 0.24182089738069584,
                    "like": 0.15747495330926245,
                    "python": 0.5976456192706835,
                    "requirement": 0.38423557741123493,
                    "thoughts": 0.3434178413970589
                },
                "Max term": "python",
                "Max score": 0.5976456192706835
            }
        ],
        "Best answer": "In Makefiles, it's annoying. In python, I find it very apropos and it makes the syntax a lot cleaner. I think the thing that makes it better in python is that no special characters are required, the only requirement is that you be consistent. You should be doing it anyway, so you get no cost added by following it. ",
        "Best answer TF-IDF scores": [
            {
                "Scores": {
                    "added": 0.2462802798236884,
                    "annoying": 0.2501850425841808,
                    "better": 0.15189103792973474,
                    "characters": 0.28399918227108206,
                    "consistent": 0.28399918227108206,
                    "cost": 0.22061562167908308,
                    "following": 0.2184471094914047,
                    "lot": 0.1558409915148003,
                    "makes": 0.341729369154393,
                    "python": 0.41097036265524045,
                    "required": 0.2228850304728177,
                    "requirement": 0.2642191785600978,
                    "special": 0.2501850425841808,
                    "syntax": 0.2392993210145215,
                    "thing": 0.17332487770341223,
                    "think": 0.12896261981249274
                },
                "Max term": "python",
                "Max score": 0.41097036265524045
            }
        ]
    },
    {
        "ID": "7705",
        "Question": "When dealing with complicated algorithms in languages with support for nested functions (such as Python and D) I often write huge functions (because the algorithm is complicated) but mitigate this by using nested functions to structure the complicated code.  Are huge (100+ line) functions still considered evil even if they're well-structured internally via the use of nested functions? Edit:  For those of you not familiar with Python or D, nested functions in these languages also allow access to the outer function scope.  In D this access allows mutation of variables in the outer scope.  In Python it only allows reading.  In D you can explicitly disable access to the outer scope in a nested function by declaring it static. ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "100": 0.08385027643090669,
                    "access": 0.2195435218390513,
                    "algorithm": 0.08385027643090669,
                    "algorithms": 0.0850296194329463,
                    "allow": 0.08171077602202738,
                    "allows": 0.16549414945736962,
                    "code": 0.0372584779334858,
                    "complicated": 0.25155082929272005,
                    "considered": 0.08073372761228584,
                    "dealing": 0.0907811727324041,
                    "disable": 0.10644396570187656,
                    "edit": 0.07089862924208894,
                    "evil": 0.09258217309888171,
                    "explicitly": 0.10262961821899998,
                    "familiar": 0.08385027643090669,
                    "function": 0.14760566262157687,
                    "functions": 0.5031016585854401,
                    "huge": 0.15619744626289778,
                    "internally": 0.09951306940037913,
                    "languages": 0.1165342591702018,
                    "line": 0.0725813336793805,
                    "mitigate": 0.10644396570187656,
                    "nested": 0.5131480910949999,
                    "python": 0.21600549283293244,
                    "reading": 0.07144133176155501,
                    "scope": 0.2723435181972123,
                    "static": 0.0907811727324041,
                    "structure": 0.09459552021528068,
                    "structured": 0.09459552021528068,
                    "support": 0.07037262793894487,
                    "use": 0.040093703661534225,
                    "using": 0.0499483936597162,
                    "variables": 0.08915196972703816,
                    "write": 0.052479167978916774
                },
                "Max term": "nested",
                "Max score": 0.5131480910949999
            }
        ],
        "Best answer": "Always remember the rule, a functions does one thing and does it well! If you can do so, avoid nested functions. It hinders readability and testing. ",
        "Best answer TF-IDF scores": [
            {
                "Scores": {
                    "avoid": 0.2742274327299069,
                    "functions": 0.6231209733000938,
                    "nested": 0.3813384422574693,
                    "readability": 0.33125986289209314,
                    "remember": 0.2766244957864191,
                    "rule": 0.31594254351715284,
                    "testing": 0.23259950745030797,
                    "thing": 0.22566375456852214
                },
                "Max term": "functions",
                "Max score": 0.6231209733000938
            }
        ]
    }
]