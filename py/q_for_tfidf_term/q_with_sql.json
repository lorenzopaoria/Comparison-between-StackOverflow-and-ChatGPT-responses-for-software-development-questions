[
    {
        "ID": "4662",
        "Question": "I want to know about Which language is best for long term career and How? Which language should I choose among Java and .NET Platform or Should I choose Oracle like DBMS Language (SQL/PLSQL)? I am confused? Detailed answer would be appreciated. ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "answer": 0.16555087076276306,
                    "appreciated": 0.27530336655232773,
                    "best": 0.14576525992792835,
                    "career": 0.22447737329174278,
                    "choose": 0.43323439211774106,
                    "confused": 0.25829101616340383,
                    "detailed": 0.2516706255219679,
                    "java": 0.16120687982836251,
                    "know": 0.11960813563331617,
                    "language": 0.4209485028466041,
                    "like": 0.0995941940633967,
                    "long": 0.15865960460406428,
                    "net": 0.17196887414933018,
                    "oracle": 0.2660195750634111,
                    "platform": 0.2062937245737766,
                    "sql": 0.21661719605887053,
                    "term": 0.21960299411904247,
                    "want": 0.12957777126131081
                },
                "Max term": "choose",
                "Max score": 0.43323439211774106
            }
        ],
        "Best answer": "All of them. Both are solid technologies and they will stay in mainstream for long long time. Anyway the most characteristic of our career is change (evolution, new technologies introduction). You need learn new things forever. Technologies knowledge are not important to stay relevant on career, fundamentals, hard work, motivation and evolution is the key. ",
        "Best answer TF-IDF scores": [
            {
                "Scores": {
                    "career": 0.29501732050474216,
                    "change": 0.11007385616984533,
                    "characteristic": 0.22663275596601126,
                    "evolution": 0.40395950330270075,
                    "forever": 0.19080058924039048,
                    "fundamentals": 0.20556046134518682,
                    "hard": 0.11833061564940718,
                    "important": 0.11300425454421248,
                    "introduction": 0.18645019552566916,
                    "key": 0.14586496833831583,
                    "knowledge": 0.1194282401026875,
                    "learn": 0.10228795206999705,
                    "long": 0.2085169241614369,
                    "mainstream": 0.18090745703052594,
                    "motivation": 0.18448816672436238,
                    "need": 0.0829832686314386,
                    "new": 0.1749583921172483,
                    "relevant": 0.1453362437951416,
                    "solid": 0.16972829461956604,
                    "stay": 0.3088669912119637,
                    "technologies": 0.4344496731670869,
                    "things": 0.087013867153155,
                    "time": 0.07117800218981515,
                    "work": 0.07517875553593704
                },
                "Max term": "technologies",
                "Max score": 0.4344496731670869
            }
        ]
    },
    {
        "ID": "7008",
        "Question": "What different types of security do there exist? Why and when should they be implemented? Example: SQL Injection Prevention ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "different": 0.20996727006662746,
                    "example": 0.206643332334169,
                    "exist": 0.3325970713387262,
                    "implemented": 0.34886194690685485,
                    "injection": 0.40267047659865224,
                    "prevention": 0.4798502802782958,
                    "security": 0.3138697951641704,
                    "sql": 0.3106841875195046,
                    "types": 0.30569280649282754
                },
                "Max term": "prevention",
                "Max score": 0.4798502802782958
            }
        ],
        "Best answer": "Preventing Buffer overflow  a buffer overflow, or buffer overrun, is an anomaly where a program, while writing data to a buffer, overruns the buffer's boundary and overwrites adjacent memory. This is a special case of violation of memory safety. Buffer overflows can be triggered by inputs that are designed to execute code, or alter the way the program operates. This may result in erratic program behavior, including memory access errors, incorrect results, a crash, or a breach of system security. Thus, they are the basis of many software vulnerabilities and can be maliciously exploited...  I cannot count exploits that are based on this. ",
        "Best answer TF-IDF scores": [
            {
                "Scores": {
                    "access": 0.077053725062978,
                    "adjacent": 0.1333226156949076,
                    "based": 0.06723883425758968,
                    "basis": 0.09728785335017422,
                    "behavior": 0.0925957000199894,
                    "boundary": 0.1260712300645326,
                    "buffer": 0.7255577404910273,
                    "case": 0.06564572368799138,
                    "code": 0.03858925455746167,
                    "count": 0.1045392389805492,
                    "crash": 0.10968417896324394,
                    "data": 0.06309326695806114,
                    "designed": 0.09558331489682556,
                    "errors": 0.08711009988051928,
                    "execute": 0.10545657428368274,
                    "exploited": 0.1333226156949076,
                    "including": 0.08815218787926053,
                    "incorrect": 0.11367490445146289,
                    "inputs": 0.1036666699523223,
                    "memory": 0.26339410609842,
                    "overflow": 0.19116662979365112,
                    "overflows": 0.1333226156949076,
                    "overrun": 0.1333226156949076,
                    "preventing": 0.12933189020668864,
                    "program": 0.20105411963779724,
                    "result": 0.0811408611215389,
                    "results": 0.09003646771979923,
                    "safety": 0.12092629008183788,
                    "security": 0.0845959157590273,
                    "software": 0.05211742553452714,
                    "special": 0.09306024867061301,
                    "triggered": 0.1333226156949076,
                    "violation": 0.11523102614027027,
                    "vulnerabilities": 0.1333226156949076,
                    "way": 0.04751722159705656,
                    "writing": 0.06362983072737528
                },
                "Max term": "buffer",
                "Max score": 0.7255577404910273
            }
        ]
    },
    {
        "ID": "7181",
        "Question": "I have been using mysql for the same amount of time I have been using PHP. However I feel about 10x more confident in PHP; or any other programming language. But I just can't seem to really really grasp SQL. I mean, I can select, update, insert, delete, join, etc. but when it comes to more complex stuff I am lost. How to write a more complicated select statement, how to use indexes properly, which engine to use, etc. For some reason I really find the mysql docs hard to follow, but the php ones easy to follow. I am starting to think that maybe my brain is just wired in a way that makes programming make since but sql confusing. I don't know. Most people think Regex is so confusing but to me it makes more scientific sense than how to construct an sql statement. Please don't get me wrong, I am not hating on SQL, I really like it, I just want to understand it better. Whats the best/fastest way to really master MySQL?  When I say \"master\" I don't mean the guru among gurus, I mean smart enough to figure out most of the questions I ask on SO myself without needing help.  ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "10x": 0.11927149517147725,
                    "ask": 0.06733340130964459,
                    "best": 0.055577122558810074,
                    "better": 0.0531325478171916,
                    "brain": 0.10310868983791932,
                    "comes": 0.07758592829388859,
                    "complex": 0.08076051281216307,
                    "complicated": 0.08880437924318475,
                    "confident": 0.10704480493312876,
                    "confusing": 0.21408960986625752,
                    "construct": 0.11533538007626781,
                    "delete": 0.10401347202469005,
                    "docs": 0.10818322477890054,
                    "easy": 0.06816504150340753,
                    "engine": 0.09655453707531395,
                    "fastest": 0.11365416708469597,
                    "feel": 0.06698864664754697,
                    "figure": 0.08730224784432013,
                    "follow": 0.15435138307919635,
                    "grasp": 0.11365416708469597,
                    "guru": 0.12434603011245847,
                    "gurus": 0.13149818540982575,
                    "hard": 0.06865848305996063,
                    "help": 0.06002718926558092,
                    "indexes": 0.1275620703146163,
                    "insert": 0.11211933987410998,
                    "join": 0.10940021662707294,
                    "know": 0.0456039801006793,
                    "language": 0.053499502202424,
                    "like": 0.037973099573547886,
                    "lost": 0.09595653454055204,
                    "make": 0.04716036570724665,
                    "makes": 0.13010133901985327,
                    "master": 0.18749746725489305,
                    "maybe": 0.0722538795039294,
                    "mean": 0.2195972180142882,
                    "mysql": 0.32454967433670157,
                    "needing": 0.11365416708469597,
                    "ones": 0.07618999459913886,
                    "people": 0.048786195967691744,
                    "php": 0.22008494640803528,
                    "programming": 0.09749138438946482,
                    "properly": 0.09225719327385555,
                    "questions": 0.06653921124296243,
                    "really": 0.2476581651478015,
                    "reason": 0.06968881300358876,
                    "regex": 0.11533538007626781,
                    "say": 0.05726429580905439,
                    "scientific": 0.10940021662707294,
                    "select": 0.196961490937563,
                    "sense": 0.07599929668373763,
                    "smart": 0.09917257474270988,
                    "sql": 0.3303656978257271,
                    "starting": 0.08152204338909802,
                    "statement": 0.18265718034282843,
                    "stuff": 0.06792340230860434,
                    "think": 0.09033848677182924,
                    "time": 0.04129931743168233,
                    "understand": 0.06266978577491591,
                    "update": 0.07677477915997888,
                    "use": 0.08175987272257193,
                    "using": 0.09957456154117814,
                    "want": 0.049405185281102236,
                    "way": 0.09373396078619219,
                    "whats": 0.11927149517147725,
                    "write": 0.0553992448964431,
                    "wrong": 0.0717996213008532
                },
                "Max term": "sql",
                "Max score": 0.3303656978257271
            }
        ],
        "Best answer": "Fastest way I found to \"master\" anything was to challenge myself with it. Take a set of data and write down eight to ten different things you would like to query for. A group of students you might want to find the average age of everyone grouped by the grade point average rounded to the nearest whole number. Then write the queries for them. Start with one table, then add more. Practice data joins and built in functions.  ",
        "Best answer TF-IDF scores": [
            {
                "Scores": {
                    "add": 0.13678598327277983,
                    "age": 0.19600245279153095,
                    "average": 0.35370130121155763,
                    "built": 0.15994539992980292,
                    "challenge": 0.2073797501078065,
                    "data": 0.23858073350090878,
                    "different": 0.10699754962216047,
                    "fastest": 0.2178671676399502,
                    "functions": 0.15120211349222223,
                    "grade": 0.2445276549959063,
                    "group": 0.16534305069967545,
                    "grouped": 0.2445276549959063,
                    "joins": 0.2445276549959063,
                    "like": 0.07279180220847958,
                    "master": 0.17970983017299516,
                    "number": 0.13234075700409895,
                    "point": 0.11536328099582216,
                    "practice": 0.14833136782938564,
                    "queries": 0.2031475486497399,
                    "query": 0.19442944916320545,
                    "rounded": 0.2520729150536311,
                    "set": 0.13113730328599457,
                    "start": 0.11611305628752218,
                    "students": 0.18627492072614124,
                    "table": 0.18394203163106174,
                    "things": 0.09678141648100796,
                    "want": 0.09470631882682716,
                    "way": 0.0898407558296721,
                    "write": 0.21239303202997578
                },
                "Max term": "average",
                "Max score": 0.35370130121155763
            }
        ]
    },
    {
        "ID": "8588",
        "Question": "SQL is officially pronounced as /ˌɛskjuːˈɛl/ like \"S-Q-L\", as stated in   Beaulieu, Alan (April 2009). Mary E. Treseler. ed. Learning SQL (2nd ed.). Sebastapol, CA, USA: O'Reilly. ISBN 978-0-596-52083-0.  But often it is pronounced  /ˈsiːkwəl/ like \"sequel\", what is the history behind this second pronunciation? ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "2009": 0.237954419733574,
                    "2nd": 0.2341808689583959,
                    "alan": 0.2524763985171468,
                    "ca": 0.25900635566167984,
                    "ed": 0.475908839467148,
                    "history": 0.18931240337274005,
                    "learning": 0.13291891666925654,
                    "like": 0.15420373955150182,
                    "mary": 0.2669983773007196,
                    "officially": 0.24217289059743566,
                    "second": 0.16552512288509205,
                    "sequel": 0.2524763985171468,
                    "sql": 0.33539286097516763,
                    "stated": 0.237954419733574,
                    "usa": 0.2524763985171468
                },
                "Max term": "ed",
                "Max score": 0.475908839467148
            }
        ],
        "Best answer": "SEQUEL = Structured English QUEry Language.  For a good historical perspective read   Don Chamberlin: ...A bunch of things were happening at about this time that I think we ought to mention just in passing. One was that we had to change the name of our language from SEQUEL to SQL. And the reason that we had to do that was because of a legal challenge that came from a lawyer. Mike, you probably can help me out with this. I believe it was from the Hawker Siddeley Aircraft Company in Great Britain, that said SEQUEL was their registered trademark. We never found out what kind of an aircraft a SEQUEL was, but they said we couldn't use their name anymore, so we had to figure out what to do about that. I think I was the one who condensed all the vowels out of SEQUEL to turn it into SQL, based on the pattern of APL and languages that had three-lettered names that end in L. So that was how that happened. ...  ",
        "Best answer TF-IDF scores": [
            {
                "Scores": {
                    "anymore": 0.12465486704293072,
                    "apl": 0.14806493090502304,
                    "based": 0.07467385256877,
                    "believe": 0.0903833445200798,
                    "bunch": 0.10676373637455651,
                    "came": 0.10283458552100433,
                    "challenge": 0.1218126444258415,
                    "change": 0.07191404366402296,
                    "company": 0.06997228340225209,
                    "end": 0.07170047519576092,
                    "english": 0.1124775845396078,
                    "figure": 0.09830098609069152,
                    "good": 0.050454893475879205,
                    "great": 0.07581637253351603,
                    "happened": 0.11088780219944189,
                    "happening": 0.12465486704293072,
                    "help": 0.06758969033170292,
                    "historical": 0.12986586110427906,
                    "kind": 0.07787999264471898,
                    "language": 0.12047923052880602,
                    "languages": 0.06758969033170292,
                    "lawyer": 0.12465486704293072,
                    "legal": 0.1124775845396078,
                    "mention": 0.1049838886971133,
                    "mike": 0.1436329259477679,
                    "names": 0.09712073735595304,
                    "ought": 0.1436329259477679,
                    "passing": 0.1218126444258415,
                    "pattern": 0.10089532185607886,
                    "perspective": 0.11013821602622156,
                    "probably": 0.06930218739805981,
                    "query": 0.11420577633311664,
                    "read": 0.06997228340225209,
                    "reason": 0.07846852981332796,
                    "registered": 0.14001171422658548,
                    "said": 0.16306044139713463,
                    "sequel": 0.7000585711329274,
                    "sql": 0.18599334306213533,
                    "structured": 0.11932669461115616,
                    "things": 0.05684836762847711,
                    "think": 0.10171974434664525,
                    "time": 0.046502395169095136,
                    "trademark": 0.14806493090502304,
                    "turn": 0.10442436786117025,
                    "use": 0.0460301785448308
                },
                "Max term": "sequel",
                "Max score": 0.7000585711329274
            }
        ]
    },
    {
        "ID": "10581",
        "Question": "Should items like Foreign Keys, Constraints, Default Values, and so on be handled by the database management system (in this case, MS SQL 2005) or the application? I have heard opinions from both sides and I'm honestly not sure which way to go. There is a chance we will be spanning multiple servers/databases and I don't think Foreign Keys can be used across linked servers. In addition to that, there are some circular references in the database design which prevents me from using ON UPDATE CASCADE on everything. The database is MS SQL 2005 (possibly 2008) and all interactions with it should go through the application. ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "2005": 0.3105442704953829,
                    "2008": 0.14795928547442944,
                    "addition": 0.1273392979075871,
                    "application": 0.15938871395569718,
                    "cascade": 0.16606511896149403,
                    "case": 0.08429061769790684,
                    "chance": 0.11510417829927508,
                    "circular": 0.17118930219182213,
                    "constraints": 0.13423078507323274,
                    "database": 0.2925091800782957,
                    "databases": 0.1320421185302988,
                    "default": 0.12820595237560922,
                    "design": 0.07885541005859985,
                    "foreign": 0.2959185709488589,
                    "handled": 0.13796280765797117,
                    "heard": 0.10681400580613334,
                    "honestly": 0.12820595237560922,
                    "interactions": 0.16606511896149403,
                    "items": 0.12343780135943017,
                    "keys": 0.28484266434027,
                    "like": 0.04943481461585634,
                    "linked": 0.1331103863901002,
                    "management": 0.09160346747116886,
                    "ms": 0.25300833045200866,
                    "multiple": 0.09943798235392211,
                    "opinions": 0.12343780135943017,
                    "possibly": 0.1105869982818737,
                    "prevents": 0.15527213524769146,
                    "references": 0.130044022523526,
                    "servers": 0.2640842370605976,
                    "sides": 0.16606511896149403,
                    "sql": 0.215041268830599,
                    "sure": 0.08170216481298151,
                    "think": 0.05880302630540723,
                    "update": 0.0999483059737033,
                    "used": 0.06951016461899132,
                    "using": 0.06481496171663986,
                    "values": 0.11560889351316316,
                    "way": 0.061013204435689715
                },
                "Max term": "2005",
                "Max score": 0.3105442704953829
            }
        ],
        "Best answer": "If there's any chance that the DB will be modified outside your application, you want the constraints in the database.  If the DB is and always will be nothing more than the back end of the application, you can leave them out, although I'd document them just in case and probably just keep them in if the performance hit wasn't too bad.  (Peoplesoft software works this way - the constraints are in the software, and (I'm not making this up) it runs everything as SYS on Oracle.) You want things like that to be monitored by the application, so it can react intelligently and not at best parrot back a database error message to the user. And, yes, this is double coverage, but without it you're probably going to get preventable data corruption or a bad user interface. ",
        "Best answer TF-IDF scores": [
            {
                "Scores": {
                    "application": 0.2851522218770665,
                    "bad": 0.20732294391785902,
                    "best": 0.0862940504056835,
                    "case": 0.10053265932253874,
                    "chance": 0.1372837150753154,
                    "constraints": 0.32019169285787147,
                    "corruption": 0.2041759363846845,
                    "coverage": 0.1551023325056835,
                    "data": 0.09662371829105251,
                    "database": 0.23258204018956258,
                    "db": 0.3079685586332036,
                    "document": 0.1411115850072283,
                    "double": 0.15626797649702281,
                    "end": 0.098872241879557,
                    "error": 0.12014656915973018,
                    "going": 0.09016358994216413,
                    "hit": 0.15291008282193208,
                    "interface": 0.13189611521911845,
                    "leave": 0.1309350166132037,
                    "like": 0.058960457429085344,
                    "making": 0.10904148812414405,
                    "message": 0.14809270133725652,
                    "modified": 0.16150069281242274,
                    "oracle": 0.157485443587661,
                    "outside": 0.13238961505361965,
                    "performance": 0.12014656915973018,
                    "probably": 0.19113018753349809,
                    "react": 0.18196577431351219,
                    "runs": 0.14722315211956222,
                    "software": 0.15962969380711894,
                    "sys": 0.2041759363846845,
                    "things": 0.07839174760383004,
                    "user": 0.19716174422472002,
                    "want": 0.15342188845556706,
                    "way": 0.0727698985157861,
                    "works": 0.10779634190046987,
                    "yes": 0.11859878449978088
                },
                "Max term": "constraints",
                "Max score": 0.32019169285787147
            }
        ]
    },
    {
        "ID": "10899",
        "Question": "What are questions to test a programmers knowledge of SQL? What is the answer to the question? And what would a lack of an correct answer mean in terms of time likely to understand the concept(s) related to the question? GOOGLED: sql challenge ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "answer": 0.326072661543684,
                    "challenge": 0.27942857742454025,
                    "concept": 0.22023179577131882,
                    "correct": 0.2079606869613462,
                    "googled": 0.33964924745100095,
                    "knowledge": 0.17898432952630516,
                    "lack": 0.22106780299109555,
                    "likely": 0.1894872444812649,
                    "mean": 0.18906732339672572,
                    "programmers": 0.15833051335469828,
                    "question": 0.26876096821817497,
                    "questions": 0.17186543642576121,
                    "related": 0.20490174545362758,
                    "sql": 0.4266540268233564,
                    "terms": 0.20148305870653305,
                    "test": 0.16399052512702492,
                    "time": 0.10667281865672626,
                    "understand": 0.16187102133787415
                },
                "Max term": "sql",
                "Max score": 0.4266540268233564
            }
        ],
        "Best answer": "It depends on how difficult you want it to be. Also, I'm a little wary of giving you the answer because most SQL problems have multiple acceptable ways to do things and there are also ways of solving SQL problems in sloppy ways that will cause other issues. The person \"grading\" the answer definitely needs to be able to solve it on their own.  That said, here are a few I came up with off the top of my head. Extremely Easy Level: Given an employees table with the columns EmpID, FirstName, Lastname, HireDate, and TerminationDate: Write a query to return all employees still working for the company with last names starting with \"Smith\" sorted by last name then first name. Easy Level Given the Employee table above, plus a new table \"AnnualReviews\" with the columns EmpID, and ReviewDate: Write a query to return all employees who have never had a review sorted by HireDate. Medium Level Given the employee table above, write a query to calculate the difference (in days) between the most and least tenured employee still working for the company? Hard Level Given the employee table above, write a query to calculate the longest period (in days) that the company has gone without a hiring or firing anyone. Harder Level Again using the same tables, write a query that returns each employee and for each row/employee include the greatest number of employees that worked for the company at any time during their tenure and the first date that maximum was reached. Extra points for not using cursors. ",
        "Best answer TF-IDF scores": [
            {
                "Scores": {
                    "able": 0.04528574438527306,
                    "acceptable": 0.07495006899453609,
                    "answer": 0.08648829717843856,
                    "calculate": 0.1605790056718121,
                    "came": 0.06256920091716961,
                    "cause": 0.059810754503484505,
                    "columns": 0.1605790056718121,
                    "company": 0.17029717527998003,
                    "date": 0.05932730044452237,
                    "days": 0.10413420933890077,
                    "definitely": 0.05841481132038792,
                    "depends": 0.05621150274868184,
                    "difference": 0.05532901299400004,
                    "difficult": 0.05301276210686957,
                    "easy": 0.09339971567170569,
                    "employee": 0.41370455041184095,
                    "employees": 0.2583520242437821,
                    "extra": 0.06138926541913325,
                    "extremely": 0.06288310791123514,
                    "firstname": 0.09008938348558768,
                    "given": 0.20427943828437023,
                    "giving": 0.06320538673784097,
                    "gone": 0.06794311335479086,
                    "greatest": 0.08028950283590605,
                    "hard": 0.04703791455866991,
                    "harder": 0.06196483799780674,
                    "head": 0.060839864458243964,
                    "hiring": 0.06614949621351492,
                    "include": 0.05677368503259079,
                    "issues": 0.05143425119122083,
                    "level": 0.22831123240480922,
                    "little": 0.045662246480961836,
                    "longest": 0.09008938348558768,
                    "maximum": 0.08332657230679977,
                    "medium": 0.07125961122349882,
                    "multiple": 0.05232982675095883,
                    "names": 0.05909263792974674,
                    "needs": 0.04792689904118503,
                    "new": 0.03477408553385915,
                    "number": 0.04729781145260533,
                    "period": 0.06746914124201042,
                    "person": 0.04960666427413065,
                    "plus": 0.06614949621351492,
                    "points": 0.056396006176612015,
                    "problems": 0.08913240427173393,
                    "query": 0.3474397319289316,
                    "reached": 0.081712880173324,
                    "return": 0.1151328222445413,
                    "returns": 0.07333637686106032,
                    "review": 0.05819706237000873,
                    "row": 0.081712880173324,
                    "said": 0.04960666427413065,
                    "sloppy": 0.09008938348558768,
                    "smith": 0.09008938348558768,
                    "solve": 0.05585073745709949,
                    "solving": 0.06353649621137869,
                    "sorted": 0.16665314461359954,
                    "sql": 0.11316674047306592,
                    "starting": 0.05585073745709949,
                    "table": 0.3286990239154239,
                    "tables": 0.07125961122349882,
                    "things": 0.03458911141556343,
                    "time": 0.028294155042521477,
                    "using": 0.06821851443907566,
                    "want": 0.03384748366750583,
                    "wary": 0.08739275173245295,
                    "ways": 0.15320957871327767,
                    "worked": 0.048688394360702256,
                    "working": 0.07648059513159629,
                    "write": 0.1897700642306628
                },
                "Max term": "employee",
                "Max score": 0.41370455041184095
            }
        ]
    },
    {
        "ID": "18357",
        "Question": "This is a specific question relating to C#. However, it can be extrapolated to other languages too.  While one is preparing for an interview of a C# Developer (ASP.NET or WinForms or ), what would be the typical reference material that one should look at?  Are there any good books/interview question collections that one should look at so that they can be better prepared? This is just to know the different scenarios. For example, I might be writing SQL Stored Procedures and Queries, but I might stumble when asked suddenly  Given an Employee Table with the following column(s).  EmployeeId, EmployeeName, ManagerId Write a SQL Query which will get me the Name of Employee and Manager Name? NOTE: I am not asking for a Question Bank so that I can learn by rote what the questions are and reproduce them (which, obviously will NOT work!) ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "asked": 0.11072108683835544,
                    "asking": 0.11725891634641031,
                    "asp": 0.1325451061689103,
                    "bank": 0.17289881683913827,
                    "better": 0.07965079446711473,
                    "books": 0.11509277093523779,
                    "collections": 0.17289881683913827,
                    "column": 0.1703785170238939,
                    "developer": 0.08908239765112534,
                    "different": 0.0836752229686184,
                    "employee": 0.301748179297676,
                    "example": 0.08235058208145057,
                    "following": 0.10997616057591211,
                    "given": 0.11174813373861384,
                    "good": 0.06717386164112403,
                    "interview": 0.24680500371357914,
                    "know": 0.0683647480707917,
                    "languages": 0.08998652447613982,
                    "learn": 0.08897152481124818,
                    "look": 0.18305007538749812,
                    "manager": 0.12069792858800737,
                    "material": 0.17289881683913827,
                    "net": 0.09829271809134281,
                    "note": 0.11725891634641031,
                    "obviously": 0.1264155451264127,
                    "prepared": 0.16047044809212563,
                    "preparing": 0.17879943157205336,
                    "procedures": 0.15735589554786278,
                    "queries": 0.15886734311974063,
                    "query": 0.15204953354396616,
                    "question": 0.2339785414966708,
                    "questions": 0.0997486711337846,
                    "reference": 0.12981659162771764,
                    "relating": 0.1756848790277905,
                    "reproduce": 0.17289881683913827,
                    "scenarios": 0.16807766355995807,
                    "specific": 0.10042241798966614,
                    "sql": 0.24762496226454045,
                    "stored": 0.14474452860634043,
                    "suddenly": 0.16047044809212563,
                    "table": 0.1438480653471153,
                    "typical": 0.1456724530632935,
                    "winforms": 0.16047044809212563,
                    "work": 0.06539155763786499,
                    "write": 0.0830487911865616,
                    "writing": 0.09408192012986762
                },
                "Max term": "employee",
                "Max score": 0.301748179297676
            }
        ],
        "Best answer": "Take a look at Scott Hanselman's blog post on \"What Great .NET Developers Ought to Know\". From there you should be able to figure out how to search and study based on the concepts he mentions there. ",
        "Best answer TF-IDF scores": [
            {
                "Scores": {
                    "able": 0.1782530063853846,
                    "based": 0.17884027008035594,
                    "blog": 0.2354261136511516,
                    "concepts": 0.23169339506507539,
                    "developers": 0.16228948524463557,
                    "figure": 0.2354261136511516,
                    "great": 0.18157655021106442,
                    "hanselman": 0.35460835783311356,
                    "know": 0.1229792825182781,
                    "look": 0.1646416286999311,
                    "mentions": 0.3353212928666847,
                    "net": 0.17681580476428613,
                    "ought": 0.3439939200307646,
                    "post": 0.21778515602194287,
                    "scott": 0.3353212928666847,
                    "search": 0.23740839026813143,
                    "study": 0.2572042061280513
                },
                "Max term": "hanselman",
                "Max score": 0.35460835783311356
            }
        ]
    },
    {
        "ID": "18579",
        "Question": "Is there any reason to keep using Linq to SQL, or is it better to move to ORM techniques like EF, NHibernate etc. We are using Linq to SQL in a new large enterprise application that will exist for a long time. The motivation for this new enterprise application is that the application was ordinary written in Visual Basic and since Microsoft stopped the support we where forced to rewrite the application. It’s seems that we are already there but this time with our DAL (Data Access Layer). I have already read this article, but it only compare to EF's weakness. ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "access": 0.11136103250734516,
                    "application": 0.3588016041960954,
                    "article": 0.12688912654772413,
                    "basic": 0.1146146366082208,
                    "better": 0.07785460711946884,
                    "compare": 0.1510841634313083,
                    "data": 0.09118483690397336,
                    "ef": 0.3853660320310303,
                    "enterprise": 0.2676457952302377,
                    "exist": 0.12955611096445854,
                    "forced": 0.15528476100521307,
                    "large": 0.10270402883763224,
                    "layer": 0.13449428134564007,
                    "like": 0.05564161460088071,
                    "linq": 0.3137034294279556,
                    "long": 0.08864047402690912,
                    "microsoft": 0.11761958293060977,
                    "motivation": 0.1568517147139778,
                    "new": 0.14874950678106014,
                    "nhibernate": 0.16899981408207698,
                    "ordinary": 0.1747673653647465,
                    "orm": 0.14982309282326361,
                    "read": 0.09105782524618676,
                    "reason": 0.10211434196010878,
                    "rewrite": 0.14747176161522724,
                    "sql": 0.24204082682488084,
                    "stopped": 0.1747673653647465,
                    "support": 0.10270402883763224,
                    "techniques": 0.13190744217249492,
                    "time": 0.12103097875180384,
                    "using": 0.14590563950658966,
                    "visual": 0.12356477628950466,
                    "weakness": 0.17821872728075255,
                    "written": 0.10371775956443194
                },
                "Max term": "ef",
                "Max score": 0.3853660320310303
            }
        ],
        "Best answer": "It's not dead, but Microsoft is now focused on the Entity Framework. I've used LINQ to SQL on small projects, and it's quite nice as a lightweight data-layer and i'd consider using it again on similar sized projects. The LINQ implementation itself is really good and until recently much better than the NHibernate LINQ project. On the larger project I used L2S on, I found it hard to come up with a unit-of-work pattern that I was happy with, due to limitations with the L2S 'DataContext' class. Trying to implement something like 'Session per request' with L2S seems either very difficult or impossible. I also wouldn't really consider L2S as a true ORM, as it really doesn't give you many mapping options. Your class design really needs to follow your database schema (table-per-class) otherwise it will fight with you every step of the way. Another thing I don't like about L2S is the need to use specific types (EntitySet and EntityRef) to handle collections, references and lazy-loading. This means it's not possible to keep your domain model ORM agnostic without adding another layer of abstraction. My other issue with L2S is the sole reliance on LINQ to generate queries. The LINQ provider is very well written and generally creates decent SQL for the majority of queries but I have my concerns that there are more complex queries that can't be expressed well with LINQ. Using L2S you basically have to revert to calling stored procedures in these cases, whereas (for example) NHibernate has several API's (LINQ provider, QueryOver, HQL etc) that can be used when you want more control over the generated SQL. In L2S's defence over NHibernate, there is a lot less overhead in getting it up and running on a project. ",
        "Best answer TF-IDF scores": [
            {
                "Scores": {
                    "abstraction": 0.06951902235055607,
                    "adding": 0.06482797842938369,
                    "agnostic": 0.0847420200987966,
                    "api": 0.06621369619539849,
                    "basically": 0.06287593561106325,
                    "better": 0.039616316326258234,
                    "calling": 0.07154643588727051,
                    "cases": 0.056525394573450245,
                    "class": 0.15739457358158454,
                    "collections": 0.08599555429623583,
                    "come": 0.051571160265834505,
                    "complex": 0.06021608512442296,
                    "concerns": 0.07199231432815655,
                    "consider": 0.10662735690616781,
                    "control": 0.052260944405887653,
                    "creates": 0.073944357146477,
                    "data": 0.04639940366538348,
                    "database": 0.05584378328086595,
                    "dead": 0.07981399401180808,
                    "decent": 0.07069761529471477,
                    "design": 0.04516355105837256,
                    "difficult": 0.057695245640008275,
                    "domain": 0.06333746206612831,
                    "entity": 0.07342852027273979,
                    "example": 0.04095912327324232,
                    "expressed": 0.09271401175412265,
                    "fight": 0.08157021950031491,
                    "focused": 0.07623747980844289,
                    "follow": 0.057543195919191235,
                    "framework": 0.052362505948136254,
                    "generally": 0.05558073142491658,
                    "generate": 0.07245384078322162,
                    "generated": 0.07504100493853018,
                    "getting": 0.04994760320901607,
                    "good": 0.033410601481568276,
                    "handle": 0.06059188652956487,
                    "happy": 0.06592462622143688,
                    "hard": 0.051192654881578224,
                    "implement": 0.05848303524431999,
                    "implementation": 0.06078389219311037,
                    "impossible": 0.06878815909007145,
                    "issue": 0.055069903941590746,
                    "larger": 0.07199231432815655,
                    "layer": 0.13687482837555162,
                    "lazy": 0.0825448989898331,
                    "lightweight": 0.09511193301332914,
                    "like": 0.05662647045536276,
                    "limitations": 0.08066281460436381,
                    "linq": 0.5586979580826565,
                    "loading": 0.08157021950031491,
                    "lot": 0.04074664442958787,
                    "majority": 0.08066281460436381,
                    "mapping": 0.08893037272890138,
                    "means": 0.05011841280936633,
                    "microsoft": 0.05985072400906606,
                    "model": 0.06137732312298095,
                    "need": 0.03590054702817576,
                    "needs": 0.05216016112065079,
                    "nhibernate": 0.2579866628887075,
                    "nice": 0.060402643633462774,
                    "options": 0.06843741418777581,
                    "orm": 0.15247495961688579,
                    "overhead": 0.0756256413817033,
                    "pattern": 0.06681162435710157,
                    "possible": 0.04747916084591229,
                    "procedures": 0.07826489334515732,
                    "project": 0.1139446007075142,
                    "projects": 0.0892863563537533,
                    "provider": 0.16314043900062983,
                    "queries": 0.23704994888189093,
                    "quite": 0.052671982682384266,
                    "really": 0.14772571035039211,
                    "recently": 0.06059188652956487,
                    "references": 0.07448125431993605,
                    "request": 0.06914851462806403,
                    "revert": 0.09804675144599467,
                    "running": 0.05897940186377447,
                    "schema": 0.08599555429623583,
                    "session": 0.08359763303702936,
                    "similar": 0.051571160265834505,
                    "sized": 0.08599555429623583,
                    "small": 0.049695477513183754,
                    "sole": 0.09271401175412265,
                    "specific": 0.04994760320901607,
                    "sql": 0.18474370973286444,
                    "step": 0.06564177329054355,
                    "stored": 0.07199231432815655,
                    "table": 0.07154643588727051,
                    "thing": 0.04345163382412235,
                    "true": 0.06078389219311037,
                    "trying": 0.049863023146681174,
                    "types": 0.06059188652956487,
                    "unit": 0.05532283778233506,
                    "use": 0.030480610413378295,
                    "used": 0.1194334998643505,
                    "using": 0.07424408371373838,
                    "want": 0.03683714650740415,
                    "way": 0.03494462804414365,
                    "work": 0.032524127973613266,
                    "written": 0.05277678127962485
                },
                "Max term": "linq",
                "Max score": 0.5586979580826565
            }
        ]
    },
    {
        "ID": "20927",
        "Question": "Just as the title says, what is your favorite whiteboard interview problem, and why has it proven effective for you? Junior, senior, Java, C, Javascript, PHP, SQL, pseudo-code, etc. ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "code": 0.10475365802090764,
                    "effective": 0.24027705487142353,
                    "favorite": 0.26744521829253587,
                    "interview": 0.22655902576580103,
                    "java": 0.16916576336958852,
                    "javascript": 0.2288530534280205,
                    "junior": 0.2946133817136482,
                    "php": 0.2019091300633227,
                    "problem": 0.15618254245560648,
                    "proven": 0.3422305683772688,
                    "pseudo": 0.33474687876144654,
                    "says": 0.23209077866776592,
                    "senior": 0.24661838858378088,
                    "sql": 0.22731172124473759,
                    "title": 0.28141157472170114,
                    "whiteboard": 0.3174310642793473
                },
                "Max term": "proven",
                "Max score": 0.3422305683772688
            }
        ],
        "Best answer": "I've found this one extremely illuminating when interviewing candidates and filtering out those with no business being there. It is similar in complexity to Fizz Buzz, but focuses on database skills. Assuming the following basic  table structure Documents (DocID, DocDate) Keywords (KeyWordID, KeyWord) DocumentKeywords (DocID,KeywordID)  Write a query to return the following: Part 1: Documents with a DocDate after 4/1/1995   Part 2: Documents that contain the keyword \"Blue\"   Part 3: Documents that contain the either the keyword \"Blue\" or \"Yellow\" Part 4: Documents that contain the both the keywords \"Blue\" and \"Yellow\"  I let them write it in any SQL variant they want, and am not too picky on minor syntax problems. I mainly want to know that they understand basic relational DB concepts. Most candidates can get through part 3 with no issues at all. You'd be amazed how many think that the answer to part 4 is just to change the operator from OR to AND in the where clause. ",
        "Best answer TF-IDF scores": [
            {
                "Scores": {
                    "amazed": 0.12908865937368477,
                    "answer": 0.061964339760764243,
                    "assuming": 0.09056670523767589,
                    "basic": 0.1535729519945434,
                    "business": 0.06815340489048356,
                    "buzz": 0.11708600666386426,
                    "candidates": 0.19913791158325914,
                    "change": 0.06269740869756771,
                    "clause": 0.11504645588483643,
                    "complexity": 0.08756630308180906,
                    "concepts": 0.08434372482772647,
                    "contain": 0.3121007035365053,
                    "database": 0.0735240995929607,
                    "db": 0.09735537171310944,
                    "documents": 0.49784477895814777,
                    "extremely": 0.09010491340315051,
                    "filtering": 0.12522466825321762,
                    "fizz": 0.12908865937368477,
                    "focuses": 0.1220675576292606,
                    "following": 0.14403479202190145,
                    "interviewing": 0.10210756611297102,
                    "issues": 0.07369989975817996,
                    "keyword": 0.3396660466301913,
                    "keywords": 0.23417201332772852,
                    "know": 0.04476834896963534,
                    "let": 0.06962516160383694,
                    "mainly": 0.10304380317501591,
                    "minor": 0.09667621927303165,
                    "operator": 0.10620091379897294,
                    "picky": 0.12908865937368477,
                    "problems": 0.06385870415037379,
                    "query": 0.09956895579162957,
                    "relational": 0.11708600666386426,
                    "return": 0.08248664325599607,
                    "similar": 0.06789875077838668,
                    "skills": 0.07250520763631027,
                    "sql": 0.08107804853440272,
                    "structure": 0.08467356656321114,
                    "syntax": 0.08248664325599607,
                    "table": 0.09419826108915241,
                    "think": 0.044341578215996484,
                    "understand": 0.0615214468831402,
                    "variant": 0.11504645588483643,
                    "want": 0.09699980443333849,
                    "write": 0.10876825762588695,
                    "yellow": 0.25817731874736954
                },
                "Max term": "documents",
                "Max score": 0.49784477895814777
            }
        ]
    },
    {
        "ID": "23303",
        "Question": "Are there any programming languages that have a built-in database as a first-class language feature rather than connecting to an external SQL (or other) database? What would be the drawbacks and benefits to such a feature? What would such a feature look like and how would it change the way we program? ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "benefits": 0.2171343820011113,
                    "built": 0.20666309889318873,
                    "change": 0.15818994243227044,
                    "class": 0.1742820495450693,
                    "connecting": 0.32569970624279343,
                    "database": 0.37101287991336646,
                    "drawbacks": 0.2856670553526472,
                    "external": 0.23350470151927571,
                    "feature": 0.5538978384559555,
                    "language": 0.13250960153677657,
                    "languages": 0.14867762509002194,
                    "like": 0.09405321706674095,
                    "look": 0.15121958893066792,
                    "program": 0.16372132955743082,
                    "programming": 0.12073518413159533,
                    "sql": 0.2045655808846141,
                    "way": 0.11608191929755378
                },
                "Max term": "feature",
                "Max score": 0.5538978384559555
            }
        ],
        "Best answer": "Languages are \"small\" and databases are \"big\"; so whenever the two are combined, it's not a language with the database as a features, but a database with the language as a feature. Many databases have some proprietary languages tacked to them, e.g. PL/SQL, T-SQL. ",
        "Best answer TF-IDF scores": [
            {
                "Scores": {
                    "big": 0.1634196080854353,
                    "combined": 0.2755160421348536,
                    "database": 0.3578291522926821,
                    "databases": 0.4845849897221657,
                    "feature": 0.1780717999491235,
                    "features": 0.1658454522587349,
                    "language": 0.2556018993174452,
                    "languages": 0.2867889037344177,
                    "pl": 0.27995566087483137,
                    "proprietary": 0.26133797516299906,
                    "small": 0.1592163849455334,
                    "sql": 0.3945929230990258
                },
                "Max term": "databases",
                "Max score": 0.4845849897221657
            }
        ]
    }
]