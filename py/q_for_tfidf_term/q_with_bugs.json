[
    {
        "ID": "3241",
        "Question": "This question is a little abstract but I'm hoping someone can point me in the right direction. My question is what amount of time can one expect to devote to a software project's bugs in relation to the original development time. I realize there are a huge number of determining factors that go into but I was hoping for a typical or average breakdown.  For example, if Project A takes 40 hours to complete and an additional 10 fixing bugs then this project would have a 4:1 ratio. If another Project (B) takes 10 hours to complete but another 8 on bugs then it would have a 5:4 ratio.  Is this a documented/researched concept? UPDATE Thanks for all the informative answers. I understand that it's impossible to put a standard to this kind of metric due to all the variables and environmental factors involved. Before I assign an answer I'd like to know if this metric has an agreed-upon name so I can do further research. I would like to get to a point where I can understand the measurements necessary to generate the metrics myself and eventually come up with a baseline standard for my project. ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "10": 0.1898269138649159,
                    "40": 0.12218239103008771,
                    "abstract": 0.12600889732434176,
                    "additional": 0.10946100740261176,
                    "agreed": 0.12218239103008771,
                    "answer": 0.07726736952227391,
                    "answers": 0.09223053117589976,
                    "assign": 0.13069216253247612,
                    "average": 0.10439957558636222,
                    "baseline": 0.12600889732434176,
                    "breakdown": 0.13069216253247612,
                    "bugs": 0.2652120746449371,
                    "come": 0.08704951112201467,
                    "complete": 0.18123059511031417,
                    "concept": 0.10032469149481613,
                    "development": 0.06605821779057512,
                    "direction": 0.13069216253247612,
                    "documented": 0.11894712605651603,
                    "eventually": 0.1076348405599339,
                    "example": 0.06974047830107913,
                    "expect": 0.10595492991136445,
                    "factors": 0.20879915117272443,
                    "fixing": 0.11146134685418793,
                    "generate": 0.1136726195276993,
                    "hoping": 0.26138432506495224,
                    "hours": 0.1861745801795602,
                    "huge": 0.09588980408397382,
                    "impossible": 0.1076348405599339,
                    "involved": 0.09491345693245795,
                    "kind": 0.08771584260838088,
                    "know": 0.056992974347991,
                    "like": 0.09317508062772427,
                    "little": 0.08289760793882223,
                    "metric": 0.26138432506495224,
                    "metrics": 0.13069216253247612,
                    "necessary": 0.09061529755515708,
                    "number": 0.08184800528912843,
                    "original": 0.10159706159216848,
                    "point": 0.14986600320973195,
                    "project": 0.3085771612261866,
                    "question": 0.13409211119208736,
                    "realize": 0.10595492991136445,
                    "research": 0.10946100740261176,
                    "right": 0.07493300160486598,
                    "software": 0.06171543224523733,
                    "standard": 0.17155428204932463,
                    "takes": 0.17155428204932463,
                    "thanks": 0.12218239103008771,
                    "time": 0.10302133464084262,
                    "typical": 0.1136726195276993,
                    "understand": 0.14308104963628962,
                    "update": 0.09912506905754548,
                    "variables": 0.10946100740261176
                },
                "Max term": "project",
                "Max score": 0.3085771612261866
            }
        ],
        "Best answer": "The equilibrium percentage of total capacity allocated to defect-fixing is equal to the defect injection rate. Many factors can affect this rate, among them, of course: what kind of product the team is developing, what technologies and technical practices they use, the team's skill level, the company culture, etc. Considering Team B, if they create on average 8 units of rework for every 10 units of work they complete, then working those 8 units will create new 6.4 units of rework.  We can estimate the total effort they will eventually have to expend as the sum of a geometric progression: 10 + 8 + 6.4 + 5.12 + ... The number of bugs will decrease exponentially with time, but Team B has such a coefficient in their exponent that it will go to zero very slowly.  Actually, the sum of the first three terms in the above series is only 24.4; of the first five, 33.6; of the first 10, 45; of the entire series, 50.  So, Team B summary: defect injection rate, 0.8; feature development, 10/50 = 20%; defect-fixing, 80%.  20/80 is their sustainable capacity allocation. By contrast, Team A is in much better shape.  Their progression looks like this: 40 + 10 + 2.5 + 0.625 + ... The sum of this series is 53 1/3, so Team A's feature development allocation is 40/(53 1/3) = 75% and defect-fixing allocation is 25%, which matches their defect injection rate of 10/40 = 0.25. Actually, all terms in Team A's series after the first three are negligibly small.  What this means in practical terms is that Team A can probably squash all their bugs with a couple of maintenance releases, the second release being pretty small in scope.  This also creates an illusion that any team can do that.  But not Team B. I thought about this equivalence while reading David Anderson's new book, \"Kanban\".  (The book is on a different subject, but addresses quality concerns, too.)  When discussing software quality, Anderson quotes this book, by Capers Jones, \"Software Assessments, Benchmarks, and Best Practices\": \"...in 2000... measured software quality for North American teams... ranged from 6 defects per function point down to less than 3 per 100 function points, a range of 200 to 1.  The midpoint is approximately 1 defect per 0.6 to 1.0 function points.  This implies that it is common for teams to spend more than 90 percent of their effort fixing defects.\"  He cites an example provided by one of his colleagues of a company that spends 90% of the time fixing their bugs. The fluency with which Anderson goes from the defect injection rate to the defext-fixing capacity allocation (failure demand is the term for it) suggests that the equivalence of the two things is well known to software quality researchers and has probably been known for some time. The key words in the line of reasoning that I'm trying to present here are \"equlibrium\" and \"sustainable\".  If we take away sustainability, then there's an obvious way to cheat these numbers: you do the initial coding, then move on to code somewhere else, and leave maintenance to others.  Or you run up the technical debt and unload it on a new owner. Obviously, no particular allocation will suit all teams.  If we decreed that 20% must be spent on bugs, then, if a team has an ultra-low defect injection rate, they will simply not have enough bugs to fill the time, and if a team had a very high rate, their bugs will continue to accumulate. The math I used here is way simplified.  I neglected things like transaction costs (planning and estimation meetings, post-mortems, etc.), which would affect the percentages somewhat.  I also omitted equations simulating sustaining one product and developing another one concurrently.  But the conclusion still stands.  Do what you can, in terms of technical practices, like unit-testing, continuous integration, code reviews, etc., to reduce your defect injection rate and, consequently, your failure demand.  If you can create only one bug for every 10 features, you will have a lot of free time to develop new features and satisfy your customers. ",
        "Best answer TF-IDF scores": [
            {
                "Scores": {
                    "10": 0.2190383953557028,
                    "100": 0.03394121729898955,
                    "12": 0.04154278699550555,
                    "20": 0.10479410211253176,
                    "25": 0.08056251824979639,
                    "40": 0.12084377737469461,
                    "50": 0.07097040525903821,
                    "75": 0.0430867723260351,
                    "80": 0.07097040525903821,
                    "90": 0.0734934610002529,
                    "actually": 0.04737925928002596,
                    "affect": 0.0749514918475226,
                    "average": 0.03441859601264535,
                    "away": 0.02987417622724531,
                    "best": 0.02271347198328443,
                    "better": 0.021543591107094473,
                    "book": 0.08308215799558226,
                    "bug": 0.030406688674217808,
                    "bugs": 0.17487096482166276,
                    "capacity": 0.12926031697810528,
                    "code": 0.03016324214058109,
                    "coding": 0.02446539690990475,
                    "colleagues": 0.04154278699550555,
                    "common": 0.0261875701198172,
                    "company": 0.050947225821755836,
                    "complete": 0.02987417622724531,
                    "concerns": 0.039214652508024445,
                    "considering": 0.03608725583190807,
                    "continue": 0.03674673050012645,
                    "continuous": 0.040281259124898196,
                    "contrast": 0.0430867723260351,
                    "costs": 0.03674673050012645,
                    "couple": 0.03230558497404262,
                    "course": 0.030406688674217808,
                    "create": 0.08308215799558226,
                    "creates": 0.039214652508024445,
                    "culture": 0.03608725583190807,
                    "customers": 0.03394121729898955,
                    "david": 0.04154278699550555,
                    "defect": 0.430867723260351,
                    "defects": 0.0861735446520702,
                    "demand": 0.0830855739910111,
                    "develop": 0.03195067400474736,
                    "developing": 0.06196725323039259,
                    "development": 0.04355632862833502,
                    "different": 0.023184350699353987,
                    "discussing": 0.04154278699550555,
                    "effort": 0.0678824345979791,
                    "entire": 0.034931367370843916,
                    "equal": 0.040281259124898196,
                    "estimate": 0.03441859601264535,
                    "estimation": 0.039214652508024445,
                    "eventually": 0.035485202629519104,
                    "example": 0.02299213703591975,
                    "factors": 0.03441859601264535,
                    "failure": 0.0749514918475226,
                    "feature": 0.053967526451426884,
                    "features": 0.05430923501873653,
                    "fixing": 0.2204803830007587,
                    "free": 0.027509528478663524,
                    "function": 0.08962252868173594,
                    "goes": 0.030983626615196293,
                    "high": 0.028918279922979174,
                    "initial": 0.04154278699550555,
                    "injection": 0.24168755474938922,
                    "integration": 0.039214652508024445,
                    "jones": 0.0430867723260351,
                    "key": 0.033075182607393915,
                    "kind": 0.028918279922979174,
                    "known": 0.06615036521478783,
                    "leave": 0.03394121729898955,
                    "level": 0.026339647602473565,
                    "like": 0.04607713355958642,
                    "line": 0.0293797340106835,
                    "looks": 0.0326796894283822,
                    "lot": 0.022103836043784023,
                    "low": 0.03394121729898955,
                    "maintenance": 0.0749514918475226,
                    "matches": 0.0430867723260351,
                    "math": 0.040281259124898196,
                    "means": 0.02788363293300311,
                    "meetings": 0.034931367370843916,
                    "new": 0.08164559488116636,
                    "number": 0.026983763225713442,
                    "numbers": 0.03608725583190807,
                    "obvious": 0.03349465933527691,
                    "obviously": 0.03394121729898955,
                    "owner": 0.039214652508024445,
                    "particular": 0.028078554186736708,
                    "percent": 0.0430867723260351,
                    "percentage": 0.04154278699550555,
                    "planning": 0.03230558497404262,
                    "point": 0.024704015277526626,
                    "points": 0.06258239867305794,
                    "post": 0.03230558497404262,
                    "practical": 0.039214652508024445,
                    "practices": 0.09922554782218174,
                    "present": 0.040281259124898196,
                    "pretty": 0.026983763225713442,
                    "probably": 0.0489307938198095,
                    "product": 0.05655825222402964,
                    "provided": 0.0374757459237613,
                    "quality": 0.12275658453656006,
                    "range": 0.038290715830656005,
                    "rate": 0.28869804665526455,
                    "reading": 0.028918279922979174,
                    "reasoning": 0.04154278699550555,
                    "reduce": 0.03608725583190807,
                    "release": 0.03394121729898955,
                    "releases": 0.040281259124898196,
                    "reviews": 0.03608725583190807,
                    "run": 0.02665421299435765,
                    "scope": 0.03674673050012645,
                    "second": 0.03195067400474736,
                    "series": 0.15685861003209778,
                    "simply": 0.028918279922979174,
                    "skill": 0.03608725583190807,
                    "slowly": 0.038290715830656005,
                    "small": 0.05150083939851121,
                    "software": 0.08138571515312137,
                    "somewhat": 0.034931367370843916,
                    "spend": 0.03013531087546483,
                    "spent": 0.0374757459237613,
                    "subject": 0.0374757459237613,
                    "suggests": 0.0430867723260351,
                    "sum": 0.12926031697810528,
                    "summary": 0.040281259124898196,
                    "team": 0.33475545609032287,
                    "teams": 0.11024019150037935,
                    "technical": 0.08252858543599056,
                    "technologies": 0.0374757459237613,
                    "term": 0.03394121729898955,
                    "terms": 0.1307187577135288,
                    "testing": 0.025339254380085732,
                    "things": 0.04095396898044143,
                    "thought": 0.02987417622724531,
                    "time": 0.08491053909394208,
                    "total": 0.0749514918475226,
                    "transaction": 0.0430867723260351,
                    "trying": 0.02665421299435765,
                    "unit": 0.02788363293300311,
                    "units": 0.1661711479820222,
                    "use": 0.016229273965706725,
                    "used": 0.02102533046108582,
                    "way": 0.03789238249104176,
                    "words": 0.035485202629519104,
                    "work": 0.018243635689395767,
                    "working": 0.02299213703591975,
                    "zero": 0.04154278699550555
                },
                "Max term": "defect",
                "Max score": 0.430867723260351
            }
        ]
    },
    {
        "ID": "3918",
        "Question": "What should you do, if a co-worker is editing your code?   Without the purpose of adding functionality or fixing bugs, just to change how it looks... ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "adding": 0.3548028734291011,
                    "bugs": 0.2759327811836209,
                    "change": 0.25234964978757696,
                    "code": 0.1427857500847017,
                    "editing": 0.38136416315583915,
                    "fixing": 0.3479008956110752,
                    "functionality": 0.29929791503799313,
                    "looks": 0.30939604872838494,
                    "purpose": 0.30939604872838494,
                    "worker": 0.40792545288257726
                },
                "Max term": "worker",
                "Max score": 0.40792545288257726
            }
        ],
        "Best answer": "Talk to them about it.  Go into the conversation with the attitude of \"They're not doing this to annoy me or because they have some form of obsessive-compulsive disorder; they're trying to make my code better.\" Because you could be wrong.  That could be a subtle bug fix and you just didn't spot it. Or, it could be that there's a coding standard you don't know about that you're violating, and they're just correcting it. Or, it could be that they're trying to annoy you, or they have some form of obsessive-compulsive disorder.  If that's the case, ask them nicely to stop, and if that doesn't work, take it up with your boss. But you'll never know unless you ask. ",
        "Best answer TF-IDF scores": [
            {
                "Scores": {
                    "ask": 0.3178510537818457,
                    "attitude": 0.23381704472015408,
                    "better": 0.12845348570383108,
                    "boss": 0.1905056323290988,
                    "bug": 0.18129963242888764,
                    "case": 0.1674181495963543,
                    "code": 0.08992404223199356,
                    "coding": 0.14587472889652547,
                    "conversation": 0.23381704472015408,
                    "fix": 0.18298378272257332,
                    "form": 0.3694792403627942,
                    "know": 0.2240647466425911,
                    "make": 0.1165848875987735,
                    "nicely": 0.2569045274528986,
                    "spot": 0.23381704472015408,
                    "standard": 0.1686140580597217,
                    "stop": 0.2115802303343676,
                    "talk": 0.20522059710835977,
                    "trying": 0.3178510537818457,
                    "unless": 0.1905056323290988,
                    "work": 0.1087775285264295,
                    "wrong": 0.16625593321583654
                },
                "Max term": "form",
                "Max score": 0.3694792403627942
            }
        ]
    },
    {
        "ID": "7455",
        "Question": "I mean, I still have a MSX2 with a Z80 processor and if you look at any Konami's game made for that computer in its time (roughly between '84 and '90) is amazing the high quality code of those games. I was a kid at the time, trying to learn how to program a computer and still today fascinated me how well made they are, mostly zero bugs or glitches, despite the really complex behavior. What hardware/software tools could they have used to accomplish that quality, which metodology? I know computers are really more complex today but at that time, even a stock control program I made in Basic was plagued with many bugs and was painful to debug. Any light you can shed will be deeply appreciated.  ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "90": 0.15900401626709168,
                    "accomplish": 0.16568487917027777,
                    "amazing": 0.17975667193550615,
                    "appreciated": 0.17975667193550615,
                    "basic": 0.13406692250673058,
                    "behavior": 0.15900401626709168,
                    "bugs": 0.2522236704845528,
                    "code": 0.06525854924661496,
                    "complex": 0.27358119022843186,
                    "computer": 0.23651342771679829,
                    "computers": 0.15900401626709168,
                    "control": 0.12513011603233296,
                    "debug": 0.14686449091069087,
                    "despite": 0.16968277613903118,
                    "game": 0.14311713727361383,
                    "games": 0.1449322235018633,
                    "hardware": 0.14311713727361383,
                    "high": 0.12513011603233296,
                    "know": 0.0813027302836455,
                    "learn": 0.1011747414819153,
                    "light": 0.16968277613903118,
                    "look": 0.1074248091337878,
                    "mean": 0.12417956783344884,
                    "program": 0.22794461977175126,
                    "quality": 0.26558539629092504,
                    "really": 0.17388134646629091,
                    "software": 0.08803950310675443,
                    "stock": 0.18643753483869224,
                    "time": 0.22044600794012245,
                    "today": 0.29372898182138174,
                    "tools": 0.12325827196070037,
                    "trying": 0.11533344215553507,
                    "used": 0.09097712752006505,
                    "zero": 0.17975667193550615
                },
                "Max term": "today",
                "Max score": 0.29372898182138174
            }
        ],
        "Best answer": "I don't know anything about Konami, so I'm taking an educated guess here.  Games on machines like the MSX would have required direct access to the hardware, so that pretty much limits the choice of languages to either C or Z80 assembly language.  (There were C compilers for the Z80 back then, for example this one.) I doubt if the games were completely written in C, if at all; mostly likely a lot of assembly code for performance reasons. As far as platforms go, since the MSX didn't have a hard drive, I would further assume the programs were initially written on a larger Z80 system, perhaps running CP/M.  For debugging, the code could probably have been downloaded into a special game cartridge for the MSX that had RAM memory in place of ROM -- this would have allowed the developer to download the program over and over again without burning ROM chips.  Debugging (e.g. setting breakpoints) could have been accomplished by replacing the Z80 inside the MSX with an In-Circuit Emulator (ICE) interface. ",
        "Best answer TF-IDF scores": [
            {
                "Scores": {
                    "access": 0.11235034133142668,
                    "accomplished": 0.15277600387043416,
                    "allowed": 0.1421354453331139,
                    "assembly": 0.3055520077408683,
                    "assume": 0.13686927510270244,
                    "burning": 0.1634165624077544,
                    "choice": 0.12252641258625124,
                    "code": 0.11440108125035937,
                    "completely": 0.12118033054222703,
                    "debugging": 0.3055520077408683,
                    "developer": 0.09024906855917962,
                    "doubt": 0.1634165624077544,
                    "download": 0.1634165624077544,
                    "drive": 0.13937048550806214,
                    "example": 0.08720300440206523,
                    "far": 0.11053977200490678,
                    "game": 0.12544528983998832,
                    "games": 0.25407250495216843,
                    "guess": 0.132485300424707,
                    "hard": 0.10803856159954707,
                    "hardware": 0.12544528983998832,
                    "initially": 0.1452264074419193,
                    "inside": 0.1421354453331139,
                    "interface": 0.12544528983998832,
                    "know": 0.07126361496258547,
                    "language": 0.07692442189828837,
                    "languages": 0.08945376992842057,
                    "larger": 0.1452264074419193,
                    "like": 0.05825273330550486,
                    "likely": 0.11053977200490678,
                    "limits": 0.15756064047389723,
                    "lot": 0.0838339171699148,
                    "machines": 0.13937048550806214,
                    "memory": 0.13686927510270244,
                    "performance": 0.12544528983998832,
                    "place": 0.11330473182995855,
                    "platforms": 0.13686927510270244,
                    "pretty": 0.1023421711379012,
                    "probably": 0.09279068366284,
                    "program": 0.09989921346758654,
                    "programs": 0.11330473182995855,
                    "ram": 0.15756064047389723,
                    "reasons": 0.11532440860836984,
                    "required": 0.11989993775994154,
                    "running": 0.11989993775994154,
                    "setting": 0.13458584890459904,
                    "special": 0.13458584890459904,
                    "taking": 0.13458584890459904,
                    "written": 0.22285889043394455
                },
                "Max term": "assembly",
                "Max score": 0.3055520077408683
            }
        ]
    },
    {
        "ID": "7927",
        "Question": "No one's perfect, and no matter what we do, we are going to produce code that has bugs in it from time to time. What are some methods/techniques for reducing the number of bugs you produce, both when writing new software and changing/maintaining existing code? ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "bugs": 0.4046790946737687,
                    "changing": 0.2389502389126305,
                    "code": 0.2094075514650087,
                    "existing": 0.2151030500884126,
                    "going": 0.1546270117981998,
                    "maintaining": 0.2722467407510048,
                    "matter": 0.21723836598620372,
                    "methods": 0.20740071861721607,
                    "new": 0.14170562329046538,
                    "number": 0.18733409890331304,
                    "perfect": 0.26583233355914204,
                    "produce": 0.4592472501325728,
                    "software": 0.14125457116821957,
                    "techniques": 0.24635512857850003,
                    "time": 0.23579571456364362,
                    "writing": 0.16669932711297222
                },
                "Max term": "produce",
                "Max score": 0.4592472501325728
            }
        ],
        "Best answer": "Avoid fancy coding.  The more complicated the code, the more likely there's bugs.  Usually on modern systems, clearly written code will be fast and small enough. Use available libraries.  The easiest way to not have bugs writing a utility routine is to not write it. Learn a few formal techniques for the more complicated stuff.  If there's complicated conditions, nail them down with pen and paper.  Ideally, know some proof techniques.  If I can prove code correct, it's almost always good except for big, dumb, obvious bugs that are easy to fix.  Obviously, this only goes so far, but sometimes you can formally reason about small but complicated things. For existing code, learn how to refactor:  how to make small changes in the code, often using an automated tool, that make the code more readable without changing the behavior. Don't do anything too quickly.  Taking a little time up front to do things right, to check what you've done, and to think about what you're doing can pay off big time later. Once you've written the code, use what you've got to make it good.  Unit tests are great.  You can often write tests ahead of time, which can be great feedback (if done consistently, this is test-driven development). Compile with warning options, and pay attention to the warnings.   Get somebody else to look at the code.  Formal code reviews are good, but they may not be at a convenient time. Pull requests, or similar if your scm doesn't support them allow for asynchronous reviews. Buddy checking can be a less formal review. Pair programming ensures two pairs of eyes look at everything.  ",
        "Best answer TF-IDF scores": [
            {
                "Scores": {
                    "ahead": 0.08750994214970138,
                    "allow": 0.07559031618433608,
                    "asynchronous": 0.09494225448257373,
                    "attention": 0.0896215152407891,
                    "automated": 0.0839813043579144,
                    "available": 0.06827470776409961,
                    "avoid": 0.06827470776409961,
                    "behavior": 0.0839813043579144,
                    "big": 0.12257574039253967,
                    "bugs": 0.19982582831416343,
                    "changes": 0.06558804190038271,
                    "changing": 0.07866056511612976,
                    "check": 0.06660860943805448,
                    "checking": 0.08750994214970138,
                    "clearly": 0.0775695595627138,
                    "code": 0.3102090370677744,
                    "coding": 0.055913435458450345,
                    "compile": 0.08564740268395953,
                    "complicated": 0.3102782382508552,
                    "conditions": 0.08750994214970138,
                    "consistently": 0.09205914747916011,
                    "convenient": 0.09205914747916011,
                    "correct": 0.07224882032092918,
                    "development": 0.04977201020968323,
                    "driven": 0.07559031618433608,
                    "easiest": 0.09494225448257373,
                    "easy": 0.06287052079099677,
                    "existing": 0.07081025553753205,
                    "eyes": 0.08564740268395953,
                    "far": 0.06660860943805448,
                    "fast": 0.07559031618433608,
                    "feedback": 0.08750994214970138,
                    "fix": 0.07013724722984147,
                    "formal": 0.25694220805187856,
                    "goes": 0.07081025553753205,
                    "good": 0.12918058089829745,
                    "got": 0.06329223400628177,
                    "great": 0.12183155036838576,
                    "ideally": 0.08750994214970138,
                    "know": 0.0429417413306773,
                    "later": 0.0738314709156561,
                    "learn": 0.10687512123534425,
                    "libraries": 0.07224882032092918,
                    "likely": 0.06660860943805448,
                    "little": 0.0624597624139665,
                    "look": 0.11347732973362219,
                    "make": 0.13406012756620744,
                    "modern": 0.07866056511612976,
                    "obvious": 0.07654899202504205,
                    "obviously": 0.0775695595627138,
                    "options": 0.08247413509212646,
                    "pair": 0.07559031618433608,
                    "pairs": 0.09205914747916011,
                    "paper": 0.08109819735450079,
                    "pay": 0.16494827018425293,
                    "pen": 0.0984708922743607,
                    "programming": 0.041803602185322204,
                    "proof": 0.09494225448257373,
                    "prove": 0.0896215152407891,
                    "pull": 0.09205914747916011,
                    "quickly": 0.07081025553753205,
                    "readable": 0.0839813043579144,
                    "reason": 0.061287870196269835,
                    "refactor": 0.08750994214970138,
                    "requests": 0.0839813043579144,
                    "review": 0.07654899202504205,
                    "reviews": 0.16494827018425293,
                    "right": 0.05645877599579618,
                    "routine": 0.09494225448257373,
                    "similar": 0.06417097719968345,
                    "small": 0.17655071387369642,
                    "somebody": 0.08564740268395953,
                    "stuff": 0.062059404108595735,
                    "support": 0.06510144017226653,
                    "systems": 0.06827470776409961,
                    "taking": 0.08109819735450079,
                    "techniques": 0.16219639470900157,
                    "test": 0.055647659313395145,
                    "tests": 0.124919524827933,
                    "things": 0.09359656455964706,
                    "think": 0.041803602185322204,
                    "time": 0.15524424034009557,
                    "tool": 0.0688715072091671,
                    "unit": 0.06372550243464085,
                    "use": 0.07418105381741665,
                    "using": 0.04620706170529839,
                    "usually": 0.06417097719968345,
                    "utility": 0.08750994214970138,
                    "warning": 0.09205914747916011,
                    "way": 0.04329979379819565,
                    "write": 0.0970965420655854,
                    "writing": 0.05487612540106924,
                    "written": 0.13428941025908628
                },
                "Max term": "complicated",
                "Max score": 0.3102782382508552
            }
        ]
    }
]