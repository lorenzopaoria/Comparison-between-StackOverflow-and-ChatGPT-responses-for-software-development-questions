[
    {
        "ID": "3241",
        "Question": "This question is a little abstract but I'm hoping someone can point me in the right direction. My question is what amount of time can one expect to devote to a software project's bugs in relation to the original development time. I realize there are a huge number of determining factors that go into but I was hoping for a typical or average breakdown.  For example, if Project A takes 40 hours to complete and an additional 10 fixing bugs then this project would have a 4:1 ratio. If another Project (B) takes 10 hours to complete but another 8 on bugs then it would have a 5:4 ratio.  Is this a documented/researched concept? UPDATE Thanks for all the informative answers. I understand that it's impossible to put a standard to this kind of metric due to all the variables and environmental factors involved. Before I assign an answer I'd like to know if this metric has an agreed-upon name so I can do further research. I would like to get to a point where I can understand the measurements necessary to generate the metrics myself and eventually come up with a baseline standard for my project. ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "10": 0.16240424269676784,
                    "40": 0.11462358060477754,
                    "abstract": 0.11059204551377644,
                    "additional": 0.09878148758612901,
                    "agreed": 0.11353306364148662,
                    "answer": 0.06827194952822994,
                    "answers": 0.08460289311524033,
                    "assign": 0.1212688727500574,
                    "average": 0.09978586962754764,
                    "baseline": 0.12474735889234521,
                    "breakdown": 0.12675751666032778,
                    "bugs": 0.2436063640451518,
                    "come": 0.07481044910781288,
                    "complete": 0.1706279771396163,
                    "concept": 0.09222272099862378,
                    "determining": 0.11832785462234721,
                    "development": 0.05769423343841178,
                    "devote": 0.13797181191118638,
                    "direction": 0.11353306364148662,
                    "documented": 0.11462358060477754,
                    "environmental": 0.14222913487746935,
                    "eventually": 0.09736759249493528,
                    "example": 0.05941635579534396,
                    "expect": 0.09187894858466489,
                    "factors": 0.19756297517225802,
                    "fixing": 0.10443389947866383,
                    "generate": 0.10510340160350605,
                    "hoping": 0.2394834994270819,
                    "hours": 0.17634934913419037,
                    "huge": 0.0896317833863645,
                    "impossible": 0.09978586962754764,
                    "involved": 0.08735099905550821,
                    "kind": 0.07481044910781288,
                    "know": 0.049325506785314804,
                    "like": 0.08214381185762208,
                    "little": 0.07208953555096699,
                    "measurements": 0.14222913487746935,
                    "metric": 0.2631046152823768,
                    "metrics": 0.11832785462234721,
                    "necessary": 0.0870841576038043,
                    "number": 0.07467169320320535,
                    "original": 0.09222272099862378,
                    "point": 0.13018470984215985,
                    "project": 0.2754849386233025,
                    "question": 0.11254445662805901,
                    "ratio": 0.25800936371725636,
                    "realize": 0.10030861062264546,
                    "relation": 0.1315523076411884,
                    "research": 0.09829845285466288,
                    "right": 0.06759222385069757,
                    "software": 0.05559909177584384,
                    "standard": 0.16050545766592103,
                    "takes": 0.16481500462355225,
                    "thanks": 0.08789614622204651,
                    "time": 0.08933912161649121,
                    "typical": 0.10510340160350605,
                    "understand": 0.1355679454578481,
                    "update": 0.08304000839479743,
                    "variables": 0.09481996671237507
                },
                "Max term": "project",
                "Max score": 0.2754849386233025
            }
        ],
        "Best answer": "The equilibrium percentage of total capacity allocated to defect-fixing is equal to the defect injection rate. Many factors can affect this rate, among them, of course: what kind of product the team is developing, what technologies and technical practices they use, the team's skill level, the company culture, etc. Considering Team B, if they create on average 8 units of rework for every 10 units of work they complete, then working those 8 units will create new 6.4 units of rework.  We can estimate the total effort they will eventually have to expend as the sum of a geometric progression: 10 + 8 + 6.4 + 5.12 + ... The number of bugs will decrease exponentially with time, but Team B has such a coefficient in their exponent that it will go to zero very slowly.  Actually, the sum of the first three terms in the above series is only 24.4; of the first five, 33.6; of the first 10, 45; of the entire series, 50.  So, Team B summary: defect injection rate, 0.8; feature development, 10/50 = 20%; defect-fixing, 80%.  20/80 is their sustainable capacity allocation. By contrast, Team A is in much better shape.  Their progression looks like this: 40 + 10 + 2.5 + 0.625 + ... The sum of this series is 53 1/3, so Team A's feature development allocation is 40/(53 1/3) = 75% and defect-fixing allocation is 25%, which matches their defect injection rate of 10/40 = 0.25. Actually, all terms in Team A's series after the first three are negligibly small.  What this means in practical terms is that Team A can probably squash all their bugs with a couple of maintenance releases, the second release being pretty small in scope.  This also creates an illusion that any team can do that.  But not Team B. I thought about this equivalence while reading David Anderson's new book, \"Kanban\".  (The book is on a different subject, but addresses quality concerns, too.)  When discussing software quality, Anderson quotes this book, by Capers Jones, \"Software Assessments, Benchmarks, and Best Practices\": \"...in 2000... measured software quality for North American teams... ranged from 6 defects per function point down to less than 3 per 100 function points, a range of 200 to 1.  The midpoint is approximately 1 defect per 0.6 to 1.0 function points.  This implies that it is common for teams to spend more than 90 percent of their effort fixing defects.\"  He cites an example provided by one of his colleagues of a company that spends 90% of the time fixing their bugs. The fluency with which Anderson goes from the defect injection rate to the defext-fixing capacity allocation (failure demand is the term for it) suggests that the equivalence of the two things is well known to software quality researchers and has probably been known for some time. The key words in the line of reasoning that I'm trying to present here are \"equlibrium\" and \"sustainable\".  If we take away sustainability, then there's an obvious way to cheat these numbers: you do the initial coding, then move on to code somewhere else, and leave maintenance to others.  Or you run up the technical debt and unload it on a new owner. Obviously, no particular allocation will suit all teams.  If we decreed that 20% must be spent on bugs, then, if a team has an ultra-low defect injection rate, they will simply not have enough bugs to fill the time, and if a team had a very high rate, their bugs will continue to accumulate. The math I used here is way simplified.  I neglected things like transaction costs (planning and estimation meetings, post-mortems, etc.), which would affect the percentages somewhat.  I also omitted equations simulating sustaining one product and developing another one concurrently.  But the conclusion still stands.  Do what you can, in terms of technical practices, like unit-testing, continuous integration, code reviews, etc., to reduce your defect injection rate and, consequently, your failure demand.  If you can create only one bug for every 10 features, you will have a lot of free time to develop new features and satisfy your customers. ",
        "Best answer TF-IDF scores": [
            {
                "Scores": {
                    "10": 0.19014865729086844,
                    "100": 0.03062278875228294,
                    "12": 0.036698835051247006,
                    "20": 0.09913446445802124,
                    "200": 0.04499130403576473,
                    "2000": 0.04499130403576473,
                    "24": 0.04400746160342075,
                    "25": 0.07595916831119318,
                    "33": 0.04499130403576473,
                    "40": 0.11503316618518991,
                    "45": 0.04499130403576473,
                    "50": 0.06943864015325386,
                    "75": 0.04499130403576473,
                    "80": 0.07228699728710317,
                    "90": 0.0712652773401373,
                    "accumulate": 0.04499130403576473,
                    "actually": 0.04412247006761198,
                    "addresses": 0.042403486851703164,
                    "affect": 0.07031931242241521,
                    "allocated": 0.04173103995679507,
                    "allocation": 0.2307747132645082,
                    "american": 0.04499130403576473,
                    "approximately": 0.04615494265290164,
                    "average": 0.033380811822592074,
                    "away": 0.02785102965903387,
                    "benchmarks": 0.04499130403576473,
                    "best": 0.020109103734272365,
                    "better": 0.0192245993770457,
                    "book": 0.07945541318973767,
                    "bug": 0.027164093898695493,
                    "bugs": 0.16298456339217296,
                    "capacity": 0.12016962409852566,
                    "cheat": 0.04615494265290164,
                    "code": 0.02754285626339287,
                    "coding": 0.023648502073152267,
                    "colleagues": 0.038344388728396635,
                    "common": 0.0251672355914438,
                    "company": 0.044969726912030716,
                    "complete": 0.02853961396451405,
                    "concerns": 0.034935691390060086,
                    "conclusion": 0.042403486851703164,
                    "concurrently": 0.04757912121982629,
                    "considering": 0.033380811822592074,
                    "continue": 0.03411101786718544,
                    "continuous": 0.03563263867006865,
                    "contrast": 0.04056740133965816,
                    "costs": 0.03411101786718544,
                    "couple": 0.028703272738734895,
                    "course": 0.024663707430922294,
                    "create": 0.0733420083524674,
                    "creates": 0.035882958693763845,
                    "culture": 0.03411101786718544,
                    "customers": 0.0313326688482285,
                    "david": 0.042403486851703164,
                    "debt": 0.04315521852371972,
                    "decrease": 0.04757912121982629,
                    "defect": 0.4005654136617522,
                    "defects": 0.07916711781462836,
                    "demand": 0.07668877745679327,
                    "develop": 0.02862091878990051,
                    "developing": 0.05691866373695072,
                    "development": 0.03860026187765267,
                    "different": 0.020195939665370324,
                    "discussing": 0.0391432227727335,
                    "effort": 0.06147150703020207,
                    "entire": 0.03257183902714604,
                    "equal": 0.038731315827613154,
                    "equations": 0.04615494265290164,
                    "equivalence": 0.09515824243965258,
                    "estimate": 0.03539176697153503,
                    "estimation": 0.04112273774735358,
                    "eventually": 0.03257183902714604,
                    "example": 0.019876222950118098,
                    "factors": 0.033044821486007084,
                    "failure": 0.0728302573572674,
                    "feature": 0.05394329376449208,
                    "features": 0.050239566024794464,
                    "fixing": 0.2096141483403605,
                    "free": 0.025662238805264567,
                    "function": 0.08188707975401534,
                    "goes": 0.02887123881359571,
                    "high": 0.027997756637818193,
                    "implies": 0.04757912121982629,
                    "initial": 0.03563263867006865,
                    "injection": 0.23238789496567888,
                    "integration": 0.031459055997657276,
                    "jones": 0.04757912121982629,
                    "kanban": 0.042403486851703164,
                    "key": 0.03062278875228294,
                    "kind": 0.025025923343179424,
                    "known": 0.06193572855085692,
                    "leave": 0.030511788693953514,
                    "level": 0.024115711268407485,
                    "like": 0.041218668578692816,
                    "line": 0.027099297987017306,
                    "looks": 0.029591138287550372,
                    "lot": 0.01977311339768737,
                    "low": 0.031719595947445015,
                    "maintenance": 0.06484331866784952,
                    "matches": 0.042403486851703164,
                    "math": 0.0364151286786337,
                    "means": 0.024320948968060366,
                    "measured": 0.04499130403576473,
                    "meetings": 0.03451004419747771,
                    "new": 0.07346128331264601,
                    "north": 0.04757912121982629,
                    "number": 0.024979506102359,
                    "numbers": 0.033920486032290066,
                    "obvious": 0.030735753515101036,
                    "obviously": 0.030511788693953514,
                    "owner": 0.037307137260688496,
                    "particular": 0.025509665583989347,
                    "percent": 0.04400746160342075,
                    "percentage": 0.038344388728396635,
                    "planning": 0.030511788693953514,
                    "point": 0.0217749833600698,
                    "points": 0.05956911481407485,
                    "post": 0.029221043749689053,
                    "practical": 0.033920486032290066,
                    "practices": 0.08766313124906716,
                    "present": 0.03563263867006865,
                    "pretty": 0.024238060238339916,
                    "probably": 0.04453907018842293,
                    "product": 0.053206665270371926,
                    "progression": 0.08998260807152945,
                    "provided": 0.034935691390060086,
                    "quality": 0.11259174532415789,
                    "quotes": 0.04757912121982629,
                    "range": 0.03699574172325261,
                    "rate": 0.27288814293748354,
                    "reading": 0.027099297987017306,
                    "reasoning": 0.037634508632451075,
                    "reduce": 0.035159656211207604,
                    "release": 0.030295417380520363,
                    "releases": 0.03563263867006865,
                    "researchers": 0.04615494265290164,
                    "reviews": 0.03242165933392476,
                    "rework": 0.09230988530580328,
                    "run": 0.023995663670015016,
                    "satisfy": 0.04315521852371972,
                    "scope": 0.03451004419747771,
                    "second": 0.02949658333618349,
                    "series": 0.15337755491358654,
                    "shape": 0.04056740133965816,
                    "simplified": 0.04615494265290164,
                    "simply": 0.026603332635185963,
                    "skill": 0.03355568145949002,
                    "slowly": 0.038731315827613154,
                    "small": 0.04823142253681497,
                    "software": 0.07439701941783165,
                    "somewhat": 0.03411101786718544,
                    "spend": 0.027778912027519732,
                    "spends": 0.04400746160342075,
                    "spent": 0.031208735973962076,
                    "squash": 0.04757912121982629,
                    "stands": 0.04173103995679507,
                    "subject": 0.03158799659480206,
                    "suggests": 0.04315521852371972,
                    "suit": 0.04400746160342075,
                    "sum": 0.1251931198703852,
                    "summary": 0.037634508632451075,
                    "team": 0.29149375068071726,
                    "teams": 0.09290359282628538,
                    "technical": 0.07745564664800317,
                    "technologies": 0.030402686165735004,
                    "term": 0.030295417380520363,
                    "terms": 0.11289748993567231,
                    "testing": 0.0248422461351711,
                    "things": 0.03653526001075252,
                    "thought": 0.02736252467331328,
                    "time": 0.07471529832347298,
                    "total": 0.07228699728710317,
                    "transaction": 0.04315521852371972,
                    "trying": 0.024197016093793943,
                    "unit": 0.026846498902315594,
                    "units": 0.1726208740948789,
                    "use": 0.014791317777736221,
                    "used": 0.019319154328412576,
                    "way": 0.033915140872563254,
                    "words": 0.031208735973962076,
                    "work": 0.01578297500532747,
                    "working": 0.020195939665370324,
                    "zero": 0.037634508632451075
                },
                "Max term": "defect",
                "Max score": 0.4005654136617522
            }
        ]
    },
    {
        "ID": "3918",
        "Question": "What should you do, if a co-worker is editing your code?   Without the purpose of adding functionality or fixing bugs, just to change how it looks... ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "adding": 0.3236467808226648,
                    "bugs": 0.27946075511395146,
                    "change": 0.23774069212849355,
                    "code": 0.14167870715784195,
                    "editing": 0.4027005146741542,
                    "fixing": 0.3594139650932006,
                    "functionality": 0.2952956319368991,
                    "looks": 0.304429880170504,
                    "purpose": 0.3084718163937729,
                    "worker": 0.41735228326301854
                },
                "Max term": "worker",
                "Max score": 0.41735228326301854
            }
        ],
        "Best answer": "Talk to them about it.  Go into the conversation with the attitude of \"They're not doing this to annoy me or because they have some form of obsessive-compulsive disorder; they're trying to make my code better.\" Because you could be wrong.  That could be a subtle bug fix and you just didn't spot it. Or, it could be that there's a coding standard you don't know about that you're violating, and they're just correcting it. Or, it could be that they're trying to annoy you, or they have some form of obsessive-compulsive disorder.  If that's the case, ask them nicely to stop, and if that doesn't work, take it up with your boss. But you'll never know unless you ask. ",
        "Best answer TF-IDF scores": [
            {
                "Scores": {
                    "ask": 0.25646015549338375,
                    "attitude": 0.1999000492672144,
                    "better": 0.10118589889951701,
                    "boss": 0.1730761501388545,
                    "bug": 0.14297428024493783,
                    "case": 0.12330529515258962,
                    "code": 0.07248392059080397,
                    "coding": 0.12447047103390547,
                    "conversation": 0.20182014538456192,
                    "correcting": 0.23680522294555692,
                    "fix": 0.1485549032595196,
                    "form": 0.31457507190391415,
                    "know": 0.1736969111949816,
                    "make": 0.08981244439728692,
                    "nicely": 0.20182014538456192,
                    "obsessive": 0.47361044589111384,
                    "spot": 0.20182014538456192,
                    "standard": 0.14130266490646373,
                    "stop": 0.16426266894349856,
                    "subtle": 0.22714125235512247,
                    "talk": 0.15574867742943974,
                    "trying": 0.25471499053031216,
                    "unless": 0.15021413120798882,
                    "work": 0.08307140668582749,
                    "wrong": 0.13673557020017466
                },
                "Max term": "obsessive",
                "Max score": 0.47361044589111384
            }
        ]
    },
    {
        "ID": "7455",
        "Question": "I mean, I still have a MSX2 with a Z80 processor and if you look at any Konami's game made for that computer in its time (roughly between '84 and '90) is amazing the high quality code of those games. I was a kid at the time, trying to learn how to program a computer and still today fascinated me how well made they are, mostly zero bugs or glitches, despite the really complex behavior. What hardware/software tools could they have used to accomplish that quality, which metodology? I know computers are really more complex today but at that time, even a stock control program I made in Basic was plagued with many bugs and was painful to debug. Any light you can shed will be deeply appreciated.  ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "90": 0.14844622400728447,
                    "accomplish": 0.161355369684489,
                    "amazing": 0.16900453548838193,
                    "appreciated": 0.15822364179841253,
                    "basic": 0.11790554597950323,
                    "behavior": 0.13766533031731507,
                    "bugs": 0.22633222339651626,
                    "code": 0.057372021316379536,
                    "complex": 0.2434708047505169,
                    "computer": 0.21875860724767615,
                    "computers": 0.14647577043830473,
                    "control": 0.1056529510780399,
                    "debug": 0.1421071239296727,
                    "deeply": 0.1738522752368315,
                    "despite": 0.15678605086155833,
                    "fascinated": 0.19821548867221372,
                    "game": 0.13569487674833533,
                    "games": 0.14647577043830473,
                    "hardware": 0.1315961711921205,
                    "high": 0.11663916590746796,
                    "know": 0.06874174858673462,
                    "learn": 0.08946216233577085,
                    "light": 0.15974342431674302,
                    "look": 0.09202975668132596,
                    "mean": 0.11033756788887303,
                    "painful": 0.16900453548838193,
                    "processor": 0.1738522752368315,
                    "program": 0.1992762211464767,
                    "quality": 0.23452963450894593,
                    "really": 0.1493242939450242,
                    "roughly": 0.1713180771135045,
                    "shed": 0.19228233473069387,
                    "software": 0.07748483568837294,
                    "stock": 0.1738522752368315,
                    "time": 0.18675917909521444,
                    "today": 0.24899050139352855,
                    "tools": 0.10387310015634386,
                    "trying": 0.10080521132959036,
                    "used": 0.08048395005548176,
                    "zero": 0.15678605086155833
                },
                "Max term": "today",
                "Max score": 0.24899050139352855
            }
        ],
        "Best answer": "I don't know anything about Konami, so I'm taking an educated guess here.  Games on machines like the MSX would have required direct access to the hardware, so that pretty much limits the choice of languages to either C or Z80 assembly language.  (There were C compilers for the Z80 back then, for example this one.) I doubt if the games were completely written in C, if at all; mostly likely a lot of assembly code for performance reasons. As far as platforms go, since the MSX didn't have a hard drive, I would further assume the programs were initially written on a larger Z80 system, perhaps running CP/M.  For debugging, the code could probably have been downloaded into a special game cartridge for the MSX that had RAM memory in place of ROM -- this would have allowed the developer to download the program over and over again without burning ROM chips.  Debugging (e.g. setting breakpoints) could have been accomplished by replacing the Z80 inside the MSX with an In-Circuit Emulator (ICE) interface. ",
        "Best answer TF-IDF scores": [
            {
                "Scores": {
                    "access": 0.10404023803202907,
                    "accomplished": 0.15558836874544404,
                    "allowed": 0.12695832102666313,
                    "assembly": 0.2660539572613672,
                    "assume": 0.11761865528442222,
                    "burning": 0.17022513543873752,
                    "chips": 0.1800161726199981,
                    "choice": 0.10988735583536803,
                    "circuit": 0.1800161726199981,
                    "code": 0.10420872518117578,
                    "compilers": 0.15558836874544404,
                    "completely": 0.11344490426816242,
                    "debugging": 0.2643592101172061,
                    "developer": 0.0813493694896277,
                    "direct": 0.13217960505860304,
                    "doubt": 0.14115199879478948,
                    "download": 0.14115199879478948,
                    "downloaded": 0.1632782840045912,
                    "drive": 0.13885048013003712,
                    "example": 0.07520192659907834,
                    "far": 0.09728891534959698,
                    "game": 0.12323594144942301,
                    "games": 0.2660539572613672,
                    "guess": 0.11383127521328965,
                    "hard": 0.0939909345503832,
                    "hardware": 0.11951356187218291,
                    "initially": 0.14115199879478948,
                    "inside": 0.1244141101793826,
                    "interface": 0.11628909001527671,
                    "know": 0.06243016911889204,
                    "language": 0.07323884807642297,
                    "languages": 0.08217501124482195,
                    "larger": 0.13217960505860304,
                    "like": 0.05198377473000014,
                    "likely": 0.10042939522999564,
                    "limits": 0.1578898874101964,
                    "lot": 0.07481181037765042,
                    "machines": 0.12695832102666313,
                    "memory": 0.11854752629768162,
                    "performance": 0.10592984617349305,
                    "place": 0.10277567325677602,
                    "platforms": 0.12980250677377742,
                    "pretty": 0.09170499000348795,
                    "probably": 0.08425705164172247,
                    "program": 0.09048975654038739,
                    "programs": 0.10649805283401612,
                    "ram": 0.1450764520943491,
                    "reasons": 0.10678724993010014,
                    "replacing": 0.1515544020205386,
                    "required": 0.11055816755162311,
                    "running": 0.1082875876084642,
                    "setting": 0.13056916382869654,
                    "special": 0.12565272366906388,
                    "taking": 0.11902571358498779,
                    "written": 0.19379885675037214
                },
                "Max term": "assembly",
                "Max score": 0.2660539572613672
            }
        ]
    },
    {
        "ID": "7927",
        "Question": "No one's perfect, and no matter what we do, we are going to produce code that has bugs in it from time to time. What are some methods/techniques for reducing the number of bugs you produce, both when writing new software and changing/maintaining existing code? ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "bugs": 0.387117533713442,
                    "changing": 0.2299762373942123,
                    "code": 0.19625765224991573,
                    "existing": 0.20278803344487076,
                    "going": 0.14971340201275737,
                    "maintaining": 0.2556853639895984,
                    "matter": 0.19449648296504057,
                    "methods": 0.19545394190849194,
                    "new": 0.13086278031890125,
                    "number": 0.17799240482285097,
                    "perfect": 0.24038340746802783,
                    "produce": 0.45790845079038606,
                    "reducing": 0.3075041233488246,
                    "software": 0.13252968597106937,
                    "techniques": 0.23209185698819765,
                    "time": 0.21295466085129336,
                    "writing": 0.1618046439977104
                },
                "Max term": "produce",
                "Max score": 0.45790845079038606
            }
        ],
        "Best answer": "Avoid fancy coding.  The more complicated the code, the more likely there's bugs.  Usually on modern systems, clearly written code will be fast and small enough. Use available libraries.  The easiest way to not have bugs writing a utility routine is to not write it. Learn a few formal techniques for the more complicated stuff.  If there's complicated conditions, nail them down with pen and paper.  Ideally, know some proof techniques.  If I can prove code correct, it's almost always good except for big, dumb, obvious bugs that are easy to fix.  Obviously, this only goes so far, but sometimes you can formally reason about small but complicated things. For existing code, learn how to refactor:  how to make small changes in the code, often using an automated tool, that make the code more readable without changing the behavior. Don't do anything too quickly.  Taking a little time up front to do things right, to check what you've done, and to think about what you're doing can pay off big time later. Once you've written the code, use what you've got to make it good.  Unit tests are great.  You can often write tests ahead of time, which can be great feedback (if done consistently, this is test-driven development). Compile with warning options, and pay attention to the warnings.   Get somebody else to look at the code.  Formal code reviews are good, but they may not be at a convenient time. Pull requests, or similar if your scm doesn't support them allow for asynchronous reviews. Buddy checking can be a less formal review. Pair programming ensures two pairs of eyes look at everything.  ",
        "Best answer TF-IDF scores": [
            {
                "Scores": {
                    "ahead": 0.08659066332298092,
                    "allow": 0.06982009890022321,
                    "asynchronous": 0.1000507522532793,
                    "attention": 0.08592125997654668,
                    "automated": 0.0800351668294741,
                    "available": 0.06263030521714345,
                    "avoid": 0.06792203962259853,
                    "behavior": 0.07796904201092937,
                    "big": 0.11680603043204124,
                    "bugs": 0.19228051021002557,
                    "changes": 0.0609186986634618,
                    "changing": 0.0761524935991391,
                    "check": 0.06696253707637491,
                    "checking": 0.08094811881097458,
                    "clearly": 0.07581407271228831,
                    "code": 0.29244235836010574,
                    "coding": 0.055798487288483106,
                    "compile": 0.08142622549713453,
                    "complicated": 0.30325629084915323,
                    "conditions": 0.08192001057689868,
                    "consistently": 0.0923581803007405,
                    "convenient": 0.09702883304682275,
                    "correct": 0.06873624308175383,
                    "development": 0.0455385337948642,
                    "driven": 0.07721593030167115,
                    "dumb": 0.09846411816535088,
                    "easiest": 0.09451314959938158,
                    "easy": 0.05819385774685311,
                    "ensures": 0.1038353202786837,
                    "existing": 0.06714960899382541,
                    "eyes": 0.09339715055484187,
                    "fancy": 0.10182445825865823,
                    "far": 0.06067182271321895,
                    "fast": 0.07279215350583174,
                    "feedback": 0.08094811881097458,
                    "fix": 0.06659522384960043,
                    "formal": 0.25399682504460513,
                    "formally": 0.11226262798250004,
                    "goes": 0.06812150075974951,
                    "good": 0.11476449355477612,
                    "got": 0.06042892880721072,
                    "great": 0.11496773979751342,
                    "ideally": 0.0835066446648271,
                    "know": 0.03893302889776112,
                    "later": 0.06696253707637491,
                    "learn": 0.10133675744602451,
                    "libraries": 0.06792203962259853,
                    "likely": 0.06263030521714345,
                    "little": 0.05690086435498268,
                    "look": 0.10424515669126908,
                    "make": 0.12078523915165025,
                    "modern": 0.0787618090313097,
                    "nail": 0.1089022878891927,
                    "obvious": 0.07252081110715822,
                    "obviously": 0.07199236756400226,
                    "options": 0.07836020934644035,
                    "pair": 0.08142622549713453,
                    "pairs": 0.09846411816535088,
                    "paper": 0.08192001057689868,
                    "pay": 0.142465849026353,
                    "pen": 0.10615669011788967,
                    "programming": 0.041615171278232714,
                    "proof": 0.09339715055484187,
                    "prove": 0.09571852039404785,
                    "pull": 0.09451314959938158,
                    "quickly": 0.06772518589532274,
                    "readable": 0.08295898083100005,
                    "reason": 0.05949473191878218,
                    "refactor": 0.08094811881097458,
                    "requests": 0.0824305372878441,
                    "review": 0.07252081110715822,
                    "reviews": 0.15299738990820455,
                    "right": 0.05335109917667624,
                    "routine": 0.09339715055484187,
                    "scm": 0.11226262798250004,
                    "similar": 0.059048503842967205,
                    "small": 0.17070259306494803,
                    "somebody": 0.0835066446648271,
                    "stuff": 0.05798756553873148,
                    "support": 0.05983830033454876,
                    "systems": 0.06424795702087119,
                    "taking": 0.07422743862435989,
                    "techniques": 0.15370608593277932,
                    "test": 0.0542029975133271,
                    "tests": 0.12233937880363181,
                    "things": 0.08620470907566702,
                    "think": 0.03856188547910589,
                    "time": 0.14103220951116474,
                    "tool": 0.06537590298844649,
                    "unit": 0.06334414006888743,
                    "use": 0.0698000367590229,
                    "using": 0.04250439625451501,
                    "usually": 0.05861511866176066,
                    "utility": 0.0913862885348164,
                    "warning": 0.09339715055484187,
                    "warnings": 0.1000507522532793,
                    "way": 0.04001127747988019,
                    "write": 0.09459088429148914,
                    "writing": 0.05357869689478066,
                    "written": 0.12085785761442144
                },
                "Max term": "complicated",
                "Max score": 0.30325629084915323
            }
        ]
    },
    {
        "ID": "10735",
        "Question": "Bugs creeping into code can be minimized, but not entirely eliminated as it is written - programmers are, although many would disagree, only humans. When we do detect an error in our code, what can we do to weed it out? How should we approach it to make most effective use of our valuable time and enable us to spend less time trying to find it and more time coding? Also, what should we avoid when debugging? Note here that we're not talking about preventing bugs; we're talking about what to do when bugs do appear. This is a wide field, I know, and may be highly dependent on language, platform and tools. If so, keep to encompassing answers such as mindsets and general methods. ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "answers": 0.12286081260225654,
                    "appear": 0.1580819082458577,
                    "approach": 0.11254282386088123,
                    "avoid": 0.12496611011549416,
                    "bugs": 0.3537665762907221,
                    "code": 0.11956643940718,
                    "coding": 0.10266063777699927,
                    "creeping": 0.2065459754781601,
                    "debugging": 0.15165951518577173,
                    "dependent": 0.17388966417711693,
                    "detect": 0.17388966417711693,
                    "disagree": 0.17388966417711693,
                    "effective": 0.1371268195545292,
                    "eliminated": 0.20036346634770638,
                    "enable": 0.19531198857513143,
                    "entirely": 0.14139778315569415,
                    "error": 0.12154120983530438,
                    "field": 0.13887728078823586,
                    "general": 0.10925361990833356,
                    "highly": 0.14139778315569415,
                    "humans": 0.18734134802053826,
                    "know": 0.07163078734680077,
                    "language": 0.08403239052734456,
                    "make": 0.07407542323532461,
                    "methods": 0.1190767933590534,
                    "minimized": 0.2065459754781601,
                    "note": 0.12286081260225654,
                    "platform": 0.123544956517219,
                    "preventing": 0.20036346634770638,
                    "programmers": 0.0962832409440913,
                    "spend": 0.1205911823368268,
                    "talking": 0.26303119414362436,
                    "time": 0.1946081866968094,
                    "tools": 0.10823861919898602,
                    "trying": 0.10504179490122276,
                    "use": 0.0642106680553175,
                    "valuable": 0.1546850367194951,
                    "weed": 0.2065459754781601,
                    "wide": 0.15931350748473494,
                    "written": 0.11117993825631155
                },
                "Max term": "bugs",
                "Max score": 0.3537665762907221
            }
        ],
        "Best answer": "The mindset and attitude to debugging is perhaps the most important part, because it determines how effectively you'll fix the error, and what you'll learn from it — if anything.   Classics on software development like The Pragmatic Programmer and Code Complete basically argue for the same approach: every error is an opportunity to learn, almost always about yourself (because only beginners blame the compiler/computer first).   So treat it as a mystery which will be interesting to crack.  And cracking that mystery should be done systematically, by expressing our assumptions (to ourselves, or to others) and then testing our assumptions, one-by-one if need be — using every tool at our disposal, especially debuggers and automated test frameworks.  Then after the mystery is solved, you can do even better by looking through all your code for similar errors you may have made; and write an automated test to ensure the error will not happen unknowingly again. One last note - I prefer to call errors \"errors\" and not \"bugs\" - Dijkstra chided his colleagues for using the latter term because it's dishonest, supporting the idea that pernicious and fickle bug-fairies planted bugs in our programs while we weren't looking, instead of being there because of our own (sloppy) thinking: http://www.cs.utexas.edu/users/EWD/transcriptions/EWD10xx/EWD1036.html  We could, for instance, begin with cleaning up our language by no longer calling a bug a bug but by calling it an error. It is much more honest because it squarely puts the blame where it belongs, viz. with the programmer who made the error. The animistic metaphor of the bug that maliciously sneaked in while the programmer was not looking is intellectually dishonest as it disguises that the error is the programmer's own creation. The nice thing of this simple change of vocabulary is that it has such a profound effect: while, before, a program with only one bug used to be \"almost correct\", afterwards a program with an error is just \"wrong\" (because in error).  ",
        "Best answer TF-IDF scores": [
            {
                "Scores": {
                    "approach": 0.05713511642771486,
                    "argue": 0.08940520804475707,
                    "assumptions": 0.17881041608951415,
                    "attitude": 0.08370199990022545,
                    "automated": 0.1495125647957871,
                    "basically": 0.06724396253929653,
                    "begin": 0.07908131359997077,
                    "beginners": 0.09510841618928871,
                    "belongs": 0.09698664765911882,
                    "better": 0.04236848430322359,
                    "blame": 0.18125819265026222,
                    "bug": 0.2993304212446569,
                    "bugs": 0.11973216849786276,
                    "calling": 0.15303361478019184,
                    "change": 0.050928812163841174,
                    "classics": 0.1048581149092931,
                    "cleaning": 0.09510841618928871,
                    "code": 0.06070082660109158,
                    "colleagues": 0.08450598111789794,
                    "compiler": 0.06851201362516007,
                    "complete": 0.06289754925761123,
                    "computer": 0.05786282224924164,
                    "correct": 0.06420260246021665,
                    "crack": 0.09196971425463193,
                    "cracking": 0.1048581149092931,
                    "creation": 0.08626650611010031,
                    "cs": 0.07852964124588387,
                    "debuggers": 0.10171941297463633,
                    "debugging": 0.07699366125930092,
                    "determines": 0.09915490676476148,
                    "development": 0.04253494591456524,
                    "dijkstra": 0.09510841618928871,
                    "edu": 0.09698664765911882,
                    "effect": 0.07651680739009592,
                    "effectively": 0.07699366125930092,
                    "ensure": 0.07748725021911004,
                    "error": 0.49362693676778796,
                    "errors": 0.20553604087548022,
                    "especially": 0.06154075439476491,
                    "expressing": 0.09915490676476148,
                    "fix": 0.06220279856552124,
                    "frameworks": 0.06676710867009152,
                    "happen": 0.06748859204427349,
                    "honest": 0.08940520804475707,
                    "html": 0.06608083393004678,
                    "http": 0.06500658367788913,
                    "idea": 0.050928812163841174,
                    "important": 0.05228464463456963,
                    "instance": 0.0690530742533619,
                    "instead": 0.053785246927430426,
                    "interesting": 0.060602684058736464,
                    "language": 0.042661097809434695,
                    "learn": 0.09465288268921357,
                    "like": 0.030280171746366834,
                    "longer": 0.06585932002927553,
                    "looking": 0.1537088235113296,
                    "metaphor": 0.10171941297463633,
                    "mindset": 0.08626650611010031,
                    "need": 0.0383945784033492,
                    "nice": 0.06459884956444888,
                    "note": 0.062373295707515576,
                    "opportunity": 0.07852964124588387,
                    "pragmatic": 0.08370199990022545,
                    "prefer": 0.06630589220326807,
                    "program": 0.1054192537406698,
                    "programmer": 0.1914653921672092,
                    "programs": 0.06203434335457402,
                    "puts": 0.09510841618928871,
                    "similar": 0.055153838035511514,
                    "simple": 0.05279618617115341,
                    "sloppy": 0.1048581149092931,
                    "software": 0.040990307360769196,
                    "solved": 0.07748725021911004,
                    "supporting": 0.09345169862022984,
                    "term": 0.06676710867009152,
                    "test": 0.10125585413102153,
                    "testing": 0.05474903766741373,
                    "thing": 0.0464702434841606,
                    "thinking": 0.055051540551931843,
                    "tool": 0.061063900525559905,
                    "treat": 0.08626650611010031,
                    "used": 0.042576870958997697,
                    "users": 0.055465271613658856,
                    "using": 0.079401862341951,
                    "vocabulary": 0.09698664765911882,
                    "write": 0.04417597375305863,
                    "wrong": 0.057253816220691596,
                    "www": 0.07319180018880511
                },
                "Max term": "error",
                "Max score": 0.49362693676778796
            }
        ]
    },
    {
        "ID": "21436",
        "Question": "The question of managing bugs in production has been a large feature in my mind of late. Sprint's are not meant to have any items added into them, but for critical bugs, this is simply unavoidable. How does one go about managing this break in the sprint? Do you simply give a sprint a percentage \"allowance\" of time, thus only filling say 80% of the schedule with sprint items \"just in case\"? ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "80": 0.154696760054176,
                    "added": 0.13576214001000608,
                    "break": 0.13106772674445596,
                    "bugs": 0.23252853064269272,
                    "case": 0.1002697794777336,
                    "critical": 0.14683818270124868,
                    "feature": 0.11544057832246378,
                    "filling": 0.19256600014251588,
                    "items": 0.29367636540249736,
                    "large": 0.10854541657199598,
                    "late": 0.14599759691900083,
                    "managing": 0.29541091632138855,
                    "meant": 0.15048584405546744,
                    "mind": 0.11571239034060736,
                    "percentage": 0.16411672707835986,
                    "production": 0.13576214001000608,
                    "question": 0.08056993061617733,
                    "say": 0.0886812098862705,
                    "schedule": 0.15251024281857153,
                    "simply": 0.22772833398855463,
                    "sprint": 0.6502213496284135,
                    "time": 0.06395736445500191
                },
                "Max term": "sprint",
                "Max score": 0.6502213496284135
            }
        ],
        "Best answer": "If this is critical, you must handle it. To measure its impact on the sprint, you must log it.  Look at this information radiator:  There is a part called \"Unplanned items\". Put your critical bug there. As you see there is the inverse with \"Next\" part where you put more user stories than planned in case you complete the sprint faster. You will talk about it in the sprint review and/or the retrospective. The objective is to find how to limit them, and also adjust your velocity accordingly. ",
        "Best answer TF-IDF scores": [
            {
                "Scores": {
                    "accordingly": 0.1969793831612068,
                    "adjust": 0.1914867614277562,
                    "bug": 0.12822029994550552,
                    "called": 0.13792954067522936,
                    "case": 0.11058102130151419,
                    "complete": 0.13471304717565655,
                    "critical": 0.3238765716597231,
                    "faster": 0.14562211863285943,
                    "handle": 0.1387903424873901,
                    "impact": 0.17927171399116779,
                    "information": 0.12446772164598428,
                    "items": 0.16193828582986156,
                    "limit": 0.18282004734710308,
                    "log": 0.15923862870178726,
                    "look": 0.10427223157631149,
                    "measure": 0.17322630585323878,
                    "objective": 0.16937519594082748,
                    "planned": 0.2037018088643446,
                    "retrospective": 0.22458357038158616,
                    "review": 0.14507929288768354,
                    "sprint": 0.5378151419735034,
                    "stories": 0.16490389282052356,
                    "talk": 0.13967646559861327,
                    "user": 0.1084341505779183,
                    "velocity": 0.22458357038158616
                },
                "Max term": "sprint",
                "Max score": 0.5378151419735034
            }
        ]
    },
    {
        "ID": "22769",
        "Question": "What language, in your opinion, allows the average programmer to output features with the least amount of hard-to-find bugs? This is of course, a very broad question, and I'm interested in very broad and general answers and wisdoms. Personally I find that I spend very little time looking for strange bugs in Java and C# programs, while C++ code has its distinct set of recurring bugs, and Python/similar has its own set of common and silly bugs that would be detected by the compiler in other languages. Also I find it hard to consider functional languages in this regard, because I've never seen a big and complex program written in entirely functional code. Your input please. Edit: Completely arbitrary clarification of hard-to-find bug: Takes more than 15 minutes to reproduce, or more than 1 hour to find cause of and fix. Forgive me if this is a duplicate, but I didn't find anything on this specific topic. ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "15": 0.11727792126045891,
                    "allows": 0.1079022180492522,
                    "answers": 0.09785144777273531,
                    "arbitrary": 0.14217924810858126,
                    "average": 0.11541203203319338,
                    "big": 0.0855796831719162,
                    "broad": 0.27067040217827415,
                    "bug": 0.09391812553423615,
                    "bugs": 0.3756725021369446,
                    "cause": 0.10921348750410975,
                    "clarification": 0.14660735661125218,
                    "code": 0.09522767230019696,
                    "common": 0.08701411504620168,
                    "compiler": 0.10748189023847737,
                    "completely": 0.10366784690047483,
                    "complex": 0.10102989870965279,
                    "consider": 0.08944911517951627,
                    "course": 0.08527319848310023,
                    "detected": 0.15957777624634323,
                    "distinct": 0.13391105904617004,
                    "duplicate": 0.12590298941462297,
                    "edit": 0.08854831488770076,
                    "entirely": 0.11261506008780736,
                    "features": 0.08685005077472481,
                    "fix": 0.09758397125099606,
                    "forgive": 0.15957777624634323,
                    "functional": 0.1996409408196317,
                    "general": 0.08701411504620168,
                    "hard": 0.25767145406467284,
                    "hour": 0.1215622732751399,
                    "input": 0.11109262593193095,
                    "interested": 0.09555343227822205,
                    "java": 0.07689116629873018,
                    "language": 0.0669268817187811,
                    "languages": 0.1501857935308563,
                    "little": 0.08337853663370143,
                    "looking": 0.08037964936445904,
                    "minutes": 0.11209582335812847,
                    "opinion": 0.10437973259939565,
                    "output": 0.11931628108848491,
                    "personally": 0.0995281940460125,
                    "program": 0.08269104978849899,
                    "programmer": 0.07509289676542814,
                    "programs": 0.09731969811793376,
                    "python": 0.09325275222500691,
                    "question": 0.06508428739458544,
                    "recurring": 0.16450178298591725,
                    "regard": 0.14660735661125218,
                    "reproduce": 0.14428241427646962,
                    "seen": 0.09218652826860377,
                    "set": 0.1711593663438324,
                    "silly": 0.1384929419889994,
                    "similar": 0.0865255369430073,
                    "specific": 0.08380155040916369,
                    "spend": 0.0960438200786219,
                    "strange": 0.13533520108913707,
                    "takes": 0.09531226547487577,
                    "time": 0.05166467759566112,
                    "topic": 0.11793667295137512,
                    "written": 0.08854831488770076
                },
                "Max term": "bugs",
                "Max score": 0.3756725021369446
            }
        ],
        "Best answer": "The more powerful the type system of the language, the more bugs will be caught at the compile time itself. The following figure compares some of the well known programming languages in terms of the power, simplicity, and safety of their type systems. [ Source ]  *Factoring in the ability to use unsafe constructs.  C# gets stuffed into the unsafe row because of the \"unsafe\" keyword and associated pointer machinery. But if you want to think of these as a kind of inline foreign function mechanism feel free to bump C# skyward. I've marked Haskell '98 as pure but GHC Haskell as not pure due to the unsafe* family of functions. If you disable unsafe* then jump GHC Haskell up accordingly.  ",
        "Best answer TF-IDF scores": [
            {
                "Scores": {
                    "98": 0.1860107123959808,
                    "ability": 0.12153535730757,
                    "accordingly": 0.16314762173778818,
                    "associated": 0.14463495956063085,
                    "bugs": 0.10619810387717185,
                    "caught": 0.16577655482363501,
                    "compile": 0.13491711787469302,
                    "constructs": 0.15303054295161528,
                    "disable": 0.16871545197552598,
                    "factoring": 0.1860107123959808,
                    "family": 0.15142019155507117,
                    "feel": 0.0947587667960456,
                    "figure": 0.12349336429762667,
                    "following": 0.10377369477609773,
                    "foreign": 0.16076946248580284,
                    "free": 0.10032659703378341,
                    "function": 0.10671259192798867,
                    "functions": 0.11157570356371795,
                    "gets": 0.11682967071416156,
                    "haskell": 0.3895108806726412,
                    "jump": 0.15303054295161528,
                    "keyword": 0.16314762173778818,
                    "kind": 0.0978389198893448,
                    "known": 0.12106895519655254,
                    "language": 0.07567770221686757,
                    "languages": 0.08491143967972017,
                    "marked": 0.1860107123959808,
                    "mechanism": 0.16076946248580284,
                    "pointer": 0.16076946248580284,
                    "power": 0.13573528253116046,
                    "powerful": 0.1318889476886111,
                    "programming": 0.06895320192532375,
                    "pure": 0.30606108590323056,
                    "row": 0.16871545197552598,
                    "safety": 0.16871545197552598,
                    "simplicity": 0.15303054295161528,
                    "source": 0.08448122580773565,
                    "systems": 0.10645402187895998,
                    "terms": 0.11034326608107721,
                    "think": 0.06389413750779875,
                    "time": 0.058419935096389236,
                    "type": 0.20528892393562495,
                    "use": 0.0578266997492497,
                    "want": 0.06988608764107378
                },
                "Max term": "haskell",
                "Max score": 0.3895108806726412
            }
        ]
    },
    {
        "ID": "23182",
        "Question": "What are the common bugs introduced by refactoring, carelessness, and newbies? I would like to request the experienced programmers here to share their experience and list the bugs they used to introduce when they were inexperienced. In your response, please write a headline mentioning the kind of bug in bold text, followed by few linebreaks, and then an explanation, cause of the bug, and finally the fix. ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "bold": 0.24494316385677936,
                    "bug": 0.30238777063805533,
                    "bugs": 0.30238777063805533,
                    "cause": 0.1758170897370405,
                    "common": 0.1400794794039657,
                    "experience": 0.11952457948411574,
                    "experienced": 0.1758170897370405,
                    "explanation": 0.2059163082066375,
                    "finally": 0.18879960046736677,
                    "fix": 0.15709533888557062,
                    "followed": 0.2155764203044669,
                    "inexperienced": 0.25041917790836354,
                    "introduce": 0.2026846472349804,
                    "introduced": 0.20764951901615394,
                    "kind": 0.13929294303216777,
                    "like": 0.0764736306357363,
                    "list": 0.1425493076035024,
                    "mentioning": 0.23601552667623452,
                    "newbies": 0.25041917790836354,
                    "programmers": 0.12344951387506503,
                    "refactoring": 0.18129310378862468,
                    "request": 0.1867691178402089,
                    "response": 0.1956967550207537,
                    "share": 0.170444794809954,
                    "text": 0.1641763960493539,
                    "used": 0.10752937369763992,
                    "write": 0.11156796361865855
                },
                "Max term": "bug",
                "Max score": 0.30238777063805533
            }
        ],
        "Best answer": "Manually written values instead of constants Example: public District GetDefaultDistrict() {   return GetById(1); }  public IList<Revenue> GetRevenues() {   return GetByCodes(new [] { 8010, 8011, 8096 }); }  and thousands of use of 1, 8010, 8011 and 8096 in other places. Try to image if the default district now is 2 and 8011 moved to 8012. Fix: public District GetDefaultDistrict() {   return GetById(Consts.DEFAULT_DISTRICT_ID); }  public IList<Revenue> GetRevenues() {   return GetByCodes(Consts.REVENUE_CODES); }  and use this constants everywhere where you need to determine default district id and/or other static values. Or even: public IList<Revenue> GetRevenues() {   var codes = GetRevenueCodes(); // get from db   return GetByCodes(codes); }  to get actual values from db. But this is just an example. ",
        "Best answer TF-IDF scores": [
            {
                "Scores": {
                    "actual": 0.09010499832901328,
                    "codes": 0.22875651001208952,
                    "constants": 0.25991870185087773,
                    "db": 0.21193342452469002,
                    "default": 0.2104549739793607,
                    "determine": 0.10451616376272778,
                    "example": 0.1173937754794688,
                    "fix": 0.08334998190403899,
                    "id": 0.11437825500604476,
                    "image": 0.11689503178509973,
                    "instead": 0.0720707019859152,
                    "manually": 0.11559466597998197,
                    "moved": 0.11323561253502952,
                    "need": 0.05144764365804938,
                    "new": 0.05423501123227221,
                    "places": 0.10451616376272778,
                    "public": 0.45052499164506643,
                    "return": 0.4489140269092022,
                    "revenue": 0.369710408323602,
                    "static": 0.09328317028347645,
                    "thousands": 0.12144041285734367,
                    "try": 0.06630835271557885,
                    "use": 0.08736109685440634,
                    "values": 0.2846646301352724,
                    "var": 0.11437825500604476,
                    "written": 0.07563230260981688
                },
                "Max term": "public",
                "Max score": 0.45052499164506643
            }
        ]
    }
]