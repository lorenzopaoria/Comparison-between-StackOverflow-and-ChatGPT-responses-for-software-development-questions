[
    {
        "ID": "49",
        "Question": "During my four years at university we have been using much functional programming in several functional programming languages. But I have also used much object oriented programming to, and in fact I use object oriented languages more when doing my own small project to prepare for my first job. But I often wish that I was coding in a functional programming language when doing these projects. However, when looking for a job, it is very rare to see a job where knowledge of a functional programming language is required. Why isn't functional programming languages used more in the industry? There is quite much news about functional programming languages these days, so I wonder if functional programming is catching on in the industry now? ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "catching": 0.14013098242672403,
                    "coding": 0.07365618533299131,
                    "days": 0.08564693298531928,
                    "fact": 0.08400653095699015,
                    "functional": 0.629461315219217,
                    "industry": 0.1798460900626334,
                    "job": 0.21097917598934174,
                    "knowledge": 0.0780919656690223,
                    "language": 0.12058186009132957,
                    "languages": 0.2705890649341438,
                    "looking": 0.07240982535673297,
                    "news": 0.1280818541296863,
                    "object": 0.16684935374970425,
                    "oriented": 0.18741401950319847,
                    "prepare": 0.11721733301217829,
                    "programming": 0.4394692282586451,
                    "project": 0.05740652909332141,
                    "projects": 0.06747515610874033,
                    "quite": 0.07961015320122523,
                    "rare": 0.11829211341932892,
                    "required": 0.09101255578018301,
                    "small": 0.07511136617144554,
                    "university": 0.10007754084218283,
                    "use": 0.046069389096443744,
                    "used": 0.12034379237116224,
                    "using": 0.05610746527595639,
                    "wish": 0.12063347471077374,
                    "wonder": 0.10241890213362764,
                    "years": 0.07219137705693586
                },
                "Max term": "functional",
                "Max score": 0.629461315219217
            }
        ],
        "Best answer": "I was a professor and, just like programmers, professors are always looking for the Next Big Thing. When they think they've found one, they make it a bandwagon, and everyone piles on. Since they are preaching to students who think professors must be really smart, else why would they be professors, they get no resistance. Functional programming is such a bandwagon. Sure it's got lots of nice interesting questions to investigate, and lots of sort-of-interesting conference articles to write. It's not a particularly new idea, and you can do it in just about any modern language, and ideas don't have to be new to be interesting. It's also a good skill to have. Given that, functional programming is just one arrow to have in your quiver, not the only one, just as OOP is not the only one. My beef with computer science academia is lack of practical interplay with industry to determine what actually makes real-world sense, i.e. quality control. If that quality control were there, there might be a different emphasis, on classifying problems and the ranges of solutions to them, with tradeoffs, rather than just the latest bandwagons. ",
        "Best answer TF-IDF scores": [
            {
                "Scores": {
                    "academia": 0.13892552972395636,
                    "actually": 0.07452978403981478,
                    "articles": 0.11729277274617729,
                    "big": 0.08362122445032986,
                    "classifying": 0.16073722182298233,
                    "computer": 0.08869804023489908,
                    "conference": 0.13532358332741565,
                    "control": 0.17135252090987807,
                    "determine": 0.11956450965387744,
                    "different": 0.06822823017091548,
                    "emphasis": 0.13892552972395636,
                    "functional": 0.195072233303521,
                    "given": 0.09111869821664939,
                    "good": 0.05477312794539799,
                    "got": 0.08652192015070204,
                    "idea": 0.07806888179366686,
                    "ideas": 0.10062159384396895,
                    "industry": 0.0975361166517605,
                    "interesting": 0.27869394025566047,
                    "investigate": 0.1457918884339524,
                    "lack": 0.10461917626484753,
                    "language": 0.06539528531233708,
                    "latest": 0.11336163585820584,
                    "like": 0.04641653807188951,
                    "looking": 0.07854019145223888,
                    "lots": 0.18673345615186135,
                    "make": 0.05764662181697492,
                    "makes": 0.07951489111551875,
                    "modern": 0.11277087127711356,
                    "new": 0.1240876490411653,
                    "nice": 0.09902371047708056,
                    "oop": 0.11658577306760838,
                    "particularly": 0.11003790697813902,
                    "practical": 0.11459406033425448,
                    "problems": 0.07951489111551875,
                    "professor": 0.14867103334955717,
                    "professors": 0.455984286688872,
                    "programmers": 0.07492908356910832,
                    "programming": 0.11916890130156974,
                    "quality": 0.19018514717821822,
                    "questions": 0.08133441479936315,
                    "ranges": 0.15592589911759544,
                    "real": 0.08147045031915703,
                    "really": 0.06054514790994287,
                    "resistance": 0.151994762229624,
                    "science": 0.10855031315281896,
                    "sense": 0.09289798008522016,
                    "skill": 0.11336163585820584,
                    "smart": 0.12122390963414874,
                    "solutions": 0.10671417809807221,
                    "sort": 0.09198999083601558,
                    "students": 0.11878036657149736,
                    "sure": 0.07671378305080459,
                    "thing": 0.07123433261739415,
                    "think": 0.11042553433068938,
                    "tradeoffs": 0.14867103334955717,
                    "world": 0.08470339355619466,
                    "write": 0.06771744178821133
                },
                "Max term": "professors",
                "Max score": 0.455984286688872
            }
        ]
    },
    {
        "ID": "163",
        "Question": "Are there any great programming or software development books that are language agnostic?  Why should I read it? ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "agnostic": 0.5835464832164842,
                    "books": 0.3941927826116693,
                    "development": 0.2738758203348112,
                    "great": 0.34571692833722917,
                    "language": 0.2746880925253898,
                    "programming": 0.25028010834826325,
                    "read": 0.3190683236114306,
                    "software": 0.2639301358641791
                },
                "Max term": "agnostic",
                "Max score": 0.5835464832164842
            }
        ],
        "Best answer": "The Pragmatic Programmer: From Journeyman to Master - Andrew Hunt and David Thomas This book is all about how to write code that works and is maintainable. A key concept is being practical. Everything in the book is boiled down to 70 tips that are easy to remember that help you deliver better, higher-quality software. ",
        "Best answer TF-IDF scores": [
            {
                "Scores": {
                    "70": 0.24061342925614773,
                    "andrew": 0.27375426234115013,
                    "better": 0.11402497151486377,
                    "boiled": 0.282201352308578,
                    "book": 0.3141773741018899,
                    "code": 0.08168111437009254,
                    "concept": 0.1829820353038724,
                    "david": 0.2515036222897546,
                    "deliver": 0.20991569923732434,
                    "easy": 0.14628541703811668,
                    "help": 0.128821199571961,
                    "higher": 0.18893228911034177,
                    "hunt": 0.26685248729916633,
                    "key": 0.1816299287544031,
                    "maintainable": 0.2297232362225409,
                    "master": 0.20118923561134736,
                    "practical": 0.20118923561134736,
                    "pragmatic": 0.22526456424673602,
                    "programmer": 0.128821199571961,
                    "quality": 0.1669510805089244,
                    "remember": 0.17495017756832876,
                    "software": 0.11031592718178981,
                    "tips": 0.20592728124570128,
                    "works": 0.14899049318385932,
                    "write": 0.11888941111944921
                },
                "Max term": "book",
                "Max score": 0.3141773741018899
            }
        ]
    },
    {
        "ID": "501",
        "Question": "No matter how much you love a programming language, there are always a few details in it that aren’t quite as nice as they could be. In this question, I would like to specifically focus on syntax elements. In a programming language that you use frequently (perhaps your favourite programming language, or perhaps the one you are forced to use at work), which syntax element do you find most unreadable, unclear, inconvenient or unpleasant? ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "details": 0.16968367439319157,
                    "element": 0.22065367277070042,
                    "elements": 0.20030580192235695,
                    "favourite": 0.23774320696956142,
                    "focus": 0.17850331989342566,
                    "forced": 0.2184493354350768,
                    "frequently": 0.19219220637936235,
                    "inconvenient": 0.27105993225441155,
                    "language": 0.3308388947901834,
                    "like": 0.07827473638375246,
                    "love": 0.17710466937073804,
                    "matter": 0.15550452748719368,
                    "nice": 0.16698907663750678,
                    "programming": 0.3014415138007966,
                    "question": 0.10724347306018722,
                    "quite": 0.14561690058091017,
                    "specifically": 0.17510267218050135,
                    "syntax": 0.3464103514800626,
                    "unclear": 0.245856802512556,
                    "unreadable": 0.256317046454616,
                    "use": 0.16853331848071032,
                    "work": 0.08991616545314482
                },
                "Max term": "syntax",
                "Max score": 0.3464103514800626
            }
        ],
        "Best answer": "Semicolon insertion in JavaScript. I haven't really been bitten by it often, but it's just such a phenomenally bad idea it makes my head spin.  Here's the rules (from ECMA-262 Section 7.9)  When the program contains a token that is not allowed by the formal grammar, then a semicolon is inserted if (a) there is a line break at that point, or (b) the unexpected token was a closing brace. When the end of a file is reached, if the program cannot be parsed otherwise, then a semicolon is inserted. When a \"restricted production\" is encountered and contains a line terminator in a place where the grammar contains the annotation \"[no LineTerminator here]\", then a semicolon is inserted.    Example: return 1; // returns 1  return 1; // returns undefined  ",
        "Best answer TF-IDF scores": [
            {
                "Scores": {
                    "allowed": 0.12634575684893595,
                    "bad": 0.09095442445611875,
                    "brace": 0.17914760837098445,
                    "break": 0.11530266272205437,
                    "closing": 0.17914760837098445,
                    "contains": 0.38315801921120485,
                    "encountered": 0.13608955302549886,
                    "end": 0.08675226856130525,
                    "example": 0.07483908306146582,
                    "file": 0.09843565269218568,
                    "formal": 0.13510855321522658,
                    "grammar": 0.30549336521992043,
                    "head": 0.12098335885551839,
                    "idea": 0.08701067060207707,
                    "javascript": 0.11328204802647124,
                    "line": 0.2040716305152686,
                    "makes": 0.08862230173986793,
                    "parsed": 0.15712808079310553,
                    "place": 0.10227978850286792,
                    "point": 0.08198840355313167,
                    "production": 0.11943242344103748,
                    "program": 0.18010630078780107,
                    "reached": 0.1624904787865231,
                    "really": 0.06747981782638308,
                    "restricted": 0.1596600160178587,
                    "return": 0.22894783993511203,
                    "returns": 0.29166669840412346,
                    "rules": 0.12045518027006462,
                    "section": 0.13325909025683447,
                    "spin": 0.16940381219442158,
                    "token": 0.3475704207551338,
                    "undefined": 0.1624904787865231,
                    "unexpected": 0.15274668260996022
                },
                "Max term": "contains",
                "Max score": 0.38315801921120485
            }
        ]
    },
    {
        "ID": "724",
        "Question": "When learning a new programming language you sometimes come across a language feature which  makes you wish you had it in your other programming languages that you know. What are some language feature which were at the time of learning very new to you and that you wish your other programming languages had.   An example of this is generators in Python or C#. Other examples may include list comprehensions in Python, template in C++ or LINQ in .NET or lazy evaluation in Haskell. What other semi-unique language features have you come across which were completely new and enlightening to you?  Are there other features of older programming languages which were unique and have fallen out of fashion? ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "come": 0.19757311837191735,
                    "completely": 0.11835800453061854,
                    "evaluation": 0.16738221827521255,
                    "example": 0.07845879042821755,
                    "examples": 0.1120265239866043,
                    "fallen": 0.18781235800753227,
                    "fashion": 0.1775972881413724,
                    "feature": 0.21293409673948696,
                    "features": 0.19831411590804915,
                    "generators": 0.1647278221087927,
                    "haskell": 0.13109452322471,
                    "include": 0.11835800453061854,
                    "know": 0.06513391048358275,
                    "language": 0.30564277764142056,
                    "languages": 0.25720160149884735,
                    "lazy": 0.15811795793472394,
                    "learning": 0.1869960066112542,
                    "linq": 0.15288680345124372,
                    "list": 0.10109597303316928,
                    "makes": 0.0929086556787962,
                    "net": 0.09364751984048987,
                    "new": 0.21748410575085753,
                    "older": 0.13878814426293826,
                    "programming": 0.27848425026610213,
                    "python": 0.21293409673948696,
                    "semi": 0.15625092154108253,
                    "template": 0.15288680345124372,
                    "time": 0.05898577358137643,
                    "unique": 0.28534346717016773,
                    "wish": 0.30577360690248745
                },
                "Max term": "wish",
                "Max score": 0.30577360690248745
            }
        ],
        "Best answer": "Practically anything in Haskell  Monads. Yes - the big scary word that makes increadibly easy parsers, IO, operations on Lists and other things so easy (once you notice common pattern) Arrows. The same for advanced users ;) Standard stuff like lambdas etc.  Currying functions Algebraic data types Pattern matching  And many more. PS. Yes. I am Haskell fanboy if anyone asked. ",
        "Best answer TF-IDF scores": [
            {
                "Scores": {
                    "advanced": 0.17233693628811037,
                    "asked": 0.13012886705762006,
                    "big": 0.12052929144399273,
                    "common": 0.12254952628273356,
                    "currying": 0.2316821307311474,
                    "data": 0.10964068209615122,
                    "easy": 0.2401952849412704,
                    "functions": 0.13897101089769065,
                    "haskell": 0.32343194867578007,
                    "io": 0.19505162381117436,
                    "like": 0.06690349826689108,
                    "lists": 0.17120669440596573,
                    "makes": 0.11461053755667532,
                    "matching": 0.21908099427097616,
                    "monads": 0.21429026453101227,
                    "notice": 0.16517266981640522,
                    "operations": 0.16906251832027847,
                    "parsers": 0.21908099427097616,
                    "pattern": 0.3157485436361116,
                    "practically": 0.192748479468489,
                    "ps": 0.192748479468489,
                    "scary": 0.21908099427097616,
                    "standard": 0.13072654367916453,
                    "stuff": 0.11967190668313607,
                    "things": 0.08895253494699298,
                    "types": 0.14317717995911192,
                    "users": 0.12254952628273356,
                    "word": 0.1564613818601072,
                    "yes": 0.26915237497198535
                },
                "Max term": "haskell",
                "Max score": 0.32343194867578007
            }
        ]
    },
    {
        "ID": "811",
        "Question": "Literate programming has good ideals. Why do you think that this isn't mainstream? It is because it has failed to deliver? ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "deliver": 0.5075617069724284,
                    "failed": 0.5222379794321498,
                    "good": 0.23251667569803688,
                    "mainstream": 0.5446742057163106,
                    "programming": 0.25294115761337066,
                    "think": 0.23438298229331458
                },
                "Max term": "mainstream",
                "Max score": 0.5446742057163106
            }
        ],
        "Best answer": "I first saw it in a book of Knuth's writings, and thought it looked neat.  Then I tried to use the literary programming display to comprehend what was going on in the program, and found it harder than it looked.  It may have been that I was too used to going through program listings, but it seemed confusing. Then I looked at the source code, and that turned me off then and there.  I'd have to learn to write programs in an entirely new way, with less correspondence between the program text and what the compiler saw, and saw no corresponding benefit. In addition, people can write long and convincing arguments that the code is doing X when it's actually doing Y, and I've run into my share of misleading comments.  I developed a fondness for reading the code to see what it's doing fairly early.  Literate programming is the antithesis of that. ",
        "Best answer TF-IDF scores": [
            {
                "Scores": {
                    "actually": 0.0848658455897231,
                    "addition": 0.1361461507640528,
                    "arguments": 0.12711784782103525,
                    "benefit": 0.12253682793078391,
                    "book": 0.10188385217622785,
                    "code": 0.15892907512887655,
                    "comments": 0.1117263824816308,
                    "compiler": 0.119587069571228,
                    "comprehend": 0.17755026998177628,
                    "confusing": 0.14899283124794083,
                    "convincing": 0.169289273039727,
                    "corresponding": 0.169289273039727,
                    "developed": 0.12529836417658655,
                    "display": 0.14351425680876675,
                    "early": 0.12053148576283243,
                    "entirely": 0.12529836417658655,
                    "fairly": 0.11737369843525912,
                    "going": 0.1616501725733885,
                    "harder": 0.12589000229182754,
                    "knuth": 0.169289273039727,
                    "learn": 0.08260785421664665,
                    "long": 0.0841992401072032,
                    "looked": 0.3959244739843082,
                    "misleading": 0.17755026998177628,
                    "new": 0.07064828778715898,
                    "people": 0.06790421513294462,
                    "program": 0.2760124603884673,
                    "programming": 0.13569567800643667,
                    "programs": 0.10828035759008178,
                    "reading": 0.10424642296915612,
                    "run": 0.0923072658770864,
                    "saw": 0.40843845229215836,
                    "share": 0.11780069691454643,
                    "source": 0.0831269389578948,
                    "text": 0.11346837486645858,
                    "thought": 0.10525901157899854,
                    "tried": 0.11613553052048495,
                    "turned": 0.13903793555780988,
                    "use": 0.05689970161100852,
                    "used": 0.07431752418424058,
                    "way": 0.0652329097630784,
                    "write": 0.15421748587006068
                },
                "Max term": "saw",
                "Max score": 0.40843845229215836
            }
        ]
    },
    {
        "ID": "827",
        "Question": "For decades, the accepted degree to get to become a software developer was \"Compter Science.\" We've had a few questions already about whether that degree really prepares students to develop software. Some schools have, in the last 8 years or so, started offering multiple distinct majors in programming.  Using the curriculum from my school:  Computer Science, which starts out with some intro programming courses in the first year, and then focuses on theoretical computer science, algorithms, and a bit of OS stuff.  Most classes involve several smaller projects and homeworks, done solo or in pairs. Software Engineering, which starts out with the same intro programming courses, does a few classes of theory, and then goes into software development practices (testing, process methodologies, sofware metrics, requirements gathering) and software design (distributed system design, info system design, real-time/embedded design, subsystem design, etc)  Different schools do it differently, so the above is just a real-world example I'm familiar with.  What I ask is: Is there a need for distinct majors in programming? ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "accepted": 0.105582671966616,
                    "algorithms": 0.09235795579123257,
                    "ask": 0.07063793734576002,
                    "bit": 0.07215975971395443,
                    "classes": 0.16791635501003757,
                    "computer": 0.15224911545916645,
                    "courses": 0.2269851130392743,
                    "curriculum": 0.13382246188844524,
                    "decades": 0.11762184519469594,
                    "degree": 0.1871570261728577,
                    "design": 0.31772551554645145,
                    "develop": 0.08298400114538887,
                    "developer": 0.062340442889100484,
                    "development": 0.055959143020205146,
                    "different": 0.05855646677962993,
                    "differently": 0.10066581433516401,
                    "distinct": 0.22459653238911553,
                    "distributed": 0.10479510301022282,
                    "embedded": 0.09834966069464504,
                    "engineering": 0.08944922441137003,
                    "example": 0.057629474447222606,
                    "familiar": 0.08911579057348636,
                    "focuses": 0.1304485873791691,
                    "gathering": 0.12294542419483413,
                    "goes": 0.08370978347563209,
                    "info": 0.105582671966616,
                    "involve": 0.11229826619455777,
                    "methodologies": 0.10066581433516401,
                    "metrics": 0.11476927494243261,
                    "multiple": 0.08013143089312554,
                    "need": 0.05051205915223176,
                    "offering": 0.12759601712690574,
                    "os": 0.09729193982588787,
                    "pairs": 0.1209957197039721,
                    "practices": 0.08472401413085745,
                    "process": 0.06824317541914762,
                    "programming": 0.20455198069039215,
                    "projects": 0.06281293861745932,
                    "questions": 0.06980477063978992,
                    "real": 0.13984304460732866,
                    "really": 0.0519625077973612,
                    "requirements": 0.0776604221452507,
                    "school": 0.09488529662930693,
                    "schools": 0.2384639949107502,
                    "science": 0.27948795345248717,
                    "smaller": 0.09488529662930693,
                    "software": 0.26963505215813516,
                    "solo": 0.11229826619455777,
                    "started": 0.07645501432068383,
                    "starts": 0.21281051054180397,
                    "students": 0.10194253275795949,
                    "stuff": 0.07125689395255312,
                    "testing": 0.0720280504224245,
                    "theoretical": 0.11476927494243261,
                    "theory": 0.10261551882602606,
                    "time": 0.043326173049629796,
                    "using": 0.052230702018388746,
                    "world": 0.07269617632569877,
                    "year": 0.08446519764141473,
                    "years": 0.06720329077089449
                },
                "Max term": "design",
                "Max score": 0.31772551554645145
            }
        ],
        "Best answer": "Yes, they should be. The relationship between computer science and software engineering is the same as the relationship between physics and mechanical engineering. One provides the theoretical background while the other takes those theories, along with good engineering principles, and applies them to the design and implementation of software. You need both in order to produce new and better software. A good computer science education trains people to produce new and better algorithms, data structures, programming languages and paradigms, compilers, and a number of other things that can be used to enhance software systems. A good software engineering education, on the other hand, trains you to take these tools and knowledge obtained through a scientific study of computation, along with a knowledge of the software development lifecycle and process models to actually build the system that a customer wants and needs. ",
        "Best answer TF-IDF scores": [
            {
                "Scores": {
                    "actually": 0.07032585753963537,
                    "algorithms": 0.10154270477760569,
                    "applies": 0.12618276902275907,
                    "background": 0.09623813582389651,
                    "better": 0.12256670444559739,
                    "build": 0.08053298370585073,
                    "compilers": 0.13108929722332274,
                    "computation": 0.13108929722332274,
                    "computer": 0.16738987834104183,
                    "customer": 0.09526137110836012,
                    "data": 0.07177625941634547,
                    "design": 0.06986449180051807,
                    "development": 0.06152412849146141,
                    "education": 0.24693205027202292,
                    "engineering": 0.39337883170652754,
                    "enhance": 0.14342134668766782,
                    "good": 0.15505078577031065,
                    "hand": 0.08538354114966255,
                    "implementation": 0.0940279415194895,
                    "knowledge": 0.1598512290113277,
                    "languages": 0.06923566690918075,
                    "lifecycle": 0.13517201421167285,
                    "models": 0.11793343654676408,
                    "need": 0.05553534686062126,
                    "needs": 0.08068770199706973,
                    "new": 0.11708836193910632,
                    "number": 0.07962859671605092,
                    "obtained": 0.14342134668766782,
                    "order": 0.08878231618184572,
                    "paradigms": 0.11698697020949705,
                    "people": 0.0562702477845634,
                    "physics": 0.13756835214983715,
                    "principles": 0.10640991826593996,
                    "process": 0.07502977469896191,
                    "produce": 0.20485484982996405,
                    "programming": 0.0562235305258097,
                    "provides": 0.1128203547218522,
                    "relationship": 0.2703440284233457,
                    "science": 0.20485484982996405,
                    "scientific": 0.12618276902275907,
                    "software": 0.35573943486852616,
                    "structures": 0.110676757390977,
                    "study": 0.11000963673154984,
                    "systems": 0.08680120402804367,
                    "takes": 0.08787792919204591,
                    "theoretical": 0.12618276902275907,
                    "things": 0.05823276636037117,
                    "tools": 0.07948169819161233,
                    "used": 0.06158477043575478,
                    "wants": 0.10383110953293842,
                    "yes": 0.08810028503641017
                },
                "Max term": "engineering",
                "Max score": 0.39337883170652754
            }
        ]
    },
    {
        "ID": "966",
        "Question": "There are a lot of questions about what programming books should be on the programmer's bookshelf. How about non-programming related books that can help you become a better programmer or developer? It would also be interesting to know why they would help. My first choice would be Sun Tzu's \"Art of War\" (however cliché), because it made it obvious that the success of any project depends on the strength of its weakest link (and warfare is a big project). ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "art": 0.2298571097142986,
                    "better": 0.1152426989910658,
                    "big": 0.14837905605751298,
                    "books": 0.33304379813595986,
                    "bookshelf": 0.28521511618820966,
                    "choice": 0.1741039958024187,
                    "depends": 0.17796070599310945,
                    "developer": 0.1288888077839526,
                    "help": 0.2603938861585999,
                    "interesting": 0.16483990380794084,
                    "know": 0.09891349027001972,
                    "link": 0.1934734889092934,
                    "lot": 0.118530790198244,
                    "non": 0.14384305187218677,
                    "obvious": 0.1842468142578637,
                    "programmer": 0.2603938861585999,
                    "programming": 0.21145551506532737,
                    "project": 0.22097432806643266,
                    "questions": 0.14432129847713696,
                    "related": 0.17206301964544843,
                    "strength": 0.2431830557165254,
                    "success": 0.2121574898841576,
                    "sun": 0.23464575521529402,
                    "war": 0.2431830557165254
                },
                "Max term": "books",
                "Max score": 0.33304379813595986
            }
        ],
        "Best answer": "The Design of Everyday Things by Donald Norman  ",
        "Best answer TF-IDF scores": [
            {
                "Scores": {
                    "design": 0.3320978834339439,
                    "donald": 0.6668392236230635,
                    "everyday": 0.6069714537584033,
                    "things": 0.2768069724174138
                },
                "Max term": "donald",
                "Max score": 0.6668392236230635
            }
        ]
    },
    {
        "ID": "1386",
        "Question": "Sometimes I feel like a musician who can't play live shows. Programming is a pretty cool skill, and a very broad world, but a lot of it happens \"off camera\"- in your head, in your office, away from spectators.  You can of course talk about programming with other programmers, and there is peer programming, and you do get to create something that you can show to people, but when it comes to explaining to non programmers what is it that you do, or how was your day at work, it's sort of tricky.  How do you get the non programmers in your life to understand what is it that you do?  NOTE: this is not a repeat of Getting non-programmers to understand the development process, because that question was about managing client expectations.  ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "away": 0.12476883461825104,
                    "broad": 0.17535632787538247,
                    "client": 0.12169145560123432,
                    "comes": 0.12576056508044234,
                    "cool": 0.1575104900880315,
                    "course": 0.11049006342656062,
                    "create": 0.10952074929518456,
                    "day": 0.1168701902031605,
                    "development": 0.0864619683615872,
                    "expectations": 0.16573590409971786,
                    "explaining": 0.1585503148062898,
                    "feel": 0.10858322174683811,
                    "getting": 0.10858322174683811,
                    "happens": 0.13619990961205872,
                    "head": 0.1439447740180035,
                    "life": 0.13299424862993742,
                    "like": 0.061551347844109656,
                    "live": 0.1519591757915749,
                    "lot": 0.08858086561276388,
                    "managing": 0.15460031639250335,
                    "non": 0.3224919540123532,
                    "note": 0.1267879341119472,
                    "office": 0.15460031639250335,
                    "peer": 0.19332952457482866,
                    "people": 0.07907850956918167,
                    "play": 0.15650715807222584,
                    "pretty": 0.10858322174683811,
                    "process": 0.10544191628978515,
                    "programmers": 0.397443349114882,
                    "programming": 0.23703856860844189,
                    "question": 0.08433091721926458,
                    "repeat": 0.1619179707174497,
                    "shows": 0.1607507870870962,
                    "skill": 0.1503249007946034,
                    "sort": 0.12198470974622524,
                    "talk": 0.13256428521189703,
                    "tricky": 0.19714745795709684,
                    "understand": 0.20316538954511693,
                    "work": 0.07070558691480722,
                    "world": 0.11232220792250956
                },
                "Max term": "programmers",
                "Max score": 0.397443349114882
            }
        ],
        "Best answer": "I don't even try. If they aren't tech oriented enough to have at least a basic understanding of programming, I am only going to bore them with the details. Usually I just go with something very high level like \"I create web sites\" or \"I write computer programs to do X\" ",
        "Best answer TF-IDF scores": [
            {
                "Scores": {
                    "basic": 0.25982622700214325,
                    "computer": 0.24103710759834981,
                    "create": 0.2244406241582101,
                    "details": 0.27343938916638444,
                    "going": 0.19289145092770374,
                    "high": 0.2570355291317918,
                    "level": 0.22139611706931656,
                    "like": 0.12613703811208746,
                    "oriented": 0.2762081048269846,
                    "programming": 0.16192086775160686,
                    "programs": 0.25841426520023236,
                    "sites": 0.2843028276545717,
                    "tech": 0.30337049091456525,
                    "try": 0.20613747324611784,
                    "understanding": 0.2650545985216191,
                    "usually": 0.22806612553917496,
                    "web": 0.20068297215036546,
                    "write": 0.1840222879712271
                },
                "Max term": "tech",
                "Max score": 0.30337049091456525
            }
        ]
    },
    {
        "ID": "3049",
        "Question": "I would like to do some web programming using functional programming. What decent web-frameworks exists for functional programming languages? ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "decent": 0.3072008703660141,
                    "exists": 0.32861451914042294,
                    "frameworks": 0.27127602281532986,
                    "functional": 0.5170468352180398,
                    "languages": 0.19448187561387,
                    "like": 0.12302890937074715,
                    "programming": 0.47379298091992034,
                    "using": 0.1613056327381718,
                    "web": 0.39147593066201086
                },
                "Max term": "functional",
                "Max score": 0.5170468352180398
            }
        ],
        "Best answer": "Compojure is an open source web framework for the Clojure programming language. http://en.wikibooks.org/wiki/Compojure ",
        "Best answer TF-IDF scores": [
            {
                "Scores": {
                    "clojure": 0.4186202641858843,
                    "en": 0.4084678668090651,
                    "framework": 0.26220845348258043,
                    "http": 0.3043790605513342,
                    "language": 0.1997512273167031,
                    "open": 0.2496921403686705,
                    "org": 0.35402263577099474,
                    "programming": 0.1820019148114403,
                    "source": 0.22298811996109288,
                    "web": 0.22557120467911398,
                    "wiki": 0.3676978095987154
                },
                "Max term": "clojure",
                "Max score": 0.4186202641858843
            }
        ]
    },
    {
        "ID": "4889",
        "Question": "why not combine the best features of the all existent programming languages and fit it in a universal programming language? ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "best": 0.20144295179238658,
                    "combine": 0.4247769403635145,
                    "existent": 0.4623571498098525,
                    "features": 0.2516374327403432,
                    "fit": 0.31263352058746774,
                    "language": 0.19391247957602645,
                    "languages": 0.2175725125147209,
                    "programming": 0.3533639623922349,
                    "universal": 0.44084475784837673
                },
                "Max term": "existent",
                "Max score": 0.4623571498098525
            }
        ],
        "Best answer": "For the same reason you don't use a Swiss army knife to carve a chicken...   The Swiss Army knife generally has a blade, as well as various tools, such as screwdrivers and can openers and many others. These attachments are stowed inside the handle of the knife through a pivot point mechanism... The design of the knife and its flexibility have both led to worldwide recognition...  ",
        "Best answer TF-IDF scores": [
            {
                "Scores": {
                    "army": 0.3697140247235599,
                    "design": 0.08777867142211737,
                    "flexibility": 0.15512434675905665,
                    "generally": 0.10802522491738964,
                    "handle": 0.11776477212012543,
                    "inside": 0.13170196189200725,
                    "knife": 0.7622441882889538,
                    "led": 0.17625604986257468,
                    "mechanism": 0.16470232662362258,
                    "pivot": 0.19056104707223845,
                    "point": 0.08721185937638509,
                    "reason": 0.10098978273956472,
                    "recognition": 0.18019647665598595,
                    "tools": 0.09986185671476829,
                    "use": 0.05924130019721958,
                    "various": 0.11430515277884176,
                    "worldwide": 0.19056104707223845
                },
                "Max term": "knife",
                "Max score": 0.7622441882889538
            }
        ]
    },
    {
        "ID": "5597",
        "Question": "I've been doing design and programming for about as long as I can remember. If there's a programming problem, I can figure it out. (Though admittedly Stack Overflow has allowed me to skip the figuring out and get straight to the doing in many instances.) I've made games, esoteric programming languages, and widgets and gizmos galore. I'm currently working on a general-purpose programming language. There's nothing I do better than programming. Is a university education really more than just a formality? ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "admittedly": 0.2228094639016975,
                    "allowed": 0.1732472607625825,
                    "better": 0.09925619258700152,
                    "currently": 0.14906158426006907,
                    "design": 0.113154440833043,
                    "education": 0.19996894954927896,
                    "esoteric": 0.2382969749823945,
                    "figure": 0.16308814617977402,
                    "figuring": 0.24564997825411605,
                    "formality": 0.24564997825411605,
                    "games": 0.1815285478645265,
                    "general": 0.12993789538883282,
                    "instances": 0.20681106046649186,
                    "language": 0.09994169510151649,
                    "languages": 0.11213597884860121,
                    "long": 0.11300700480727084,
                    "overflow": 0.17611445067649067,
                    "problem": 0.1060089625634831,
                    "programming": 0.4553058352211721,
                    "purpose": 0.15480685907783004,
                    "really": 0.09252937246762322,
                    "remember": 0.15229022456356014,
                    "skip": 0.20681106046649186,
                    "stack": 0.1499522302829013,
                    "straight": 0.19430615762011128,
                    "university": 0.16589425749086095,
                    "widgets": 0.2382969749823945,
                    "working": 0.1042712015780642
                },
                "Max term": "programming",
                "Max score": 0.4553058352211721
            }
        ],
        "Best answer": "Hooboy.  This is a tough position to be in; you have my sympathies. I'm biased towards getting a degree, most likely because 1) I have one (BS in Computer Science) and 2) I've often found the knowledge gained pursuing it to be very useful.  But it's hardly a pre-requisite for a successful career; the IT world is rich with people who kick ass, are acknowledged as kicking ass, and who technically don't have more than a high school diploma. The nice thing about a university degree is that you can put it on hold and come back to it later when life permits.  (Though the dangerous thing about the previous sentence is that it's a good way to simply quit without admitting to yourself you're quitting.)  You can test the waters and see what kind of job you could get by sending your resume out today and seeing what kind of nibbles you get; you haven't committed to anything until you actually say yes to a job offer. And it sounds like your school is a bad fit for you, regardless.  If you're so consistently bored with everything they're throwing at you, then you may need to find a school that will do a better job of giving you your money's worth and making you work for that degree.  Have you considered transferring somewhere better?  Edit:  Based on your comments elsewhere, given how much you love the high-level theoretic aspects of programming, have you considered that the best way to continue to explore that and get paid may be a career in academia?  Which would definitely require you to get your degree.  :-) ",
        "Best answer TF-IDF scores": [
            {
                "Scores": {
                    "academia": 0.11041971666044781,
                    "acknowledged": 0.12775591733029534,
                    "actually": 0.05923718738228144,
                    "aspects": 0.09503134020693907,
                    "ass": 0.24161460622270511,
                    "bad": 0.06486252335324237,
                    "based": 0.06443137127203968,
                    "best": 0.053995469617700784,
                    "better": 0.10324092861548922,
                    "biased": 0.1120530845072852,
                    "bored": 0.12393181897381314,
                    "bs": 0.11816556259092868,
                    "career": 0.16630521148082225,
                    "come": 0.06719774791496688,
                    "comments": 0.07798610393402203,
                    "committed": 0.11587718286376739,
                    "computer": 0.07049829135462114,
                    "considered": 0.17106380044707237,
                    "consistently": 0.10510447028834242,
                    "continue": 0.09159236797497708,
                    "dangerous": 0.11041971666044781,
                    "definitely": 0.08283814937090972,
                    "degree": 0.3466489909095677,
                    "edit": 0.06876868439473699,
                    "explore": 0.11587718286376739,
                    "fit": 0.08379937650910378,
                    "gained": 0.11587718286376739,
                    "getting": 0.065082236507675,
                    "given": 0.07242226003775534,
                    "giving": 0.08963167301728461,
                    "good": 0.04353435455927131,
                    "hardly": 0.10105338329809654,
                    "high": 0.15035498726127533,
                    "hold": 0.09503134020693907,
                    "job": 0.1818857245024715,
                    "kick": 0.11587718286376739,
                    "kind": 0.13439549582993376,
                    "knowledge": 0.06732329713075474,
                    "later": 0.07620399152146834,
                    "level": 0.06475371415401661,
                    "life": 0.07971363350844914,
                    "like": 0.03689243433111861,
                    "likely": 0.07127387127388318,
                    "love": 0.08347294013820093,
                    "making": 0.06822887941169489,
                    "money": 0.0757859856447358,
                    "need": 0.0467787790069751,
                    "nice": 0.07870526083486266,
                    "offer": 0.08963167301728461,
                    "paid": 0.08666224772739192,
                    "people": 0.047397804003782816,
                    "position": 0.08315260574041113,
                    "pre": 0.11587718286376739,
                    "previous": 0.08447151721774712,
                    "programming": 0.047358452915753496,
                    "pursuing": 0.12393181897381314,
                    "quit": 0.10755684544215967,
                    "quitting": 0.12393181897381314,
                    "regardless": 0.09503134020693907,
                    "require": 0.07752290299880435,
                    "resume": 0.0938067199787916,
                    "rich": 0.10892856864482461,
                    "say": 0.05563462810196679,
                    "school": 0.26361734582963553,
                    "science": 0.0862771216028717,
                    "seeing": 0.09266380379721306,
                    "sending": 0.12775591733029534,
                    "sentence": 0.11587718286376739,
                    "simply": 0.07143329001702764,
                    "sounds": 0.08705622809716561,
                    "successful": 0.09503134020693907,
                    "technically": 0.10295950053033857,
                    "test": 0.06168351653451653,
                    "thing": 0.1132358442647334,
                    "throwing": 0.10755684544215967,
                    "today": 0.08024097946418356,
                    "tough": 0.10755684544215967,
                    "transferring": 0.12080730311135256,
                    "university": 0.0862771216028717,
                    "useful": 0.06849665659889465,
                    "way": 0.09106641363848902,
                    "work": 0.042379270535297525,
                    "world": 0.06732329713075474,
                    "worth": 0.07365316575700824,
                    "yes": 0.07420902176973715
                },
                "Max term": "degree",
                "Max score": 0.3466489909095677
            }
        ]
    },
    {
        "ID": "6974",
        "Question": "What's the worst programming-related or technical book you've ever read? This can be any book which one way or another can be connected to programming, as long as it's not fiction. ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "book": 0.4765833721663668,
                    "connected": 0.4047950894986305,
                    "fiction": 0.42807815966249113,
                    "long": 0.19692992033088536,
                    "programming": 0.3173726867965753,
                    "read": 0.20230047806142723,
                    "related": 0.25824865729483193,
                    "technical": 0.2322942628508013,
                    "way": 0.1525703997594138,
                    "worst": 0.31842627782846145
                },
                "Max term": "book",
                "Max score": 0.4765833721663668
            }
        ],
        "Best answer": "Any book that allows you to teach yourself X in Y hours. I've read some in the past but once read you don't know any details whatsoever about X and you can't use the book as a reference for X either. After discovering that it seems better to go for the big books.  ",
        "Best answer TF-IDF scores": [
            {
                "Scores": {
                    "allows": 0.2364466860471016,
                    "better": 0.14565129510782132,
                    "big": 0.18753120042188726,
                    "book": 0.4013185955985934,
                    "books": 0.21046131750997504,
                    "details": 0.22565668472280592,
                    "discovering": 0.3604736041487627,
                    "hours": 0.22347490732631942,
                    "know": 0.12501336820114,
                    "past": 0.23116640571645786,
                    "read": 0.34070405509739476,
                    "reference": 0.23738563844289987,
                    "teach": 0.259923187807459,
                    "use": 0.11206343229450906,
                    "whatsoever": 0.3604736041487627
                },
                "Max term": "book",
                "Max score": 0.4013185955985934
            }
        ]
    },
    {
        "ID": "7126",
        "Question": "Note: this question is an edited excerpt from a blog posting I wrote a few months ago.  After placing a link to the blog in a comment on Programmers.SE someone requested that I post a question here so that they could answer it.  This posting is my most popular, as people seem to type \"I don't get object-oriented programming\" into Google a lot.  Feel free to answer here, or in a comment at Wordpress.  What is object-oriented programming?    No one has given me a satisfactory   answer.  I feel like you will not get   a good definition from someone who   goes around saying “object” and   “object-oriented” with his nose in the   air. Nor will you get a good   definition from someone who has done   nothing but object-oriented   programming. No one who understands   both procedural and object-oriented   programming has ever given me a   consistent idea of what an   object-oriented program actually does.  Can someone please give me their ideas of the advantages of object-oriented programming? ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "actually": 0.05462075367923596,
                    "advantages": 0.08352466268711234,
                    "ago": 0.07212650196756694,
                    "air": 0.10332063688934914,
                    "answer": 0.16963648856938796,
                    "blog": 0.15641555684270045,
                    "comment": 0.15163609823716756,
                    "consistent": 0.09317815719302248,
                    "definition": 0.1557770764869899,
                    "edited": 0.10332063688934914,
                    "feel": 0.12002058052617096,
                    "free": 0.0635363714901807,
                    "given": 0.13355659177022383,
                    "goes": 0.07148143887843572,
                    "good": 0.0802833274855225,
                    "google": 0.06842581287163338,
                    "idea": 0.05721445751388848,
                    "ideas": 0.07374269713739548,
                    "like": 0.034017357293201884,
                    "link": 0.07990854217738677,
                    "lot": 0.048955661580672515,
                    "months": 0.07169354745036319,
                    "nose": 0.11779972682582386,
                    "note": 0.07007142176766794,
                    "object": 0.5305261572408898,
                    "oriented": 0.5214256613969213,
                    "people": 0.04370402937465761,
                    "placing": 0.11427364559872863,
                    "popular": 0.08102443047704744,
                    "post": 0.07234751048416664,
                    "posting": 0.1898714562902057,
                    "procedural": 0.09800375262358704,
                    "program": 0.05921506076842761,
                    "programmers": 0.05491338891915731,
                    "programming": 0.21833872484928238,
                    "question": 0.09321371642995417,
                    "requested": 0.10043961875138514,
                    "satisfactory": 0.11779972682582386,
                    "saying": 0.07788853824349495,
                    "se": 0.09589370940706489,
                    "type": 0.06500426466972255,
                    "understands": 0.10181455959614574,
                    "wordpress": 0.10332063688934914,
                    "wrote": 0.07788853824349495
                },
                "Max term": "object",
                "Max score": 0.5305261572408898
            }
        ],
        "Best answer": "From your blog, it seems that you're familiar with both imperative and functional programming, and that you're familiar with the basic concepts involved in object-oriented programming, but you've just never really had it \"click\" as to what makes it useful.  I'll try to explain in terms of that knowledge, and hope that it's helpful to you. At its core, OOP is a way to use the imperative paradigm to better manage high degrees of complexity by creating \"smart\" data structures that model the problem domain.  In a (standard procedural non-object-oriented) program, you've got two basic things: variables, and code that knows what to do with them.  The code takes input from the user and various other sources, stores it in variables, operates on it, and produces output data which goes to the user or various other locations. Object-oriented programming is a way to simplify your program by taking that basic pattern and repeating it on a smaller scale.  Just like a program is a large collection of data with code that knows what to do with it, each object is a small piece of data bound to code that knows what to do with it. By breaking down the problem domain into smaller pieces and making sure as much data as possible is bound directly to code that knows what to do with it, you make it a lot easier to reason about the process as a whole and also about the sub-issues that make up the process. By grouping data into object classes, you can centralize code related to that data, making relevant code easier both to find and to debug.  And by encapsulating the data behind access specifiers and only accessing it through methods, (or properties, if your language supports them,) you greatly reduce the potential for data corruption or the violation of invariants. And by using inheritance and polymorphism, you can reuse preexisting classes, customizing them to fit your specific needs, without having to either modify the originals or rewrite everything from the ground up.  (Which is a thing you should never do, if you can avoid it.)  Just be careful you understand your base object, or you could end up with killer kangaroos. To me, these are the fundamental principles of object-oriented programming: complexity management, code centralization and improved problem-domain modeling through the creation of object classes, inheritance and polymorphism, and increased safety without sacrificing power or control through the use of encapsulation and properties.  I hope this helps you understand why so many programmers find it useful. EDIT: In response to Joel's question in the comments,  Can you explain what an \"object-oriented program\" contains   (other than these fancy defintions you've outlined) that is fundamentally   different from an imperative program? How do you \"get the ball rolling?\"  A little disclaimer here.  My model of \"an object-oriented program\" is basically the Delphi model, which is very similar to the C#/.NET model since they were created by former Delphi team members.  What I'm saying here may not apply, or not apply as much, in other OO languages. An object-oriented program is one in which all the logic is structured around objects.  Of course this has to be bootstrapped somewhere.  Your typical Delphi program contains initialization code that creates a singleton object called Application.  At the start of the program, it calls Application.Initialize, then a call to Application.CreateForm for every form you want to load into memory from the beginning, and then Application.Run, which displays the main form on screen and starts up the input/event loop that forms the core of any interactive computer programs. Application and your forms poll for incoming events from the OS and translate them into method calls on your object.  One thing that's very common is the use of event handlers, or \"delegates\" in .NET-speak.  An object has a method that says, \"do X and Y, but also check to see if this particular event handler is assigned, and call it if it is.\"  An event handler is a method pointer--a very simple closure that contains a reference to the method and a reference to the object instance--that's used to extend the behavior of objects.  For example, if I have a button object on my form, I customize its behavior by attaching an OnClick event handler, which causes some other object to execute a method when the button is clicked. So in an object-oriented program, most of the work gets done by defining objects with certain responsibilities and linking them together, either through method pointers or by one object directly calling a method defined in another object's public interface.  (And now we're back to encapsulation.)  This is an idea that I had no concept of back before I took OOP classes in college. ",
        "Best answer TF-IDF scores": [
            {
                "Scores": {
                    "access": 0.027510553513079277,
                    "accessing": 0.047600280850545365,
                    "application": 0.11079762945988661,
                    "apply": 0.06548038353544751,
                    "assigned": 0.03916063074744574,
                    "avoid": 0.028799505410487546,
                    "ball": 0.040585442682364206,
                    "base": 0.029700317777138625,
                    "basic": 0.08494296495278868,
                    "basically": 0.030525358053050324,
                    "beginning": 0.03564848539982057,
                    "behavior": 0.06611903469686721,
                    "better": 0.01923314903944196,
                    "blog": 0.031602044570594075,
                    "bound": 0.07920232542113943,
                    "breaking": 0.035898916747120056,
                    "button": 0.07920232542113943,
                    "called": 0.029234039082076814,
                    "calling": 0.03473476063065155,
                    "calls": 0.06457857165705118,
                    "careful": 0.03916063074744574,
                    "causes": 0.03836144144153719,
                    "certain": 0.02737469347556908,
                    "check": 0.028392668411409118,
                    "classes": 0.11587914796627784,
                    "click": 0.03671515594531978,
                    "code": 0.12399797368637072,
                    "collection": 0.037651245644075924,
                    "college": 0.03643132340135393,
                    "comments": 0.029056661540787888,
                    "common": 0.02517842809348423,
                    "complexity": 0.06457857165705118,
                    "computer": 0.02626679482319195,
                    "concept": 0.030864473893607122,
                    "concepts": 0.03110098911290828,
                    "contains": 0.10180671397422898,
                    "control": 0.025371933231313728,
                    "core": 0.06294609326065173,
                    "corruption": 0.047600280850545365,
                    "course": 0.024674676001337673,
                    "created": 0.031473046630325865,
                    "creates": 0.035898916747120056,
                    "creating": 0.030749422476981335,
                    "creation": 0.03916063074744574,
                    "customize": 0.0450113127991584,
                    "customizing": 0.047600280850545365,
                    "data": 0.2027361592176721,
                    "debug": 0.03412618789393281,
                    "defined": 0.031868132274415525,
                    "defining": 0.039601162710569716,
                    "degrees": 0.043174410733751174,
                    "delphi": 0.12342307818634192,
                    "different": 0.020204921307199506,
                    "directly": 0.06346740489755164,
                    "disclaimer": 0.04174959879883271,
                    "domain": 0.09224826743094401,
                    "easier": 0.0516600620801884,
                    "edit": 0.02562236457861321,
                    "encapsulation": 0.08228205212422794,
                    "end": 0.023050446419517416,
                    "event": 0.18661864341019258,
                    "events": 0.040074355516614764,
                    "example": 0.019885062405890542,
                    "execute": 0.037651245644075924,
                    "explain": 0.055298734519689856,
                    "extend": 0.03916063074744574,
                    "familiar": 0.06149884495396267,
                    "fancy": 0.043174410733751174,
                    "fit": 0.031222615283026382,
                    "form": 0.08969040115010579,
                    "forms": 0.07286264680270786,
                    "functional": 0.028884078578938897,
                    "fundamental": 0.040585442682364206,
                    "fundamentally": 0.043174410733751174,
                    "gets": 0.029896800383368595,
                    "goes": 0.028884078578938897,
                    "got": 0.02562236457861321,
                    "greatly": 0.03916063074744574,
                    "ground": 0.040585442682364206,
                    "grouping": 0.047600280850545365,
                    "handler": 0.1428008425516361,
                    "handlers": 0.0450113127991584,
                    "helpful": 0.031868132274415525,
                    "helps": 0.031602044570594075,
                    "high": 0.028010207943689976,
                    "hope": 0.06679131421672731,
                    "idea": 0.02311910493985681,
                    "imperative": 0.11508432432461158,
                    "improved": 0.03836144144153719,
                    "increased": 0.0450113127991584,
                    "inheritance": 0.08014871103322953,
                    "initialization": 0.04402703282736391,
                    "initialize": 0.0461754689156269,
                    "input": 0.06429158515852917,
                    "instance": 0.03134660327335603,
                    "interactive": 0.04174959879883271,
                    "interface": 0.030749422476981335,
                    "invariants": 0.047600280850545365,
                    "involved": 0.029234039082076814,
                    "issues": 0.02717617445379988,
                    "joel": 0.034322670500162786,
                    "killer": 0.0461754689156269,
                    "knowledge": 0.025083831091154616,
                    "knows": 0.12440395645163312,
                    "language": 0.01936598077200134,
                    "languages": 0.021728901116052895,
                    "large": 0.025371933231313728,
                    "like": 0.013745666518768115,
                    "linking": 0.040585442682364206,
                    "little": 0.024126436131159983,
                    "load": 0.03540750657959028,
                    "locations": 0.04242234474777143,
                    "logic": 0.03030889051385736,
                    "loop": 0.035898916747120056,
                    "lot": 0.019781906998051033,
                    "main": 0.027649367259844928,
                    "make": 0.034142625553091936,
                    "makes": 0.023547322181961806,
                    "making": 0.05084247978460602,
                    "manage": 0.030749422476981335,
                    "management": 0.025470930266574404,
                    "members": 0.032436078060484166,
                    "memory": 0.03134660327335603,
                    "method": 0.19162285432898354,
                    "methods": 0.027442262157621335,
                    "model": 0.11919121339243167,
                    "modeling": 0.0450113127991584,
                    "modify": 0.03540750657959028,
                    "needs": 0.025323004402856238,
                    "net": 0.04746916861760036,
                    "non": 0.024006335144584095,
                    "object": 0.5359349033246438,
                    "objects": 0.09190922242768429,
                    "oo": 0.03452539168126043,
                    "oop": 0.06905078336252087,
                    "oriented": 0.2407961725157299,
                    "os": 0.03357060451418305,
                    "output": 0.03452539168126043,
                    "paradigm": 0.037651245644075924,
                    "particular": 0.025521010373251645,
                    "pattern": 0.032436078060484166,
                    "piece": 0.03357060451418305,
                    "pieces": 0.03799647463097724,
                    "pointer": 0.04114102606211397,
                    "pointers": 0.037651245644075924,
                    "polymorphism": 0.08228205212422794,
                    "possible": 0.023050446419517416,
                    "potential": 0.033225375527281734,
                    "power": 0.03473476063065155,
                    "principles": 0.033395657108363654,
                    "problem": 0.061624956288131014,
                    "procedural": 0.039601162710569716,
                    "process": 0.04709464436392361,
                    "produces": 0.04114102606211397,
                    "program": 0.23927504749878284,
                    "programmers": 0.022189293688872125,
                    "programming": 0.07058070441024117,
                    "programs": 0.028160454425594367,
                    "properties": 0.07129697079964115,
                    "public": 0.030525358053050324,
                    "question": 0.018832807175136173,
                    "really": 0.017929674358966835,
                    "reason": 0.02522625738730609,
                    "reduce": 0.035175292593775526,
                    "reference": 0.06269320654671207,
                    "related": 0.02871603780534414,
                    "relevant": 0.030525358053050324,
                    "repeating": 0.0450113127991584,
                    "response": 0.035175292593775526,
                    "responsibilities": 0.03874854061695698,
                    "reuse": 0.04114102606211397,
                    "rewrite": 0.03643132340135393,
                    "rolling": 0.0450113127991584,
                    "run": 0.024006335144584095,
                    "safety": 0.043174410733751174,
                    "saying": 0.031473046630325865,
                    "says": 0.030525358053050324,
                    "scale": 0.03452539168126043,
                    "screen": 0.033935571324743,
                    "similar": 0.02503705300011232,
                    "simple": 0.023966798294614927,
                    "simplify": 0.043174410733751174,
                    "singleton": 0.04402703282736391,
                    "small": 0.024126436131159983,
                    "smaller": 0.06548038353544751,
                    "smart": 0.035898916747120056,
                    "sources": 0.03701219465918275,
                    "speak": 0.037323728682038516,
                    "specific": 0.024248839512753587,
                    "standard": 0.026858438214944935,
                    "start": 0.02192625133297367,
                    "starts": 0.03671515594531978,
                    "stores": 0.047600280850545365,
                    "structured": 0.03836144144153719,
                    "structures": 0.03473476063065155,
                    "sub": 0.03874854061695698,
                    "supports": 0.03540750657959028,
                    "sure": 0.022717809707744976,
                    "takes": 0.027579583167765553,
                    "taking": 0.031473046630325865,
                    "team": 0.02243256809815074,
                    "terms": 0.028236924571550758,
                    "thing": 0.0421902805129149,
                    "things": 0.018275754079447332,
                    "took": 0.03473476063065155,
                    "translate": 0.040585442682364206,
                    "try": 0.022463639599216906,
                    "typical": 0.035175292593775526,
                    "understand": 0.04537095921791493,
                    "use": 0.04439368754523284,
                    "used": 0.019327746041771576,
                    "useful": 0.05104202074650329,
                    "user": 0.045965036645640875,
                    "using": 0.018022214831931165,
                    "variables": 0.06346740489755164,
                    "various": 0.05710461249590835,
                    "violation": 0.04114102606211397,
                    "want": 0.017883902257087525,
                    "way": 0.033930223787889346,
                    "work": 0.015789994090888507
                },
                "Max term": "object",
                "Max score": 0.5359349033246438
            }
        ]
    },
    {
        "ID": "7456",
        "Question": "Linguistic relativity is the idea that language shapes the way we think.  My question is, how much, and to what extent, does this apply to programming?  Are some native, natural languages better-suited for thinking about programming than others?  For instance, can the following be stated more concisely in a non-English language?  Select a pivot.  Move all the items less than the pivot to one side of the list, and all the items greater than the pivot to the other side. Does a Chinese-speaking programmer view programming in a radically different lens than an English-speaking programmer, or do the differences fade away when both are immersed in the subject? Are some programming languages and domains easier to think about in one language or another.  For instance, is it any easier to grok Ruby if you are Japanese because the creator of Ruby is Japanese?  Note that this question is not focused on \"how do programming languages affect the way people think about programming\", but rather \"how do natural languages affect the way people think about programming\". To get it out of the way, one language that clearly has a pragmatic advantage is English.  I think the advantage has little to do with programming languages choosing English keywords like if, for, while, and do, just as musicians who don't speak Italian aren't tripped up by words like forte.  It has more to do with communication of ideas with other programmers, as English is the lingua franca these days, at least in the programming world.  For instance, to ask a question in StackOverflow, you really need to know English and know it pretty well if you want good answers.  Although this sounds like an imperialist attitude, it really is true in practice. That aside, how do the intrinsic properties of languages affect how programmers who speak them think about data structures, algorithms, etc.?  Are any languages particularly concise when it comes to talking about logic and programming, allowing native speakers of those languages to think faster? ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "advantage": 0.12123769475456486,
                    "affect": 0.1944460022190653,
                    "algorithms": 0.05872143448822368,
                    "allowing": 0.06712974428530832,
                    "answers": 0.0521730476573418,
                    "apply": 0.06032832453013694,
                    "aside": 0.06440246443015382,
                    "ask": 0.04491178886211399,
                    "attitude": 0.07001375156264329,
                    "away": 0.05134219119732162,
                    "better": 0.0354397330724192,
                    "choosing": 0.0738425340356674,
                    "clearly": 0.05923306194291025,
                    "comes": 0.05175028681800946,
                    "communication": 0.06061884737728243,
                    "concise": 0.07478428271622693,
                    "concisely": 0.08771009074260572,
                    "creator": 0.07955481386981059,
                    "data": 0.04150770776056986,
                    "days": 0.05069199386843216,
                    "differences": 0.06253097643774248,
                    "different": 0.0372303576709122,
                    "domains": 0.07816902843543842,
                    "easier": 0.09519079828643608,
                    "english": 0.3997740350605909,
                    "extent": 0.06820007979223325,
                    "fade": 0.08771009074260572,
                    "faster": 0.056872055323178836,
                    "focused": 0.06820007979223325,
                    "following": 0.04893266666346938,
                    "forte": 0.08771009074260572,
                    "franca": 0.08771009074260572,
                    "good": 0.029888260901000024,
                    "greater": 0.06937761948049938,
                    "grok": 0.08293955958902206,
                    "idea": 0.04260014344304929,
                    "ideas": 0.05490656754313924,
                    "instance": 0.17328133585247651,
                    "items": 0.12648852024844065,
                    "keywords": 0.07955481386981059,
                    "know": 0.060836265084395394,
                    "language": 0.1427379755312796,
                    "languages": 0.32030800735988024,
                    "like": 0.07598486623204045,
                    "lingua": 0.08771009074260572,
                    "list": 0.04721274501061149,
                    "little": 0.04445629026862094,
                    "logic": 0.05584831622369878,
                    "native": 0.1364001595844665,
                    "natural": 0.12963066814604354,
                    "need": 0.03211570185764796,
                    "non": 0.04423498761572437,
                    "note": 0.0521730476573418,
                    "particularly": 0.06004480291943812,
                    "people": 0.06508137982249376,
                    "pivot": 0.2631302722278172,
                    "practice": 0.05161267615571549,
                    "pragmatic": 0.07001375156264329,
                    "pretty": 0.04468183540228277,
                    "programmer": 0.08007700183997006,
                    "programmers": 0.08177367562498339,
                    "programming": 0.3251367364793793,
                    "properties": 0.06568725716287227,
                    "question": 0.10410614370883055,
                    "radically": 0.08293955958902206,
                    "really": 0.06607580194528766,
                    "ruby": 0.11249437511471738,
                    "select": 0.06568725716287227,
                    "shapes": 0.08508467799566782,
                    "sounds": 0.05976795302851062,
                    "speak": 0.13754824850015512,
                    "speakers": 0.07816902843543842,
                    "speaking": 0.1332580116868636,
                    "stackoverflow": 0.05923306194291025,
                    "stated": 0.07816902843543842,
                    "structures": 0.06400359309649391,
                    "subject": 0.05823113114902807,
                    "suited": 0.06937761948049938,
                    "talking": 0.05584831622369878,
                    "think": 0.21089712353552886,
                    "thinking": 0.046048659386134415,
                    "true": 0.054375699564947345,
                    "view": 0.05624718755735869,
                    "want": 0.032953559554114824,
                    "way": 0.12504224572526224,
                    "words": 0.05753198029007714,
                    "world": 0.04622042269215223
                },
                "Max term": "english",
                "Max score": 0.3997740350605909
            }
        ],
        "Best answer": "I don't know that any particular natural language lends itself to better programming (except maybe Latin?). I do know that knowing more than one language is pretty powerful. Dijkstra said in one of his last interviews (as reprinted in CACM Vol. 53 No. 8, p. 44):  There is an enormous difference   between one who is monolingual and   someone who at least knows a second   language well, because it makes you   much more conscious about language   structure in general. You will   discover that certain constructions in   one language you just can't translate.  ",
        "Best answer TF-IDF scores": [
            {
                "Scores": {
                    "better": 0.0986763822614058,
                    "certain": 0.14044687701138098,
                    "conscious": 0.2258823197490531,
                    "difference": 0.1499863183918626,
                    "dijkstra": 0.22150791057345137,
                    "discover": 0.2369049505348326,
                    "enormous": 0.2258823197490531,
                    "general": 0.12917885626523776,
                    "interviews": 0.18165952164182178,
                    "know": 0.16938904524356874,
                    "knowing": 0.15776104892826798,
                    "knows": 0.15956477455249837,
                    "language": 0.49678940188269977,
                    "latin": 0.24421500084704642,
                    "lends": 0.24421500084704642,
                    "makes": 0.1208104070786715,
                    "maybe": 0.13418802084044584,
                    "natural": 0.18046813920186303,
                    "particular": 0.13093648731800964,
                    "powerful": 0.17315808888964923,
                    "pretty": 0.12440956768176635,
                    "programming": 0.09052922839600584,
                    "said": 0.13447413101305158,
                    "second": 0.15140061312080966,
                    "structure": 0.16018878211522003,
                    "translate": 0.20822511426290816
                },
                "Max term": "language",
                "Max score": 0.49678940188269977
            }
        ]
    },
    {
        "ID": "7551",
        "Question": "Why are there so many programming languages? And what prompts someone to create a programming languages in spite of the fact that other languages already exist? ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "create": 0.24323378328580791,
                    "exist": 0.31829017649553604,
                    "fact": 0.2683488982639863,
                    "languages": 0.6482735029363603,
                    "programming": 0.35095807992747113,
                    "prompts": 0.47337876012730185
                },
                "Max term": "languages",
                "Max score": 0.6482735029363603
            }
        ],
        "Best answer": "Programming languages evolve New programming languages often learn from existing languages and add, remove and combine features in a new way. There is a few different paradigms like object oriented and functional and many modern languages try to mix features from them both. There is also new problems that needs to be solved, e.g. the increase of multi-core CPUs. The most common solution to that have been threads, but some programming languages try to solve the concurrency problem in a different way e.g. the Actor Model. See Erlang - Software for a Concurrent World ",
        "Best answer TF-IDF scores": [
            {
                "Scores": {
                    "actor": 0.18994822291796423,
                    "add": 0.10625487102138154,
                    "combine": 0.1745093051805561,
                    "common": 0.10357442565367275,
                    "concurrency": 0.15939667974578292,
                    "concurrent": 0.16485057528863745,
                    "core": 0.12946807942910646,
                    "cpus": 0.19580935441019856,
                    "different": 0.1662306409280891,
                    "erlang": 0.16290404102019165,
                    "evolve": 0.16923845004799787,
                    "existing": 0.11712287358913298,
                    "features": 0.20675827415375422,
                    "functional": 0.11881805481428524,
                    "increase": 0.1420242598377314,
                    "languages": 0.4469219533532031,
                    "learn": 0.08837618275167271,
                    "like": 0.05654441610184384,
                    "mix": 0.16485057528863745,
                    "model": 0.1225767691319875,
                    "modern": 0.1373769637835682,
                    "multi": 0.14469770368798385,
                    "needs": 0.10416915730851377,
                    "new": 0.22674451667257628,
                    "object": 0.11023156329201401,
                    "oriented": 0.12381792250552358,
                    "paradigms": 0.15103211271579003,
                    "problem": 0.08450050217296416,
                    "problems": 0.09686467962270567,
                    "programming": 0.21775652240024598,
                    "remove": 0.1359942133416084,
                    "software": 0.07654424865763529,
                    "solution": 0.10828502902356822,
                    "solve": 0.12139162708953026,
                    "solved": 0.14469770368798385,
                    "threads": 0.1578043017539459,
                    "try": 0.1848136476940824,
                    "way": 0.1395759666998699,
                    "world": 0.10318528975732247
                },
                "Max term": "languages",
                "Max score": 0.4469219533532031
            }
        ]
    },
    {
        "ID": "7915",
        "Question": "I have been offered an interesting job, but there's a big caveat for me: they use pair programming. I hate the idea of pair programming, and I'm probably not suited for it: I like to do frequent pauses, I hate to see someone programming (I would constantly poke the pair away to code myself), I have to be in full control of the machine I'm working on, I like to work listening music, and basically I don't like to being tied to someone else. I'm not even a social person. I have however never actually worked with true pair programming (besides few times for a short time to help someone else or to solve a complex task together)... so it is pair programming really that bad? And given my attitude, should I refuse the job or should I leave my current one and give a try?  For people that asked about it: I'm looking for a job where formal design and development are used, as I hate my current job where we are \"coding in the wild\". The company is very interested in my technical profile so they insisted even when I specified I never worked with pair programming and that I probably wouldn't like it (besides being an unsociable loner programmer, I don't like and believe the very concept of pair programming). ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "actually": 0.05652960606704648,
                    "asked": 0.06847683263070532,
                    "attitude": 0.09731870983723986,
                    "away": 0.07136534889249112,
                    "bad": 0.06189782222459357,
                    "basically": 0.07818326547118021,
                    "believe": 0.07442155728367097,
                    "big": 0.06342531295268423,
                    "code": 0.03528784340824532,
                    "coding": 0.060596811747959466,
                    "company": 0.057615109566265976,
                    "complex": 0.07487586662789278,
                    "concept": 0.07905182805254804,
                    "constantly": 0.09194632650303732,
                    "control": 0.06498402370558395,
                    "current": 0.13822404510866693,
                    "design": 0.056158749252816616,
                    "development": 0.04945456577305886,
                    "formal": 0.09194632650303732,
                    "frequent": 0.1014287272826431,
                    "given": 0.06911202255433346,
                    "hate": 0.27583897950911196,
                    "help": 0.0556532847674043,
                    "idea": 0.059213953062485926,
                    "interested": 0.07081711594765715,
                    "interesting": 0.07046157836491801,
                    "job": 0.23142958693589175,
                    "leave": 0.07818326547118021,
                    "like": 0.17603087450235014,
                    "listening": 0.1152855082540555,
                    "looking": 0.05957143362784537,
                    "machine": 0.07818326547118021,
                    "music": 0.11826721043574899,
                    "offered": 0.09825348337826069,
                    "pair": 0.6189986374721355,
                    "people": 0.045231370819242445,
                    "person": 0.06713190380690957,
                    "probably": 0.11412670634649037,
                    "profile": 0.10693142273815945,
                    "programmer": 0.0556532847674043,
                    "programming": 0.3163567285861986,
                    "really": 0.04592249131960103,
                    "refuse": 0.10537271198525973,
                    "short": 0.07099782590452819,
                    "social": 0.09403692428767019,
                    "solve": 0.0755819079830816,
                    "specified": 0.11276451498023264,
                    "suited": 0.09643448992131474,
                    "task": 0.06943911515162846,
                    "technical": 0.06615732960205879,
                    "tied": 0.10865449753482939,
                    "time": 0.038290026600375046,
                    "times": 0.06786539376463603,
                    "true": 0.0755819079830816,
                    "try": 0.057535138332603146,
                    "use": 0.03790120389482467,
                    "used": 0.049503311218076884,
                    "wild": 0.1152855082540555,
                    "work": 0.04044222176365073,
                    "worked": 0.13177844769699837,
                    "working": 0.0517499818884919
                },
                "Max term": "pair",
                "Max score": 0.6189986374721355
            }
        ],
        "Best answer": "Guess what - nobody likes pair programming at first. When I first tried pair programming I was against the idea and I had tons of objections similar to yours.  I don't like to watch someone else coding, I like to listen to music, I feel I'll be quicker working on my own, I don't want to stop and explain myself constantly, etc etc etc. Then I tried it.  And guess what?  It still sucked.  We were having all kinds of problems - I wanted to work different hours to the other guy, we had different keyboard settings and shortcuts, our desks didn't work very well for pair programming etc etc. This went on for about a week.  During that week we were rewriting the entire legacy login system for a distributed application.  We had to learn how some seriously difficult threading issues work, figure out how remoting sinks worked, change tons and tons of legacy code to work with our new login module and pretty much do some of the most hectic coding I've had to do in my career.  After a week of this we deployed it.. and everything just worked.  Not a single bug.  Not one. That's when I figured there might be something to this pair programming nonsense.  We started to do more pair programming.  We even started to force everyone to work in pairs.  It rocked.  I probably learnt more in a month of doing that than I did in the previous 2 years.  The other issues didn't go away.  Sometimes you'll be stuck with a pair that you dislike.  It's gonna happen.  Sometimes you'll struggle to find overlapping working hours.  Sometimes you'll want to just work on your own.  But the advantages of pair programming are just incredible. Since then I've always tried to do as much pair programming as possible.  It's simply the best way of learning.  This company forces everyone to do pair programming? Where do I sign up?  It seems to me they are really enlightened and you will be in a really intense working environment.  Awesome. Having said that, make sure that the pairs are rotated often.  You don't want to be stuck developing with one other developer for months on end - you'll go out of your mind.  We're all human, after all.  Also, check that this has been an ongoing practice for a while.  If it's not, it's not the end of the world, but if it's an accepted practice it's a massive green light. Trust me, you want to work for a company like that. ",
        "Best answer TF-IDF scores": [
            {
                "Scores": {
                    "accepted": 0.06485273987118556,
                    "advantages": 0.06008047301995601,
                    "application": 0.03944698776130098,
                    "away": 0.049600691997053976,
                    "awesome": 0.06644134336193218,
                    "best": 0.03581287560537004,
                    "bug": 0.04837730853556483,
                    "career": 0.05515155154178892,
                    "change": 0.04115516974778505,
                    "check": 0.050542834210231063,
                    "code": 0.02452592860954695,
                    "coding": 0.084232581838614,
                    "company": 0.08008786752455889,
                    "constantly": 0.0639049831874019,
                    "deployed": 0.07431999767887748,
                    "developer": 0.03829178075186112,
                    "developing": 0.05068403472804159,
                    "different": 0.07193504837679801,
                    "difficult": 0.04986200225277657,
                    "dislike": 0.07224764052184991,
                    "distributed": 0.06436898620490462,
                    "end": 0.08206589637663878,
                    "entire": 0.05800811586292844,
                    "environment": 0.0481476745535113,
                    "explain": 0.04921965646844874,
                    "feel": 0.04316625184799876,
                    "figure": 0.056255962852510125,
                    "figured": 0.07431999767887748,
                    "force": 0.06436898620490462,
                    "forces": 0.0713378354443155,
                    "gonna": 0.07551757750723735,
                    "green": 0.0704954875114316,
                    "guess": 0.1071625326789487,
                    "guy": 0.05885046379581235,
                    "happen": 0.0545369967138775,
                    "hours": 0.10506261082156518,
                    "human": 0.06345918112737021,
                    "idea": 0.04115516974778505,
                    "incredible": 0.08473501217035306,
                    "intense": 0.08473501217035306,
                    "issues": 0.09675461707112966,
                    "keyboard": 0.06702436836238065,
                    "kinds": 0.06303020585873421,
                    "learn": 0.038244122419936334,
                    "learning": 0.04218335008438736,
                    "learnt": 0.07837414182837689,
                    "legacy": 0.1278099663748038,
                    "light": 0.0682886140446732,
                    "like": 0.0734075008978074,
                    "likes": 0.0682886140446732,
                    "listen": 0.0704954875114316,
                    "login": 0.14647330989577972,
                    "make": 0.03038927229077375,
                    "massive": 0.06897770353646247,
                    "mind": 0.0481476745535113,
                    "module": 0.0626168331944863,
                    "month": 0.056974085554240265,
                    "months": 0.05157018423926064,
                    "music": 0.08219865199582278,
                    "new": 0.03270732295993392,
                    "nonsense": 0.07837414182837689,
                    "objections": 0.08473501217035306,
                    "ongoing": 0.07837414182837689,
                    "overlapping": 0.08473501217035306,
                    "pair": 0.5531392859077767,
                    "pairs": 0.14863999535775496,
                    "possible": 0.04103294818831939,
                    "practice": 0.09972400450555315,
                    "pretty": 0.04316625184799876,
                    "previous": 0.056026328870456596,
                    "probably": 0.03966044934957297,
                    "problems": 0.04191745502369022,
                    "programming": 0.2512866201765428,
                    "quicker": 0.07837414182837689,
                    "really": 0.06383454668209654,
                    "rewriting": 0.0713378354443155,
                    "said": 0.0466583423969322,
                    "seriously": 0.0626168331944863,
                    "settings": 0.0713378354443155,
                    "shortcuts": 0.07685635785340778,
                    "sign": 0.06109904921951718,
                    "similar": 0.04456937969201049,
                    "simply": 0.047378632829290064,
                    "single": 0.04507841231027828,
                    "started": 0.09392293381540556,
                    "stop": 0.05558052681042491,
                    "struggle": 0.0713378354443155,
                    "stuck": 0.12691836225474043,
                    "sucked": 0.08219865199582278,
                    "sure": 0.04044080933290293,
                    "threading": 0.07837414182837689,
                    "tons": 0.21674292156554975,
                    "tried": 0.1612982744309555,
                    "trust": 0.06436898620490462,
                    "want": 0.12734317095024905,
                    "wanted": 0.056026328870456596,
                    "watch": 0.06971128034731962,
                    "way": 0.030200220190262462,
                    "week": 0.16609204676334013,
                    "went": 0.056974085554240265,
                    "work": 0.19675844811998378,
                    "worked": 0.09158929785259463,
                    "working": 0.10790257256519702,
                    "world": 0.0446526510938373,
                    "years": 0.041278719828482024
                },
                "Max term": "pair",
                "Max score": 0.5531392859077767
            }
        ]
    },
    {
        "ID": "8721",
        "Question": "Here's a bit information about me, before starting with the question. I am a Computer Science Undergraduate, Java being my primary coding language. The basic problem in my University are the teaching standards. No one is concerned about teaching coding knowledge to students, rather than just theoretical knowledge. The effect being, most of my fellow college mates don't understand programming at all. Even I haven't been able to come out of the traditional programming environment, which limits my coding to an extent. What are the possible ways by which I can develop and expand my programming/coding skills. Also, can you suggest the sources for the same? Edited: Sources suggesting development of coding skills. ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "able": 0.09152091695322874,
                    "basic": 0.10830016366060537,
                    "bit": 0.09523582080628804,
                    "coding": 0.4524698981417507,
                    "college": 0.13934708856461483,
                    "come": 0.09576485606542497,
                    "computer": 0.10046852660861254,
                    "concerned": 0.14672964578117706,
                    "develop": 0.10952156013544409,
                    "development": 0.07385438834984238,
                    "edited": 0.15968909438908474,
                    "effect": 0.1328578627942519,
                    "environment": 0.10345342823625782,
                    "expand": 0.15328141406842352,
                    "extent": 0.1415688777024287,
                    "fellow": 0.14978648513239848,
                    "information": 0.10090466033215968,
                    "java": 0.0851017137073732,
                    "knowledge": 0.19188755753347464,
                    "language": 0.07407342873732686,
                    "limits": 0.15968909438908474,
                    "possible": 0.08816623440462312,
                    "primary": 0.132057042214333,
                    "problem": 0.07857028366376953,
                    "programming": 0.2024744385495188,
                    "question": 0.07203407958703156,
                    "science": 0.12295525353756565,
                    "skills": 0.20452366777549674,
                    "sources": 0.2831377554048574,
                    "standards": 0.12406557380276423,
                    "starting": 0.11287240110488388,
                    "students": 0.13454286462096837,
                    "suggest": 0.11592924045610531,
                    "suggesting": 0.15328141406842352,
                    "teaching": 0.27869417712922967,
                    "theoretical": 0.15147148695911497,
                    "traditional": 0.1482102711893253,
                    "undergraduate": 0.17216490660893224,
                    "understand": 0.08677026363754547,
                    "university": 0.12295525353756565,
                    "ways": 0.10321041290289554
                },
                "Max term": "coding",
                "Max score": 0.4524698981417507
            }
        ],
        "Best answer": "My favorite quote is from Confucius:  I hear, I know. I see, I remember. I   do, I understand.  All knowledge I got, was from applying one and single strategy:  Take the most challenging path, always.  You want to learn C#? Get a job as a C# developer. You want to learn Italian? Go there with a dictionnary english/italian, and talk Italian You want to learn coding ? Code! ",
        "Best answer TF-IDF scores": [
            {
                "Scores": {
                    "applying": 0.25552677499836346,
                    "challenging": 0.2737304715139978,
                    "code": 0.08889975319939965,
                    "coding": 0.15265998397072197,
                    "developer": 0.13879718532169608,
                    "english": 0.23331989089636704,
                    "favorite": 0.22696881760272872,
                    "got": 0.1653284838239828,
                    "hear": 0.20742094790447713,
                    "job": 0.14575864642405773,
                    "know": 0.10651750354333743,
                    "knowledge": 0.16185359278897316,
                    "learn": 0.41587331088493745,
                    "path": 0.2227753274909055,
                    "quote": 0.23002209744112206,
                    "remember": 0.1904115501846079,
                    "single": 0.16339686022916078,
                    "strategy": 0.24083161625175464,
                    "talk": 0.19102193799333123,
                    "understand": 0.14637821334020734,
                    "want": 0.34618800727180354
                },
                "Max term": "learn",
                "Max score": 0.41587331088493745
            }
        ]
    },
    {
        "ID": "8748",
        "Question": "Quote from Wikipedia of the article \"High-level programming language\":  A high-level programming language is a programming language with strong abstraction from the details of the computer. In comparison to low-level programming languages, it may use natural language elements, be easier to use, or be more portable across platforms. Such languages hide the details of CPU operations such as memory access models and management of scope.  I.e., as the level of programming language increases, the further away the programmer goes from the hardware on which the program runs. Now I do not know the statistics of language usages across levels, but I would suspect that the higher level languages more and more are replacing the lower level languages. If so, can this lead to a deficit of programmers with computer architecture knowledge? Would this be a problem for the industry? ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "abstraction": 0.10406276085862716,
                    "access": 0.08482321126791861,
                    "architecture": 0.09312589662558346,
                    "article": 0.0966508925646801,
                    "away": 0.08591119027970044,
                    "comparison": 0.11608997842407567,
                    "computer": 0.16197666728584093,
                    "cpu": 0.12074386121298132,
                    "details": 0.1837509643355439,
                    "easier": 0.07964166111485728,
                    "elements": 0.10845587943819997,
                    "goes": 0.08905819719024119,
                    "hardware": 0.09743849398868898,
                    "hide": 0.12210215215978362,
                    "high": 0.17272758870055965,
                    "higher": 0.09825892144778432,
                    "increases": 0.1287264190297218,
                    "industry": 0.08905819719024119,
                    "know": 0.05089883995683887,
                    "knowledge": 0.07734090493825325,
                    "language": 0.3582664400379167,
                    "languages": 0.26798663561754943,
                    "lead": 0.09411874951668069,
                    "level": 0.4463338307146109,
                    "levels": 0.11947326488771094,
                    "low": 0.0978444343493868,
                    "lower": 0.11068702772856533,
                    "management": 0.07853444672295996,
                    "memory": 0.0966508925646801,
                    "models": 0.11411959434304314,
                    "natural": 0.10845587943819997,
                    "operations": 0.10709758849139765,
                    "platforms": 0.10582699216612729,
                    "portable": 0.1287264190297218,
                    "problem": 0.06333601738352543,
                    "program": 0.07377560722462818,
                    "programmer": 0.06699665890438736,
                    "programmers": 0.06841618601247915,
                    "programming": 0.2720266060251238,
                    "quote": 0.1099148734689284,
                    "replacing": 0.12356114619051208,
                    "runs": 0.10582699216612729,
                    "scope": 0.10645204180624275,
                    "statistics": 0.1287264190297218,
                    "strong": 0.1000100670718635,
                    "suspect": 0.11411959434304314,
                    "usages": 0.14237269175130546,
                    "use": 0.09125262021890314,
                    "wikipedia": 0.10463345038142058
                },
                "Max term": "level",
                "Max score": 0.4463338307146109
            }
        ],
        "Best answer": "It can, but likely won't lead to a problem. It's just economics.  If the vast majority of people lose the ability to understand the underlying architecture, and there is still a huge NEED to understand the underlying architecture, then the ones who do will have jobs and get paid more, while those who don't will only have jobs where that is not needed (and may still get paid more...who knows?). Is it helpful to know? Absolutely. You'll likely be better.  Is it necessary in most cases?  No.  That's why abstraction is so great, we stand on the shoulders of giants without having to be giants ourselves (but there will always be giants around). ",
        "Best answer TF-IDF scores": [
            {
                "Scores": {
                    "ability": 0.12396008096487965,
                    "absolutely": 0.1345202334204574,
                    "abstraction": 0.1345202334204574,
                    "architecture": 0.24076465487172044,
                    "better": 0.07665809931264529,
                    "cases": 0.10937739075013275,
                    "giants": 0.5691653066174316,
                    "great": 0.0971466789511424,
                    "helpful": 0.12701770489017863,
                    "huge": 0.11956130159904094,
                    "jobs": 0.2573926167474156,
                    "know": 0.06579610011621978,
                    "knows": 0.12396008096487965,
                    "lead": 0.12166577217209992,
                    "likely": 0.2116881192674709,
                    "lose": 0.140199146144777,
                    "majority": 0.15608361973524368,
                    "necessary": 0.11616298190660344,
                    "need": 0.069468036270704,
                    "needed": 0.10964958151297426,
                    "ones": 0.10992471493567099,
                    "paid": 0.2573926167474156,
                    "people": 0.07038730889482056,
                    "problem": 0.08187343649212486,
                    "shoulders": 0.1840428561481576,
                    "stand": 0.14752053801195486,
                    "underlying": 0.2926732450275074,
                    "understand": 0.18083629937585174,
                    "vast": 0.15783946028482287
                },
                "Max term": "giants",
                "Max score": 0.5691653066174316
            }
        ]
    },
    {
        "ID": "9006",
        "Question": "Functional programming is one of the oldest programming paradigms. However it isn't used much in the industry compared to more popular paradigms. But it have largely been emphasized in academia. What's your strongest opinion against functional programming? ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "academia": 0.26793440866762247,
                    "compared": 0.2198028572239805,
                    "emphasized": 0.30072164316416566,
                    "functional": 0.376220004930012,
                    "industry": 0.188110002465006,
                    "largely": 0.2811769981637223,
                    "oldest": 0.29313997808386705,
                    "opinion": 0.19670185560093478,
                    "paradigms": 0.4782211110873459,
                    "popular": 0.2132232654505379,
                    "programming": 0.34474710118345253,
                    "used": 0.1258735793016329
                },
                "Max term": "paradigms",
                "Max score": 0.4782211110873459
            }
        ],
        "Best answer": "The problem is that most common code inherently involves state -- business apps, games, UI, etc. There's no problem with some parts of an app being purely functional; in fact most apps could benefit in at least one area. But forcing the paradigm all over the place feels counter-intuitive. ",
        "Best answer TF-IDF scores": [
            {
                "Scores": {
                    "app": 0.1516939223176435,
                    "apps": 0.36389626846098605,
                    "area": 0.19612513075494548,
                    "benefit": 0.18715432335872045,
                    "business": 0.14758840360221367,
                    "code": 0.08091244626900648,
                    "common": 0.14786720578712245,
                    "counter": 0.2275614032808104,
                    "fact": 0.1584688173424405,
                    "feels": 0.21561979562488343,
                    "forcing": 0.25856079256055453,
                    "functional": 0.16962965183313575,
                    "games": 0.2065765269092416,
                    "inherently": 0.25856079256055453,
                    "intuitive": 0.2353476139161782,
                    "involves": 0.22314469007292193,
                    "paradigm": 0.22111723842024997,
                    "parts": 0.18336334826486528,
                    "place": 0.1595995177120164,
                    "problem": 0.2412729409807123,
                    "purely": 0.2325686597348981,
                    "state": 0.17926851446790915,
                    "ui": 0.18636484743838144
                },
                "Max term": "apps",
                "Max score": 0.36389626846098605
            }
        ]
    },
    {
        "ID": "9598",
        "Question": "Do you think that only the programming pratice will help you to improve your logical programming skill or do you train your brain with puzzle games, trying imagine how universe works, playing instruments and so on? Devoting more time with programming, will do you get logical programming skills more fast? ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "brain": 0.2201089002796855,
                    "fast": 0.18201679323915507,
                    "games": 0.2074389468370026,
                    "help": 0.128141659416843,
                    "imagine": 0.20484100152539358,
                    "improve": 0.17811794085603538,
                    "instruments": 0.2807127219328365,
                    "logical": 0.39595126758581395,
                    "playing": 0.2309416468410664,
                    "programming": 0.41623497376294905,
                    "puzzle": 0.2596402374683483,
                    "skill": 0.19797563379290697,
                    "skills": 0.15766787174523253,
                    "think": 0.09642400173804548,
                    "time": 0.0881627664601182,
                    "train": 0.2546120766171637,
                    "trying": 0.1427603132676427,
                    "universe": 0.2596402374683483,
                    "works": 0.1482045587011369
                },
                "Max term": "programming",
                "Max score": 0.41623497376294905
            }
        ],
        "Best answer": "I think full-time programming practices my logical skills quite enough, and they need rest  after work. Doing something else such as practicing motoric skills by playing musical instruments is good to the brain. ",
        "Best answer TF-IDF scores": [
            {
                "Scores": {
                    "brain": 0.30112706140974926,
                    "good": 0.13086555843356876,
                    "instruments": 0.3840380691037811,
                    "logical": 0.2708469342177384,
                    "need": 0.14061839435918735,
                    "playing": 0.31594714880685243,
                    "practices": 0.23585961512360748,
                    "practicing": 0.37254271624987373,
                    "programming": 0.1423609112874761,
                    "quite": 0.20631021657410545,
                    "rest": 0.24539732116346422,
                    "skills": 0.4314052074863144,
                    "think": 0.13191595730954636,
                    "time": 0.12061390864320085,
                    "work": 0.1273933416667112
                },
                "Max term": "skills",
                "Max score": 0.4314052074863144
            }
        ]
    },
    {
        "ID": "9730",
        "Question": "I've heard a lot of talk about using functional languages such as Haskell as of late. What are some of the big differences, pros and cons of functional programming vs. object-oriented programming? ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "big": 0.19150209188523434,
                    "cons": 0.27761650746020045,
                    "differences": 0.26243340032251733,
                    "functional": 0.4467375476968561,
                    "haskell": 0.2569412547435027,
                    "heard": 0.2296809831290744,
                    "languages": 0.16803575665749274,
                    "late": 0.26390749232856003,
                    "lot": 0.15297909879528598,
                    "object": 0.20722683240705836,
                    "oriented": 0.23276813926761356,
                    "programming": 0.27291030521170045,
                    "pros": 0.28173375915718474,
                    "talk": 0.22893843657851007,
                    "using": 0.1393709000631484,
                    "vs": 0.23438724874966324
                },
                "Max term": "functional",
                "Max score": 0.4467375476968561
            }
        ],
        "Best answer": "I would say that it is more Functional Programming vs Imperative Programming. The biggest difference is that Imperative programming is about Control flow while Functional programming is about Data flow. Another way to say it is that functional programming only uses expressions while in imperative programming both expressions and statements are used. For example, in imperative programming variables and loops are common when handling state, while in functional programming the state is handled via parameter passing, which avoids side-effects and assignments. Imperative pseudo-code for a function for calculate the sum of a list (the sum is kept in a variable): int sumList(List<int> list) {     int sum = 0;     for(int n = 0; n < list.size(); n++) {         sum = sum + list.get(n);     }      return sum; }  Functional pseudo-code for the same function (the sum is passed as a parameter): fun sumList([], sum) = sum  |  sumList(v::lst, sum) = sumList(lst, v+sum)  I recommend the presentation Taming Effects with Functional Programming by Simon Peyton-Jones for a good introduction to functional concepts. ",
        "Best answer TF-IDF scores": [
            {
                "Scores": {
                    "assignments": 0.06234201056751994,
                    "avoids": 0.06516361753801327,
                    "biggest": 0.05514318680042317,
                    "calculate": 0.06516361753801327,
                    "code": 0.04232652276283542,
                    "common": 0.038675784383143195,
                    "concepts": 0.047773242418759417,
                    "control": 0.038973021484678565,
                    "data": 0.03460184228365266,
                    "difference": 0.04490547972211887,
                    "effects": 0.10951701431003014,
                    "example": 0.030544813329891403,
                    "expressions": 0.13263768446608798,
                    "flow": 0.11370651534484942,
                    "fun": 0.05078167548949101,
                    "function": 0.08389338931893552,
                    "functional": 0.310575415492172,
                    "good": 0.024915586661508927,
                    "handled": 0.05892579283785444,
                    "handling": 0.05368747245078267,
                    "imperative": 0.2946289641892722,
                    "int": 0.20737216921451865,
                    "introduction": 0.06015340216921822,
                    "jones": 0.07311728086906139,
                    "kept": 0.0563969859302748,
                    "list": 0.19678850565043335,
                    "loops": 0.06234201056751994,
                    "parameter": 0.11785158567570889,
                    "passed": 0.05836517890199587,
                    "passing": 0.06015340216921822,
                    "presentation": 0.06083008933794877,
                    "programming": 0.2439377555382958,
                    "pseudo": 0.13525705594793233,
                    "recommend": 0.04623491989812983,
                    "return": 0.046721370352415456,
                    "say": 0.063681633132662,
                    "size": 0.04916256113060237,
                    "state": 0.09377806762953055,
                    "statements": 0.055960999766619765,
                    "sum": 0.7054325721821652,
                    "used": 0.029688737348824084,
                    "uses": 0.04361307693493036,
                    "variable": 0.04937813186767676,
                    "variables": 0.048745133295485146,
                    "vs": 0.046556524897183434,
                    "way": 0.026059570010087345
                },
                "Max term": "sum",
                "Max score": 0.7054325721821652
            }
        ]
    },
    {
        "ID": "9965",
        "Question": "I don't see any use for case sensitivity in a programming language, apart from obfuscating code. Why implement this in a programming language?  Update: It looks like someone you know made a statement on this. ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "apart": 0.31491594160274394,
                    "case": 0.20103024350160112,
                    "code": 0.11817383988488037,
                    "implement": 0.24353168813200063,
                    "know": 0.14159299610690643,
                    "language": 0.33221463522901656,
                    "like": 0.11790034396590848,
                    "looks": 0.25392416854398997,
                    "obfuscating": 0.408280637209588,
                    "programming": 0.30269500994955456,
                    "sensitivity": 0.408280637209588,
                    "statement": 0.2835605287968644,
                    "update": 0.23837329510951089,
                    "use": 0.1269256029249062
                },
                "Max term": "obfuscating",
                "Max score": 0.408280637209588
            }
        ],
        "Best answer": "Why would anyone WANT case insensitivity? In what scenario is it useful to be able to refer to a single variable as VARIABLE in one place, Variable in another, and variable in a third? Case insensitivity is exasperating. I’d much rather get a compiler error when I accidentally type VAriable instead of Variable rather than let case-typos like that slip into my code. In conclusion, many programming languages have case sensitivity not just for historical/inertial reasons but because case insensitivity is a Bad Idea. ",
        "Best answer TF-IDF scores": [
            {
                "Scores": {
                    "able": 0.08851675079420174,
                    "accidentally": 0.1665136084857839,
                    "bad": 0.08940264819161306,
                    "case": 0.4335210470839737,
                    "code": 0.05096829801573529,
                    "compiler": 0.1150541408950922,
                    "conclusion": 0.1569360515188404,
                    "error": 0.10362019032753458,
                    "historical": 0.15444731371970485,
                    "idea": 0.08552617884473362,
                    "instead": 0.09032306964326867,
                    "languages": 0.080383297181512,
                    "let": 0.09497639770324749,
                    "like": 0.05085033940900959,
                    "place": 0.10053478985011977,
                    "programming": 0.06527607755664863,
                    "reasons": 0.10445889956441633,
                    "refer": 0.14486975675276137,
                    "scenario": 0.13187702317111477,
                    "sensitivity": 0.17609116545272738,
                    "single": 0.09367922370173185,
                    "slip": 0.1569360515188404,
                    "type": 0.09717065593890385,
                    "useful": 0.09441172152465438,
                    "variable": 0.7135155480435971,
                    "want": 0.06615921450507835
                },
                "Max term": "variable",
                "Max score": 0.7135155480435971
            }
        ]
    },
    {
        "ID": "10512",
        "Question": "I started, like many others, with console-based (as in terminal, not Playstation) programming. But sooner or later, one needs to touch upon GUI-based programming, whether you want to or not. This transition holds many changes in how you need to think about the frontend (and possibly also the backend). So, what are the major differences when moving from console-based programming to GUI-based programming? ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "based": 0.4752741403030771,
                    "changes": 0.127844855562555,
                    "console": 0.3797372858477872,
                    "differences": 0.1679629500913186,
                    "gui": 0.3459798178462723,
                    "holds": 0.2066382119303842,
                    "later": 0.14052854162109746,
                    "like": 0.0680337065013666,
                    "major": 0.14897655294870146,
                    "moving": 0.1679629500913186,
                    "need": 0.08626521342801116,
                    "needs": 0.1253353445556407,
                    "possibly": 0.15219321529655136,
                    "programming": 0.3493367834837013,
                    "sooner": 0.20087626103179024,
                    "started": 0.13057096144384836,
                    "terminal": 0.19834665257782863,
                    "think": 0.0809265264599782,
                    "touch": 0.17644095974525362,
                    "transition": 0.1938242030710116,
                    "want": 0.08851576281125009
                },
                "Max term": "based",
                "Max score": 0.4752741403030771
            }
        ],
        "Best answer": "The biggest difference is the design of the UI. A good GUI can make or break an application. Mac fans would draw attention to the beautifully designed GUI's of the average Mac OS X app and they've got a point, but this isn't a technology issue - it's a design/ethos/usability issue. As for technical issues, in no particular order:  The user can do anything they want in any order at any time, unlike console program in which you're either asking for input or telling them the output. You cannot assume that they'll follow the order you hope, unless you enforce the workflow Wizard-stylee. As already mentioned, events play a big part in this, and you can get multiple events happen while you're servicing the last one, so you can't really construct your state based on the 'current event'. Use closures or a similar mechanism to maintain context across different events. In a console app, your FSM is usually self-contained around the 'get input, process input, update output' loop. There isn't the same kind of structure in GUI programming - the 'main' is a re-entrant event-driven thing, often a ginormous switch() statement. You need to consider different screen sizes/resolutions and allow the GUI to resize from 800x600 up to the users' monitor maximum. You need to consider different input strategies - mouse, keyboard, touch, etc. Some technologies come for free (Mouse-wheel scrolling), others require some integration work (Ink). Accessibility - a GUI is much more suitable for less able users who have restricted vision, hearing, motor skills or cognitive skills. A 'ding' noise is nice and obvious compared to a cryptic error message on the console. Internationalization - i'm assuming your console app is US/ANSI only, but when you get into GUI, you can have language/resource packages that can target other languages and regions with no change to the coding, if you prepared for it from the start. For example, no hard-coded language strings in the code - everything as resource lookups. You have lots more options for implementation technology - web-based, various GUI kits, Flash/WPF, etc. Use of colour and animation. Console programs are generally monochromatic and don't animate much. Many modern GUI frameworks provide themed widgets and have move/size/show/hide animation effects, often for free. Graphics. Console apps sometimes use ASCII art for diagrams, but a GUI app gives you full graphical ability. Lovely art can make a big difference too.  ",
        "Best answer TF-IDF scores": [
            {
                "Scores": {
                    "ability": 0.04796548496044564,
                    "able": 0.03690218227641303,
                    "accessibility": 0.07121409392393813,
                    "allow": 0.04565721416172907,
                    "animation": 0.14682301884104423,
                    "ansi": 0.07121409392393813,
                    "app": 0.1593454099975571,
                    "application": 0.03417551776387385,
                    "apps": 0.047781413395288574,
                    "art": 0.11832582789216674,
                    "ascii": 0.07341150942052212,
                    "asking": 0.04366774845592311,
                    "assume": 0.04796548496044564,
                    "assuming": 0.05150443553290666,
                    "attention": 0.056186190360470116,
                    "average": 0.05150443553290666,
                    "based": 0.0740475168267271,
                    "big": 0.07638256076432026,
                    "biggest": 0.05536508646329866,
                    "break": 0.04724898416228221,
                    "change": 0.035655428072267195,
                    "closures": 0.06790066943747101,
                    "code": 0.02124842368048611,
                    "coded": 0.05756250195988266,
                    "coding": 0.03648811050341617,
                    "cognitive": 0.06941867473346276,
                    "colour": 0.07341150942052212,
                    "come": 0.03861338251240169,
                    "compared": 0.05205166197683155,
                    "consider": 0.07983615061753566,
                    "console": 0.3549774836765002,
                    "construct": 0.0643882979419104,
                    "contained": 0.06790066943747101,
                    "context": 0.05025624278635619,
                    "cryptic": 0.06941867473346276,
                    "current": 0.041615508198119475,
                    "design": 0.06763150038300207,
                    "designed": 0.05263109627289633,
                    "diagrams": 0.05756250195988266,
                    "difference": 0.09017236441155181,
                    "different": 0.09348308945118697,
                    "draw": 0.05708203876838392,
                    "driven": 0.05049354443795085,
                    "effects": 0.054978858842726554,
                    "enforce": 0.06259287875143503,
                    "error": 0.04319872924248558,
                    "event": 0.11512500391976532,
                    "events": 0.18541396447426287,
                    "example": 0.030667727585917782,
                    "fans": 0.07341150942052212,
                    "flash": 0.05975991745646666,
                    "follow": 0.04308488355818163,
                    "frameworks": 0.04674387129079556,
                    "free": 0.07919035230181354,
                    "generally": 0.041615508198119475,
                    "gives": 0.049360394378442383,
                    "good": 0.0250158485542527,
                    "got": 0.039516079002659195,
                    "graphical": 0.06941867473346276,
                    "graphics": 0.05916291394608337,
                    "gui": 0.4851316280454185,
                    "happen": 0.04724898416228221,
                    "hard": 0.03832998044989324,
                    "hearing": 0.05756250195988266,
                    "hide": 0.06107487345544328,
                    "hope": 0.05150443553290666,
                    "implementation": 0.04551132198202789,
                    "input": 0.19830733034305573,
                    "integration": 0.048539290481270925,
                    "issue": 0.08246606261548892,
                    "issues": 0.041912441508336715,
                    "keyboard": 0.0580676148313693,
                    "kind": 0.03861338251240169,
                    "language": 0.05973434838946494,
                    "languages": 0.03351138691780292,
                    "loop": 0.05536508646329866,
                    "lots": 0.04264222287764772,
                    "lovely": 0.07121409392393813,
                    "mac": 0.10995771768545311,
                    "main": 0.04264222287764772,
                    "maintain": 0.04707771824524099,
                    "make": 0.052656447244542916,
                    "maximum": 0.06790066943747101,
                    "mechanism": 0.06344972694198343,
                    "mentioned": 0.052934121474438926,
                    "message": 0.053246768114962234,
                    "modern": 0.05150443553290666,
                    "monitor": 0.05975991745646666,
                    "mouse": 0.13317142687698877,
                    "multiple": 0.04264222287764772,
                    "need": 0.0537603399907134,
                    "nice": 0.04522586599480382,
                    "noise": 0.06941867473346276,
                    "obvious": 0.047423281491387824,
                    "options": 0.05124181884934157,
                    "order": 0.1289170169877007,
                    "os": 0.05177424808234793,
                    "output": 0.10649353622992447,
                    "packages": 0.06344972694198343,
                    "particular": 0.0393597655299494,
                    "play": 0.05390351422726872,
                    "point": 0.03359739219822675,
                    "prepared": 0.05975991745646666,
                    "process": 0.03631584590050488,
                    "program": 0.03690218227641303,
                    "programming": 0.0272132640508367,
                    "programs": 0.043430446804328456,
                    "provide": 0.04253459839641466,
                    "really": 0.027652031345002187,
                    "regions": 0.06941867473346276,
                    "require": 0.04454645579421156,
                    "resource": 0.11073017292659731,
                    "restricted": 0.0654258400464034,
                    "screen": 0.052337117964055636,
                    "self": 0.049148611118980334,
                    "similar": 0.03861338251240169,
                    "size": 0.049360394378442383,
                    "sizes": 0.07341150942052212,
                    "skills": 0.08246606261548892,
                    "start": 0.033815750191501036,
                    "state": 0.04707771824524099,
                    "statement": 0.05098602415566719,
                    "strategies": 0.0566239309599557,
                    "strings": 0.056186190360470116,
                    "structure": 0.04815306286069882,
                    "suitable": 0.05860004406437566,
                    "switch": 0.052934121474438926,
                    "target": 0.05460720937731631,
                    "technical": 0.03983635249938928,
                    "technologies": 0.04690938009454016,
                    "technology": 0.09017236441155181,
                    "telling": 0.0580676148313693,
                    "thing": 0.03253396954792167,
                    "time": 0.023056175423623274,
                    "touch": 0.054978858842726554,
                    "ui": 0.048941286787379565,
                    "unless": 0.04403478008208654,
                    "unlike": 0.06344972694198343,
                    "update": 0.04286106615080449,
                    "usability": 0.05860004406437566,
                    "use": 0.06846614249338483,
                    "user": 0.03544477743020973,
                    "users": 0.07766283635940267,
                    "usually": 0.03832998044989324,
                    "various": 0.04403478008208654,
                    "vision": 0.06259287875143503,
                    "want": 0.027581439343688993,
                    "web": 0.03372782512512447,
                    "wheel": 0.06107487345544328,
                    "widgets": 0.07121409392393813,
                    "work": 0.024352110517851484,
                    "workflow": 0.0580676148313693,
                    "wpf": 0.05424907747341555
                },
                "Max term": "gui",
                "Max score": 0.4851316280454185
            }
        ]
    },
    {
        "ID": "10865",
        "Question": "Functional programming is a declarative paradigm. One of the strenghts with FP is that side-effects are avoided. It's said that for some problems FP isn't a good fit. For what common problems isn't functional programming a good fit?  ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "avoided": 0.24687454301831038,
                    "common": 0.1531562185522086,
                    "declarative": 0.2626228079707805,
                    "effects": 0.21684384746651605,
                    "fit": 0.37984402142214785,
                    "fp": 0.5356183346217703,
                    "functional": 0.3513941565446601,
                    "good": 0.19733159117257593,
                    "paradigm": 0.22902630717122752,
                    "problems": 0.2864689415105381,
                    "programming": 0.21466538240767202,
                    "said": 0.15943436870787311
                },
                "Max term": "fp",
                "Max score": 0.5356183346217703
            }
        ],
        "Best answer": "Real-time embedded programming is all about the side effects.  Interacting with digital and analog io, timers, serial and parallel ports, everything interesting is done by calling functions with side efffects.   ",
        "Best answer TF-IDF scores": [
            {
                "Scores": {
                    "calling": 0.24356065730685564,
                    "digital": 0.32378307368031534,
                    "effects": 0.24996770895585924,
                    "embedded": 0.23795673002693282,
                    "functions": 0.20020919537420495,
                    "interacting": 0.3156199937054773,
                    "interesting": 0.19290440972862774,
                    "io": 0.28100197593307036,
                    "parallel": 0.3087182079280135,
                    "ports": 0.3156199937054773,
                    "programming": 0.12372823683841204,
                    "real": 0.16917492839699383,
                    "serial": 0.3156199937054773,
                    "time": 0.10482755497734297,
                    "timers": 0.3337738761245147
                },
                "Max term": "timers",
                "Max score": 0.3337738761245147
            }
        ]
    },
    {
        "ID": "11050",
        "Question": "I haven't been programming for almost a decade. I used to be able to program in QBasic, Turbo Pascal, C, C++, Visual Basic and Assembly. I have no knowledge in any other programming language (other than HTML). I want a project (in some programming language) to help me acquaint myself with the new environment (unix, python, perl, java, flash?) in a way that would give me the feeling that I've gained a mini-super-power. By that I mean something that give me the feeling of hacking (not actually learn about hacking, but just like learning C for the first time feels like hacking). Something that would put my programming skills to use in a way that the programming languages I do (did) know don't. ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "able": 0.09797628966599396,
                    "actually": 0.09037462285447945,
                    "assembly": 0.14403276448085853,
                    "basic": 0.1159390504261298,
                    "decade": 0.18027810950282955,
                    "environment": 0.11075045344001146,
                    "feeling": 0.2827432121782174,
                    "feels": 0.150338064567685,
                    "flash": 0.15866419333344073,
                    "gained": 0.1767868658444262,
                    "hacking": 0.49227907865660464,
                    "help": 0.08897363649592285,
                    "html": 0.12283059681730527,
                    "java": 0.09110431178838767,
                    "know": 0.06759523472427027,
                    "knowledge": 0.102711115371624,
                    "language": 0.15859630677062758,
                    "languages": 0.08897363649592285,
                    "learn": 0.08797006166343226,
                    "learning": 0.09703116906035371,
                    "like": 0.1125691473952653,
                    "mean": 0.10849729536546496,
                    "mini": 0.1767868658444262,
                    "new": 0.07523418072031081,
                    "pascal": 0.16215543699184404,
                    "perl": 0.1515543531600674,
                    "power": 0.14222891206593494,
                    "program": 0.09797628966599396,
                    "programming": 0.36125975171746977,
                    "project": 0.07550442074641718,
                    "python": 0.11049029716658874,
                    "skills": 0.10947481070236727,
                    "super": 0.16215543699184404,
                    "time": 0.061214767868586345,
                    "unix": 0.15558469818087295,
                    "use": 0.06059315190809837,
                    "used": 0.07914159309858722,
                    "visual": 0.12499261222710878,
                    "want": 0.07322946568039626,
                    "way": 0.13893456375935548
                },
                "Max term": "hacking",
                "Max score": 0.49227907865660464
            }
        ],
        "Best answer": "In my mind there are two mainstream lanaguages (and their associated class hierarchies) in which to learn - C# and Java. Depending on the enviornment you are targeting, I'd start with one of those. I'm not saying all these newer dynamic languages are not good to learn, but the classic C#/Java would be an easier transition for you coming from C/C++/QuickBasic ",
        "Best answer TF-IDF scores": [
            {
                "Scores": {
                    "associated": 0.2427226536419874,
                    "class": 0.16703607667585585,
                    "classic": 0.25681190485568234,
                    "coming": 0.21080922517865872,
                    "depending": 0.22015301408306462,
                    "dynamic": 0.22641442270771753,
                    "easier": 0.16939102734755265,
                    "good": 0.10637169370967431,
                    "hierarchies": 0.3121583734371119,
                    "java": 0.29181715806142816,
                    "languages": 0.14249618505948805,
                    "learn": 0.2817778092516527,
                    "mainstream": 0.24917747343531582,
                    "mind": 0.17737295821929525,
                    "newer": 0.26615569376008824,
                    "saying": 0.20639741757154645,
                    "start": 0.14379039008539693,
                    "targeting": 0.29518015311233947,
                    "transition": 0.25681190485568234
                },
                "Max term": "hierarchies",
                "Max score": 0.3121583734371119
            }
        ]
    },
    {
        "ID": "12444",
        "Question": "In maths, a variable means you can put any number there, and an equation will still be true: root(square(x)) = abs(x)  In programming languages, this is not so: a var can change. In Python: y = (x**2)**.5 x *= 2 assert y == abs(x)  will raise an exception, since x in the last line is not the same. Are there programming languages that use immutable variables? ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "assert": 0.2741830475253004,
                    "change": 0.15407653272664765,
                    "exception": 0.20727154357195474,
                    "immutable": 0.25823840507708623,
                    "languages": 0.28962312793951533,
                    "line": 0.18068271994742877,
                    "maths": 0.2934167469687752,
                    "means": 0.16215826747087725,
                    "number": 0.1665491522208389,
                    "programming": 0.23519141941750538,
                    "python": 0.17983161491786614,
                    "raise": 0.2827223547743288,
                    "root": 0.24666658317983936,
                    "square": 0.3172305437146433,
                    "true": 0.19666645641119176,
                    "use": 0.09862010185535036,
                    "var": 0.25823840507708623,
                    "variable": 0.2142346027343117,
                    "variables": 0.21148824128815039
                },
                "Max term": "square",
                "Max score": 0.3172305437146433
            }
        ],
        "Best answer": "Purely functional programming languages, such as Haskell, enforce immutable variables. I like to call them identifiers though, instead of variables. ",
        "Best answer TF-IDF scores": [
            {
                "Scores": {
                    "enforce": 0.3384006419916065,
                    "functional": 0.2408348927211837,
                    "haskell": 0.27703254333924116,
                    "identifiers": 0.38501017341623267,
                    "immutable": 0.32308458783212773,
                    "instead": 0.20357832041292234,
                    "languages": 0.18117516038921028,
                    "like": 0.11461110356632674,
                    "programming": 0.14712513961948295,
                    "purely": 0.3301937344814053,
                    "variables": 0.5291900036907912
                },
                "Max term": "variables",
                "Max score": 0.5291900036907912
            }
        ]
    },
    {
        "ID": "12450",
        "Question": "Say, for example, I wanted to pay somebody to create a programming language or scripting language for me. What type of document would they need, in order to fully understand what it is exactly that I want. I mean, are there standard documents that describe the new programming/scripting language in question? ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "create": 0.15787639894473365,
                    "document": 0.21235387912048648,
                    "documents": 0.23699432508774734,
                    "exactly": 0.19496096023722614,
                    "example": 0.12835699108102266,
                    "fully": 0.2202826778070987,
                    "language": 0.3750190425086134,
                    "mean": 0.17103614685293334,
                    "need": 0.11250451246132386,
                    "new": 0.1185998631458518,
                    "order": 0.17985682564104397,
                    "pay": 0.19496096023722614,
                    "programming": 0.22779729481245986,
                    "question": 0.12156474107385706,
                    "say": 0.13380312277166426,
                    "scripting": 0.4818452576876764,
                    "somebody": 0.22855351989699643,
                    "standard": 0.17336975082284092,
                    "type": 0.1695507250632895,
                    "understand": 0.14643353107974666,
                    "want": 0.11543961168695463,
                    "wanted": 0.203156795948734
                },
                "Max term": "scripting",
                "Max score": 0.4818452576876764
            }
        ],
        "Best answer": "What you need to write is called a language specification. It should contain a description of the language's grammar (preferably in Extended Backus-Naur-Form) and its semantics. For the latter part you could either write a description in your own words (but take care to be precise) or a formal semantics. ",
        "Best answer TF-IDF scores": [
            {
                "Scores": {
                    "called": 0.16843477593458014,
                    "care": 0.1813350369503895,
                    "contain": 0.2210231974990508,
                    "description": 0.41367024116092516,
                    "extended": 0.22562780486418732,
                    "form": 0.1722533400053121,
                    "formal": 0.20683512058046258,
                    "grammar": 0.23383699820668516,
                    "language": 0.22315798531481637,
                    "need": 0.1004200220277536,
                    "precise": 0.24875359089553134,
                    "preferably": 0.2281659728639113,
                    "semantics": 0.4888409782958241,
                    "specification": 0.20539223587503558,
                    "words": 0.1798921522449625,
                    "write": 0.23108222263967573
                },
                "Max term": "semantics",
                "Max score": 0.4888409782958241
            }
        ]
    },
    {
        "ID": "12556",
        "Question": "I'm a student at the University of South Florida who's frustrated with the educational environment in the Computer Science program. Right now, I'm taking \"Program Design.\" I should be learning how to organize my source code into functions and modules in order to make my programs readable and maintainable; instead, I'm learning about arrays and recursion in C. Next semester, I have to take \"Object-Oriented Design,\" which is taught through C++ (shudder.) Two years ago, I fell in love with programming, and I've been learning as much as I could since then. The prospect of taking another C++ class bores me almost to tears. For that reason, I thought I would start a programming club in order to meet similarly ambitious students, learn new languages, discuss software development topics, and work with other students developers.  However, I'm beginning to realize that there may not be any other students who share my software development experience. It's not because of a lack of motivation but a lack of opportunity: I know of only one other programming class (\"Programming Languages\") and no classes on real-world software development. Everybody else only has experience writing trivial scripts in C and C++. I've realized that if I want to work with other student software developers, I'm going to have to train them myself. Now, I'm planning to make the club a software development bootcamp, teaching members how to develop software with modern tools and languages. Obviously, starting an unofficial software development course is a monumental task with many possible approaches. My question to you, dear reader, is  What's my plan of attack? Should I  lecture the club myself, trying to balance club work with homework? ask the CS faculty to teach on topics within their expertise which may be less than relevant to members? try to find a sympathetic, experienced developer inside or outside the school who can share my workload? show video lectures (from MIT OpenCourseWare, Google Tech Talks, etc)? hold hands-on programming workshops? assign homework? do something else?  ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "ago": 0.06619453107491559,
                    "approaches": 0.08096607580625308,
                    "arrays": 0.09344092455913763,
                    "ask": 0.055358245398921604,
                    "assign": 0.09217906432757389,
                    "attack": 0.09344092455913763,
                    "balance": 0.08477094642167218,
                    "beginning": 0.08096607580625308,
                    "class": 0.1157009195588225,
                    "classes": 0.06579718446221064,
                    "code": 0.03129205514066836,
                    "computer": 0.059658054949301154,
                    "course": 0.05604197948979608,
                    "cs": 0.08096607580625308,
                    "design": 0.09959932421597015,
                    "develop": 0.06503373218706493,
                    "developer": 0.048855581935242184,
                    "developers": 0.09895618282640725,
                    "development": 0.21927310507827355,
                    "discuss": 0.08274408461266605,
                    "educational": 0.09635109997532607,
                    "environment": 0.06143048489658232,
                    "everybody": 0.08477094642167218,
                    "experience": 0.09758955158217963,
                    "experienced": 0.07177565912374462,
                    "expertise": 0.08712783561369122,
                    "fell": 0.10811140794676204,
                    "frustrated": 0.09999572316872349,
                    "functions": 0.06484898772520772,
                    "going": 0.04774173111084145,
                    "google": 0.06279820139474436,
                    "hands": 0.08338873492566747,
                    "hold": 0.08041875635613793,
                    "inside": 0.07471875678820203,
                    "instead": 0.05545397013019754,
                    "know": 0.03749337286514493,
                    "lack": 0.14073313344533553,
                    "languages": 0.14805430036231815,
                    "learn": 0.04879477579108982,
                    "learning": 0.16146223099723236,
                    "lecture": 0.1048753256886125,
                    "love": 0.07063764459900049,
                    "maintainable": 0.08800702867982173,
                    "make": 0.07754591472124842,
                    "meet": 0.07750858093994949,
                    "members": 0.14733988979604287,
                    "mit": 0.09217906432757389,
                    "modern": 0.07584937409568081,
                    "modules": 0.08477094642167218,
                    "motivation": 0.08800702867982173,
                    "new": 0.041730503658381414,
                    "object": 0.06086169653931276,
                    "obviously": 0.06933025138141577,
                    "opportunity": 0.08096607580625308,
                    "order": 0.1265687113174543,
                    "organize": 0.09101826543972323,
                    "oriented": 0.06836307678678513,
                    "outside": 0.07010046303404775,
                    "plan": 0.07010046303404775,
                    "planning": 0.06933025138141577,
                    "possible": 0.052352972959126484,
                    "program": 0.10868995648510087,
                    "programming": 0.200381678199121,
                    "programs": 0.06395900028259502,
                    "question": 0.0427737245014706,
                    "readable": 0.07989134390178317,
                    "reader": 0.09999572316872349,
                    "real": 0.05479679809173756,
                    "realize": 0.07624672070838574,
                    "realized": 0.09344092455913763,
                    "reason": 0.05729475025435321,
                    "recursion": 0.09805921831329188,
                    "relevant": 0.06933025138141577,
                    "right": 0.05137829526311217,
                    "school": 0.07436065849210319,
                    "science": 0.0730106384502362,
                    "scripts": 0.08551481429933207,
                    "semester": 0.09635109997532607,
                    "share": 0.13916494136028784,
                    "similarly": 0.08551481429933207,
                    "software": 0.2958344131347125,
                    "source": 0.04910138856787679,
                    "south": 0.10811140794676204,
                    "start": 0.049799662107985074,
                    "starting": 0.06702345634675089,
                    "student": 0.16083751271227587,
                    "students": 0.2396740317053495,
                    "taking": 0.14296534906010497,
                    "talks": 0.09217906432757389,
                    "task": 0.06157623732076133,
                    "taught": 0.0784152664202553,
                    "teach": 0.07795483904635156,
                    "teaching": 0.08274408461266605,
                    "tech": 0.07508592182053508,
                    "thought": 0.062174352774242214,
                    "tools": 0.056654841561186185,
                    "topics": 0.16083751271227587,
                    "train": 0.09805921831329188,
                    "trivial": 0.07546262466586191,
                    "try": 0.05102019696701333,
                    "trying": 0.054981542553594775,
                    "university": 0.0730106384502362,
                    "video": 0.08096607580625308,
                    "want": 0.040618538757505165,
                    "work": 0.10758834583330727,
                    "workshops": 0.10811140794676204,
                    "world": 0.05697126671328075,
                    "writing": 0.05159747692839062,
                    "years": 0.05266654721103016
                },
                "Max term": "software",
                "Max score": 0.2958344131347125
            }
        ],
        "Best answer": "Frankly your whole attitude concerns me. You haven't even gotten the group together and already you assume you will be only one who has any knowledge to impart and the one who should decide what the group will do.  The best bet is to get the intial group together and, as a group, brainstorm what they want to do. What you personally want to do is irrelevant in terms of what the group wants to do. Deciding what to do without the input of the other group members before the first meeting,  you will come across as an arrogant idiot that I wouldn't want to work with voluntarily. Thus you would kill the group before it got started. ",
        "Best answer TF-IDF scores": [
            {
                "Scores": {
                    "assume": 0.11083317819551437,
                    "attitude": 0.13540630583445268,
                    "best": 0.0716937668180966,
                    "bet": 0.14463249334701545,
                    "brainstorm": 0.164553415198715,
                    "come": 0.08922340529357203,
                    "concerns": 0.12455409973738357,
                    "decide": 0.10654186567302265,
                    "deciding": 0.14661240052960453,
                    "frankly": 0.15689713137611155,
                    "got": 0.09130925350387742,
                    "gotten": 0.14281115529537652,
                    "group": 0.7788662828637096,
                    "idiot": 0.164553415198715,
                    "input": 0.11455649671588573,
                    "irrelevant": 0.13300887174101128,
                    "kill": 0.15117857756330452,
                    "knowledge": 0.08939010624579302,
                    "meeting": 0.1230365656406367,
                    "members": 0.11559097386228065,
                    "personally": 0.10263148556193187,
                    "started": 0.09401212276323752,
                    "terms": 0.10062664185278489,
                    "want": 0.1911961434887232,
                    "wants": 0.11612640040584504,
                    "work": 0.05627008267898512
                },
                "Max term": "group",
                "Max score": 0.7788662828637096
            }
        ]
    },
    {
        "ID": "13053",
        "Question": "Which was the first language with generic programming support, and what was the first major staticly typed language (widely used) with generics support.  Generics implement the concept of parameterized types to allow for multiple types. The term generic means \"pertaining to or appropriate to large groups of classes.\"  I have seen the following mentions of \"first\":   First-order parametric polymorphism is now a standard element of statically typed programming languages. Starting with System F [20,42] and functional programming lan- guages, the constructs have found their way into mainstream languages such as Java and C#. In these languages, first-order parametric polymorphism is usually called generics.  From \"Generics of a Higher Kind\", Adriaan Moors, Frank Piessens, and Martin Odersky  Generic programming is a style of computer programming in which algorithms are written in terms of to-be-specified-later types that are then instantiated when needed for specific types provided as parameters. This approach, pioneered by Ada in 1983  From Wikipedia Generic Programming ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "1983": 0.12394031042362112,
                    "20": 0.08607946779736289,
                    "42": 0.11719922616461802,
                    "ada": 0.12023042404577527,
                    "algorithms": 0.08297737190067075,
                    "allow": 0.07708286263217122,
                    "approach": 0.0675326279922769,
                    "appropriate": 0.08333492459407602,
                    "called": 0.07611879203287011,
                    "classes": 0.07543073966128001,
                    "computer": 0.06839276252259079,
                    "concept": 0.08036407363742663,
                    "constructs": 0.10196538013005482,
                    "element": 0.10089239111018641,
                    "following": 0.06914517867645976,
                    "frank": 0.12023042404577527,
                    "functional": 0.07520757443877428,
                    "generic": 0.37943553700317345,
                    "generics": 0.4227010660316026,
                    "groups": 0.09415130685118331,
                    "higher": 0.08297737190067075,
                    "implement": 0.07392805407417402,
                    "java": 0.05793198618834869,
                    "kind": 0.06519079437093327,
                    "language": 0.10084922297311294,
                    "languages": 0.16973135670838643,
                    "large": 0.06606274636508544,
                    "later": 0.07392805407417402,
                    "mainstream": 0.09893418224889756,
                    "major": 0.07837231166798216,
                    "martin": 0.10196538013005482,
                    "means": 0.06335438502471473,
                    "mentions": 0.11719922616461802,
                    "multiple": 0.07199266684920462,
                    "needed": 0.07163122740897906,
                    "order": 0.1451000007171103,
                    "parameters": 0.09282055205636598,
                    "polymorphism": 0.2142437586574144,
                    "programming": 0.2756641638939902,
                    "provided": 0.09100505273610605,
                    "seen": 0.06945594584506604,
                    "specific": 0.06313846563341896,
                    "specified": 0.11463638487317711,
                    "standard": 0.0699332674171771,
                    "starting": 0.07683655354272091,
                    "statically": 0.10567526650790066,
                    "style": 0.07659384033507292,
                    "support": 0.13212549273017088,
                    "term": 0.07891746081662011,
                    "terms": 0.07352253252023153,
                    "typed": 0.19786836449779513,
                    "types": 0.3063753613402917,
                    "used": 0.05032505694089068,
                    "usually": 0.0647123279849503,
                    "way": 0.04417329471456006,
                    "widely": 0.09637134095745666,
                    "wikipedia": 0.08836051319943827,
                    "written": 0.06671481266321419
                },
                "Max term": "generics",
                "Max score": 0.4227010660316026
            }
        ],
        "Best answer": "Before generics there were templates, and before that macro substitution. ",
        "Best answer TF-IDF scores": [
            {
                "Scores": {
                    "generics": 0.4838310258409562,
                    "macro": 0.514694877147827,
                    "substitution": 0.5504713763746367,
                    "templates": 0.4449471717672607
                },
                "Max term": "substitution",
                "Max score": 0.5504713763746367
            }
        ]
    },
    {
        "ID": "13778",
        "Question": "I'm pretty sure about who, but when? The one with proficient knowledge of programming and software development or the one who's just a beginner in programming? I'm pursuing bachelors right now, when is it preferable for folks like me to read this Must read for programmers book? ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "beginner": 0.28784967010996887,
                    "book": 0.20773787908325905,
                    "development": 0.15138181678144547,
                    "folks": 0.29789530798010444,
                    "knowledge": 0.19665918116857256,
                    "like": 0.10776709157280373,
                    "preferable": 0.33849072860840684,
                    "pretty": 0.19011278243489166,
                    "proficient": 0.33849072860840684,
                    "programmers": 0.17396578344451383,
                    "programming": 0.2766790982840287,
                    "pursuing": 0.36201925750585445,
                    "read": 0.35272294170884266,
                    "right": 0.1773527965795679,
                    "software": 0.14588445019224194,
                    "sure": 0.17810939002232484
                },
                "Max term": "pursuing",
                "Max score": 0.36201925750585445
            }
        ],
        "Best answer": "Like Robert Harvey said, it's probably best to read it as an intermediate programmer. I read it after having programmed, more or less, for 10 years. After having read it, I wished I had read it at least 5 years sooner. Code Complete is a bible of best (or at least very good) practices which you only really appreciate after first having tried out a few of your own. It's like doing a math exercise - you won't appreciate the solution unless you've first made your own stab at it. Maybe the book's solution solved the problem differently compared to your solution, and while the final answer may be the same it is the approach which is interesting. Some approaches are better than others, are more intuitive and yield a better understanding of the problem. The same goes for programming. The following quote of Robert Harvey really says it best:  If you're a beginning programmer you won't understand a lot of the material, and if you are experienced, the book will only confirm what you already know.  ",
        "Best answer TF-IDF scores": [
            {
                "Scores": {
                    "10": 0.08959511741895947,
                    "answer": 0.07532849182793884,
                    "appreciate": 0.24021546545643374,
                    "approach": 0.08550797215667916,
                    "approaches": 0.11752685208268518,
                    "beginning": 0.11752685208268518,
                    "best": 0.19897709641793257,
                    "better": 0.12681669007200577,
                    "book": 0.17471144324698315,
                    "code": 0.045422193174842376,
                    "compared": 0.1112694607814386,
                    "complete": 0.09413198444160907,
                    "confirm": 0.1483944645070612,
                    "differently": 0.1145144605438583,
                    "exercise": 0.12104347922731203,
                    "experienced": 0.10418644091334461,
                    "final": 0.11315587110401266,
                    "following": 0.08754973986369201,
                    "goes": 0.09522578007504054,
                    "good": 0.053475717660288684,
                    "harvey": 0.31385968317433616,
                    "interesting": 0.09069750698190215,
                    "intermediate": 0.12910578403824344,
                    "intuitive": 0.1321181755770703,
                    "know": 0.05442375764075916,
                    "like": 0.09063414041917807,
                    "lot": 0.06521750451942288,
                    "material": 0.13764116111835034,
                    "math": 0.12010773272821687,
                    "maybe": 0.08622772876501397,
                    "practices": 0.09637953894658235,
                    "probably": 0.07345143258127718,
                    "problem": 0.13544450376216297,
                    "programmed": 0.1321181755770703,
                    "programmer": 0.14327281054125768,
                    "programming": 0.0581730746347213,
                    "quote": 0.11752685208268518,
                    "read": 0.296646593698855,
                    "really": 0.11822203174374496,
                    "robert": 0.2846770361855659,
                    "said": 0.08641157997770675,
                    "says": 0.10063679285207178,
                    "solution": 0.2603525123013028,
                    "solved": 0.11596681775587121,
                    "sooner": 0.13380314101267607,
                    "stab": 0.15692984158716808,
                    "tried": 0.09957518152332985,
                    "understand": 0.07479007807832797,
                    "understanding": 0.09522578007504054,
                    "unless": 0.09413198444160907,
                    "years": 0.15289696189767565,
                    "yield": 0.15692984158716808
                },
                "Max term": "harvey",
                "Max score": 0.31385968317433616
            }
        ]
    },
    {
        "ID": "15094",
        "Question": "I've seen a lot of tests measuring execution speed of programming languages, but I've never found tests measuring development speed. I've heard development speed is increased when working with dynamic languages, but is there any proof of that ? I'm not trying to say dynamic languages aren't efficient, but I'd kind of like to see the results of a scientific study, if such a thing exists. Even better would be informations on maintenance facility. Are some languages easier to debug than others ? EDIT : I'm mostly interested in the differences between two languages that are close in syntax. For example, I guess programming in C will usually be slower than programming in Java; but is programming in Java faster than programming in C# ?  ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "better": 0.0695846678098607,
                    "close": 0.11630203111958581,
                    "debug": 0.12346701225818109,
                    "development": 0.13971611826341496,
                    "differences": 0.12277737008783614,
                    "dynamic": 0.24982262719631482,
                    "easier": 0.0934518900548953,
                    "edit": 0.0927005621414179,
                    "efficient": 0.1281027656086698,
                    "example": 0.07194326103617558,
                    "execution": 0.1387899690239305,
                    "exists": 0.13283378217488379,
                    "faster": 0.11166627776909711,
                    "guess": 0.10889871466206302,
                    "heard": 0.1074544133220867,
                    "increased": 0.16284890437816957,
                    "interested": 0.10003416663509464,
                    "java": 0.16099356263620063,
                    "kind": 0.09058293118708348,
                    "languages": 0.3930709326208502,
                    "like": 0.04973120296484509,
                    "lot": 0.07157004941219333,
                    "maintenance": 0.11735227092895176,
                    "measuring": 0.31857564745776423,
                    "programming": 0.3191972658832927,
                    "proof": 0.14327522479278773,
                    "results": 0.11630203111958581,
                    "say": 0.07499578252766095,
                    "scientific": 0.14327522479278773,
                    "seen": 0.09650938025419468,
                    "slower": 0.1401904764226835,
                    "speed": 0.35882353866142946,
                    "study": 0.12491131359815741,
                    "syntax": 0.11004446833342657,
                    "tests": 0.18767384117150313,
                    "thing": 0.07632126825085954,
                    "trying": 0.08758264834828772,
                    "usually": 0.08991809977744887,
                    "working": 0.07310049614873919
                },
                "Max term": "languages",
                "Max score": 0.3930709326208502
            }
        ],
        "Best answer": "Absolutely the programming language makes a difference. However, I think that difference is far more about how familiar the programmer is with each language than any particular aspect of the language, especially given your constraint of languages with similar syntax. ",
        "Best answer TF-IDF scores": [
            {
                "Scores": {
                    "absolutely": 0.24560155093025463,
                    "aspect": 0.2612356759871802,
                    "constraint": 0.3463862609773433,
                    "difference": 0.42547099764811974,
                    "especially": 0.20329253325760874,
                    "familiar": 0.2237629125016436,
                    "far": 0.18720286700920813,
                    "given": 0.19635940463838045,
                    "language": 0.4227775267230894,
                    "languages": 0.15812076479901171,
                    "makes": 0.17135337735187242,
                    "particular": 0.1857158655704307,
                    "programmer": 0.15812076479901171,
                    "programming": 0.1284035821898434,
                    "similar": 0.18219411775804933,
                    "syntax": 0.2213381103858689,
                    "think": 0.1189826709688837
                },
                "Max term": "difference",
                "Max score": 0.42547099764811974
            }
        ]
    },
    {
        "ID": "15269",
        "Question": "I feel that side effects are a natural phenomenon. But it is something like taboo in functional languages. What are the reasons? My question is specific to functional programming style. Not all programming languages/paradigms. ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "effects": 0.3044594466506902,
                    "feel": 0.20709963346749954,
                    "functional": 0.4933747104556118,
                    "languages": 0.3711556962896565,
                    "like": 0.11739623647994098,
                    "natural": 0.3004180962743208,
                    "paradigms": 0.31356945287953586,
                    "programming": 0.3014007743659442,
                    "question": 0.1608434688630549,
                    "reasons": 0.24116027185308947,
                    "specific": 0.20709963346749954,
                    "style": 0.25123442738313534
                },
                "Max term": "functional",
                "Max score": 0.4933747104556118
            }
        ],
        "Best answer": "Writing your functions/methods without side effects - so they're pure functions - makes it easier to reason about the correctness of your program. It also makes it easy to compose those functions to create new behaviour. It also makes certain optimisations possible, where the compiler can for instance memoise the results of functions, or use Common Subexpression Elimination. Edit: at Benjol's request: Because a lot of your state's stored in the stack (data flow, not control flow, as Jonas has called it here), you can parallelise or otherwise reorder the execution of those parts of your computation that are independent of each other. You can easily find those independent parts because one part doesn't provide inputs to the other. In environments with debuggers that let you roll back the stack and resume computing (like Smalltalk), having pure functions means that you can very easily see how a value changes, because the previous states are available for inspection. In a mutation-heavy calculation, unless you explicitly add do/undo actions to your structure or algorithm, you cannot see the history of the computation. (This ties back to the first paragraph: writing pure functions makes it easier to inspect the correctness of your program.) ",
        "Best answer TF-IDF scores": [
            {
                "Scores": {
                    "actions": 0.1084046925105903,
                    "add": 0.06485546704292287,
                    "algorithm": 0.08220587984871577,
                    "available": 0.06667768328962895,
                    "behaviour": 0.09632002366813872,
                    "calculation": 0.11054550310452782,
                    "called": 0.07340243824237531,
                    "certain": 0.06873389070880541,
                    "changes": 0.06485546704292287,
                    "common": 0.0632193864140093,
                    "compiler": 0.07809007938409238,
                    "compose": 0.11951741138616762,
                    "computation": 0.20659831618024513,
                    "computing": 0.09079144981174407,
                    "control": 0.06370524979023433,
                    "correctness": 0.20124180566719943,
                    "create": 0.061411019227322554,
                    "data": 0.05656012600277776,
                    "debuggers": 0.11593991496953418,
                    "easier": 0.12971093408584575,
                    "easily": 0.14725970012232487,
                    "easy": 0.06195453786778412,
                    "edit": 0.06433404663395803,
                    "effects": 0.0895081839580224,
                    "elimination": 0.11301688756289871,
                    "environments": 0.08775747203557219,
                    "execution": 0.09632002366813872,
                    "explicitly": 0.09453682487659348,
                    "flow": 0.1858645208113632,
                    "functions": 0.43014423497732185,
                    "heavy": 0.09147377680340402,
                    "history": 0.08474256893673975,
                    "independent": 0.19458394727002595,
                    "inputs": 0.0929322604056816,
                    "inspect": 0.11951741138616762,
                    "inspection": 0.11951741138616762,
                    "instance": 0.07870678096929248,
                    "let": 0.06446282053441586,
                    "like": 0.034513377878144534,
                    "lot": 0.049669503508021545,
                    "makes": 0.2364956627966547,
                    "means": 0.061093538270446265,
                    "methods": 0.0689035458836355,
                    "mutation": 0.11593991496953418,
                    "new": 0.0461331682549799,
                    "paragraph": 0.11054550310452782,
                    "parts": 0.15679093016489015,
                    "possible": 0.05787633262093901,
                    "previous": 0.07902426192616878,
                    "program": 0.12015699813262418,
                    "provide": 0.06924833905224939,
                    "pure": 0.2949800168120638,
                    "reason": 0.06333947884379906,
                    "request": 0.08429092598847517,
                    "results": 0.08071342957184173,
                    "resume": 0.08775747203557219,
                    "roll": 0.10329915809012256,
                    "smalltalk": 0.10329915809012256,
                    "stack": 0.14591413785068846,
                    "state": 0.07664475315999487,
                    "states": 0.09832667227068795,
                    "stored": 0.08775747203557219,
                    "structure": 0.07839546508244508,
                    "ties": 0.11593991496953418,
                    "undo": 0.1084046925105903,
                    "unless": 0.07169070582955364,
                    "use": 0.03715537333313716,
                    "value": 0.06823543819615607,
                    "writing": 0.11408226002524187
                },
                "Max term": "functions",
                "Max score": 0.43014423497732185
            }
        ]
    },
    {
        "ID": "15286",
        "Question": "I come from a scientific and embedded programming background, and I have had minimal experience with web programming.  What would be the best approach to take to get up to speed with web programming?  Tools and framework suggestions? One approach would be to dive into learning a framework, such as Rails. I started doing this with rails tutorial, but I find that the framework abstracts so many important concepts that I should be learning. To sum up, experienced programmer wants to learn web-app programming. ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "app": 0.12131481891795085,
                    "approach": 0.24362929464543803,
                    "background": 0.1418547921722955,
                    "best": 0.09448758290839598,
                    "come": 0.11759047235495258,
                    "concepts": 0.14607070570472952,
                    "dive": 0.1932253243937972,
                    "embedded": 0.15938376859663997,
                    "experience": 0.10090210927856158,
                    "experienced": 0.14842399177018759,
                    "framework": 0.3581846002528011,
                    "important": 0.11147322250776631,
                    "learn": 0.10090210927856158,
                    "learning": 0.2225904913290338,
                    "minimal": 0.17845644212438028,
                    "programmer": 0.10205321472855666,
                    "programming": 0.3314934217980171,
                    "rails": 0.3325938898309185,
                    "scientific": 0.1859931130441085,
                    "speed": 0.1552692427823521,
                    "started": 0.12390168125108902,
                    "suggestions": 0.15604822190559778,
                    "sum": 0.19608358233544798,
                    "tools": 0.11715584141305307,
                    "tutorial": 0.1859931130441085,
                    "wants": 0.1530468180593804,
                    "web": 0.30813702115023084
                },
                "Max term": "framework",
                "Max score": 0.3581846002528011
            }
        ],
        "Best answer": "Few years back I asked this question to myself! This is what I find easy and organized way to start web programming, you can skip steps which you have already know    To learn web programming, first you have to know  What is a website What are the main role players [Webserver, Mark-up languages, Client side scripting, Server side scripting, Protocols (http), Browsers      Trace complete server round trip i.e. from typing google.com in browser and to loading the complete page.   Why http is stateless? Role of session to overcome this?   Start learning html & little JavaScript    Basic tags Marquee :-) Alert, change color page background color via javascript etc Have some fun playing around with html, javscript and css    Server side scripting   Start with php  Use all necessary input – type elements and create forms Validate form with plain javascript Retrieve submitted form data and display it via php   I think you can complete 1 to 5 quickly.  Its interesting part for all novice web programmers, because of the visual excitement they get while using html and css first time/ Then move to serious stuff!!!   At this time, you know fundamental things of web programming and working of website. Now, it’s your responsibility to choose most appropriate language, platform and framework. No one here can’t help you with this; You have to consider your personal interests and future plans to decide.   My recommendation is to go with php, since you learned it in initial stages.   Next, is databases a.  Learn how to connect database  b.  Basic sql queries. Select, insert, update and delete c.  Manipulate user inputs using database Now, start creating a personal website; or any simple website Download any open source website and learn from it.  Here are few references, which may help you  1. W3 Schools – for learning basics of html, css, JavaScript, asp, database queries  2. Php.net– for everything about php  3. For exploring open source projects   - http://bitbucket.org/   - http://github.com/   - http://www.codeplex.com/   - http://sourceforge.net/  Always remember that there are several peoples here for help you; if anything happen, post it in stackoverflow.   Find someone with some amount of web programming experience to guide you; it’s always easy to learn from experienced programmers.   Do not forget to find some books too… for a starter you can checkout dummies  All the best!!! ",
        "Best answer TF-IDF scores": [
            {
                "Scores": {
                    "alert": 0.07922439328561995,
                    "appropriate": 0.05326885835530625,
                    "asked": 0.044497952902325624,
                    "asp": 0.05326885835530625,
                    "background": 0.05026949153013314,
                    "basic": 0.0942509125579282,
                    "basics": 0.06266553556617473,
                    "best": 0.03348383707014459,
                    "bitbucket": 0.07685298162432233,
                    "books": 0.04625489910473165,
                    "browser": 0.05558266937734673,
                    "browsers": 0.0638475628601843,
                    "change": 0.03847870284458101,
                    "checkout": 0.07922439328561995,
                    "choose": 0.04975928354268377,
                    "client": 0.045231160288454315,
                    "codeplex": 0.0675491197800731,
                    "color": 0.1498307944316143,
                    "com": 0.14379894208411992,
                    "complete": 0.1425646508159291,
                    "connect": 0.0675491197800731,
                    "consider": 0.043078875811573325,
                    "create": 0.0407074641502757,
                    "creating": 0.05117836063343607,
                    "css": 0.17799661536995165,
                    "data": 0.03749195715300514,
                    "database": 0.13536980421948447,
                    "databases": 0.06110753764852117,
                    "decide": 0.04975928354268377,
                    "delete": 0.06266553556617473,
                    "display": 0.06212042675285424,
                    "download": 0.06212042675285424,
                    "easy": 0.08213549167337854,
                    "elements": 0.05854463806917011,
                    "experience": 0.03575697126671938,
                    "experienced": 0.052597437724188366,
                    "exploring": 0.07685298162432233,
                    "forget": 0.05398557653420704,
                    "form": 0.09951856708536753,
                    "forms": 0.0606351357910403,
                    "framework": 0.042310303028660186,
                    "fun": 0.0550232090535044,
                    "fundamental": 0.0675491197800731,
                    "future": 0.04686936456362325,
                    "github": 0.06669848255905127,
                    "google": 0.04601872734260142,
                    "guide": 0.0606351357910403,
                    "happen": 0.05099026206062786,
                    "help": 0.10849467546762162,
                    "html": 0.19970658371817793,
                    "http": 0.2946900479322972,
                    "initial": 0.059332205123317217,
                    "input": 0.0535024346132286,
                    "inputs": 0.06160191943509134,
                    "insert": 0.0675491197800731,
                    "interesting": 0.045787690158141485,
                    "interests": 0.06948670418858828,
                    "javascript": 0.20038674491181716,
                    "know": 0.08242579873537566,
                    "language": 0.03223212236625301,
                    "languages": 0.03616489182254054,
                    "learn": 0.14302788506687752,
                    "learned": 0.04821639194161268,
                    "learning": 0.07888003392202897,
                    "little": 0.040155272836242324,
                    "loading": 0.06591091550490416,
                    "main": 0.04601872734260142,
                    "manipulate": 0.07185811584988591,
                    "mark": 0.06324012371026028,
                    "necessary": 0.04850756883879218,
                    "net": 0.07900617425577841,
                    "open": 0.08058130836407262,
                    "org": 0.05712556097841781,
                    "organized": 0.06847381508425522,
                    "overcome": 0.07060640114599433,
                    "page": 0.09886452828594862,
                    "peoples": 0.07491539721580714,
                    "personal": 0.09614748317201949,
                    "php": 0.22099286384489686,
                    "plain": 0.06324012371026028,
                    "plans": 0.0675491197800731,
                    "platform": 0.04738787188138614,
                    "players": 0.07185811584988591,
                    "playing": 0.06517770811877546,
                    "post": 0.048656204715210254,
                    "programmers": 0.07386230915136245,
                    "programming": 0.11747227925250722,
                    "projects": 0.03607288006225284,
                    "protocols": 0.07185811584988591,
                    "queries": 0.1276951257203686,
                    "question": 0.03134472519185019,
                    "quickly": 0.047794059867805376,
                    "recommendation": 0.06948670418858828,
                    "references": 0.060182842344339044,
                    "remember": 0.049115007988716194,
                    "responsibility": 0.05893112764044747,
                    "retrieve": 0.07685298162432233,
                    "role": 0.11116533875469346,
                    "round": 0.06591091550490416,
                    "schools": 0.06847381508425522,
                    "scripting": 0.18636128025856272,
                    "select": 0.059332205123317217,
                    "server": 0.12923662743471998,
                    "session": 0.0675491197800731,
                    "simple": 0.03988957669916656,
                    "skip": 0.06669848255905127,
                    "source": 0.071963316224447,
                    "sourceforge": 0.07060640114599433,
                    "sql": 0.04975928354268377,
                    "stackoverflow": 0.0535024346132286,
                    "stages": 0.07327719294063821,
                    "start": 0.1459734209835405,
                    "starter": 0.07922439328561995,
                    "steps": 0.05449173371469815,
                    "stuff": 0.040922164218641505,
                    "submitted": 0.06847381508425522,
                    "tags": 0.06847381508425522,
                    "things": 0.03041758373921065,
                    "think": 0.027213348163450748,
                    "time": 0.04976362763391833,
                    "trace": 0.06517770811877546,
                    "trip": 0.07685298162432233,
                    "type": 0.04371761775858101,
                    "typing": 0.060182842344339044,
                    "update": 0.04625489910473165,
                    "use": 0.024629147129931684,
                    "user": 0.03825137242399762,
                    "using": 0.05999120216142545,
                    "validate": 0.07327719294063821,
                    "visual": 0.05080543493372094,
                    "way": 0.02823619257710793,
                    "web": 0.18199234040231443,
                    "website": 0.2513474576506657,
                    "working": 0.03362842830638964,
                    "www": 0.055299258130440676,
                    "years": 0.038594218024586284
                },
                "Max term": "http",
                "Max score": 0.2946900479322972
            }
        ]
    },
    {
        "ID": "15397",
        "Question": "Am I wrong if I think that Python is all I need to master, in order to solve most of the common programming tasks? EDIT I'm not OK with learning new programming languages if they don't teach me new concepts of programming and problem solving; hence the idea behind mastering a modern, fast evolving, with a rich set of class libraries, widely used and documented, and of course has a \"friendly\" learning curve programming language. I think that in the fast evolving tech industry, specialization is key to success. ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "class": 0.10839555373268445,
                    "common": 0.10715076468539429,
                    "concepts": 0.13235515551436036,
                    "course": 0.10500696834969933,
                    "curve": 0.1616999797184319,
                    "documented": 0.16325315343885205,
                    "edit": 0.10904000628843251,
                    "evolving": 0.40514097809746663,
                    "fast": 0.26269725552630746,
                    "friendly": 0.16665422934949048,
                    "idea": 0.0983869907982302,
                    "industry": 0.1229207437205837,
                    "key": 0.13037805521723447,
                    "language": 0.08241498003362581,
                    "languages": 0.09247075956107458,
                    "learning": 0.20168998947280536,
                    "libraries": 0.12256082928757053,
                    "master": 0.14441816637564228,
                    "mastering": 0.20257048904873332,
                    "modern": 0.142120476427137,
                    "need": 0.07417269069460534,
                    "new": 0.15638254454129433,
                    "ok": 0.13085900834673028,
                    "order": 0.1185771522024312,
                    "problem": 0.08741823444339676,
                    "programming": 0.30036729940056295,
                    "python": 0.11483313603340803,
                    "rich": 0.17271774085197772,
                    "set": 0.10538437917268544,
                    "solve": 0.12558317931243249,
                    "solving": 0.14286499265522212,
                    "specialization": 0.1915527279151875,
                    "success": 0.15068221858488612,
                    "tasks": 0.12116702929340699,
                    "teach": 0.14606552785910398,
                    "tech": 0.14068998075902217,
                    "think": 0.13916474503628076,
                    "used": 0.08225226611969728,
                    "widely": 0.15751122133960402,
                    "wrong": 0.1106059703797319
                },
                "Max term": "evolving",
                "Max score": 0.40514097809746663
            }
        ],
        "Best answer": "Yes You would be wrong to think that any single language can do everything without considering other languages.  I think that in the fast evolving tech industry, specialization is key to success.  I can't think of a better way to shoot yourself in the foot. Learning and mastering a language is great, but you mention you aren't comfortable with learning new languages if they \"don't teach me new concepts of programming and problem solving.\"  Languages don't teach you these concepts, thick dusty tomes and many years working closely with people better then yourself does. These basic patterns, concepts, and principals of design transcend languages and can be applied in many different scopes. ",
        "Best answer TF-IDF scores": [
            {
                "Scores": {
                    "applied": 0.1366746927538576,
                    "basic": 0.11274912924261941,
                    "better": 0.15317483735086487,
                    "closely": 0.16161338345934115,
                    "comfortable": 0.13439620248437326,
                    "concepts": 0.3715373602407466,
                    "considering": 0.13298327630354795,
                    "design": 0.08731149472078006,
                    "different": 0.08045706734166463,
                    "dusty": 0.1895468407743728,
                    "evolving": 0.1895468407743728,
                    "fast": 0.12290397061027653,
                    "foot": 0.18387316414609045,
                    "great": 0.09705710734379827,
                    "industry": 0.11501793152243296,
                    "key": 0.12199579804928183,
                    "language": 0.15423272334696936,
                    "languages": 0.3461025427961845,
                    "learning": 0.18872295021803334,
                    "mastering": 0.1895468407743728,
                    "mention": 0.13439620248437326,
                    "new": 0.14632840849255643,
                    "patterns": 0.12337051816944963,
                    "people": 0.07032241007931388,
                    "problem": 0.08179794718683349,
                    "programming": 0.07026402629112732,
                    "shoot": 0.18387316414609045,
                    "single": 0.10083754544532146,
                    "solving": 0.1336799261443095,
                    "specialization": 0.1792374327995129,
                    "success": 0.14099456750962136,
                    "teach": 0.2733493855077152,
                    "tech": 0.1316447499668348,
                    "think": 0.19532636189508454,
                    "way": 0.06755597457455143,
                    "working": 0.08045706734166463,
                    "wrong": 0.10349489876197311,
                    "years": 0.09233787467887758,
                    "yes": 0.11010124562014928
                },
                "Max term": "concepts",
                "Max score": 0.3715373602407466
            }
        ]
    },
    {
        "ID": "15839",
        "Question": "End-User Programming is where regular end users, i.e. non-programmers, are able to customize a program, or create a new one, with minimal training or instruction. App Inventor for Android is one recent example, but perhaps the most popular example of end-user programming is the spreadsheet. What examples of end-user programming have you seen used, or believe to be useful? What's the philosophy of the system? What challenges remain? ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "able": 0.11387488902150981,
                    "android": 0.18256834268865482,
                    "app": 0.12292932125017521,
                    "believe": 0.13828538089871759,
                    "challenges": 0.1907203795283438,
                    "create": 0.11640059435390347,
                    "customize": 0.21421616266705368,
                    "end": 0.43880330278603846,
                    "example": 0.1892724960941112,
                    "examples": 0.1351253295390188,
                    "instruction": 0.21421616266705368,
                    "minimal": 0.180831406243192,
                    "new": 0.08744242111388278,
                    "non": 0.11425005569862401,
                    "philosophy": 0.1957968382423204,
                    "popular": 0.15581590069944326,
                    "program": 0.11387488902150981,
                    "programmers": 0.10560245970900307,
                    "programming": 0.25192879384394706,
                    "recent": 0.16633858275701555,
                    "regular": 0.155083621534012,
                    "remain": 0.1986931349343403,
                    "seen": 0.12695123236088846,
                    "spreadsheet": 0.21975657107789048,
                    "training": 0.16334717451671463,
                    "used": 0.0919838887736031,
                    "useful": 0.12145864160723299,
                    "user": 0.3281326344895164,
                    "users": 0.11982823678662802
                },
                "Max term": "end",
                "Max score": 0.43880330278603846
            }
        ],
        "Best answer": "Any domain-specific language worth it's salt ought to be considered a viable example of end-user programming, since that is its primary objective...to be familiar enough to the user that they don't have to be a software engineer to use it. ",
        "Best answer TF-IDF scores": [
            {
                "Scores": {
                    "considered": 0.23753287385493593,
                    "domain": 0.22919443874031986,
                    "end": 0.17180921475159178,
                    "engineer": 0.2639140167194465,
                    "example": 0.14821565253285793,
                    "familiar": 0.22919443874031986,
                    "language": 0.14434661649393055,
                    "objective": 0.2675768002277412,
                    "ought": 0.3441742910654867,
                    "primary": 0.257339069525608,
                    "programming": 0.13152039640184573,
                    "salt": 0.3354971164642451,
                    "software": 0.13869338766206715,
                    "specific": 0.1807415786878625,
                    "use": 0.11029785798589113,
                    "user": 0.34260580937941915,
                    "viable": 0.2951719261624368,
                    "worth": 0.20454413014387746
                },
                "Max term": "ought",
                "Max score": 0.3441742910654867
            }
        ]
    },
    {
        "ID": "16189",
        "Question": "What is that feature according to you that has made object oriented programming so much successful ?  Message Passing Inheritance Polymorphism Encapsulation  Or some other feature that you may like to introduce. Also I would like to know that what is the connection between Abstract Data type and Object Oriented programming? ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "abstract": 0.2246528957063445,
                    "according": 0.21789563343174045,
                    "connection": 0.219477735896528,
                    "data": 0.1367275048790582,
                    "encapsulation": 0.24971366119439323,
                    "feature": 0.3275651894962386,
                    "inheritance": 0.24323929162464358,
                    "introduce": 0.22112718178136775,
                    "know": 0.10019814607844957,
                    "like": 0.16686412763631508,
                    "message": 0.209558749163948,
                    "object": 0.3252963761015719,
                    "oriented": 0.36539009594532423,
                    "passing": 0.23769325694167986,
                    "polymorphism": 0.24971366119439323,
                    "programming": 0.21420182959645592,
                    "successful": 0.21491292143285293,
                    "type": 0.1594315487717363
                },
                "Max term": "oriented",
                "Max score": 0.36539009594532423
            }
        ],
        "Best answer": "I'd suggest that the most important characteristic of object oriented programming is that of complexity management. The human brain can only hold so many concepts at one time - the oft quoted limit of remembering 7+/-2 independent items comes to mind. When I'm working on a 600kloc system at work, I can't hold the whole thing in my head at once. If I had to do that, I'd be limited to working on much smaller systems. Fortunately, I don't have to. The various design patterns and other structures that we've used on that project mean that I don't have to deal with the entire system at once - I can pick up individual pieces and work on them, knowing that they fit into the wider application in well defined ways. All of the important OO concepts provide ways to manage complexity. Encapsulation - let me deal with an external API that provides me with various services, without worrying how those services are implemented. Abstraction - let me concentrate on the essential characteristics and ignore what's not relevant. Composition - let me reuse components that have already been built in new combinations Polymorphism - let me ask for a service without worrying about how different objects might provide it in different ways. Inheritance - let me reuse an interface or an implementation, providing only the pieces that are different from what has gone before. Single Responsibility Principle - lets keep the purpose for each object clear and concise, so it's easy to reason about Liskov Substitution Prinicple - let's not lay traps for each other by introducing odd dependencies Open/Closed Principle - let's allow extension and modification in ways that don't require us to risk breaking existing code Dependency Injection - let's take composition to the next level and assemble the components together much later. Interface oriented development - let's take abstraction to the next level and only depend on the abstraction, never on a concrete implementation. ",
        "Best answer TF-IDF scores": [
            {
                "Scores": {
                    "abstraction": 0.19749115067928738,
                    "allow": 0.057743245967336536,
                    "api": 0.06270043608312913,
                    "application": 0.043222201891472405,
                    "ask": 0.04754082693955722,
                    "brain": 0.07280001134959566,
                    "breaking": 0.07002091267173446,
                    "built": 0.0589116937089288,
                    "characteristic": 0.09284444798333526,
                    "characteristics": 0.07916199137216279,
                    "clear": 0.05522714397331195,
                    "closed": 0.06953244580174378,
                    "code": 0.026873145405988175,
                    "combinations": 0.09006534930547405,
                    "comes": 0.05477963563733304,
                    "complexity": 0.12596063993564616,
                    "components": 0.1355004474327248,
                    "composition": 0.16548974543373746,
                    "concentrate": 0.07724215121556285,
                    "concepts": 0.12132508944600506,
                    "concise": 0.07916199137216279,
                    "concrete": 0.07816511477968298,
                    "deal": 0.11138266686138965,
                    "defined": 0.06215885907412919,
                    "depend": 0.07280001134959566,
                    "dependencies": 0.0721923635823296,
                    "dependency": 0.07280001134959566,
                    "design": 0.04276719937316264,
                    "development": 0.037661687670572805,
                    "different": 0.11822922460501664,
                    "easy": 0.04812800747341807,
                    "encapsulation": 0.08024565792370147,
                    "entire": 0.0635596946043904,
                    "essential": 0.07343883387337481,
                    "existing": 0.05553467339371726,
                    "extension": 0.07916199137216279,
                    "external": 0.066563201312529,
                    "fit": 0.060899776823804576,
                    "fortunately": 0.09284444798333526,
                    "gone": 0.07002091267173446,
                    "head": 0.06270043608312913,
                    "hold": 0.13812483221139255,
                    "human": 0.06953244580174378,
                    "ignore": 0.06953244580174378,
                    "implementation": 0.11511746863038845,
                    "implemented": 0.06547953476099033,
                    "important": 0.092588713297024,
                    "independent": 0.07557911002745686,
                    "individual": 0.06270043608312913,
                    "inheritance": 0.07816511477968298,
                    "injection": 0.07557911002745686,
                    "interface": 0.11995362651936893,
                    "introducing": 0.07916199137216279,
                    "items": 0.06694644104951766,
                    "knowing": 0.059976813259684465,
                    "later": 0.05537995949452382,
                    "lay": 0.09006534930547405,
                    "let": 0.45068860065633876,
                    "lets": 0.06953244580174378,
                    "level": 0.09411732890551125,
                    "limit": 0.07557911002745686,
                    "limited": 0.0635596946043904,
                    "liskov": 0.09284444798333526,
                    "manage": 0.059976813259684465,
                    "management": 0.04968110309363926,
                    "mean": 0.05168229108173752,
                    "mind": 0.05275557471585606,
                    "modification": 0.0763828926943016,
                    "new": 0.03583752769307094,
                    "object": 0.10453421569173076,
                    "objects": 0.05975637726220235,
                    "odd": 0.07816511477968298,
                    "oo": 0.06734184913991603,
                    "open": 0.04721732021263212,
                    "oriented": 0.11741836032395367,
                    "patterns": 0.06042974712775708,
                    "pick": 0.05702105475849464,
                    "pieces": 0.14822440747785906,
                    "polymorphism": 0.08024565792370147,
                    "principle": 0.13812483221139255,
                    "programming": 0.03441695312585912,
                    "project": 0.03596625554425028,
                    "provide": 0.10758807003099186,
                    "provides": 0.06906241610569627,
                    "providing": 0.0721923635823296,
                    "purpose": 0.058509906971157134,
                    "quoted": 0.09284444798333526,
                    "reason": 0.04920386812766322,
                    "relevant": 0.059539775129218465,
                    "remembering": 0.09006534930547405,
                    "require": 0.056338456060562,
                    "responsibility": 0.06906241610569627,
                    "reuse": 0.16049131584740295,
                    "risk": 0.063266638525212,
                    "service": 0.05932687577869803,
                    "services": 0.11995362651936893,
                    "single": 0.0493925733851173,
                    "smaller": 0.06385981295125116,
                    "structures": 0.0677502237163624,
                    "substitution": 0.09006534930547405,
                    "suggest": 0.0591175547384232,
                    "systems": 0.05313492308936232,
                    "thing": 0.04114611546917766,
                    "time": 0.029159431493923624,
                    "used": 0.037698809333596935,
                    "various": 0.11138266686138965,
                    "ways": 0.2105266008940147,
                    "wider": 0.08421177900539606,
                    "work": 0.06159683341498069,
                    "working": 0.0788194830700111,
                    "worrying": 0.1717496403870041
                },
                "Max term": "let",
                "Max score": 0.45068860065633876
            }
        ]
    },
    {
        "ID": "16323",
        "Question": "After reading this post about ideal programming language learning sequence, I am wondering what would have been the answers if the question was performance -instead of learning- oriented ? Since there are many programming languages I chose to ask the question for OOL to be the least subjective. But any thought or comparison about no-OOL are appreciated :D If we omit the programming effort, time and costs. What is your ranking of the most powerful object oriented languages ? ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "answers": 0.15544204624073268,
                    "appreciated": 0.2085958420402167,
                    "ask": 0.133808176338657,
                    "chose": 0.21498691194181854,
                    "comparison": 0.20670057854751728,
                    "costs": 0.18734845715275983,
                    "effort": 0.16881044191944602,
                    "ideal": 0.2000033596629863,
                    "instead": 0.1340395556323871,
                    "language": 0.10631678610459468,
                    "languages": 0.23857784012501082,
                    "learning": 0.26018366395853415,
                    "object": 0.14711074319853415,
                    "oriented": 0.3304851361462222,
                    "performance": 0.15377250043539908,
                    "post": 0.16049117866295004,
                    "powerful": 0.1852858719307789,
                    "programming": 0.2906093580635016,
                    "question": 0.20677946092797972,
                    "ranking": 0.24710641673639255,
                    "reading": 0.14883788245658397,
                    "sequence": 0.20490255183208753,
                    "subjective": 0.2127245892237081,
                    "thought": 0.15028360634998983,
                    "time": 0.08207199164277433,
                    "wondering": 0.16252385446696593
                },
                "Max term": "oriented",
                "Max score": 0.3304851361462222
            }
        ],
        "Best answer": "Any time you care deeply about performance, you generally want to get as close to the metal as you can.  In most languages, you can write out performance critical segments in C code.  C programmers can drop down to assembly language for the really critical stuff.  So if I'm writing some C# code, but I really need a tight performance on an inner loop, I can write some C or C++ code and use interop to call that code.  If I need even more performance, I can write assembly in my C library.  Going lower than assembly is possible, but who wants to write machine code these days?   However, and this is the big consideration, dropping close to the metal is only high-performance for small, tight goals.  If I was writing a 3D renderer, I might do the floating point math and rendering in C, (using a library to execute it on the video card.)  But performance problems are also architectural, and performance issues from large-scale problems are often better solved in a high level language.   Look at Erlang: Ericsson needed a language to do massive parallel work easily, because doing parallel processing was going to get them way more performance than any tightly optimized C routines running on one CPU core.  Likewise, having the fastest code running in your loop is only performance enhancing if you can't remove the loop entirely by doing something better at the high level. You can do huge system, high level programming in C, but sometimes the greater expressiveness of a more powerful language will show opportunities for architectural optimizations that wouldn't be obvious otherwise. ",
        "Best answer TF-IDF scores": [
            {
                "Scores": {
                    "architectural": 0.15487872310521084,
                    "assembly": 0.21302266795991237,
                    "better": 0.07765103324025717,
                    "big": 0.0499892275821011,
                    "card": 0.07905266666533291,
                    "care": 0.0635339170161837,
                    "close": 0.1297839476514196,
                    "code": 0.16687457605441738,
                    "consideration": 0.08715519221891029,
                    "core": 0.0635339170161837,
                    "cpu": 0.07905266666533291,
                    "critical": 0.13857277466300255,
                    "days": 0.05553492308828835,
                    "deeply": 0.0842789570612515,
                    "drop": 0.07411604279893759,
                    "dropping": 0.09321335950495602,
                    "easily": 0.05919691838527416,
                    "enhancing": 0.0960895946626148,
                    "entirely": 0.06578126559071885,
                    "erlang": 0.07994195843034196,
                    "execute": 0.07600570559323383,
                    "expressiveness": 0.0960895946626148,
                    "fastest": 0.0830504452426421,
                    "floating": 0.08715519221891029,
                    "generally": 0.05447125860782475,
                    "goals": 0.07743936155260542,
                    "going": 0.08486585602865045,
                    "greater": 0.07600570559323383,
                    "high": 0.22617425608688493,
                    "huge": 0.060554975194800256,
                    "inner": 0.0856370138707776,
                    "interop": 0.0960895946626148,
                    "issues": 0.054859919754364626,
                    "language": 0.15637464396215053,
                    "languages": 0.043863634066806975,
                    "large": 0.0512177394007105,
                    "level": 0.1461104489556851,
                    "library": 0.11191514276401059,
                    "likewise": 0.08887636087404648,
                    "look": 0.044613577251934114,
                    "loop": 0.21740495837966461,
                    "lower": 0.07246831945988821,
                    "machine": 0.06162083983198146,
                    "massive": 0.07822078977520579,
                    "math": 0.07354307655557929,
                    "metal": 0.18642671900991203,
                    "need": 0.07036783904061661,
                    "needed": 0.05553492308828835,
                    "obvious": 0.06207315354293295,
                    "opportunities": 0.07822078977520579,
                    "optimizations": 0.0830504452426421,
                    "optimized": 0.0856370138707776,
                    "parallel": 0.17775272174809295,
                    "performance": 0.5088920761954911,
                    "point": 0.043976207866201704,
                    "possible": 0.04653140724522369,
                    "powerful": 0.06813132082897867,
                    "problems": 0.09506887788998349,
                    "processing": 0.07471566803442337,
                    "programmers": 0.04479301798886363,
                    "programming": 0.03561991209188527,
                    "really": 0.0723884443873428,
                    "remove": 0.06673648904985971,
                    "rendering": 0.08887636087404648,
                    "routines": 0.08192890182299169,
                    "running": 0.1156041732123104,
                    "scale": 0.06969561592791144,
                    "small": 0.04870348298522836,
                    "solved": 0.07100755598663747,
                    "stuff": 0.04963362935844603,
                    "tight": 0.168557914122503,
                    "time": 0.030178626872188682,
                    "use": 0.029872172779776926,
                    "using": 0.03638103152290517,
                    "video": 0.07196277944577831,
                    "want": 0.03610182310194654,
                    "wants": 0.06578126559071885,
                    "way": 0.034247082079482564,
                    "work": 0.03187489873604761,
                    "write": 0.16192743558015318,
                    "writing": 0.09171984229646074
                },
                "Max term": "performance",
                "Max score": 0.5088920761954911
            }
        ]
    },
    {
        "ID": "16836",
        "Question": "I think the world now programs in English-based programming languages not only because of historical/economic circumstances, but because the English morphology in particular has some properties that suit algorithmic thinking best. But anyway it would be interesting to hear your opinions on this, especially if you are multilingual yourself. I've seen some mentioning of German-based languages (see Plankalkul for example, in fact the first ever programming language we know very little about, thanks to WW2), also a Russian-based flavor of Algol which existed back in the 80's at least on paper, not sure if it ever existed in binary or not. Both looked a bit sluggish because there were more shortened words and weird abbreviations than full words like in the EN-based languages. So if you know of any other national language-based PL's, even completely archaic and irrelevant today, purely theoretical or whatever, would be interesting to take a look at them. And back to the main question: so what, if any, makes the Shakespeare's language so good for programming? (There is actually a list of Non-English-based programming languages on Wikipedia (of course, where else?), but it would be interesting to hear opinions of native speakers of those languages on how a given \"national\" programming languages really feels like.) ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "80": 0.0928727811637464,
                    "actually": 0.05668760165425171,
                    "algorithmic": 0.11859775753593148,
                    "based": 0.36994935817622,
                    "best": 0.05167148894273831,
                    "binary": 0.09357075003096847,
                    "bit": 0.06395029328888452,
                    "circumstances": 0.09759070760578177,
                    "completely": 0.07704565422690753,
                    "course": 0.06337480290739313,
                    "economic": 0.12225726558988378,
                    "en": 0.10171221221100954,
                    "english": 0.27861834349123926,
                    "especially": 0.0717522374033808,
                    "example": 0.05107308848579031,
                    "existed": 0.23719551507186296,
                    "fact": 0.06930518495800317,
                    "feels": 0.09429974973623571,
                    "flavor": 0.11859775753593148,
                    "german": 0.10895817789517268,
                    "given": 0.06930518495800317,
                    "good": 0.041660623310908494,
                    "hear": 0.1651274585248771,
                    "historical": 0.10723028724654056,
                    "interesting": 0.21197553799735883,
                    "irrelevant": 0.09586281695714965,
                    "know": 0.08479840067371637,
                    "language": 0.14921961461225436,
                    "languages": 0.3348529866530607,
                    "like": 0.07060914651203168,
                    "list": 0.06580886027046322,
                    "little": 0.06196669551353708,
                    "look": 0.05676300313426759,
                    "looked": 0.08815485472171106,
                    "main": 0.07101504394674953,
                    "makes": 0.06047929067833815,
                    "mentioning": 0.10895817789517268,
                    "national": 0.23121544348505646,
                    "native": 0.095062668363654,
                    "non": 0.061658226362703336,
                    "opinions": 0.1763097094434221,
                    "paper": 0.0892132731097941,
                    "particular": 0.0655485406298618,
                    "pl": 0.10895817789517268,
                    "programming": 0.22660065682430403,
                    "programs": 0.07232772778487218,
                    "properties": 0.09156009732562376,
                    "purely": 0.10171221221100954,
                    "question": 0.048370460582845755,
                    "really": 0.046050840895810026,
                    "seen": 0.06851277029203305,
                    "speakers": 0.10895817789517268,
                    "suit": 0.11307968250040046,
                    "sure": 0.058348758566797325,
                    "thanks": 0.07555373589422203,
                    "theoretical": 0.10171221221100954,
                    "think": 0.04199501436400226,
                    "thinking": 0.06418626560483112,
                    "today": 0.07678738443232015,
                    "weird": 0.10292756761501466,
                    "wikipedia": 0.0871606234723721,
                    "words": 0.1603852540724657,
                    "world": 0.0644256828935903
                },
                "Max term": "based",
                "Max score": 0.36994935817622
            }
        ],
        "Best answer": "Disclaimer: My native language is German. I don't think there is any reason English as a language to take keywords from would be better than any other natural language. I do think it's the one all-important language in IT, but not because of linguistic properties, but because most tech people speak it to some degree, it's the native tounge of quite a few important people in the field, most tech-related terms are already English, etc. But since we talk about programming languages, not about documentation/API/names/etc, I have to object: Programming languages are not based on English - or on any other natural language, for that matter. Programming languages are formal languages. They do use, to varying degree, a handful of words from (usually) English. Some even try to mimic its grammar -- but utterly fail to read like English regardless. To add insult to injury, they only associate one single (in rare cases a handful of) meaning(s) with each word they borrow. Often, this meaning is very jargon-y, specialized, or based on a questionable analogy. Therefore, knowing the myriad natural-language meanings of a word borrowed by programming language doesn't really help understanding the programming concept behind the keyword. Examples off the top of my head: array, type, goto, class, void. (Fun fact that sprung to mind as I re-read the question: All of these, except goto, have German translations which are at most one character longer: Feld, Typ, Klasse, Leere. They all sound weird to me, but that's probably a matter of habit.) ",
        "Best answer TF-IDF scores": [
            {
                "Scores": {
                    "add": 0.05866852065072629,
                    "analogy": 0.09999991407726096,
                    "api": 0.07301369839018475,
                    "array": 0.08339222982074954,
                    "based": 0.10905261143450426,
                    "better": 0.04368482561432036,
                    "cases": 0.06233042932073767,
                    "character": 0.08551839830026703,
                    "class": 0.0578528843429636,
                    "concept": 0.07010340100598997,
                    "degree": 0.1466792377823754,
                    "disclaimer": 0.09482711017601322,
                    "documentation": 0.06485170560320982,
                    "english": 0.4106515835175789,
                    "examples": 0.06448911541911584,
                    "fact": 0.06128875132705164,
                    "fail": 0.07177866730462548,
                    "field": 0.07269494156032577,
                    "formal": 0.08153828136125367,
                    "fun": 0.07508906873743143,
                    "german": 0.19271027626901227,
                    "goto": 0.18965422035202645,
                    "grammar": 0.09218292763307762,
                    "habit": 0.09102208009512659,
                    "handful": 0.18965422035202645,
                    "head": 0.07301369839018475,
                    "help": 0.04935350181600439,
                    "important": 0.10781813986176063,
                    "jargon": 0.10223553856263945,
                    "keyword": 0.09482711017601322,
                    "keywords": 0.09806332806121094,
                    "knowing": 0.06984208128857546,
                    "language": 0.3079057120589932,
                    "languages": 0.19741400726401756,
                    "like": 0.031220942737643843,
                    "longer": 0.06790549527252544,
                    "matter": 0.12405018968878424,
                    "meaning": 0.15978938443627458,
                    "mind": 0.06143305950213,
                    "names": 0.07091685823600292,
                    "native": 0.16813380543913162,
                    "natural": 0.23968407665441188,
                    "object": 0.060864247306441084,
                    "people": 0.08022263380131361,
                    "probably": 0.05060395475726759,
                    "programming": 0.20039007637115583,
                    "properties": 0.08096946916556476,
                    "question": 0.042775517185812614,
                    "questionable": 0.10487972110557506,
                    "quite": 0.05808128043230882,
                    "rare": 0.0863025272049443,
                    "read": 0.10218650800189319,
                    "really": 0.04072420465763432,
                    "reason": 0.057297151527631554,
                    "regardless": 0.080422126776811,
                    "related": 0.06522359397767588,
                    "single": 0.05751689591240947,
                    "sound": 0.08801071713164911,
                    "speak": 0.08477449924645139,
                    "specialized": 0.10223553856263945,
                    "talk": 0.06724112635420375,
                    "tech": 0.15017813747486286,
                    "terms": 0.06413536978595069,
                    "think": 0.07427501979515541,
                    "try": 0.05102233526825539,
                    "type": 0.05966055527075385,
                    "understanding": 0.06560527000355852,
                    "use": 0.033610902628115,
                    "usually": 0.05645002889260436,
                    "utterly": 0.10487972110557506,
                    "varying": 0.10223553856263945,
                    "void": 0.08713148721776542,
                    "weird": 0.09102208009512659,
                    "word": 0.1460273967803695,
                    "words": 0.07091685823600292
                },
                "Max term": "english",
                "Max score": 0.4106515835175789
            }
        ]
    },
    {
        "ID": "17214",
        "Question": "There are lots of books about programming out there, and it seems Code Complete is pretty much at the top of most people's list of \"must-read programming books\", but what about The Art of Computer Programming by Donald Knuth?  I'm a busy person, between work and a young family I don't have a ton of free time, so I have to be picky about how I use it. I'm wondering - has anybody here read 'TAOCP'?  If so, is it worth making time to read or would some other book or more on-the-side programming like pet projects or contributing to open source be a better use of my time in terms of professional development? DISCLAIMER - For those of you who sport \"Knuth is my homeboy\" t-shirts, don't get me wrong - I want to read it, but I'm just wondering if it should be right at the top of my priority list or if something else should come first. ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "anybody": 0.1399319755888093,
                    "art": 0.14845286894956136,
                    "better": 0.07442932399167031,
                    "book": 0.10253898447513991,
                    "books": 0.21509583662909101,
                    "busy": 0.15920943324711417,
                    "code": 0.05331700630734035,
                    "come": 0.09688953825088484,
                    "complete": 0.11049302680909465,
                    "computer": 0.10164844966931146,
                    "contributing": 0.15920943324711417,
                    "development": 0.07472174949157852,
                    "disclaimer": 0.16156451598997895,
                    "donald": 0.1703778348506392,
                    "family": 0.14995088312733035,
                    "free": 0.09935307617745373,
                    "knuth": 0.3407556697012784,
                    "like": 0.05319361196176386,
                    "list": 0.19830920778947303,
                    "lots": 0.10699879201931194,
                    "making": 0.098376282341183,
                    "open": 0.09368036832158996,
                    "people": 0.06834085198574949,
                    "person": 0.10143074194951891,
                    "pet": 0.1786919515540869,
                    "picky": 0.18420575425554622,
                    "pretty": 0.09383927347599443,
                    "priority": 0.14570452061625583,
                    "professional": 0.11729073732324205,
                    "programming": 0.2731364533876962,
                    "projects": 0.08387356222572986,
                    "read": 0.3482066188748661,
                    "right": 0.08754097103208791,
                    "source": 0.08366146078306892,
                    "terms": 0.10927254830472036,
                    "time": 0.1735591687603734,
                    "ton": 0.16156451598997895,
                    "use": 0.11453115475138309,
                    "want": 0.06920794679011918,
                    "wondering": 0.22912814729612985,
                    "work": 0.06110484474524715,
                    "worth": 0.10619732717743313,
                    "wrong": 0.10057860004506179,
                    "young": 0.15325039928653128
                },
                "Max term": "read",
                "Max score": 0.3482066188748661
            }
        ],
        "Best answer": "TAOCP is an utterly invaluable reference for understanding how the data structures and algorithms that we use every day work and why they work, but undertaking to read it cover-to-cover would be an extraordinary investment of your time. As one family man to another, spend the time with your kids. ",
        "Best answer TF-IDF scores": [
            {
                "Scores": {
                    "algorithms": 0.21607356681727388,
                    "cover": 0.4681808436148897,
                    "data": 0.15273329993384283,
                    "day": 0.17696077705246382,
                    "family": 0.2627243827148154,
                    "investment": 0.28307227571338445,
                    "kids": 0.2876336543187369,
                    "man": 0.23409042180744485,
                    "read": 0.15252055722044364,
                    "reference": 0.21253747532351402,
                    "spend": 0.1884314374291435,
                    "structures": 0.2355099934122748,
                    "time": 0.2027251614043334,
                    "understanding": 0.19584096830777345,
                    "use": 0.1003332768241224,
                    "utterly": 0.31308073476491965,
                    "work": 0.2141198808805642
                },
                "Max term": "cover",
                "Max score": 0.4681808436148897
            }
        ]
    },
    {
        "ID": "18737",
        "Question": "I've just finished my master and I'm starting to dig into the laboral world, i.e. learning how programming teams and technology companies work in the real world. I'm starting to design the idea of my own service or product based on free software, and I will require a well coupled, enthusiast and fluid team to build and the idea. My problem is that I'm not sure which would be the best skills to ask for a programming team of 4-5 members. I have many friends and acquaintances, with whom I've worked during my studies. Must of those ones I have in mind are very capable and smart people, with a good logic and programming base, although some of them have some characteristics that I believe that could influtiate negatively in the group: lack of communication, fear to debate ideas, hard to give when debating, lack of structured programming (testing, good commenting, previous design and analysis). Some of them have this negative characteristics, but must of them have a lot of enthusiasm, nice working skills (from an individual point of view), and ability to see the whole picture. The question is: how to pick the best team for a large scale project, with a lot of programming? Which of these negative skills do you think are just too influential? Which can be softened with good leadership? Wich good skills are to be expected? And any other opinion about social and programming skills of a programming team. ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "ability": 0.08325918150158289,
                    "analysis": 0.08644032186866701,
                    "ask": 0.06524965869747018,
                    "base": 0.0795095017552076,
                    "based": 0.06426637454309088,
                    "believe": 0.0777863960619321,
                    "best": 0.10771439457434323,
                    "build": 0.06766118651292298,
                    "capable": 0.10373212776083943,
                    "characteristics": 0.21729924577932927,
                    "commenting": 0.11558044300312405,
                    "communication": 0.08806950696498121,
                    "companies": 0.07622119172269658,
                    "debate": 0.10601464737417543,
                    "debating": 0.12361445269183509,
                    "design": 0.11739573508443113,
                    "dig": 0.11786296261646005,
                    "enthusiasm": 0.11786296261646005,
                    "expected": 0.09084752520343488,
                    "fear": 0.10864962288966463,
                    "finished": 0.09610351665369225,
                    "fluid": 0.12742875824540867,
                    "free": 0.0687298785877816,
                    "friends": 0.09828863711095163,
                    "good": 0.17369148477595497,
                    "group": 0.08358478192980215,
                    "hard": 0.06653373361827748,
                    "idea": 0.12378241395176531,
                    "ideas": 0.07977047637622856,
                    "individual": 0.08605618198034702,
                    "influential": 0.12742875824540867,
                    "lack": 0.1658793348409224,
                    "large": 0.06792216113394393,
                    "leadership": 0.12361445269183509,
                    "learning": 0.06343743609876487,
                    "logic": 0.0811386868515218,
                    "lot": 0.10591466266354697,
                    "master": 0.09084752520343488,
                    "members": 0.0868332933281692,
                    "mind": 0.072406886169123,
                    "negative": 0.19983564441453167,
                    "negatively": 0.11558044300312405,
                    "nice": 0.07850371133603258,
                    "ones": 0.07383217017203951,
                    "opinion": 0.08085614313534503,
                    "people": 0.047276427064792,
                    "pick": 0.07826124619775462,
                    "picture": 0.09828863711095163,
                    "point": 0.05831883858401078,
                    "previous": 0.08425520141140762,
                    "problem": 0.05499121375200985,
                    "product": 0.07125036267964262,
                    "programming": 0.3306602372329363,
                    "project": 0.04936359020157555,
                    "question": 0.050416535148979695,
                    "real": 0.06458789196504615,
                    "require": 0.07732438129794822,
                    "scale": 0.09242650907235085,
                    "service": 0.0814259794233043,
                    "skills": 0.3578644561128659,
                    "smart": 0.09610351665369225,
                    "social": 0.09828863711095163,
                    "software": 0.04981344525980537,
                    "starting": 0.1579984199223005,
                    "structured": 0.10269584044571951,
                    "studies": 0.10483531733609106,
                    "sure": 0.060816915980029675,
                    "team": 0.24021322949569673,
                    "teams": 0.0829396674204612,
                    "technology": 0.07826124619775462,
                    "testing": 0.06653373361827748,
                    "think": 0.043771407016857986,
                    "view": 0.08171818321639425,
                    "work": 0.04227074512484122,
                    "worked": 0.0688682882965849,
                    "working": 0.05408976557736286,
                    "world": 0.13430178943773124
                },
                "Max term": "skills",
                "Max score": 0.3578644561128659
            }
        ],
        "Best answer": " Joel Spolsky said:  In principle, it’s simple. You’re   looking for people who are  Smart, and Get things done.   ",
        "Best answer TF-IDF scores": [
            {
                "Scores": {
                    "joel": 0.38710974012617977,
                    "looking": 0.26232400891169405,
                    "people": 0.19917725324523547,
                    "principle": 0.3993451112866111,
                    "said": 0.29561669176064914,
                    "simple": 0.2703105826057722,
                    "smart": 0.4048875023498856,
                    "spolsky": 0.4640108614903317,
                    "things": 0.20612389156232094
                },
                "Max term": "spolsky",
                "Max score": 0.4640108614903317
            }
        ]
    },
    {
        "ID": "19842",
        "Question": "As part of a continuing quest for knowledge, I'm spending some time this week learning the basics of F# as an introduction to functional programming. I think I am understanding the construction of software under this model and some of the proposed benefits, but am still a little fuzzy on the real-world use cases. I was hoping that a F# success stories, or at least a few applications that I'd be familiar with might make it a little clearer about when F# (or any functional programming language) would be appropriate for a project. So back to the question, what are some well known applications that use F# or a similar functional programming language?  BTW: I am also open to hearing about some lesser-known apps, but if you mention one, please give the basics of what the app is about and why the language used was the appropriate choice. ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "app": 0.09790557818924531,
                    "applications": 0.19869568184492573,
                    "appropriate": 0.24262552407852422,
                    "apps": 0.11743210940903281,
                    "basics": 0.2854248969818593,
                    "benefits": 0.12028272368353825,
                    "btw": 0.16687909117217334,
                    "cases": 0.10401654334802397,
                    "choice": 0.11013572705291147,
                    "clearer": 0.17502247578899885,
                    "construction": 0.1538341640285095,
                    "continuing": 0.17502247578899885,
                    "familiar": 0.11655193065471647,
                    "functional": 0.328444717237664,
                    "fuzzy": 0.163647331252005,
                    "hearing": 0.14147103544402762,
                    "hoping": 0.15189695054277536,
                    "introduction": 0.1484335883930177,
                    "knowledge": 0.09507719841175633,
                    "known": 0.23486421881806563,
                    "language": 0.22021315519228468,
                    "learning": 0.08981940931608884,
                    "lesser": 0.1559400349793536,
                    "little": 0.18289661947371028,
                    "make": 0.06470672626149072,
                    "mention": 0.12792707519171032,
                    "model": 0.11294493456231233,
                    "open": 0.09175662280182297,
                    "programming": 0.20064565534868814,
                    "project": 0.06989261840160203,
                    "proposed": 0.16079671697749956,
                    "question": 0.07138345565850122,
                    "real": 0.09144830973685514,
                    "similar": 0.09489989177039085,
                    "software": 0.07052955643209163,
                    "spending": 0.13808848221174772,
                    "stories": 0.1324783619919485,
                    "success": 0.13420782958151842,
                    "think": 0.061974792251492605,
                    "time": 0.05666503191317808,
                    "understanding": 0.10948157241255467,
                    "use": 0.11217923406859544,
                    "used": 0.07325946098853943,
                    "week": 0.11788450105345302,
                    "world": 0.09507719841175633
                },
                "Max term": "functional",
                "Max score": 0.328444717237664
            }
        ],
        "Best answer": " The entire F# system (compiler, libraries and tools) IronJS (already mentioned) The XBox Live TrueSkill algorithm, as well as the whole Achievements system, the ranking system and the matchmaking system surrounding it  I guess the main reason why there are no \"well-known\" applications written in F#, is because it takes years, even decades to become \"well-known\" and F# simply isn't that old yet. However, the overwhelming majority of applications are not \"well-known\". There is only one PowerPoint, but there are literally millions of hand-written custom little one-off in-house payroll apps. And F# is certainly used in-house in many financial companies, doing scientific and numeric computing in, say, biotech or greentech, doing statistics god knows where and so on. These applications aren't well-known, either because they simply aren't \"sexy\" or often because the companies consider F# their secret weapon which gives them a competitive edge. (OCaml, Smalltalk and APL fill similar roles. Many financial companies use APL, for example, but they don't widely publicize it. Indeed, oftentimes the APL users aren't even programmers, and thus wouldn't even know where and how to publicize it even if they wanted to.) ",
        "Best answer TF-IDF scores": [
            {
                "Scores": {
                    "algorithm": 0.09383675304240863,
                    "apl": 0.4092818848414882,
                    "applications": 0.22536627812602533,
                    "apps": 0.08879655288015441,
                    "certainly": 0.09095205125654289,
                    "companies": 0.2448109315563679,
                    "competitive": 0.1261859990290031,
                    "compiler": 0.08913862983660573,
                    "computing": 0.10363704968580735,
                    "consider": 0.07418339544929616,
                    "custom": 0.10994783208475427,
                    "decades": 0.1163220481150718,
                    "edge": 0.10522940872786529,
                    "entire": 0.09339575376764772,
                    "example": 0.05699263166973698,
                    "financial": 0.21394728142130306,
                    "gives": 0.09173091706916353,
                    "god": 0.11965863913991599,
                    "guess": 0.08626832096090191,
                    "hand": 0.07680222450569073,
                    "house": 0.215824675940061,
                    "know": 0.04731341063429629,
                    "known": 0.35518621152061763,
                    "knows": 0.08913862983660573,
                    "libraries": 0.0825423411115016,
                    "literally": 0.11350100059973864,
                    "little": 0.06914884448737314,
                    "live": 0.09726283365548981,
                    "main": 0.07924592701679554,
                    "majority": 0.11223839073708951,
                    "mentioned": 0.09837229965936937,
                    "millions": 0.1163220481150718,
                    "ocaml": 0.12900704654433626,
                    "old": 0.07807740776926564,
                    "overwhelming": 0.12900704654433626,
                    "payroll": 0.12900704654433626,
                    "programmers": 0.06359679524299047,
                    "ranking": 0.12900704654433626,
                    "reason": 0.07230104519334196,
                    "roles": 0.11223839073708951,
                    "say": 0.05941080441479372,
                    "scientific": 0.11350100059973864,
                    "secret": 0.12374229651789828,
                    "similar": 0.07175876598246866,
                    "simply": 0.15256358734450984,
                    "smalltalk": 0.11791440715712974,
                    "statistics": 0.11965863913991599,
                    "surrounding": 0.13234363756918044,
                    "takes": 0.0790459186398991,
                    "tools": 0.07149353548016775,
                    "use": 0.04241228970575338,
                    "used": 0.05539530571644553,
                    "users": 0.07216396152369227,
                    "wanted": 0.0902049849034048,
                    "widely": 0.10608075219691217,
                    "written": 0.14687265819231612,
                    "years": 0.06646065116223546
                },
                "Max term": "apl",
                "Max score": 0.4092818848414882
            }
        ]
    },
    {
        "ID": "20965",
        "Question": "Hello Over the years have I made a programming journey from C in 1990 to Pascal, C++ with I programmed commercially, java VHDL, C# and now I'm taking a look on F#.   In the spring I will go back to study embedded programming in C in a university course so before I do that I will refresh my knowledge in C. I don't remember much of the C that I learnt and I think I am thankful for that for probably learned some bad habits back then.   I have some questions to get me on the way. --edit-- To clarify: I am thankful for tips that have been given regarding embedded programming but now I am more interested in relearning C in general. Sorry if my question was unclear,  Compiler, Debugger, IDE? As a microslave I was thinking about 2010 C++ Express, any alternatives? Where do you find good libraries with code for C. I'm thinking something similar to Boost, POCO in C++ Source for procedural programming patterns and best practices. Where can you find good code learn from?  Thanks in advance Gorgen ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "2010": 0.13356478987160358,
                    "advance": 0.13718634574576127,
                    "alternatives": 0.14388280401528167,
                    "bad": 0.09235318433664944,
                    "best": 0.07688035095073434,
                    "boost": 0.1649893694568111,
                    "clarify": 0.16211537787920954,
                    "code": 0.10530078732978876,
                    "commercially": 0.1649893694568111,
                    "compiler": 0.11885124767228186,
                    "course": 0.09429333639588744,
                    "debugger": 0.15314262628500933,
                    "edit": 0.09791489227004513,
                    "embedded": 0.25936699169116945,
                    "express": 0.14144069496836295,
                    "general": 0.09621840586720824,
                    "given": 0.10311696162232695,
                    "good": 0.12397101018390948,
                    "habits": 0.15721886722794567,
                    "hello": 0.15721886722794567,
                    "ide": 0.11750774913697251,
                    "interested": 0.1056610059651707,
                    "java": 0.08502465884536023,
                    "journey": 0.18190266387027196,
                    "knowledge": 0.09585690701866306,
                    "learn": 0.08209956625227477,
                    "learned": 0.11070693977765597,
                    "learnt": 0.168247632377355,
                    "libraries": 0.11005621518836005,
                    "look": 0.08445585159770042,
                    "pascal": 0.15133433796389414,
                    "patterns": 0.1183951460567567,
                    "practices": 0.11171676909667826,
                    "probably": 0.08514002892305547,
                    "procedural": 0.15133433796389414,
                    "programmed": 0.15314262628500933,
                    "programming": 0.269721478962997,
                    "question": 0.07196885673991127,
                    "questions": 0.09204431026328984,
                    "refresh": 0.168247632377355,
                    "regarding": 0.1381824320478191,
                    "remember": 0.11277020143212386,
                    "similar": 0.09567814632189163,
                    "sorry": 0.15314262628500933,
                    "source": 0.08261545705356445,
                    "spring": 0.14659679025904554,
                    "study": 0.13193747191753902,
                    "taking": 0.12027305133230046,
                    "thanks": 0.1124139801278786,
                    "think": 0.062483034813715296,
                    "thinking": 0.19100137142883553,
                    "tips": 0.1327375673990246,
                    "unclear": 0.1649893694568111,
                    "university": 0.12284392440349338,
                    "way": 0.06483153021838556,
                    "years": 0.0886140086090957
                },
                "Max term": "programming",
                "Max score": 0.269721478962997
            }
        ],
        "Best answer": "There is a very good chance for embedded C programming that you will end up with using the GNU C compiler to target the destination platform, so you might as well learn to use gcc along with gdb to debug (perhaps even using Emacs as both a C IDE which is pretty good, and as the gdb frontend). For this you essentially just need any modern Linux distribution which contain all of the above - usually as optional packages just requiring a single command to install. This looks like a good C tutorial : http://www.faqs.org/docs/learnc/ You will naturally need the K&R manual.  Use ANSI C if you can. ",
        "Best answer TF-IDF scores": [
            {
                "Scores": {
                    "ansi": 0.20611080964566736,
                    "chance": 0.14286091824234226,
                    "command": 0.17123178043167125,
                    "compiler": 0.13882371305325775,
                    "contain": 0.17123178043167125,
                    "debug": 0.15232712048449307,
                    "destination": 0.21247066149764213,
                    "distribution": 0.17676545362429527,
                    "docs": 0.17479907620081556,
                    "emacs": 0.17479907620081556,
                    "embedded": 0.15147627616541576,
                    "end": 0.10288896433086298,
                    "essentially": 0.14984719460793858,
                    "gcc": 0.18635530537941186,
                    "gnu": 0.18635530537941186,
                    "good": 0.2172057460281997,
                    "http": 0.13172077189916023,
                    "ide": 0.1372544450917843,
                    "install": 0.1550435719345601,
                    "learn": 0.09589606209797304,
                    "like": 0.06135574844901765,
                    "linux": 0.13882371305325775,
                    "looks": 0.13214301914857826,
                    "manual": 0.16960269887419407,
                    "modern": 0.14906629184061138,
                    "naturally": 0.16659980111315636,
                    "need": 0.1555954248908533,
                    "optional": 0.18635530537941186,
                    "org": 0.15320414869887566,
                    "packages": 0.18363885392934487,
                    "platform": 0.12708879258064537,
                    "pretty": 0.10823816329995221,
                    "programming": 0.07876176719470802,
                    "requiring": 0.20091443231904585,
                    "single": 0.11303285191690052,
                    "target": 0.1580464696955978,
                    "tutorial": 0.17676545362429527,
                    "use": 0.13210504910914042,
                    "using": 0.1608894669767126,
                    "usually": 0.11093623282868859,
                    "www": 0.14830621564931878
                },
                "Max term": "good",
                "Max score": 0.2172057460281997
            }
        ]
    },
    {
        "ID": "22070",
        "Question": "Similar question was closed on SO. Sometimes when we're programming, we find that some particular control structure would be very useful to us, but is not directly available in our programming language. What alternative control structures do you think are a useful way of organizing computation? The goal here is to get new ways of thinking about structuring code, in order to improve chunking and reasoning. You can create a wishful syntax/semantic not available now or cite a less known control structure on an existent programming language. Answers should give ideas for a new programming language or enhancing an actual language. Think of this as brainstorming, so post something you think is a crazy idea but it can be viable in some scenario. It's about imperative programming. ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "actual": 0.11413101160096405,
                    "alternative": 0.12986951247562703,
                    "answers": 0.10586418567800382,
                    "available": 0.1985782752582762,
                    "cite": 0.16829242934112026,
                    "closed": 0.13328583054301485,
                    "code": 0.051512778868056316,
                    "computation": 0.15382184590956788,
                    "control": 0.2845887410325649,
                    "crazy": 0.1498336801297856,
                    "create": 0.09144659561013381,
                    "directly": 0.11864888058080802,
                    "enhancing": 0.17797230081695525,
                    "existent": 0.1726450831250035,
                    "goal": 0.11767431667273953,
                    "idea": 0.086439832401279,
                    "ideas": 0.11141076326429238,
                    "imperative": 0.14342927970197153,
                    "improve": 0.11292705058986087,
                    "known": 0.11583698721590885,
                    "language": 0.28962922856624324,
                    "new": 0.13739297066577413,
                    "order": 0.10417829714925564,
                    "organizing": 0.16829242934112026,
                    "particular": 0.0954202969844229,
                    "post": 0.10930290966025658,
                    "programming": 0.32986702317503563,
                    "question": 0.07041382874031188,
                    "reasoning": 0.1407739344425272,
                    "scenario": 0.13328583054301485,
                    "semantic": 0.16461231300360699,
                    "similar": 0.09361083271959288,
                    "structure": 0.2334759619124882,
                    "structures": 0.12986951247562703,
                    "structuring": 0.1726450831250035,
                    "syntax": 0.11372290763699457,
                    "think": 0.18339889968439638,
                    "thinking": 0.09343720649585036,
                    "useful": 0.1908405939688458,
                    "viable": 0.14806446341683624,
                    "way": 0.06343071812669429,
                    "ways": 0.10088891785701018
                },
                "Max term": "programming",
                "Max score": 0.32986702317503563
            }
        ],
        "Best answer": "OK, this is a fun question. I would also like to have a general else for while and for loops, for when the condition isn't true on the first test: while (condition) {     // process } else {     // condition was never true }  This avoids the awkward re-computation of the condition or storing it in a variable. ",
        "Best answer TF-IDF scores": [
            {
                "Scores": {
                    "avoids": 0.21204062330579382,
                    "awkward": 0.20285919165187494,
                    "computation": 0.2056361773852406,
                    "condition": 0.7527724968600482,
                    "fun": 0.1652421785365558,
                    "general": 0.12584994107575753,
                    "like": 0.06870529466776555,
                    "loops": 0.20285919165187494,
                    "ok": 0.15369557593006056,
                    "process": 0.11769714527407923,
                    "question": 0.09413247183192253,
                    "storing": 0.20867802109256026,
                    "test": 0.11487407259740583,
                    "true": 0.2949980947495795,
                    "variable": 0.16067508610598663
                },
                "Max term": "condition",
                "Max score": 0.7527724968600482
            }
        ]
    },
    {
        "ID": "24157",
        "Question": "My younger brother is looking to start programming. He's 14, and technically-inclined, but no real experience programming. He's looking to me for guidance, and I don't feel as if my experience is enough, so I figured I'd ask here. He's more interested in web programming, but also has an interest in desktop/mobile/server applications. What would be a good learning path for him to take? I'm going to buy him a bunch of books for Christmas to get him started; the question is, what should he learn, and in which order? The way I see it, he needs to learn theory and code. I'd like to start him off with Python or Ruby or PHP. If he wants to get in to web, he's also going to need to learn HTML, CSS, Javascript, etc. Out of those three domains (Languages, Theory, Markup/Etc.), what is the best order do you think to learn in? Also, am I missing anything? Thanks! ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "14": 0.16572137900338368,
                    "applications": 0.10239053077795841,
                    "ask": 0.09521473827560174,
                    "best": 0.07859043321178802,
                    "books": 0.10856559095043729,
                    "bunch": 0.13408029000246482,
                    "buy": 0.13184505076435335,
                    "code": 0.05382151870699421,
                    "css": 0.13925953869276886,
                    "desktop": 0.12057096811300626,
                    "domains": 0.16572137900338368,
                    "experience": 0.16785148346684375,
                    "feel": 0.09472722800161511,
                    "figured": 0.1630933209118299,
                    "going": 0.16422906469616805,
                    "good": 0.06336427497774949,
                    "guidance": 0.1630933209118299,
                    "html": 0.11718360485970164,
                    "inclined": 0.15654904268897432,
                    "interested": 0.10801126854529228,
                    "javascript": 0.11758270908086642,
                    "languages": 0.08488317839549915,
                    "learn": 0.3357029669336875,
                    "learning": 0.09257027539445647,
                    "like": 0.05369695674189626,
                    "looking": 0.1817183890956839,
                    "markup": 0.16572137900338368,
                    "missing": 0.1325681008591476,
                    "mobile": 0.1434264491922576,
                    "need": 0.0680865363947401,
                    "needs": 0.09892341489140696,
                    "order": 0.21769488239969334,
                    "path": 0.1348722130770719,
                    "php": 0.10373915552091852,
                    "programming": 0.20679075618238604,
                    "python": 0.10541063594487386,
                    "question": 0.07356969055163648,
                    "real": 0.09424906355047559,
                    "ruby": 0.11924622415853832,
                    "server": 0.10111109742936472,
                    "start": 0.17130823997964245,
                    "started": 0.10305572971035017,
                    "technically": 0.14985760485535307,
                    "thanks": 0.11491445197710719,
                    "theory": 0.2766363270266589,
                    "think": 0.0638728714641776,
                    "wants": 0.12729731635355043,
                    "way": 0.06627360544843323,
                    "web": 0.1708628177049402,
                    "younger": 0.17583509049723245
                },
                "Max term": "learn",
                "Max score": 0.3357029669336875
            }
        ],
        "Best answer": "Register him an account for StackOverflow.com and Programmers.StackExchange.com and get him into the habit of browsing different questions when he is bored. Start with the hot/most popular questions.  Also Help him come up with a goal of something he wants to create that is slightly beyond his reach, a simple game, an app that can send a tweet? It has to be something that is exciting. This will help guide the topics he exposes himself to and provide him motivation through the tangible output he creates. And Where possible don't buy books in physical form if he works well with digital print, I am sure one of you has an android or iphone or blackberry or ipod touch? Get the ibooks or kindle app and buy digital versions. Having to deal with a physical book slows the process of knowledge acquisition; the tools built into digital readers provide many benefits to technical reading. Note: as mentioned in the comments, there are drawbacks to digital vs printed books, so take this point with a grain of salt ",
        "Best answer TF-IDF scores": [
            {
                "Scores": {
                    "account": 0.09007814310963248,
                    "acquisition": 0.1264337764990733,
                    "android": 0.10503806517404272,
                    "app": 0.14145122716370181,
                    "benefits": 0.08689054896719821,
                    "blackberry": 0.130335076430902,
                    "book": 0.07255162268261252,
                    "books": 0.15219140368508496,
                    "bored": 0.1264337764990733,
                    "browsing": 0.12055110991040639,
                    "built": 0.08270026123269432,
                    "buy": 0.18482544210456764,
                    "com": 0.15771275596602136,
                    "come": 0.06855434795899522,
                    "comments": 0.07956050122132947,
                    "create": 0.06696940464039389,
                    "creates": 0.09829538764095073,
                    "deal": 0.07817951807448195,
                    "different": 0.05532341229503559,
                    "digital": 0.5057351059962932,
                    "drawbacks": 0.11431523203592638,
                    "exciting": 0.12324618235663905,
                    "form": 0.08186089857831422,
                    "game": 0.08922512690984954,
                    "goal": 0.08617684317780379,
                    "guide": 0.09975317866091901,
                    "habit": 0.10972822209970812,
                    "help": 0.11899249067929897,
                    "hot": 0.11615728828237608,
                    "iphone": 0.10309346690930456,
                    "ipod": 0.130335076430902,
                    "knowledge": 0.06868243178460187,
                    "mentioned": 0.09397944304146116,
                    "motivation": 0.10609798750460811,
                    "note": 0.07752788871246265,
                    "output": 0.094534517090614,
                    "physical": 0.21945644419941623,
                    "point": 0.05964893944560077,
                    "popular": 0.08964643317560961,
                    "possible": 0.06311478928637021,
                    "print": 0.10134367137299649,
                    "printed": 0.12055110991040639,
                    "process": 0.06447529261361289,
                    "programmers": 0.060756853472509406,
                    "provide": 0.15103217946925027,
                    "questions": 0.131901336219586,
                    "reach": 0.10972822209970812,
                    "readers": 0.1264337764990733,
                    "reading": 0.07423401239470359,
                    "register": 0.11264888946952341,
                    "salt": 0.12324618235663905,
                    "send": 0.09900909343034515,
                    "simple": 0.06562386674440933,
                    "slightly": 0.09829538764095073,
                    "stackexchange": 0.10843256544725945,
                    "stackoverflow": 0.0880188994242535,
                    "start": 0.06003661306745312,
                    "sure": 0.062203991482703724,
                    "tangible": 0.1264337764990733,
                    "technical": 0.07072561358185091,
                    "tools": 0.06830096143687306,
                    "topics": 0.09694984974496619,
                    "touch": 0.09760967763656117,
                    "tweet": 0.130335076430902,
                    "versions": 0.09007814310963248,
                    "vs": 0.08298924903536951,
                    "wants": 0.08922512690984954,
                    "works": 0.0688114608868436
                },
                "Max term": "digital",
                "Max score": 0.5057351059962932
            }
        ]
    },
    {
        "ID": "24170",
        "Question": "Long time back, when I was reading my introductory programming books on (Basic, Pascal, C/C++), one thing that was emphasized is you can't become a professional programmer over night or over few weeks. It takes time to grasp programming and to apply it for solving problems and developing applications. Now, once someone has the grasp of basic programming, the person can quickly adapt to new technologies. In recent times, the use of frameworks in application development is prevalent. Though the learning curve for framework is way smaller than that of programming, even so they too would require some time to learn. Of course, different frameworks have different complexity, hence the learning curve would vary greatly. My question is, should one start to do commercial projects while they are learning a particular framework, or should a demo/learning project be done first to get the hang the framework and then proceed onto real projects? ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "adapt": 0.14058010490609282,
                    "application": 0.07571975647520793,
                    "applications": 0.08956218267440294,
                    "apply": 0.11187420523744962,
                    "basic": 0.1935017518533909,
                    "books": 0.09496357929761527,
                    "commercial": 0.12019501690282794,
                    "complexity": 0.11033344628458452,
                    "course": 0.08431409891320692,
                    "curve": 0.25967015900964174,
                    "demo": 0.14495840881557503,
                    "developing": 0.09728962804488975,
                    "development": 0.06597844843771718,
                    "different": 0.13808162940307117,
                    "emphasized": 0.15778294528790635,
                    "framework": 0.2605953895394372,
                    "frameworks": 0.20713275364559117,
                    "grasp": 0.28116020981218565,
                    "greatly": 0.1338130354443039,
                    "hang": 0.13693526005073794,
                    "learn": 0.07341081792528009,
                    "learning": 0.3238891663947837,
                    "long": 0.07482502897056548,
                    "new": 0.06278275402087366,
                    "night": 0.1338130354443039,
                    "particular": 0.08720604853569976,
                    "pascal": 0.1353183462135821,
                    "person": 0.08956218267440294,
                    "prevalent": 0.15044167552433624,
                    "problems": 0.08046189751320128,
                    "proceed": 0.15778294528790635,
                    "professional": 0.10356637682279558,
                    "programmer": 0.07424829885810279,
                    "programming": 0.2411763580071438,
                    "project": 0.06300826871277554,
                    "projects": 0.1481187883916361,
                    "question": 0.06435226006176138,
                    "quickly": 0.09812355192764913,
                    "reading": 0.0926402852188879,
                    "real": 0.08244074703455127,
                    "recent": 0.1194293821280805,
                    "require": 0.0986977522294303,
                    "smaller": 0.11187420523744962,
                    "solving": 0.11471175019406671,
                    "start": 0.07492265039605607,
                    "takes": 0.09424025276222224,
                    "technologies": 0.10393308044966182,
                    "thing": 0.0720827192249456,
                    "time": 0.1532507569063268,
                    "times": 0.09054074812329425,
                    "use": 0.05056484851929222,
                    "vary": 0.12865542182875955,
                    "way": 0.05797028995323502,
                    "weeks": 0.10754433276227861
                },
                "Max term": "learning",
                "Max score": 0.3238891663947837
            }
        ],
        "Best answer": "When one understands the need of a framework. ",
        "Best answer TF-IDF scores": [
            {
                "Scores": {
                    "framework": 0.49451672437227917,
                    "need": 0.3390483438117105,
                    "understands": 0.8003120827993587
                },
                "Max term": "understands",
                "Max score": 0.8003120827993587
            }
        ]
    },
    {
        "ID": "24578",
        "Question": "There are some issues about how to manage our program designs and programming styles. I was assigned to find a solution to write reusable code - though, the programming team does not follow the rules. I would rather use MVC to perform a well structured programming style. I found out that a blueprint for next works requires a bunch of experts. The thing is that I have to do it all myself. And the worse part is that I have to use a general MVC platform. I need your helps and suggestions for:  Is there a way that I can write a document for MVC - to use it in our design in Java? How can I represent it? How much work does it need? How can I connect the Model, the View, and the controller parts together?  ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "assigned": 0.16889717203275662,
                    "bunch": 0.14803137420016466,
                    "code": 0.05942165978004492,
                    "connect": 0.1750422902776139,
                    "controller": 0.18620833571703616,
                    "design": 0.09456645035423134,
                    "designs": 0.17743848410486113,
                    "document": 0.14188625595530738,
                    "experts": 0.15963111138268893,
                    "follow": 0.12048777504414623,
                    "general": 0.10859287044289939,
                    "helps": 0.13629749716875048,
                    "issues": 0.11720901641031474,
                    "java": 0.09595951709269177,
                    "manage": 0.1326201953052397,
                    "model": 0.128515925873127,
                    "mvc": 0.44671709114403046,
                    "need": 0.15034191150478,
                    "parts": 0.13466104411798427,
                    "perform": 0.1507423012420042,
                    "platform": 0.12279777519687163,
                    "program": 0.10319772202132846,
                    "programming": 0.22830738066726336,
                    "represent": 0.1707971568221112,
                    "requires": 0.13466104411798427,
                    "reusable": 0.1829647255966274,
                    "rules": 0.1380373718761214,
                    "solution": 0.11353171454680397,
                    "structured": 0.1654503221963152,
                    "style": 0.12687132643669916,
                    "styles": 0.16889717203275662,
                    "suggestions": 0.14329881463030997,
                    "team": 0.09675016057950032,
                    "thing": 0.09098192406368263,
                    "use": 0.19146699476960521,
                    "view": 0.13165382048356844,
                    "way": 0.07316938893517266,
                    "work": 0.06810118472208097,
                    "works": 0.10838811963704065,
                    "worse": 0.15271019939876943,
                    "write": 0.17298016055413906
                },
                "Max term": "mvc",
                "Max score": 0.44671709114403046
            }
        ],
        "Best answer": " MVC is just a design pattern - it's not a silver bullet. Ask yourself:  Are you actually designing a UI? There are lots of MVC frameworks out there, don't re-invent the wheel! UML is typically used to represent the MVC structure - there's a million generic diagrams out there already  ",
        "Best answer TF-IDF scores": [
            {
                "Scores": {
                    "actually": 0.11867967062177835,
                    "ask": 0.13106107339733897,
                    "bullet": 0.21548644617133092,
                    "design": 0.11790108453878953,
                    "designing": 0.18455868332363468,
                    "diagrams": 0.20069587016117924,
                    "frameworks": 0.16297592363074384,
                    "generic": 0.19589725917916298,
                    "invent": 0.24203328306990385,
                    "lots": 0.1486752266605942,
                    "million": 0.22449450673035537,
                    "mvc": 0.5569462460587943,
                    "pattern": 0.17441416334423043,
                    "represent": 0.2129420100896025,
                    "silver": 0.2482931432995315,
                    "structure": 0.16788917303297865,
                    "typically": 0.17136022479724183,
                    "ui": 0.17063737336237544,
                    "uml": 0.2182346465007277,
                    "used": 0.10392849125961909,
                    "wheel": 0.2129420100896025
                },
                "Max term": "mvc",
                "Max score": 0.5569462460587943
            }
        ]
    }
]