[
    {
        "ID": "49",
        "Question": "During my four years at university we have been using much functional programming in several functional programming languages. But I have also used much object oriented programming to, and in fact I use object oriented languages more when doing my own small project to prepare for my first job. But I often wish that I was coding in a functional programming language when doing these projects. However, when looking for a job, it is very rare to see a job where knowledge of a functional programming language is required. Why isn't functional programming languages used more in the industry? There is quite much news about functional programming languages these days, so I wonder if functional programming is catching on in the industry now? ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "coding": 0.07430680339466691,
                    "days": 0.08997018229731327,
                    "fact": 0.08852027791394888,
                    "functional": 0.6196419453976422,
                    "industry": 0.19203180212646126,
                    "job": 0.21779190647035968,
                    "knowledge": 0.08195563702666037,
                    "language": 0.12320219376794225,
                    "languages": 0.28653840806412145,
                    "looking": 0.07736897763363625,
                    "object": 0.18820820768430552,
                    "oriented": 0.19623836556226434,
                    "prepare": 0.11910354386788073,
                    "programming": 0.4444430249444303,
                    "project": 0.061796589253054736,
                    "projects": 0.07616777766925485,
                    "quite": 0.08355250199584843,
                    "rare": 0.12234306327855508,
                    "required": 0.09601590106323063,
                    "small": 0.07820970086727252,
                    "university": 0.10609426272914234,
                    "use": 0.04929188250037064,
                    "used": 0.12771712657130874,
                    "using": 0.06140740631350234,
                    "wish": 0.1308640252979215,
                    "wonder": 0.10453686308259699,
                    "years": 0.07696090115857489
                },
                "Max term": "functional",
                "Max score": 0.6196419453976422
            }
        ],
        "Best answer": "I was a professor and, just like programmers, professors are always looking for the Next Big Thing. When they think they've found one, they make it a bandwagon, and everyone piles on. Since they are preaching to students who think professors must be really smart, else why would they be professors, they get no resistance. Functional programming is such a bandwagon. Sure it's got lots of nice interesting questions to investigate, and lots of sort-of-interesting conference articles to write. It's not a particularly new idea, and you can do it in just about any modern language, and ideas don't have to be new to be interesting. It's also a good skill to have. Given that, functional programming is just one arrow to have in your quiver, not the only one, just as OOP is not the only one. My beef with computer science academia is lack of practical interplay with industry to determine what actually makes real-world sense, i.e. quality control. If that quality control were there, there might be a different emphasis, on classifying problems and the ranges of solutions to them, with tradeoffs, rather than just the latest bandwagons. ",
        "Best answer TF-IDF scores": [
            {
                "Scores": {
                    "academia": 0.16281731419902543,
                    "actually": 0.08951893270561613,
                    "articles": 0.13885941421541065,
                    "big": 0.10133681322326513,
                    "computer": 0.10327448575785017,
                    "conference": 0.16281731419902543,
                    "control": 0.21855416008824732,
                    "determine": 0.14818525626127255,
                    "different": 0.08760957269561334,
                    "functional": 0.22026884576244782,
                    "given": 0.11288924360410663,
                    "good": 0.07119814713004664,
                    "got": 0.10465094113138444,
                    "idea": 0.09428602405618806,
                    "ideas": 0.12498528221210461,
                    "industry": 0.11946026492708582,
                    "interesting": 0.3416280761646487,
                    "lack": 0.13199947709203688,
                    "language": 0.07664234019646525,
                    "latest": 0.14818525626127255,
                    "like": 0.05803912064854669,
                    "looking": 0.09626029087791788,
                    "lots": 0.24415421695088182,
                    "make": 0.07388751947358255,
                    "makes": 0.09157878590129978,
                    "modern": 0.13006180455745187,
                    "new": 0.15426215236248675,
                    "nice": 0.11824392403980286,
                    "oop": 0.13636737574362354,
                    "particularly": 0.13199947709203688,
                    "practical": 0.14818525626127255,
                    "problems": 0.09839589481870635,
                    "professor": 0.16281731419902543,
                    "programmers": 0.0872438798268313,
                    "programming": 0.13824085624602125,
                    "quality": 0.2319377423220361,
                    "questions": 0.10465094113138444,
                    "ranges": 0.16281731419902543,
                    "real": 0.09839589481870635,
                    "really": 0.0759259497971977,
                    "science": 0.13199947709203688,
                    "sense": 0.11708166096682691,
                    "skill": 0.13636737574362354,
                    "smart": 0.14161423493829334,
                    "solutions": 0.1282578745850446,
                    "sort": 0.11946026492708582,
                    "students": 0.14469386249520474,
                    "sure": 0.09575257368439553,
                    "thing": 0.09289738195957283,
                    "think": 0.13824085624602125,
                    "world": 0.10072157039267896,
                    "write": 0.08027244311488567
                },
                "Max term": "interesting",
                "Max score": 0.3416280761646487
            }
        ]
    },
    {
        "ID": "163",
        "Question": "Are there any great programming or software development books that are language agnostic?  Why should I read it? ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "agnostic": 0.5365079880612943,
                    "books": 0.4210561393582145,
                    "development": 0.29006439653819577,
                    "great": 0.35500871863563344,
                    "language": 0.27013775579854465,
                    "programming": 0.24362561588177936,
                    "read": 0.34487128080352614,
                    "software": 0.2709950436153421
                },
                "Max term": "agnostic",
                "Max score": 0.5365079880612943
            }
        ],
        "Best answer": "The Pragmatic Programmer: From Journeyman to Master - Andrew Hunt and David Thomas This book is all about how to write code that works and is maintainable. A key concept is being practical. Everything in the book is boiled down to 70 tips that are easy to remember that help you deliver better, higher-quality software. ",
        "Best answer TF-IDF scores": [
            {
                "Scores": {
                    "70": 0.26565156994329037,
                    "better": 0.13282704855470898,
                    "book": 0.3414954600419461,
                    "code": 0.0929857610195507,
                    "concept": 0.20392509606726783,
                    "david": 0.2561321256943475,
                    "deliver": 0.24835417340731675,
                    "easy": 0.16961004582700678,
                    "help": 0.14416211272334087,
                    "higher": 0.21536940646452996,
                    "hunt": 0.2561321256943475,
                    "key": 0.20392509606726783,
                    "maintainable": 0.24177800845023076,
                    "master": 0.2187840787180863,
                    "practical": 0.24177800845023076,
                    "pragmatic": 0.22249603878772864,
                    "programmer": 0.13732179442093506,
                    "quality": 0.1892139840288559,
                    "remember": 0.18579931177529954,
                    "software": 0.12544594218954838,
                    "tips": 0.21536940646452996,
                    "works": 0.17829570531457528,
                    "write": 0.13097194632866932
                },
                "Max term": "book",
                "Max score": 0.3414954600419461
            }
        ]
    },
    {
        "ID": "501",
        "Question": "No matter how much you love a programming language, there are always a few details in it that aren’t quite as nice as they could be. In this question, I would like to specifically focus on syntax elements. In a programming language that you use frequently (perhaps your favourite programming language, or perhaps the one you are forced to use at work), which syntax element do you find most unreadable, unclear, inconvenient or unpleasant? ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "details": 0.18317545622373252,
                    "element": 0.23862118228381987,
                    "elements": 0.23007035368584636,
                    "favourite": 0.23007035368584636,
                    "focus": 0.1934552933728247,
                    "forced": 0.23007035368584636,
                    "frequently": 0.1906154866031566,
                    "language": 0.33697557143689955,
                    "like": 0.0850607544781154,
                    "love": 0.20350905402368002,
                    "matter": 0.17329548206258788,
                    "nice": 0.17329548206258788,
                    "programming": 0.30390376526875507,
                    "question": 0.12241444891402051,
                    "quite": 0.1523520063182501,
                    "specifically": 0.18549858295948726,
                    "syntax": 0.3759433795017904,
                    "unclear": 0.23007035368584636,
                    "unreadable": 0.23007035368584636,
                    "use": 0.17976043840094827,
                    "work": 0.101036064721154
                },
                "Max term": "syntax",
                "Max score": 0.3759433795017904
            }
        ],
        "Best answer": "Semicolon insertion in JavaScript. I haven't really been bitten by it often, but it's just such a phenomenally bad idea it makes my head spin.  Here's the rules (from ECMA-262 Section 7.9)  When the program contains a token that is not allowed by the formal grammar, then a semicolon is inserted if (a) there is a line break at that point, or (b) the unexpected token was a closing brace. When the end of a file is reached, if the program cannot be parsed otherwise, then a semicolon is inserted. When a \"restricted production\" is encountered and contains a line terminator in a place where the grammar contains the annotation \"[no LineTerminator here]\", then a semicolon is inserted.    Example: return 1; // returns 1  return 1; // returns undefined  ",
        "Best answer TF-IDF scores": [
            {
                "Scores": {
                    "allowed": 0.15727984592136376,
                    "bad": 0.10690877032398308,
                    "break": 0.14444946576143317,
                    "contains": 0.4398044609240541,
                    "encountered": 0.16070014719162287,
                    "end": 0.10077256609508425,
                    "example": 0.09649440408121422,
                    "file": 0.12044354879553301,
                    "formal": 0.15727984592136376,
                    "grammar": 0.34869716275103674,
                    "head": 0.14444946576143317,
                    "idea": 0.10471610670041001,
                    "javascript": 0.1466014869746847,
                    "line": 0.2466042996348277,
                    "makes": 0.10170938919027551,
                    "place": 0.12537724648916687,
                    "point": 0.10367888939136123,
                    "production": 0.14244598194332142,
                    "program": 0.22108676502224905,
                    "reached": 0.17434858137551837,
                    "really": 0.08432500935191911,
                    "return": 0.28489196388664284,
                    "returns": 0.36165689277933555,
                    "rules": 0.14892584695747085,
                    "section": 0.16070014719162287,
                    "unexpected": 0.16070014719162287
                },
                "Max term": "contains",
                "Max score": 0.4398044609240541
            }
        ]
    },
    {
        "ID": "724",
        "Question": "When learning a new programming language you sometimes come across a language feature which  makes you wish you had it in your other programming languages that you know. What are some language feature which were at the time of learning very new to you and that you wish your other programming languages had.   An example of this is generators in Python or C#. Other examples may include list comprehensions in Python, template in C++ or LINQ in .NET or lazy evaluation in Haskell. What other semi-unique language features have you come across which were completely new and enlightening to you?  Are there other features of older programming languages which were unique and have fallen out of fashion? ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "come": 0.22161957815216562,
                    "completely": 0.12336654390654452,
                    "example": 0.08877623309998496,
                    "examples": 0.12206305156841789,
                    "fashion": 0.16636475928993869,
                    "feature": 0.2083770508411909,
                    "features": 0.20969644100385176,
                    "generators": 0.16636475928993869,
                    "haskell": 0.13701391111739122,
                    "include": 0.1261813863494624,
                    "know": 0.07254928126439911,
                    "language": 0.31324885908918537,
                    "languages": 0.2732028140070532,
                    "learning": 0.2046037715596999,
                    "linq": 0.16040319071578177,
                    "list": 0.11165799661346344,
                    "makes": 0.0935740940543396,
                    "net": 0.10170149437068687,
                    "new": 0.23643479784307764,
                    "older": 0.14784643588532007,
                    "programming": 0.2825056645424262,
                    "python": 0.22506803827723137,
                    "semi": 0.16040319071578177,
                    "template": 0.14784643588532007,
                    "time": 0.06557057136074648,
                    "unique": 0.29569287177064013,
                    "wish": 0.33272951857987737
                },
                "Max term": "wish",
                "Max score": 0.33272951857987737
            }
        ],
        "Best answer": "Practically anything in Haskell  Monads. Yes - the big scary word that makes increadibly easy parsers, IO, operations on Lists and other things so easy (once you notice common pattern) Arrows. The same for advanced users ;) Standard stuff like lambdas etc.  Currying functions Algebraic data types Pattern matching  And many more. PS. Yes. I am Haskell fanboy if anyone asked. ",
        "Best answer TF-IDF scores": [
            {
                "Scores": {
                    "advanced": 0.2049746654271033,
                    "asked": 0.15248719848660588,
                    "big": 0.14355466795681127,
                    "common": 0.14018511556163757,
                    "data": 0.14099920405411565,
                    "easy": 0.2945234255170006,
                    "functions": 0.18169129276186227,
                    "haskell": 0.3799128524400862,
                    "io": 0.23064851492778976,
                    "like": 0.0822187557334258,
                    "lists": 0.2006120365136694,
                    "makes": 0.12973135609647118,
                    "notice": 0.18699168151924564,
                    "operations": 0.1899564262200431,
                    "pattern": 0.3684935133291158,
                    "practically": 0.23064851492778976,
                    "standard": 0.15138145860256672,
                    "stuff": 0.14536183296754948,
                    "things": 0.10961568499794395,
                    "types": 0.16922851745749776,
                    "users": 0.14926433751229648,
                    "word": 0.1899564262200431,
                    "yes": 0.30061554741138113
                },
                "Max term": "haskell",
                "Max score": 0.3799128524400862
            }
        ]
    },
    {
        "ID": "811",
        "Question": "Literate programming has good ideals. Why do you think that this isn't mainstream? It is because it has failed to deliver? ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "deliver": 0.5449768073902389,
                    "failed": 0.5180461713318036,
                    "good": 0.2549101039296775,
                    "mainstream": 0.4971571471461307,
                    "programming": 0.2474712647271232,
                    "think": 0.2474712647271232
                },
                "Max term": "deliver",
                "Max score": 0.5449768073902389
            }
        ],
        "Best answer": "I first saw it in a book of Knuth's writings, and thought it looked neat.  Then I tried to use the literary programming display to comprehend what was going on in the program, and found it harder than it looked.  It may have been that I was too used to going through program listings, but it seemed confusing. Then I looked at the source code, and that turned me off then and there.  I'd have to learn to write programs in an entirely new way, with less correspondence between the program text and what the compiler saw, and saw no corresponding benefit. In addition, people can write long and convincing arguments that the code is doing X when it's actually doing Y, and I've run into my share of misleading comments.  I developed a fondness for reading the code to see what it's doing fairly early.  Literate programming is the antithesis of that. ",
        "Best answer TF-IDF scores": [
            {
                "Scores": {
                    "actually": 0.08884889139974537,
                    "addition": 0.1436108417123655,
                    "arguments": 0.13534667797880653,
                    "benefit": 0.13308865366990913,
                    "book": 0.1038676380787568,
                    "code": 0.1696926460610072,
                    "comments": 0.11983226449440221,
                    "compiler": 0.13308865366990913,
                    "confusing": 0.15107645293821154,
                    "convincing": 0.15580786303100702,
                    "developed": 0.13534667797880653,
                    "display": 0.15107645293821154,
                    "early": 0.1240497784122166,
                    "entirely": 0.13782006376270461,
                    "fairly": 0.12729787572024825,
                    "going": 0.16706858054847534,
                    "harder": 0.14055426489575518,
                    "knuth": 0.1615986409806679,
                    "learn": 0.08769532776323102,
                    "long": 0.08964744390745828,
                    "looked": 0.42166279468726553,
                    "new": 0.07655375688748402,
                    "people": 0.07227511005847563,
                    "program": 0.2963636652284685,
                    "programming": 0.13720613564509115,
                    "programs": 0.11204427758499642,
                    "reading": 0.10845915075026921,
                    "run": 0.0999676783330272,
                    "saw": 0.42166279468726553,
                    "share": 0.12562304244406308,
                    "source": 0.09605368727643891,
                    "text": 0.12729787572024825,
                    "thought": 0.11204427758499642,
                    "tried": 0.12116337209915054,
                    "turned": 0.13782006376270461,
                    "use": 0.06086853285541705,
                    "used": 0.07885633212371947,
                    "way": 0.07105843839655607,
                    "write": 0.1593432219340852
                },
                "Max term": "looked",
                "Max score": 0.42166279468726553
            }
        ]
    },
    {
        "ID": "966",
        "Question": "There are a lot of questions about what programming books should be on the programmer's bookshelf. How about non-programming related books that can help you become a better programmer or developer? It would also be interesting to know why they would help. My first choice would be Sun Tzu's \"Art of War\" (however cliché), because it made it obvious that the success of any project depends on the strength of its weakest link (and warfare is a big project). ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "art": 0.22582425682666904,
                    "better": 0.12406243941959483,
                    "big": 0.1544304144197611,
                    "books": 0.3640986455482678,
                    "choice": 0.1860372144473583,
                    "depends": 0.19046907352277803,
                    "developer": 0.13702911043281799,
                    "help": 0.2692991159699485,
                    "interesting": 0.17353932133658267,
                    "know": 0.1082026653620979,
                    "link": 0.20434758437589465,
                    "lot": 0.12728870532729178,
                    "non": 0.14669413947024287,
                    "obvious": 0.1928847017196842,
                    "programmer": 0.2565211978540697,
                    "programming": 0.21066966722922784,
                    "project": 0.2343367525314647,
                    "questions": 0.15948092005549053,
                    "related": 0.1860372144473583,
                    "strength": 0.2481225184284298,
                    "success": 0.22582425682666904,
                    "sun": 0.2481225184284298,
                    "war": 0.2392312158790379
                },
                "Max term": "books",
                "Max score": 0.3640986455482678
            }
        ],
        "Best answer": "The Design of Everyday Things by Donald Norman  ",
        "Best answer TF-IDF scores": [
            {
                "Scores": {
                    "design": 0.3587255147124199,
                    "donald": 0.6256604202319488,
                    "everyday": 0.6256604202319488,
                    "things": 0.29734505579321807
                },
                "Max term": "donald",
                "Max score": 0.6256604202319488
            }
        ]
    },
    {
        "ID": "1386",
        "Question": "Sometimes I feel like a musician who can't play live shows. Programming is a pretty cool skill, and a very broad world, but a lot of it happens \"off camera\"- in your head, in your office, away from spectators.  You can of course talk about programming with other programmers, and there is peer programming, and you do get to create something that you can show to people, but when it comes to explaining to non programmers what is it that you do, or how was your day at work, it's sort of tricky.  How do you get the non programmers in your life to understand what is it that you do?  NOTE: this is not a repeat of Getting non-programmers to understand the development process, because that question was about managing client expectations.  ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "away": 0.13096688979175816,
                    "client": 0.13096688979175816,
                    "comes": 0.14499994116772555,
                    "cool": 0.1765910190913488,
                    "course": 0.13330139764311716,
                    "create": 0.12140933747260235,
                    "day": 0.11981246186733097,
                    "development": 0.0954743797420311,
                    "expectations": 0.16786457715501898,
                    "explaining": 0.18212149398519323,
                    "feel": 0.11351400591909852,
                    "getting": 0.11480499357395303,
                    "happens": 0.1487965938066895,
                    "head": 0.15088939813724947,
                    "life": 0.14683890609760222,
                    "like": 0.06733328061126505,
                    "live": 0.15556534803393204,
                    "lot": 0.09690210826570762,
                    "managing": 0.16786457715501898,
                    "non": 0.33502512296766546,
                    "note": 0.14162606375385414,
                    "office": 0.16786457715501898,
                    "people": 0.0844813013010411,
                    "play": 0.15820471906817463,
                    "pretty": 0.11829546420516568,
                    "process": 0.11547169362818582,
                    "programmers": 0.40485910719204626,
                    "programming": 0.24056731722178445,
                    "question": 0.09690210826570762,
                    "repeat": 0.16786457715501898,
                    "shows": 0.16786457715501898,
                    "skill": 0.15820471906817463,
                    "sort": 0.13859016901616253,
                    "talk": 0.15088939813724947,
                    "understand": 0.20679598880750524,
                    "work": 0.07997918357845876,
                    "world": 0.11685073252444872
                },
                "Max term": "programmers",
                "Max score": 0.40485910719204626
            }
        ],
        "Best answer": "I don't even try. If they aren't tech oriented enough to have at least a basic understanding of programming, I am only going to bore them with the details. Usually I just go with something very high level like \"I create web sites\" or \"I write computer programs to do X\" ",
        "Best answer TF-IDF scores": [
            {
                "Scores": {
                    "basic": 0.2608256931050015,
                    "computer": 0.23006710961749943,
                    "create": 0.2331334730758373,
                    "details": 0.2784327843634954,
                    "going": 0.18749477289347502,
                    "high": 0.24343923640675807,
                    "level": 0.22173184977278146,
                    "like": 0.12929517522518844,
                    "oriented": 0.2719541742697251,
                    "programming": 0.15398127617959498,
                    "programs": 0.25148614192860685,
                    "sites": 0.2751034522677027,
                    "tech": 0.2987207626067987,
                    "try": 0.20796280523459326,
                    "understanding": 0.2897418779342074,
                    "usually": 0.23637027543928607,
                    "web": 0.21444141532836355,
                    "write": 0.1788248940079867
                },
                "Max term": "tech",
                "Max score": 0.2987207626067987
            }
        ]
    },
    {
        "ID": "3049",
        "Question": "I would like to do some web programming using functional programming. What decent web-frameworks exists for functional programming languages? ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "decent": 0.3464588185796234,
                    "frameworks": 0.28872285910450096,
                    "functional": 0.514991072648968,
                    "languages": 0.2083770035543695,
                    "like": 0.13569612577274245,
                    "programming": 0.48481304695373856,
                    "using": 0.17862724107533717,
                    "web": 0.45011531504717234
                },
                "Max term": "functional",
                "Max score": 0.514991072648968
            }
        ],
        "Best answer": "Compojure is an open source web framework for the Clojure programming language. http://en.wikibooks.org/wiki/Compojure ",
        "Best answer TF-IDF scores": [
            {
                "Scores": {
                    "clojure": 0.39980760077865585,
                    "en": 0.38548076594486025,
                    "framework": 0.26240558186647756,
                    "http": 0.3032389645176145,
                    "language": 0.18819982569270094,
                    "open": 0.24883857324794828,
                    "org": 0.3638777120728619,
                    "programming": 0.16972932312882863,
                    "source": 0.23764428972227872,
                    "web": 0.23637287063408788,
                    "wiki": 0.39980760077865585
                },
                "Max term": "clojure",
                "Max score": 0.39980760077865585
            }
        ]
    },
    {
        "ID": "4889",
        "Question": "why not combine the best features of the all existent programming languages and fit it in a universal programming language? ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "best": 0.32416217809422204,
                    "features": 0.3875453283245449,
                    "fit": 0.5244420670485217,
                    "language": 0.289461593534574,
                    "languages": 0.33660871479011956,
                    "programming": 0.5221059069697195
                },
                "Max term": "fit",
                "Max score": 0.5244420670485217
            }
        ],
        "Best answer": "For the same reason you don't use a Swiss army knife to carve a chicken...   The Swiss Army knife generally has a blade, as well as various tools, such as screwdrivers and can openers and many others. These attachments are stowed inside the handle of the knife through a pivot point mechanism... The design of the knife and its flexibility have both led to worldwide recognition...  ",
        "Best answer TF-IDF scores": [
            {
                "Scores": {
                    "army": 0.632220060141631,
                    "design": 0.1812432584450087,
                    "flexibility": 0.3047824410472191,
                    "generally": 0.21732845957270255,
                    "handle": 0.24573661934032429,
                    "inside": 0.2749442237456303,
                    "mechanism": 0.3161100300708155,
                    "point": 0.1812432584450087,
                    "reason": 0.19674555641010996,
                    "tools": 0.20898783117726322,
                    "use": 0.11906754682172192,
                    "various": 0.24901283251938083
                },
                "Max term": "army",
                "Max score": 0.632220060141631
            }
        ]
    },
    {
        "ID": "5597",
        "Question": "I've been doing design and programming for about as long as I can remember. If there's a programming problem, I can figure it out. (Though admittedly Stack Overflow has allowed me to skip the figuring out and get straight to the doing in many instances.) I've made games, esoteric programming languages, and widgets and gizmos galore. I'm currently working on a general-purpose programming language. There's nothing I do better than programming. Is a university education really more than just a formality? ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "admittedly": 0.23280540108197842,
                    "allowed": 0.21659094701026468,
                    "better": 0.12451111205044654,
                    "currently": 0.18465881251256813,
                    "design": 0.14277677287066293,
                    "education": 0.23280540108197842,
                    "figure": 0.1888721546915705,
                    "games": 0.1935822705163038,
                    "general": 0.17573535450883246,
                    "language": 0.11722011598246848,
                    "languages": 0.13631277333410585,
                    "long": 0.13814468587891546,
                    "overflow": 0.19616315075954857,
                    "problem": 0.12972425040977684,
                    "programming": 0.5285788886774402,
                    "purpose": 0.1888721546915705,
                    "really": 0.11612443746488138,
                    "remember": 0.1741669274373862,
                    "skip": 0.24901985515369213,
                    "stack": 0.1888721546915705,
                    "straight": 0.22130106283499798,
                    "university": 0.20188571975608036,
                    "working": 0.13288297835433252
                },
                "Max term": "programming",
                "Max score": 0.5285788886774402
            }
        ],
        "Best answer": "Hooboy.  This is a tough position to be in; you have my sympathies. I'm biased towards getting a degree, most likely because 1) I have one (BS in Computer Science) and 2) I've often found the knowledge gained pursuing it to be very useful.  But it's hardly a pre-requisite for a successful career; the IT world is rich with people who kick ass, are acknowledged as kicking ass, and who technically don't have more than a high school diploma. The nice thing about a university degree is that you can put it on hold and come back to it later when life permits.  (Though the dangerous thing about the previous sentence is that it's a good way to simply quit without admitting to yourself you're quitting.)  You can test the waters and see what kind of job you could get by sending your resume out today and seeing what kind of nibbles you get; you haven't committed to anything until you actually say yes to a job offer. And it sounds like your school is a bad fit for you, regardless.  If you're so consistently bored with everything they're throwing at you, then you may need to find a school that will do a better job of giving you your money's worth and making you work for that degree.  Have you considered transferring somewhere better?  Edit:  Based on your comments elsewhere, given how much you love the high-level theoretic aspects of programming, have you considered that the best way to continue to explore that and get paid may be a career in academia?  Which would definitely require you to get your degree.  :-) ",
        "Best answer TF-IDF scores": [
            {
                "Scores": {
                    "academia": 0.1220116867135638,
                    "actually": 0.06708350414661006,
                    "aspects": 0.1084303736797918,
                    "bad": 0.07213532855109177,
                    "based": 0.07790056644248579,
                    "best": 0.06431925340871379,
                    "better": 0.12201284742118507,
                    "biased": 0.11763948048253269,
                    "career": 0.17220929636791515,
                    "come": 0.08126774761224784,
                    "comments": 0.0904768544149887,
                    "committed": 0.1220116867135638,
                    "computer": 0.07739161073734653,
                    "considered": 0.18508251201833523,
                    "consistently": 0.1140671278782517,
                    "continue": 0.10405816744876069,
                    "dangerous": 0.11763948048253269,
                    "definitely": 0.08952087491865882,
                    "degree": 0.39566993042572246,
                    "edit": 0.08126774761224784,
                    "fit": 0.10405816744876069,
                    "getting": 0.07415708879446357,
                    "given": 0.08459669717385553,
                    "giving": 0.10048581484447972,
                    "good": 0.0533543134828929,
                    "hardly": 0.1140671278782517,
                    "high": 0.16377964371797082,
                    "hold": 0.1084303736797918,
                    "job": 0.20305930373542755,
                    "kind": 0.16377964371797082,
                    "knowledge": 0.07641172191167696,
                    "later": 0.09148187947625779,
                    "level": 0.07458773674436452,
                    "life": 0.09484906064601982,
                    "like": 0.04349323068334705,
                    "likely": 0.0825322955796766,
                    "love": 0.10405816744876069,
                    "making": 0.08188982185898541,
                    "money": 0.08610464818395758,
                    "need": 0.05743407110631155,
                    "nice": 0.08860937601569413,
                    "offer": 0.10048581484447972,
                    "paid": 0.10048581484447972,
                    "people": 0.05456981588538248,
                    "position": 0.09484906064601982,
                    "previous": 0.08860937601569413,
                    "programming": 0.051797316907851665,
                    "pursuing": 0.1220116867135638,
                    "quit": 0.11763948048253269,
                    "quitting": 0.1220116867135638,
                    "regardless": 0.1084303736797918,
                    "require": 0.08533616957265865,
                    "resume": 0.11104674678774289,
                    "say": 0.06356069314384916,
                    "school": 0.28454718193805945,
                    "science": 0.09891748260643062,
                    "seeing": 0.10048581484447972,
                    "simply": 0.08188982185898541,
                    "sounds": 0.09366120042017587,
                    "successful": 0.11763948048253269,
                    "technically": 0.1140671278782517,
                    "test": 0.06895098254590462,
                    "thing": 0.13923047828078616,
                    "throwing": 0.11763948048253269,
                    "today": 0.09611360861344859,
                    "tough": 0.1084303736797918,
                    "transferring": 0.11763948048253269,
                    "university": 0.09891748260643062,
                    "useful": 0.07895994297539562,
                    "way": 0.10730238659659101,
                    "work": 0.051661719875589984,
                    "world": 0.07547851254337462,
                    "worth": 0.08188982185898541,
                    "yes": 0.07951191448916779
                },
                "Max term": "degree",
                "Max score": 0.39566993042572246
            }
        ]
    },
    {
        "ID": "6974",
        "Question": "What's the worst programming-related or technical book you've ever read? This can be any book which one way or another can be connected to programming, as long as it's not fiction. ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "book": 0.5250121802089781,
                    "fiction": 0.4084104365391373,
                    "long": 0.22656720055735421,
                    "programming": 0.34676292705557726,
                    "read": 0.2454351410380172,
                    "related": 0.3062178332148711,
                    "technical": 0.2607570242194253,
                    "way": 0.17958695487295992,
                    "worst": 0.36294962754369153
                },
                "Max term": "book",
                "Max score": 0.5250121802089781
            }
        ],
        "Best answer": "Any book that allows you to teach yourself X in Y hours. I've read some in the past but once read you don't know any details whatsoever about X and you can't use the book as a reference for X either. After discovering that it seems better to go for the big books.  ",
        "Best answer TF-IDF scores": [
            {
                "Scores": {
                    "allows": 0.2677247650464391,
                    "better": 0.17219917986533353,
                    "big": 0.21435005497035461,
                    "book": 0.4427203554307474,
                    "books": 0.25268521418251205,
                    "details": 0.2643718631019597,
                    "hours": 0.24530013444815185,
                    "know": 0.1501857477715655,
                    "past": 0.25538360027406554,
                    "read": 0.4139299504719888,
                    "reference": 0.28844754001103656,
                    "teach": 0.3219704528724667,
                    "use": 0.12972153309130538
                },
                "Max term": "book",
                "Max score": 0.4427203554307474
            }
        ]
    },
    {
        "ID": "7126",
        "Question": "Note: this question is an edited excerpt from a blog posting I wrote a few months ago.  After placing a link to the blog in a comment on Programmers.SE someone requested that I post a question here so that they could answer it.  This posting is my most popular, as people seem to type \"I don't get object-oriented programming\" into Google a lot.  Feel free to answer here, or in a comment at Wordpress.  What is object-oriented programming?    No one has given me a satisfactory   answer.  I feel like you will not get   a good definition from someone who   goes around saying “object” and   “object-oriented” with his nose in the   air. Nor will you get a good   definition from someone who has done   nothing but object-oriented   programming. No one who understands   both procedural and object-oriented   programming has ever given me a   consistent idea of what an   object-oriented program actually does.  Can someone please give me their ideas of the advantages of object-oriented programming? ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "actually": 0.05468813662715785,
                    "advantages": 0.08063998552866819,
                    "ago": 0.07223656133708935,
                    "answer": 0.1764195275857416,
                    "blog": 0.16127997105733638,
                    "comment": 0.16383705774510862,
                    "consistent": 0.09299035215035867,
                    "definition": 0.15891247857038832,
                    "edited": 0.09590262260773272,
                    "feel": 0.11954976463389122,
                    "free": 0.06350647413451992,
                    "given": 0.13793065201660007,
                    "goes": 0.0715265215744323,
                    "good": 0.08699151967445652,
                    "google": 0.0715265215744323,
                    "idea": 0.05760040708453189,
                    "ideas": 0.0763549339051787,
                    "like": 0.03545676052892317,
                    "link": 0.08191852887255431,
                    "lot": 0.05102729016518701,
                    "months": 0.08191852887255431,
                    "note": 0.07457829741232427,
                    "object": 0.5722121725954584,
                    "oriented": 0.5220480818862699,
                    "people": 0.04448666754700908,
                    "popular": 0.07945623928519416,
                    "post": 0.07457829741232427,
                    "posting": 0.18105612512599703,
                    "procedural": 0.09590262260773272,
                    "program": 0.06080577318786972,
                    "programmers": 0.053298280884818465,
                    "programming": 0.21113228803507056,
                    "question": 0.10205458033037403,
                    "requested": 0.09590262260773272,
                    "saying": 0.07835419789780121,
                    "se": 0.09590262260773272,
                    "type": 0.06956816225086386,
                    "understands": 0.09590262260773272,
                    "wordpress": 0.09590262260773272,
                    "wrote": 0.0773233070268771
                },
                "Max term": "object",
                "Max score": 0.5722121725954584
            }
        ],
        "Best answer": "From your blog, it seems that you're familiar with both imperative and functional programming, and that you're familiar with the basic concepts involved in object-oriented programming, but you've just never really had it \"click\" as to what makes it useful.  I'll try to explain in terms of that knowledge, and hope that it's helpful to you. At its core, OOP is a way to use the imperative paradigm to better manage high degrees of complexity by creating \"smart\" data structures that model the problem domain.  In a (standard procedural non-object-oriented) program, you've got two basic things: variables, and code that knows what to do with them.  The code takes input from the user and various other sources, stores it in variables, operates on it, and produces output data which goes to the user or various other locations. Object-oriented programming is a way to simplify your program by taking that basic pattern and repeating it on a smaller scale.  Just like a program is a large collection of data with code that knows what to do with it, each object is a small piece of data bound to code that knows what to do with it. By breaking down the problem domain into smaller pieces and making sure as much data as possible is bound directly to code that knows what to do with it, you make it a lot easier to reason about the process as a whole and also about the sub-issues that make up the process. By grouping data into object classes, you can centralize code related to that data, making relevant code easier both to find and to debug.  And by encapsulating the data behind access specifiers and only accessing it through methods, (or properties, if your language supports them,) you greatly reduce the potential for data corruption or the violation of invariants. And by using inheritance and polymorphism, you can reuse preexisting classes, customizing them to fit your specific needs, without having to either modify the originals or rewrite everything from the ground up.  (Which is a thing you should never do, if you can avoid it.)  Just be careful you understand your base object, or you could end up with killer kangaroos. To me, these are the fundamental principles of object-oriented programming: complexity management, code centralization and improved problem-domain modeling through the creation of object classes, inheritance and polymorphism, and increased safety without sacrificing power or control through the use of encapsulation and properties.  I hope this helps you understand why so many programmers find it useful. EDIT: In response to Joel's question in the comments,  Can you explain what an \"object-oriented program\" contains   (other than these fancy defintions you've outlined) that is fundamentally   different from an imperative program? How do you \"get the ball rolling?\"  A little disclaimer here.  My model of \"an object-oriented program\" is basically the Delphi model, which is very similar to the C#/.NET model since they were created by former Delphi team members.  What I'm saying here may not apply, or not apply as much, in other OO languages. An object-oriented program is one in which all the logic is structured around objects.  Of course this has to be bootstrapped somewhere.  Your typical Delphi program contains initialization code that creates a singleton object called Application.  At the start of the program, it calls Application.Initialize, then a call to Application.CreateForm for every form you want to load into memory from the beginning, and then Application.Run, which displays the main form on screen and starts up the input/event loop that forms the core of any interactive computer programs. Application and your forms poll for incoming events from the OS and translate them into method calls on your object.  One thing that's very common is the use of event handlers, or \"delegates\" in .NET-speak.  An object has a method that says, \"do X and Y, but also check to see if this particular event handler is assigned, and call it if it is.\"  An event handler is a method pointer--a very simple closure that contains a reference to the method and a reference to the object instance--that's used to extend the behavior of objects.  For example, if I have a button object on my form, I customize its behavior by attaching an OnClick event handler, which causes some other object to execute a method when the button is clicked. So in an object-oriented program, most of the work gets done by defining objects with certain responsibilities and linking them together, either through method pointers or by one object directly calling a method defined in another object's public interface.  (And now we're back to encapsulation.)  This is an idea that I had no concept of back before I took OOP classes in college. ",
        "Best answer TF-IDF scores": [
            {
                "Scores": {
                    "access": 0.02776017766146112,
                    "application": 0.11575439922290588,
                    "apply": 0.06763691766699803,
                    "assigned": 0.04037791742779127,
                    "avoid": 0.02799599403267711,
                    "ball": 0.038931002079523866,
                    "base": 0.03138885824814028,
                    "basic": 0.08710708063360535,
                    "basically": 0.03180734122126882,
                    "beginning": 0.038931002079523866,
                    "behavior": 0.06887294497939674,
                    "better": 0.020189150773188277,
                    "blog": 0.032735240798891604,
                    "bound": 0.07786200415904773,
                    "breaking": 0.03588338783796577,
                    "button": 0.08075583485558253,
                    "called": 0.03180734122126882,
                    "calls": 0.06450941450257322,
                    "causes": 0.03774878615936171,
                    "certain": 0.028759726979710725,
                    "check": 0.02731281163144332,
                    "classes": 0.13301702627814485,
                    "click": 0.03588338783796577,
                    "code": 0.12720098899051593,
                    "collection": 0.04037791742779127,
                    "college": 0.035119654890932155,
                    "comments": 0.029941942899872877,
                    "common": 0.024541163954709625,
                    "complexity": 0.06763691766699803,
                    "computer": 0.025611579940636554,
                    "concept": 0.030995753920130417,
                    "concepts": 0.033818458833499015,
                    "contains": 0.09820572239667481,
                    "control": 0.027100194696604154,
                    "core": 0.06763691766699803,
                    "course": 0.028495027551605476,
                    "created": 0.03180734122126882,
                    "creates": 0.03674923684111211,
                    "creating": 0.030995753920130417,
                    "data": 0.22215312326712394,
                    "debug": 0.03180734122126882,
                    "defined": 0.03443647248969837,
                    "defining": 0.038931002079523866,
                    "delphi": 0.12113375228337378,
                    "different": 0.02172675620888436,
                    "directly": 0.07349847368222422,
                    "disclaimer": 0.04037791742779127,
                    "domain": 0.09976276970860865,
                    "easier": 0.05226119142256233,
                    "edit": 0.02689432865831478,
                    "end": 0.02250191512460201,
                    "event": 0.18374618420556055,
                    "events": 0.038931002079523866,
                    "example": 0.02154662697172748,
                    "execute": 0.038931002079523866,
                    "explain": 0.05226119142256233,
                    "extend": 0.038931002079523866,
                    "familiar": 0.06361468244253764,
                    "fit": 0.03443647248969837,
                    "form": 0.08710708063360535,
                    "forms": 0.07786200415904773,
                    "functional": 0.02731281163144332,
                    "fundamental": 0.04037791742779127,
                    "fundamentally": 0.038931002079523866,
                    "gets": 0.03225470725128661,
                    "goes": 0.02903569354453512,
                    "got": 0.025952934308806935,
                    "greatly": 0.03774878615936171,
                    "ground": 0.038931002079523866,
                    "grouping": 0.038931002079523866,
                    "helpful": 0.029625575982857064,
                    "helps": 0.03138885824814028,
                    "high": 0.027100194696604154,
                    "hope": 0.06763691766699803,
                    "idea": 0.02338248430558063,
                    "imperative": 0.1076501635138973,
                    "improved": 0.03774878615936171,
                    "initialization": 0.038931002079523866,
                    "input": 0.06763691766699803,
                    "instance": 0.03588338783796577,
                    "interactive": 0.04037791742779127,
                    "interface": 0.030995753920130417,
                    "involved": 0.02932392924367352,
                    "issues": 0.029941942899872877,
                    "joel": 0.03062512530110666,
                    "knowledge": 0.025287300593657382,
                    "knows": 0.11976777159949151,
                    "language": 0.01900693485302612,
                    "languages": 0.02210275924640922,
                    "large": 0.02731281163144332,
                    "like": 0.01439342512592964,
                    "little": 0.025611579940636554,
                    "load": 0.032735240798891604,
                    "locations": 0.03774878615936171,
                    "logic": 0.030274540702836226,
                    "loop": 0.038931002079523866,
                    "lot": 0.020714173246949207,
                    "main": 0.03062512530110666,
                    "make": 0.03664750490358467,
                    "makes": 0.022711102154282993,
                    "making": 0.05420038939320831,
                    "manage": 0.03588338783796577,
                    "management": 0.026501224330304923,
                    "members": 0.03225470725128661,
                    "memory": 0.033818458833499015,
                    "method": 0.19768497846346278,
                    "methods": 0.02799599403267711,
                    "model": 0.1210981628113449,
                    "modify": 0.03443647248969837,
                    "needs": 0.02903569354453512,
                    "net": 0.04936736072602754,
                    "non": 0.023872093061875366,
                    "object": 0.5807138708907024,
                    "objects": 0.09976276970860865,
                    "oo": 0.04037791742779127,
                    "oop": 0.06763691766699803,
                    "oriented": 0.2421963256226898,
                    "os": 0.032735240798891604,
                    "output": 0.032735240798891604,
                    "paradigm": 0.03674923684111211,
                    "particular": 0.026313262313193718,
                    "pattern": 0.03225470725128661,
                    "piece": 0.03588338783796577,
                    "pieces": 0.04037791742779127,
                    "pointer": 0.038931002079523866,
                    "pointers": 0.04037791742779127,
                    "possible": 0.023746181619240615,
                    "potential": 0.032735240798891604,
                    "power": 0.032735240798891604,
                    "principles": 0.03443647248969837,
                    "problem": 0.06310334252096392,
                    "procedural": 0.038931002079523866,
                    "process": 0.04936736072602754,
                    "program": 0.2468368036301377,
                    "programmers": 0.021636066121455674,
                    "programming": 0.06856614612652073,
                    "programs": 0.02799599403267711,
                    "properties": 0.07549757231872342,
                    "public": 0.033818458833499015,
                    "question": 0.020714173246949207,
                    "really": 0.01882927345055188,
                    "reason": 0.025131046393031566,
                    "reduce": 0.033818458833499015,
                    "reference": 0.06763691766699803,
                    "related": 0.030274540702836226,
                    "relevant": 0.030274540702836226,
                    "repeating": 0.03774878615936171,
                    "response": 0.03588338783796577,
                    "responsibilities": 0.03774878615936171,
                    "reuse": 0.03674923684111211,
                    "rewrite": 0.03443647248969837,
                    "rolling": 0.04037791742779127,
                    "run": 0.0249784691052065,
                    "saying": 0.03180734122126882,
                    "says": 0.030995753920130417,
                    "scale": 0.03674923684111211,
                    "screen": 0.032735240798891604,
                    "similar": 0.026313262313193718,
                    "simple": 0.0249784691052065,
                    "singleton": 0.04037791742779127,
                    "small": 0.02413149707478196,
                    "smaller": 0.07549757231872342,
                    "smart": 0.035119654890932155,
                    "sources": 0.03774878615936171,
                    "speak": 0.03774878615936171,
                    "specific": 0.026313262313193718,
                    "standard": 0.026501224330304923,
                    "start": 0.02250191512460201,
                    "starts": 0.03674923684111211,
                    "structured": 0.03588338783796577,
                    "structures": 0.03588338783796577,
                    "sub": 0.03774878615936171,
                    "supports": 0.03674923684111211,
                    "sure": 0.023746181619240615,
                    "takes": 0.026501224330304923,
                    "taking": 0.03325425656953621,
                    "team": 0.02413149707478196,
                    "terms": 0.03062512530110666,
                    "thing": 0.046076215376411975,
                    "things": 0.019189601454938674,
                    "took": 0.035119654890932155,
                    "translate": 0.03674923684111211,
                    "try": 0.023150879844581175,
                    "typical": 0.035119654890932155,
                    "understand": 0.04420551849281844,
                    "use": 0.045626830374412314,
                    "used": 0.01970347304796293,
                    "useful": 0.05226119142256233,
                    "user": 0.0488034253085246,
                    "using": 0.018947171890339277,
                    "variables": 0.06763691766699803,
                    "various": 0.06361468244253764,
                    "violation": 0.04037791742779127,
                    "want": 0.019067253758230596,
                    "way": 0.035510097618545886,
                    "work": 0.017096662750113095
                },
                "Max term": "object",
                "Max score": 0.5807138708907024
            }
        ]
    },
    {
        "ID": "7456",
        "Question": "Linguistic relativity is the idea that language shapes the way we think.  My question is, how much, and to what extent, does this apply to programming?  Are some native, natural languages better-suited for thinking about programming than others?  For instance, can the following be stated more concisely in a non-English language?  Select a pivot.  Move all the items less than the pivot to one side of the list, and all the items greater than the pivot to the other side. Does a Chinese-speaking programmer view programming in a radically different lens than an English-speaking programmer, or do the differences fade away when both are immersed in the subject? Are some programming languages and domains easier to think about in one language or another.  For instance, is it any easier to grok Ruby if you are Japanese because the creator of Ruby is Japanese?  Note that this question is not focused on \"how do programming languages affect the way people think about programming\", but rather \"how do natural languages affect the way people think about programming\". To get it out of the way, one language that clearly has a pragmatic advantage is English.  I think the advantage has little to do with programming languages choosing English keywords like if, for, while, and do, just as musicians who don't speak Italian aren't tripped up by words like forte.  It has more to do with communication of ideas with other programmers, as English is the lingua franca these days, at least in the programming world.  For instance, to ask a question in StackOverflow, you really need to know English and know it pretty well if you want good answers.  Although this sounds like an imperialist attitude, it really is true in practice. That aside, how do the intrinsic properties of languages affect how programmers who speak them think about data structures, algorithms, etc.?  Are any languages particularly concise when it comes to talking about logic and programming, allowing native speakers of those languages to think faster? ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "advantage": 0.13300056732972507,
                    "affect": 0.2071768282485119,
                    "algorithms": 0.06342533798769599,
                    "allowing": 0.07655353824347613,
                    "answers": 0.05603234093396383,
                    "apply": 0.06650028366486253,
                    "aside": 0.07226333661250173,
                    "ask": 0.049117415113099486,
                    "attitude": 0.07226333661250173,
                    "away": 0.05505104634776174,
                    "better": 0.039699746815185934,
                    "choosing": 0.07939873830337697,
                    "clearly": 0.0625456418417339,
                    "comes": 0.06094974458307341,
                    "communication": 0.0677155396186704,
                    "concise": 0.07939873830337697,
                    "creator": 0.07939873830337697,
                    "data": 0.048537745439991675,
                    "days": 0.054587339362890265,
                    "differences": 0.07056073967857124,
                    "different": 0.042723278967903046,
                    "easier": 0.102765890999785,
                    "english": 0.4143536564970238,
                    "extent": 0.0677155396186704,
                    "faster": 0.0595315580308996,
                    "focused": 0.07422884052644048,
                    "following": 0.057095501206133034,
                    "good": 0.034720159090412886,
                    "greater": 0.07655353824347613,
                    "idea": 0.04597908635535023,
                    "ideas": 0.06094974458307341,
                    "instance": 0.21168221903571371,
                    "items": 0.14845768105288096,
                    "know": 0.06924929800993598,
                    "language": 0.1495001963926011,
                    "languages": 0.3477011810381898,
                    "like": 0.08490926731721628,
                    "list": 0.053289555374771605,
                    "little": 0.05036235801113872,
                    "logic": 0.0595315580308996,
                    "native": 0.14845768105288096,
                    "natural": 0.13811788549900794,
                    "need": 0.03737504909815027,
                    "non": 0.04694184818133117,
                    "note": 0.0595315580308996,
                    "particularly": 0.06437025441288095,
                    "people": 0.07102228724890305,
                    "practice": 0.057662285040056806,
                    "pragmatic": 0.06650028366486253,
                    "pretty": 0.04972469830384862,
                    "programmer": 0.08208629989203901,
                    "programmers": 0.08508989375017353,
                    "programming": 0.3370694825028104,
                    "properties": 0.07422884052644048,
                    "question": 0.12219643747698598,
                    "radically": 0.07939873830337697,
                    "really": 0.0740513949396559,
                    "ruby": 0.12685067597539199,
                    "select": 0.07056073967857124,
                    "sounds": 0.06094974458307341,
                    "speak": 0.14845768105288096,
                    "speakers": 0.07655353824347613,
                    "speaking": 0.14845768105288096,
                    "stackoverflow": 0.06539084190163474,
                    "structures": 0.07056073967857124,
                    "subject": 0.06905894274950397,
                    "suited": 0.0677155396186704,
                    "talking": 0.05887754099386467,
                    "think": 0.23594863775196728,
                    "thinking": 0.050039542369058936,
                    "true": 0.061722741053765504,
                    "view": 0.06539084190163474,
                    "want": 0.037493659598001855,
                    "way": 0.13965341095089379,
                    "words": 0.06539084190163474,
                    "world": 0.049117415113099486
                },
                "Max term": "english",
                "Max score": 0.4143536564970238
            }
        ],
        "Best answer": "I don't know that any particular natural language lends itself to better programming (except maybe Latin?). I do know that knowing more than one language is pretty powerful. Dijkstra said in one of his last interviews (as reprinted in CACM Vol. 53 No. 8, p. 44):  There is an enormous difference   between one who is monolingual and   someone who at least knows a second   language well, because it makes you   much more conscious about language   structure in general. You will   discover that certain constructions in   one language you just can't translate.  ",
        "Best answer TF-IDF scores": [
            {
                "Scores": {
                    "better": 0.1177777935595374,
                    "certain": 0.1677761103029353,
                    "conscious": 0.22711245150922144,
                    "difference": 0.19399592430723195,
                    "dijkstra": 0.23555334627992564,
                    "general": 0.16623192872992382,
                    "interviews": 0.20089263750492473,
                    "know": 0.20544285995388972,
                    "knowing": 0.19728732068726607,
                    "knows": 0.17467282350062804,
                    "language": 0.5544054018092232,
                    "makes": 0.1324901443892824,
                    "maybe": 0.15809486848940224,
                    "natural": 0.20487813034313165,
                    "particular": 0.1535041276088242,
                    "powerful": 0.20933353227562895,
                    "pretty": 0.14751895720908598,
                    "programming": 0.09999887432594493,
                    "said": 0.14941071117205384,
                    "second": 0.17467282350062804,
                    "structure": 0.20933353227562895,
                    "translate": 0.21438465038812182
                },
                "Max term": "language",
                "Max score": 0.5544054018092232
            }
        ]
    },
    {
        "ID": "7551",
        "Question": "Why are there so many programming languages? And what prompts someone to create a programming languages in spite of the fact that other languages already exist? ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "create": 0.2910297678032157,
                    "exist": 0.34757869607060443,
                    "fact": 0.3062790947863856,
                    "languages": 0.7435645790283543,
                    "programming": 0.3844418775335006
                },
                "Max term": "languages",
                "Max score": 0.7435645790283543
            }
        ],
        "Best answer": "Programming languages evolve New programming languages often learn from existing languages and add, remove and combine features in a new way. There is a few different paradigms like object oriented and functional and many modern languages try to mix features from them both. There is also new problems that needs to be solved, e.g. the increase of multi-core CPUs. The most common solution to that have been threads, but some programming languages try to solve the concurrency problem in a different way e.g. the Actor Model. See Erlang - Software for a Concurrent World ",
        "Best answer TF-IDF scores": [
            {
                "Scores": {
                    "actor": 0.16858838570395152,
                    "add": 0.11735577899666433,
                    "common": 0.10627404878942429,
                    "concurrency": 0.14644882168943305,
                    "concurrent": 0.15914038128892274,
                    "core": 0.14644882168943305,
                    "different": 0.1881728473547639,
                    "erlang": 0.15539087375234198,
                    "existing": 0.125737341475791,
                    "features": 0.22039701528970285,
                    "functional": 0.11827650396913325,
                    "increase": 0.15208357371453896,
                    "languages": 0.4785734121797862,
                    "learn": 0.09488875242733943,
                    "like": 0.06232987020920911,
                    "mix": 0.17485416643870866,
                    "model": 0.13110209530681968,
                    "modern": 0.13967708860255607,
                    "multi": 0.1417580105090057,
                    "needs": 0.125737341475791,
                    "new": 0.2484998005010558,
                    "object": 0.125737341475791,
                    "oriented": 0.13110209530681968,
                    "paradigms": 0.15208357371453896,
                    "problem": 0.09108842207898749,
                    "problems": 0.10567016323881072,
                    "programming": 0.22269120890721658,
                    "remove": 0.1491250930175848,
                    "software": 0.0825696067196381,
                    "solution": 0.11922844583846717,
                    "solve": 0.12454228470389045,
                    "solved": 0.1634688700766238,
                    "threads": 0.15539087375234198,
                    "try": 0.20050701251673625,
                    "way": 0.15377436269098985,
                    "world": 0.10816777269695936
                },
                "Max term": "languages",
                "Max score": 0.4785734121797862
            }
        ]
    },
    {
        "ID": "7915",
        "Question": "I have been offered an interesting job, but there's a big caveat for me: they use pair programming. I hate the idea of pair programming, and I'm probably not suited for it: I like to do frequent pauses, I hate to see someone programming (I would constantly poke the pair away to code myself), I have to be in full control of the machine I'm working on, I like to work listening music, and basically I don't like to being tied to someone else. I'm not even a social person. I have however never actually worked with true pair programming (besides few times for a short time to help someone else or to solve a complex task together)... so it is pair programming really that bad? And given my attitude, should I refuse the job or should I leave my current one and give a try?  For people that asked about it: I'm looking for a job where formal design and development are used, as I hate my current job where we are \"coding in the wild\". The company is very interested in my technical profile so they insisted even when I specified I never worked with pair programming and that I probably wouldn't like it (besides being an unsociable loner programmer, I don't like and believe the very concept of pair programming). ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "actually": 0.06105480464101993,
                    "asked": 0.07341558430800439,
                    "attitude": 0.10106713293224802,
                    "away": 0.07699411181528563,
                    "bad": 0.06565262874129771,
                    "basically": 0.08747601473549578,
                    "believe": 0.07909451731802608,
                    "big": 0.06911498101341661,
                    "code": 0.03886955778157005,
                    "coding": 0.06305417397814703,
                    "company": 0.06565262874129771,
                    "complex": 0.08147576068040109,
                    "concept": 0.08524400099314465,
                    "constantly": 0.09658548406713256,
                    "control": 0.07453049955114684,
                    "current": 0.16295152136080218,
                    "design": 0.0636691602839821,
                    "development": 0.0561284236118096,
                    "formal": 0.09658548406713256,
                    "frequent": 0.10706738698734272,
                    "given": 0.07699411181528563,
                    "hate": 0.3212021609620282,
                    "help": 0.06026210367020545,
                    "idea": 0.06430611497636762,
                    "interested": 0.08234582765337377,
                    "interesting": 0.07766712887694179,
                    "job": 0.2464142022756783,
                    "leave": 0.08747601473549578,
                    "like": 0.19792277821199336,
                    "looking": 0.06565262874129771,
                    "machine": 0.08524400099314465,
                    "offered": 0.10106713293224802,
                    "pair": 0.5967080069520124,
                    "people": 0.0496657038203753,
                    "person": 0.07571979586365653,
                    "probably": 0.12610834795629405,
                    "profile": 0.11104666923685748,
                    "programmer": 0.0574027395634387,
                    "programming": 0.32999655779436265,
                    "really": 0.05178395108100933,
                    "short": 0.07985347592205239,
                    "social": 0.09868588956987301,
                    "solve": 0.07909451731802608,
                    "suited": 0.09470660732035825,
                    "task": 0.07341558430800439,
                    "technical": 0.07089975286884456,
                    "time": 0.04376764394482512,
                    "times": 0.07341558430800439,
                    "true": 0.08632510990288852,
                    "try": 0.0636691602839821,
                    "use": 0.04182738044026559,
                    "used": 0.05418816010725007,
                    "work": 0.04701895428017283,
                    "worked": 0.14576644265232033,
                    "working": 0.05925717102122116
                },
                "Max term": "pair",
                "Max score": 0.5967080069520124
            }
        ],
        "Best answer": "Guess what - nobody likes pair programming at first. When I first tried pair programming I was against the idea and I had tons of objections similar to yours.  I don't like to watch someone else coding, I like to listen to music, I feel I'll be quicker working on my own, I don't want to stop and explain myself constantly, etc etc etc. Then I tried it.  And guess what?  It still sucked.  We were having all kinds of problems - I wanted to work different hours to the other guy, we had different keyboard settings and shortcuts, our desks didn't work very well for pair programming etc etc. This went on for about a week.  During that week we were rewriting the entire legacy login system for a distributed application.  We had to learn how some seriously difficult threading issues work, figure out how remoting sinks worked, change tons and tons of legacy code to work with our new login module and pretty much do some of the most hectic coding I've had to do in my career.  After a week of this we deployed it.. and everything just worked.  Not a single bug.  Not one. That's when I figured there might be something to this pair programming nonsense.  We started to do more pair programming.  We even started to force everyone to work in pairs.  It rocked.  I probably learnt more in a month of doing that than I did in the previous 2 years.  The other issues didn't go away.  Sometimes you'll be stuck with a pair that you dislike.  It's gonna happen.  Sometimes you'll struggle to find overlapping working hours.  Sometimes you'll want to just work on your own.  But the advantages of pair programming are just incredible. Since then I've always tried to do as much pair programming as possible.  It's simply the best way of learning.  This company forces everyone to do pair programming? Where do I sign up?  It seems to me they are really enlightened and you will be in a really intense working environment.  Awesome. Having said that, make sure that the pairs are rotated often.  You don't want to be stuck developing with one other developer for months on end - you'll go out of your mind.  We're all human, after all.  Also, check that this has been an ongoing practice for a while.  If it's not, it's not the end of the world, but if it's an accepted practice it's a massive green light. Trust me, you want to work for a company like that. ",
        "Best answer TF-IDF scores": [
            {
                "Scores": {
                    "accepted": 0.06799983135801022,
                    "advantages": 0.062034021532195324,
                    "application": 0.0438714407995631,
                    "away": 0.053053041745063555,
                    "awesome": 0.07651706656227254,
                    "best": 0.04033646879961633,
                    "bug": 0.053998721547716406,
                    "career": 0.053998721547716406,
                    "change": 0.04733476377440063,
                    "check": 0.05175839564641659,
                    "code": 0.026783194493431348,
                    "coding": 0.08689536499332691,
                    "company": 0.09047631230921564,
                    "constantly": 0.06655254015364143,
                    "deployed": 0.07377512925925679,
                    "developer": 0.042257613820654946,
                    "developing": 0.05502329583000667,
                    "different": 0.0823453886144822,
                    "difficult": 0.05556950899753909,
                    "dislike": 0.07153480335795698,
                    "distributed": 0.06799983135801022,
                    "end": 0.0852832759612666,
                    "entire": 0.062034021532195324,
                    "environment": 0.05022041935892338,
                    "explain": 0.04951806974511678,
                    "feel": 0.04598309774517002,
                    "figure": 0.0580353049493791,
                    "figured": 0.07651706656227254,
                    "force": 0.06964063479778905,
                    "forces": 0.07153480335795698,
                    "gonna": 0.07153480335795698,
                    "green": 0.06964063479778905,
                    "guess": 0.12406804306439065,
                    "guy": 0.06301756815369466,
                    "happen": 0.0580353049493791,
                    "hours": 0.1090006658988647,
                    "human": 0.06525789405499448,
                    "idea": 0.044310336490261025,
                    "issues": 0.1134813177014643,
                    "keyboard": 0.06655254015364143,
                    "learn": 0.04152379742142879,
                    "learning": 0.04705227379327677,
                    "legacy": 0.13310508030728285,
                    "light": 0.06964063479778905,
                    "like": 0.08182759824520915,
                    "likes": 0.07153480335795698,
                    "listen": 0.07377512925925679,
                    "login": 0.15303413312454509,
                    "make": 0.03472392523789196,
                    "massive": 0.07651706656227254,
                    "mind": 0.05175839564641659,
                    "module": 0.07377512925925679,
                    "month": 0.06027563085067891,
                    "months": 0.06301756815369466,
                    "new": 0.036248256023714946,
                    "nonsense": 0.07377512925925679,
                    "ongoing": 0.07651706656227254,
                    "pair": 0.5286388910686713,
                    "pairs": 0.14306960671591396,
                    "possible": 0.04499955112367069,
                    "practice": 0.11113901799507818,
                    "pretty": 0.047920006428397874,
                    "previous": 0.05556950899753909,
                    "probably": 0.043447682496663455,
                    "problems": 0.04624179725808539,
                    "programming": 0.2598687946927372,
                    "really": 0.07136379792304316,
                    "rewriting": 0.07377512925925679,
                    "said": 0.04853452312361745,
                    "seriously": 0.06112339959352673,
                    "settings": 0.06964063479778905,
                    "shortcuts": 0.07377512925925679,
                    "sign": 0.06655254015364143,
                    "similar": 0.049864227086248665,
                    "simply": 0.05135548174714359,
                    "single": 0.05022041935892338,
                    "started": 0.09972845417249733,
                    "stop": 0.06301756815369466,
                    "struggle": 0.06964063479778905,
                    "stuck": 0.14306960671591396,
                    "sure": 0.04499955112367069,
                    "threading": 0.07377512925925679,
                    "tons": 0.2295511996868176,
                    "tried": 0.17211281762442293,
                    "trust": 0.06525789405499448,
                    "want": 0.1445315081033965,
                    "wanted": 0.06525789405499448,
                    "watch": 0.06799983135801022,
                    "way": 0.03364621897563405,
                    "week": 0.1762129636895571,
                    "went": 0.0587376545631857,
                    "work": 0.2267899375414326,
                    "worked": 0.10044083871784676,
                    "working": 0.12249403598909042,
                    "world": 0.04733476377440063,
                    "years": 0.04499955112367069
                },
                "Max term": "pair",
                "Max score": 0.5286388910686713
            }
        ]
    },
    {
        "ID": "8748",
        "Question": "Quote from Wikipedia of the article \"High-level programming language\":  A high-level programming language is a programming language with strong abstraction from the details of the computer. In comparison to low-level programming languages, it may use natural language elements, be easier to use, or be more portable across platforms. Such languages hide the details of CPU operations such as memory access models and management of scope.  I.e., as the level of programming language increases, the further away the programmer goes from the hardware on which the program runs. Now I do not know the statistics of language usages across levels, but I would suspect that the higher level languages more and more are replacing the lower level languages. If so, can this lead to a deficit of programmers with computer architecture knowledge? Would this be a problem for the industry? ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "abstraction": 0.10682840904482156,
                    "access": 0.08917882762389616,
                    "architecture": 0.10682840904482156,
                    "article": 0.10218023222105997,
                    "away": 0.08993638140384762,
                    "computer": 0.16455302992332854,
                    "details": 0.1991460594831457,
                    "easier": 0.08394383923130164,
                    "elements": 0.1250648020345799,
                    "goes": 0.09327638825392459,
                    "hardware": 0.09957302974157285,
                    "hide": 0.1250648020345799,
                    "high": 0.17411730003281858,
                    "higher": 0.10516108477518418,
                    "increases": 0.1250648020345799,
                    "industry": 0.09517136979644213,
                    "know": 0.05656596641621805,
                    "knowledge": 0.08123477624014332,
                    "language": 0.3663556165066904,
                    "languages": 0.2840180896370039,
                    "lead": 0.10083586687227562,
                    "level": 0.4757739744452404,
                    "levels": 0.11805593960996204,
                    "low": 0.10218023222105997,
                    "lower": 0.11062624604154696,
                    "management": 0.08513447374853991,
                    "memory": 0.1086408937146442,
                    "models": 0.11527442286530855,
                    "natural": 0.11282095121736752,
                    "operations": 0.10682840904482156,
                    "platforms": 0.1086408937146442,
                    "portable": 0.1297129788583415,
                    "problem": 0.06757259954404922,
                    "program": 0.07929566240754006,
                    "programmer": 0.06705181159032769,
                    "programmers": 0.06950528323826871,
                    "programming": 0.2753336362261789,
                    "quote": 0.1036173836169291,
                    "runs": 0.11282095121736752,
                    "scope": 0.11062624604154696,
                    "strong": 0.10682840904482156,
                    "suspect": 0.11805593960996204,
                    "use": 0.09771664746063688,
                    "wikipedia": 0.10682840904482156
                },
                "Max term": "level",
                "Max score": 0.4757739744452404
            }
        ],
        "Best answer": "It can, but likely won't lead to a problem. It's just economics.  If the vast majority of people lose the ability to understand the underlying architecture, and there is still a huge NEED to understand the underlying architecture, then the ones who do will have jobs and get paid more, while those who don't will only have jobs where that is not needed (and may still get paid more...who knows?). Is it helpful to know? Absolutely. You'll likely be better.  Is it necessary in most cases?  No.  That's why abstraction is so great, we stand on the shoulders of giants without having to be giants ourselves (but there will always be giants around). ",
        "Best answer TF-IDF scores": [
            {
                "Scores": {
                    "ability": 0.14722706255272294,
                    "absolutely": 0.1635139886706615,
                    "abstraction": 0.1635139886706615,
                    "architecture": 0.327027977341323,
                    "better": 0.09927175980898573,
                    "cases": 0.13765866759074313,
                    "great": 0.12282124262013433,
                    "helpful": 0.14567145969699455,
                    "huge": 0.14567145969699455,
                    "jobs": 0.31279876735316525,
                    "know": 0.08658115265805179,
                    "knows": 0.14722706255272294,
                    "lead": 0.15434166754680181,
                    "likely": 0.26859880402552755,
                    "lose": 0.16932704421654182,
                    "majority": 0.1914270258803607,
                    "necessary": 0.13765866759074313,
                    "need": 0.09345870426310537,
                    "needed": 0.13765866759074313,
                    "ones": 0.13765866759074313,
                    "paid": 0.327027977341323,
                    "people": 0.08879788923692751,
                    "problem": 0.10342815525462891,
                    "stand": 0.1806991019007726,
                    "underlying": 0.3712279406689607,
                    "understand": 0.21736226864374134,
                    "vast": 0.18561397033448035
                },
                "Max term": "underlying",
                "Max score": 0.3712279406689607
            }
        ]
    }
]