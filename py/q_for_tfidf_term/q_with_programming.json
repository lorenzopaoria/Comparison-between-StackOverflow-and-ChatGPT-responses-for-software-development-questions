[
    {
        "ID": "39",
        "Question": "What's your favourite quote about programming? One quote per answer, and please check for duplicates before posting! ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "answer": 0.37933870912174267,
                    "check": 0.43870424261910873,
                    "favourite": 0.5552479607013989,
                    "posting": 0.5315762983647503,
                    "programming": 0.26975372550460147
                },
                "Max term": "favourite",
                "Max score": 0.5552479607013989
            }
        ],
        "Best answer": " Debugging is twice as hard as writing the code in the first place. Therefore, if you write the code as cleverly as possible, you are, by definition, not smart enough to debug it.    — Brian W. Kernighan ",
        "Best answer TF-IDF scores": [
            {
                "Scores": {
                    "code": 0.40851829847944604,
                    "definition": 0.47253449505536155,
                    "hard": 0.38242963449161704,
                    "place": 0.38242963449161704,
                    "possible": 0.34180674630984414,
                    "write": 0.29458356784772927,
                    "writing": 0.33720582712436786
                },
                "Max term": "definition",
                "Max score": 0.47253449505536155
            }
        ]
    },
    {
        "ID": "49",
        "Question": "During my four years at university we have been using much functional programming in several functional programming languages. But I have also used much object oriented programming to, and in fact I use object oriented languages more when doing my own small project to prepare for my first job. But I often wish that I was coding in a functional programming language when doing these projects. However, when looking for a job, it is very rare to see a job where knowledge of a functional programming language is required. Why isn't functional programming languages used more in the industry? There is quite much news about functional programming languages these days, so I wonder if functional programming is catching on in the industry now? ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "coding": 0.07348273758717556,
                    "days": 0.09442020201953659,
                    "fact": 0.08827914011575275,
                    "functional": 0.6309558190378302,
                    "industry": 0.21393501118382377,
                    "job": 0.22899957511668115,
                    "knowledge": 0.08498853233035374,
                    "language": 0.11918968446584587,
                    "languages": 0.29044529143018444,
                    "looking": 0.08657049272392736,
                    "object": 0.21393501118382377,
                    "oriented": 0.18884040403907318,
                    "prepare": 0.10696750559191189,
                    "programming": 0.4342538706878649,
                    "project": 0.06367324039657121,
                    "projects": 0.08213807821196892,
                    "quite": 0.08827914011575275,
                    "required": 0.0997849348589309,
                    "small": 0.08213807821196892,
                    "university": 0.10696750559191189,
                    "use": 0.05063234959598797,
                    "used": 0.12515659601236068,
                    "using": 0.06542875212456516,
                    "wonder": 0.10696750559191189,
                    "years": 0.0784696429251484
                },
                "Max term": "functional",
                "Max score": 0.6309558190378302
            }
        ],
        "Best answer": "I would say that one of the reasons that functional programming is not more prevalent is the lack of knowledge base.  My experience is that corporations are very risk averse in terms of implementing technologies that are not main stream and would rather invest in tried and true frameworks (java, c++, c#).  It's only when there is a business need (like in Ericsson) that new paradigms are considered.  But even in Ericsson's case I heard that management demanded that c++ be used and Joe Armstrong was compelled to code erlang calls in c++!! This should show how reluctant corporations are to implement new technologies! ",
        "Best answer TF-IDF scores": [
            {
                "Scores": {
                    "base": 0.19464546770762092,
                    "business": 0.17405377652772425,
                    "calls": 0.1884315601695211,
                    "case": 0.16670428382753238,
                    "code": 0.08731493509014085,
                    "considered": 0.1884315601695211,
                    "erlang": 0.2019949604078128,
                    "experience": 0.14047870385624225,
                    "frameworks": 0.17830092291201466,
                    "functional": 0.17021176528646717,
                    "heard": 0.17830092291201466,
                    "implement": 0.1884315601695211,
                    "java": 0.14414583149382632,
                    "knowledge": 0.16049037628943258,
                    "lack": 0.19464546770762092,
                    "like": 0.08778640955740791,
                    "main": 0.17405377652772425,
                    "management": 0.16049037628943258,
                    "need": 0.12023907262090121,
                    "new": 0.2426281717192393,
                    "paradigms": 0.2019949604078128,
                    "programming": 0.10250436912026029,
                    "reasons": 0.17405377652772425,
                    "risk": 0.2019949604078128,
                    "say": 0.12472264553291082,
                    "technologies": 0.38929093541524185,
                    "terms": 0.2109900125032272,
                    "tried": 0.1884315601695211,
                    "true": 0.17830092291201466,
                    "used": 0.11817140876754717
                },
                "Max term": "technologies",
                "Max score": 0.38929093541524185
            }
        ]
    },
    {
        "ID": "163",
        "Question": "Are there any great programming or software development books that are language agnostic?  Why should I read it? ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "agnostic": 0.4860681199705606,
                    "books": 0.4095870143622821,
                    "development": 0.3001248234586737,
                    "great": 0.37950169457330235,
                    "language": 0.27080329455012836,
                    "programming": 0.24666014382963883,
                    "read": 0.3732413973155734,
                    "software": 0.29731300511518993
                },
                "Max term": "agnostic",
                "Max score": 0.4860681199705606
            }
        ],
        "Best answer": "The Pragmatic Programmer: From Journeyman to Master - Andrew Hunt and David Thomas This book is all about how to write code that works and is maintainable. A key concept is being practical. Everything in the book is boiled down to 70 tips that are easy to remember that help you deliver better, higher-quality software. ",
        "Best answer TF-IDF scores": [
            {
                "Scores": {
                    "better": 0.17020129987810437,
                    "book": 0.4030746649100853,
                    "code": 0.10964656889966348,
                    "concept": 0.23662474264762293,
                    "deliver": 0.253657112851028,
                    "easy": 0.19804488344836696,
                    "help": 0.17865764992512823,
                    "higher": 0.23662474264762293,
                    "key": 0.253657112851028,
                    "maintainable": 0.253657112851028,
                    "master": 0.253657112851028,
                    "pragmatic": 0.2649527359688568,
                    "programmer": 0.17020129987810437,
                    "quality": 0.2137450601177085,
                    "remember": 0.22390309754869528,
                    "software": 0.15515429914463358,
                    "tips": 0.23662474264762293,
                    "works": 0.23662474264762293,
                    "write": 0.1581328307150475
                },
                "Max term": "book",
                "Max score": 0.4030746649100853
            }
        ]
    },
    {
        "ID": "501",
        "Question": "No matter how much you love a programming language, there are always a few details in it that aren’t quite as nice as they could be. In this question, I would like to specifically focus on syntax elements. In a programming language that you use frequently (perhaps your favourite programming language, or perhaps the one you are forced to use at work), which syntax element do you find most unreadable, unclear, inconvenient or unpleasant? ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "details": 0.19303375627445155,
                    "elements": 0.22842391382342644,
                    "favourite": 0.22842391382342644,
                    "focus": 0.22842391382342644,
                    "forced": 0.22842391382342644,
                    "frequently": 0.19303375627445155,
                    "language": 0.3655091602671271,
                    "like": 0.09504011594531117,
                    "love": 0.22842391382342644,
                    "matter": 0.20400147832171975,
                    "nice": 0.1981739768570867,
                    "programming": 0.33292261895230085,
                    "question": 0.13633118361213784,
                    "quite": 0.18047889808259926,
                    "specifically": 0.210728835048939,
                    "syntax": 0.421457670097878,
                    "use": 0.20702672568932798,
                    "work": 0.11907916888733364
                },
                "Max term": "syntax",
                "Max score": 0.421457670097878
            }
        ],
        "Best answer": "Semicolon insertion in JavaScript. I haven't really been bitten by it often, but it's just such a phenomenally bad idea it makes my head spin.  Here's the rules (from ECMA-262 Section 7.9)  When the program contains a token that is not allowed by the formal grammar, then a semicolon is inserted if (a) there is a line break at that point, or (b) the unexpected token was a closing brace. When the end of a file is reached, if the program cannot be parsed otherwise, then a semicolon is inserted. When a \"restricted production\" is encountered and contains a line terminator in a place where the grammar contains the annotation \"[no LineTerminator here]\", then a semicolon is inserted.    Example: return 1; // returns 1  return 1; // returns undefined  ",
        "Best answer TF-IDF scores": [
            {
                "Scores": {
                    "bad": 0.1396097381462379,
                    "break": 0.1693210733645856,
                    "contains": 0.5271430757668044,
                    "encountered": 0.18353910731647116,
                    "end": 0.13280146599141684,
                    "example": 0.11173473799393592,
                    "file": 0.1422084072872233,
                    "formal": 0.1693210733645856,
                    "head": 0.1757143585889348,
                    "idea": 0.14501518378301884,
                    "javascript": 0.15923321773490443,
                    "line": 0.2792194762924758,
                    "makes": 0.13280146599141684,
                    "place": 0.1422084072872233,
                    "point": 0.13079714983113327,
                    "production": 0.18353910731647116,
                    "program": 0.2844168145744466,
                    "reached": 0.18353910731647116,
                    "really": 0.10553048819430617,
                    "return": 0.3102060788254,
                    "rules": 0.1757143585889348,
                    "section": 0.1757143585889348,
                    "unexpected": 0.18353910731647116
                },
                "Max term": "contains",
                "Max score": 0.5271430757668044
            }
        ]
    },
    {
        "ID": "724",
        "Question": "When learning a new programming language you sometimes come across a language feature which  makes you wish you had it in your other programming languages that you know. What are some language feature which were at the time of learning very new to you and that you wish your other programming languages had.   An example of this is generators in Python or C#. Other examples may include list comprehensions in Python, template in C++ or LINQ in .NET or lazy evaluation in Haskell. What other semi-unique language features have you come across which were completely new and enlightening to you?  Are there other features of older programming languages which were unique and have fallen out of fashion? ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "come": 0.2727673119604116,
                    "completely": 0.13971160072767513,
                    "example": 0.1006468935820348,
                    "examples": 0.1363836559802058,
                    "feature": 0.2515115121849168,
                    "features": 0.26124959939997955,
                    "haskell": 0.14343192643419173,
                    "include": 0.14343192643419173,
                    "know": 0.08750194265423891,
                    "language": 0.35272497306253,
                    "languages": 0.3223243732929978,
                    "learning": 0.23221978320557246,
                    "list": 0.11610989160278623,
                    "makes": 0.11962309354412007,
                    "net": 0.12153799867230443,
                    "new": 0.28517494216155825,
                    "programming": 0.32127819099262833,
                    "python": 0.2667463275284395,
                    "time": 0.08492203904803086,
                    "unique": 0.330651708392158
                },
                "Max term": "language",
                "Max score": 0.35272497306253
            }
        ],
        "Best answer": "Practically anything in Haskell  Monads. Yes - the big scary word that makes increadibly easy parsers, IO, operations on Lists and other things so easy (once you notice common pattern) Arrows. The same for advanced users ;) Standard stuff like lambdas etc.  Currying functions Algebraic data types Pattern matching  And many more. PS. Yes. I am Haskell fanboy if anyone asked. ",
        "Best answer TF-IDF scores": [
            {
                "Scores": {
                    "asked": 0.15636269863717944,
                    "big": 0.1648004939892921,
                    "common": 0.14937925741588817,
                    "data": 0.14729486305530992,
                    "easy": 0.31797067274771057,
                    "functions": 0.19622044199483785,
                    "haskell": 0.36905993735258497,
                    "like": 0.0884967335091975,
                    "lists": 0.20362940313353597,
                    "makes": 0.15389910916929306,
                    "notice": 0.20362940313353597,
                    "operations": 0.2126972387154055,
                    "pattern": 0.3924408839896757,
                    "practically": 0.2126972387154055,
                    "standard": 0.1617889845692889,
                    "stuff": 0.1648004939892921,
                    "things": 0.11618871414421617,
                    "types": 0.18452996867629248,
                    "users": 0.1617889845692889,
                    "word": 0.20362940313353597,
                    "yes": 0.31797067274771057
                },
                "Max term": "pattern",
                "Max score": 0.3924408839896757
            }
        ]
    },
    {
        "ID": "811",
        "Question": "Literate programming has good ideals. Why do you think that this isn't mainstream? It is because it has failed to deliver? ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "deliver": 0.51244016298256,
                    "failed": 0.493795265953833,
                    "good": 0.292392762030301,
                    "mainstream": 0.51244016298256,
                    "programming": 0.2600429016266636,
                    "think": 0.27903504452357747
                },
                "Max term": "deliver",
                "Max score": 0.51244016298256
            }
        ],
        "Best answer": "I would blame the network effect. For other people to edit your code and documentation, they must be able to understand it.   This pushes people away from something like cweb/noweb, because using them would require you to learn TeX and the program-specific syntax on top of the programming language you are using for the project. This can be seen as a huge waste of time, especially if they don't need any of the math typesetting that is such a big draw for TeX in the first place. (And for many applications programmers, they really won't need it.) Instead they prefer something like Visual Studio's XML comments, because that's already popular and well-established.  The places I have seen literate programming take off are in scientific/statistical computing, where most of the programmers have significant training (aka PhDs) in math, CS, or statistics, and thus are already famliiar with LaTeX. The documentation they write is more likely to include a lot of complicated formulae that are best written in TeX, and they are more likely to be programming in R. The proportion of R programmers who know about SWeave is definitely much higher than, say, the proportion of C programmers who know about cweb.  ",
        "Best answer TF-IDF scores": [
            {
                "Scores": {
                    "able": 0.12196398929068855,
                    "applications": 0.11403148764118379,
                    "away": 0.12889369505890869,
                    "best": 0.09167102137039285,
                    "big": 0.11182440221093828,
                    "code": 0.059726431217106794,
                    "comments": 0.1190587944791889,
                    "complicated": 0.13314422242608404,
                    "computing": 0.13817152926408915,
                    "definitely": 0.1443244555614795,
                    "documentation": 0.25042344155315854,
                    "draw": 0.1443244555614795,
                    "edit": 0.11643072609776715,
                    "especially": 0.1190587944791889,
                    "higher": 0.12889369505890869,
                    "huge": 0.13817152926408915,
                    "include": 0.12521172077657927,
                    "instead": 0.10787856134379344,
                    "know": 0.15277308314000343,
                    "language": 0.0769795503971975,
                    "learn": 0.09491875285628354,
                    "like": 0.12009787207227327,
                    "likely": 0.2328614521955343,
                    "lot": 0.09167102137039285,
                    "need": 0.1644953567929035,
                    "network": 0.1443244555614795,
                    "people": 0.14936079722399614,
                    "place": 0.11182440221093828,
                    "places": 0.12889369505890869,
                    "popular": 0.13314422242608404,
                    "prefer": 0.12889369505890869,
                    "program": 0.11182440221093828,
                    "programmers": 0.3588024911252838,
                    "programming": 0.21034958608377094,
                    "project": 0.08224767839645175,
                    "really": 0.08298302457970794,
                    "require": 0.10978096027400848,
                    "say": 0.0853145971184272,
                    "seen": 0.2088546638066549,
                    "specific": 0.11403148764118379,
                    "studio": 0.13314422242608404,
                    "syntax": 0.13314422242608404,
                    "time": 0.07413436398303175,
                    "training": 0.1443244555614795,
                    "understand": 0.09491875285628354,
                    "using": 0.16903059838343576,
                    "visual": 0.12889369505890869,
                    "write": 0.08613775817747146,
                    "written": 0.12889369505890869,
                    "xml": 0.1443244555614795
                },
                "Max term": "programmers",
                "Max score": 0.3588024911252838
            }
        ]
    },
    {
        "ID": "827",
        "Question": "For decades, the accepted degree to get to become a software developer was \"Compter Science.\" We've had a few questions already about whether that degree really prepares students to develop software. Some schools have, in the last 8 years or so, started offering multiple distinct majors in programming.  Using the curriculum from my school:  Computer Science, which starts out with some intro programming courses in the first year, and then focuses on theoretical computer science, algorithms, and a bit of OS stuff.  Most classes involve several smaller projects and homeworks, done solo or in pairs. Software Engineering, which starts out with the same intro programming courses, does a few classes of theory, and then goes into software development practices (testing, process methodologies, sofware metrics, requirements gathering) and software design (distributed system design, info system design, real-time/embedded design, subsystem design, etc)  Different schools do it differently, so the above is just a real-world example I'm familiar with.  What I ask is: Is there a need for distinct majors in programming? ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "accepted": 0.11970860131934442,
                    "algorithms": 0.11460511280649253,
                    "ask": 0.08947888727913815,
                    "bit": 0.09275172894271476,
                    "classes": 0.22087051814428918,
                    "computer": 0.18550345788542952,
                    "decades": 0.11970860131934442,
                    "degree": 0.22921022561298507,
                    "design": 0.38449422831280095,
                    "develop": 0.10690969797430691,
                    "developer": 0.08071951893356573,
                    "development": 0.07076341326518841,
                    "different": 0.08289934624618342,
                    "differently": 0.11970860131934442,
                    "engineering": 0.11460511280649253,
                    "example": 0.07287607202411803,
                    "familiar": 0.11970860131934442,
                    "goes": 0.10690969797430691,
                    "multiple": 0.10690969797430691,
                    "need": 0.06821958554632061,
                    "practices": 0.09875222952633798,
                    "process": 0.08661629654534297,
                    "programming": 0.23263005695723105,
                    "projects": 0.0880028347590353,
                    "questions": 0.0880028347590353,
                    "real": 0.1760056695180706,
                    "really": 0.06882951172092945,
                    "requirements": 0.10116191682494477,
                    "school": 0.11460511280649253,
                    "schools": 0.23941720263868885,
                    "science": 0.35912580395803323,
                    "smaller": 0.11970860131934442,
                    "software": 0.35050221450572966,
                    "solo": 0.11460511280649253,
                    "started": 0.09657240221372028,
                    "stuff": 0.09275172894271476,
                    "testing": 0.08947888727913815,
                    "theory": 0.11460511280649253,
                    "time": 0.06149007101798859,
                    "using": 0.07010044290114593,
                    "world": 0.08289934624618342,
                    "year": 0.09657240221372028,
                    "years": 0.08407246882647518
                },
                "Max term": "design",
                "Max score": 0.38449422831280095
            }
        ],
        "Best answer": "Yes, they should be. The relationship between computer science and software engineering is the same as the relationship between physics and mechanical engineering. One provides the theoretical background while the other takes those theories, along with good engineering principles, and applies them to the design and implementation of software. You need both in order to produce new and better software. A good computer science education trains people to produce new and better algorithms, data structures, programming languages and paradigms, compilers, and a number of other things that can be used to enhance software systems. A good software engineering education, on the other hand, trains you to take these tools and knowledge obtained through a scientific study of computation, along with a knowledge of the software development lifecycle and process models to actually build the system that a customer wants and needs. ",
        "Best answer TF-IDF scores": [
            {
                "Scores": {
                    "actually": 0.08692536209877093,
                    "algorithms": 0.12017092269329561,
                    "background": 0.10889948238886211,
                    "better": 0.16126689309092807,
                    "build": 0.11210177919484753,
                    "computer": 0.19451245368545275,
                    "customer": 0.10607485642287456,
                    "data": 0.08692536209877093,
                    "design": 0.08063344654546403,
                    "development": 0.0742000462000587,
                    "engineering": 0.48068369077318246,
                    "good": 0.20570464928537407,
                    "hand": 0.11579855955449951,
                    "implementation": 0.12017092269329561,
                    "knowledge": 0.1909579977951704,
                    "languages": 0.08157402210594206,
                    "need": 0.07153267720871814,
                    "needs": 0.10889948238886211,
                    "new": 0.14434444902993046,
                    "number": 0.09917577925723717,
                    "paradigms": 0.12017092269329561,
                    "people": 0.06495124180867973,
                    "physics": 0.12552226268612446,
                    "process": 0.09082282649732104,
                    "produce": 0.23159711910899902,
                    "programming": 0.06098194030388986,
                    "provides": 0.12552226268612446,
                    "science": 0.2510445253722489,
                    "software": 0.441029271644964,
                    "structures": 0.12017092269329561,
                    "study": 0.12552226268612446,
                    "systems": 0.11579855955449951,
                    "takes": 0.09725622684272638,
                    "things": 0.06856821642845802,
                    "tools": 0.10126245153063869,
                    "used": 0.07030258180150857,
                    "wants": 0.10889948238886211,
                    "yes": 0.09382443926440831
                },
                "Max term": "engineering",
                "Max score": 0.48068369077318246
            }
        ]
    },
    {
        "ID": "966",
        "Question": "There are a lot of questions about what programming books should be on the programmer's bookshelf. How about non-programming related books that can help you become a better programmer or developer? It would also be interesting to know why they would help. My first choice would be Sun Tzu's \"Art of War\" (however cliché), because it made it obvious that the success of any project depends on the strength of its weakest link (and warfare is a big project). ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "better": 0.16032303375340282,
                    "big": 0.1933740154594962,
                    "books": 0.40267913949443285,
                    "choice": 0.20588419619519893,
                    "depends": 0.21652423576999863,
                    "developer": 0.16828858804112307,
                    "help": 0.33657717608224613,
                    "interesting": 0.1933740154594962,
                    "know": 0.13209256636661093,
                    "lot": 0.15852348103974193,
                    "non": 0.1752790063526441,
                    "obvious": 0.23024163256600644,
                    "programmer": 0.32064606750680563,
                    "programming": 0.2425001061606864,
                    "project": 0.2844560492931014,
                    "questions": 0.18347325406390527,
                    "related": 0.21652423576999863,
                    "war": 0.23893517790129232
                },
                "Max term": "books",
                "Max score": 0.40267913949443285
            }
        ],
        "Best answer": "The Design of Everyday Things by Donald Norman  ",
        "Best answer TF-IDF scores": [
            {
                "Scores": {
                    "design": 0.7618004295900059,
                    "things": 0.6478117824464776
                },
                "Max term": "design",
                "Max score": 0.7618004295900059
            }
        ]
    },
    {
        "ID": "1200",
        "Question": "Coming from a procedural/OO programming background, I tend to write Scheme programs in a procedural fashion. I would be intersted in learning Scheme or Lisp in a functional way from the ground up, to kind of reset my programmer's mind. Is there a tutorial or book out there that's the de-facto standard for describing best practices, design methodologies, and other helpful information on functional programming concepts? What about that book makes it special? ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "background": 0.20382415915627713,
                    "best": 0.14922539786157465,
                    "book": 0.35741082033598015,
                    "coming": 0.2249206032544017,
                    "concepts": 0.2249206032544017,
                    "design": 0.15091939907772003,
                    "functional": 0.37906027805778925,
                    "helpful": 0.20981780981035558,
                    "information": 0.1820317987200856,
                    "kind": 0.20382415915627713,
                    "learning": 0.1649981396333168,
                    "lisp": 0.2249206032544017,
                    "makes": 0.16999058064307423,
                    "mind": 0.2249206032544017,
                    "practices": 0.19380820361203616,
                    "programmer": 0.15091939907772003,
                    "programming": 0.2282764331564885,
                    "programs": 0.19853738460217435,
                    "standard": 0.17870541016799008,
                    "tend": 0.20981780981035558,
                    "way": 0.13158340432730503,
                    "write": 0.14021815228829496
                },
                "Max term": "functional",
                "Max score": 0.37906027805778925
            }
        ],
        "Best answer": "Use it. If you do functional programming daily, maybe smaller applications or exercises from books, then you will be better on it. I have used it since the first programming lecture in university. At the beginning it was very hard, because it is so different, but now I prefer it to imperative programming. If you are looking for a good book, I would recommend Real World Functional Programming: With Examples in F# and C# by Tomas Petricek and Jon Skeet ",
        "Best answer TF-IDF scores": [
            {
                "Scores": {
                    "applications": 0.18107142749968225,
                    "better": 0.1472175301223162,
                    "book": 0.1743219842193954,
                    "books": 0.184881195671897,
                    "daily": 0.21142067789106994,
                    "different": 0.15870507415249424,
                    "examples": 0.18905432454388196,
                    "functional": 0.369762391343794,
                    "good": 0.1251892843473881,
                    "hard": 0.1775667805137039,
                    "imperative": 0.22917385129502862,
                    "looking": 0.1775667805137039,
                    "maybe": 0.19366750448711126,
                    "prefer": 0.20467123461078307,
                    "programming": 0.44535418083826017,
                    "real": 0.16847535051225324,
                    "recommend": 0.21940357493526966,
                    "smaller": 0.22917385129502862,
                    "university": 0.21940357493526966,
                    "use": 0.10385320707686103,
                    "used": 0.12835582376110655,
                    "world": 0.15870507415249424
                },
                "Max term": "programming",
                "Max score": 0.44535418083826017
            }
        ]
    },
    {
        "ID": "1386",
        "Question": "Sometimes I feel like a musician who can't play live shows. Programming is a pretty cool skill, and a very broad world, but a lot of it happens \"off camera\"- in your head, in your office, away from spectators.  You can of course talk about programming with other programmers, and there is peer programming, and you do get to create something that you can show to people, but when it comes to explaining to non programmers what is it that you do, or how was your day at work, it's sort of tricky.  How do you get the non programmers in your life to understand what is it that you do?  NOTE: this is not a repeat of Getting non-programmers to understand the development process, because that question was about managing client expectations.  ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "away": 0.15016673945350925,
                    "client": 0.1551187880032456,
                    "comes": 0.1551187880032456,
                    "course": 0.14209333198303367,
                    "create": 0.13564684061788687,
                    "day": 0.13564684061788687,
                    "development": 0.09939520215638732,
                    "expectations": 0.16814424402345754,
                    "explaining": 0.16814424402345754,
                    "feel": 0.1278995753119552,
                    "getting": 0.1302802737067919,
                    "happens": 0.16097581829282284,
                    "head": 0.16097581829282284,
                    "life": 0.14587707988190346,
                    "like": 0.06995961228419856,
                    "live": 0.1551187880032456,
                    "lot": 0.10680071182126767,
                    "non": 0.35426781930988116,
                    "note": 0.1551187880032456,
                    "office": 0.16814424402345754,
                    "people": 0.08700590013752593,
                    "play": 0.15016673945350925,
                    "pretty": 0.12166236629794139,
                    "process": 0.12166236629794139,
                    "programmers": 0.4180204483660393,
                    "programming": 0.24506638182076015,
                    "question": 0.10035422045612089,
                    "repeat": 0.16097581829282284,
                    "shows": 0.16814424402345754,
                    "sort": 0.16814424402345754,
                    "talk": 0.1551187880032456,
                    "understand": 0.22116891944027492,
                    "work": 0.08765490660045286,
                    "world": 0.1164414900097147
                },
                "Max term": "programmers",
                "Max score": 0.4180204483660393
            }
        ],
        "Best answer": "I don't even try. If they aren't tech oriented enough to have at least a basic understanding of programming, I am only going to bore them with the details. Usually I just go with something very high level like \"I create web sites\" or \"I write computer programs to do X\" ",
        "Best answer TF-IDF scores": [
            {
                "Scores": {
                    "basic": 0.2909227573948823,
                    "computer": 0.24433852887083451,
                    "create": 0.2544034376005702,
                    "details": 0.26649372703366947,
                    "going": 0.22473202379440865,
                    "high": 0.2816352710923689,
                    "level": 0.24433852887083451,
                    "like": 0.1312081120152259,
                    "oriented": 0.26649372703366947,
                    "programming": 0.15320600094466716,
                    "programs": 0.26649372703366947,
                    "sites": 0.2735900845168343,
                    "try": 0.20493985015144017,
                    "understanding": 0.3019075221930285,
                    "usually": 0.23182838127757346,
                    "web": 0.22473202379440865,
                    "write": 0.18821270400009657
                },
                "Max term": "understanding",
                "Max score": 0.3019075221930285
            }
        ]
    },
    {
        "ID": "1745",
        "Question": "To put it another way... What is the most commonly held and frustrating misunderstanding about programming, you have encountered? Which widespread and longstanding myths/misconceptions do you find hard for programmers to dispel/correct. Please, explain why this is a myth. ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "commonly": 0.44165659071088564,
                    "correct": 0.40023137913984147,
                    "encountered": 0.46132403208519956,
                    "explain": 0.32399217666006874,
                    "hard": 0.35743965853030324,
                    "programmers": 0.28672239102544156,
                    "programming": 0.22412306775982968,
                    "way": 0.25837863187481125
                },
                "Max term": "encountered",
                "Max score": 0.46132403208519956
            }
        ],
        "Best answer": "That because you're a programmer, you know how to fix [person]'s virus ridden machine. ",
        "Best answer TF-IDF scores": [
            {
                "Scores": {
                    "fix": 0.40932189159525173,
                    "know": 0.2685432336958693,
                    "machine": 0.48575349152675484,
                    "person": 0.40088716945315894,
                    "programmer": 0.32593557006515606,
                    "virus": 0.5073846151596967
                },
                "Max term": "virus",
                "Max score": 0.5073846151596967
            }
        ]
    },
    {
        "ID": "2259",
        "Question": "Sometimes, one creates a exploratory prototype and forgets about structure in the directories... What are good tips on dividing the programming files over (several levels of) directories? ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "files": 0.5907736590992156,
                    "good": 0.3818840532374425,
                    "programming": 0.33963302169061427,
                    "tips": 0.62434002288398
                },
                "Max term": "tips",
                "Max score": 0.62434002288398
            }
        ],
        "Best answer": "If your language is OOP and package based (Eg Java), then you should probably keep each package in its own folder (eg my/package/name) to keep with the convention. If your language isn't package based (Eg PHP), then organize by what each file does. Here's an example  Does this do utility functions? Goes in /util Is this a 3rd party plugin? Goes in /plugin Is this part of the admin panel? Goes in /admin, along with ALL supporting files Is this Javascript? Goes in /javascript Is this CSS? Goes in /css Is this a template? Goes in /templates/templateName etc  Language agnostic, Most people have a /src directory for all source files, a /lib directory for libraries, and a /bin or /dist directory for builds.  ",
        "Best answer TF-IDF scores": [
            {
                "Scores": {
                    "agnostic": 0.1211536490610346,
                    "based": 0.1961031256450762,
                    "css": 0.25309750182470975,
                    "directory": 0.3796462527370646,
                    "example": 0.07704021084874749,
                    "file": 0.0980515628225381,
                    "files": 0.21388461769668277,
                    "functions": 0.11674552988034813,
                    "goes": 0.6781111093082021,
                    "java": 0.08645658014019736,
                    "javascript": 0.21958006773305058,
                    "language": 0.20249511929203676,
                    "libraries": 0.11674552988034813,
                    "oop": 0.1211536490610346,
                    "organize": 0.12654875091235487,
                    "party": 0.1211536490610346,
                    "people": 0.06548239607222556,
                    "php": 0.09998681283451855,
                    "probably": 0.09303131682069571,
                    "source": 0.0962598011722041,
                    "utility": 0.12654875091235487
                },
                "Max term": "goes",
                "Max score": 0.6781111093082021
            }
        ]
    }
]