[
    {
        "ID": "1",
        "Question": "A coworker of mine believes that any use of in-code comments (ie, not javadoc style method or class comments) is a code smell.  What do you think? ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "believes": 0.3701659493778878,
                    "class": 0.2465546847107563,
                    "code": 0.25913765549193013,
                    "comments": 0.5489875865723288,
                    "coworker": 0.3569013030642521,
                    "method": 0.25889769313896366,
                    "smell": 0.3460632978788912,
                    "style": 0.2744937932861644,
                    "think": 0.1571456268237192,
                    "use": 0.13942851322840058
                },
                "Max term": "comments",
                "Max score": 0.5489875865723288
            }
        ],
        "Best Answer": "Only if the comment describes what the code is doing. If I wanted to know what was happening in a method or block, I would read the code. I would hope, anyway, that any developers working on a given project were at least familiar enough with the development language to read what is written and understand what it is doing. In some cases of extreme optimization, you might be using techniques that makes it difficult for someone to follow what your code is doing. In these cases, comments can and should be used to not only explain why you have such optimizations, but what the code is doing. A good rule of thumb would be to have someone else (or multiple other people) familiar with the implementation language and project look at your code - if they can't understand both the why and the how, then you should comment both the why and the how. However, what's not clear in the code is why you have done something. If you take an approach that might not be obvious to others, you should have a comment that explains why you made the decisions that you did. I would suspect that you might not even realize that a comment is needed until after something like a code review, where people want to know why you did X instead of Y - you can capture your answer in the code for everyone else who looks at it in the future. The most important thing, though, is to change your comments when you change your code. If you change an algorithm, be sure to update the comments with why you went with algorithm X over Y. Stale comments are an even bigger code smell. ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "algorithm": 0.18213761683934745,
                "answer": 0.06834909760312961,
                "approach": 0.08085705437756112,
                "bigger": 0.100552419668725,
                "block": 0.09682691574664375,
                "capture": 0.11560755113219245,
                "cases": 0.16031279064440437,
                "change": 0.21455041479899412,
                "clear": 0.09521152678566963,
                "code": 0.40465998841747286,
                "comment": 0.3808461071426785,
                "comments": 0.34291166214647345,
                "decisions": 0.100552419668725,
                "describes": 0.10807998540045873,
                "developers": 0.06596128235975049,
                "development": 0.05843371662801676,
                "difficult": 0.08395845713185467,
                "explain": 0.07481550243914682,
                "extreme": 0.11146483276619654,
                "familiar": 0.18213761683934745,
                "follow": 0.08395845713185467,
                "future": 0.09372551299235019,
                "given": 0.08015639532220219,
                "good": 0.05055385832487523,
                "happening": 0.10807998540045873,
                "hope": 0.09682691574664375,
                "implementation": 0.09372551299235019,
                "important": 0.07381173034160886,
                "instead": 0.07481550243914682,
                "know": 0.10082958409191255,
                "language": 0.10883895618524804,
                "like": 0.041210362921491495,
                "look": 0.06661276188588067,
                "looks": 0.0876839610539359,
                "makes": 0.06502502037815823,
                "method": 0.08085705437756112,
                "multiple": 0.08158519717062246,
                "needed": 0.08015639532220219,
                "obvious": 0.08987063390261428,
                "optimization": 0.11560755113219245,
                "people": 0.10341112315009673,
                "project": 0.10918435888860116,
                "read": 0.13894921911218294,
                "realize": 0.09372551299235019,
                "review": 0.08987063390261428,
                "rule": 0.09234967911545883,
                "smell": 0.10807998540045873,
                "stale": 0.11146483276619654,
                "sure": 0.06798859576277202,
                "suspect": 0.10521813773024791,
                "techniques": 0.09521152678566963,
                "thing": 0.06596128235975049,
                "understand": 0.12656650132149072,
                "update": 0.0876839610539359,
                "used": 0.056413763090870574,
                "using": 0.05424836848111454,
                "want": 0.05459217944430058,
                "wanted": 0.09859637415140746,
                "went": 0.08874512194965242,
                "working": 0.061690967193018025,
                "written": 0.07882974097453957
            },
            "Max term": "code",
            "Max score": 0.40465998841747286
        }
    },
    {
        "ID": "4",
        "Question": "When starting a project for a company that's not primarily a programming company, one of the expectations is that there's a finished product at the end free of all bugs and does everything needed right away. However, that's rarely the case.  What are some ways to manage expectations and explain to non-programmers how software development differs from other types of product development? ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "away": 0.16990871637373117,
                    "bugs": 0.16576245728011696,
                    "case": 0.15969615574362575,
                    "company": 0.28976121973473906,
                    "development": 0.2477256554590262,
                    "differs": 0.24505506437788319,
                    "end": 0.136564949624908,
                    "expectations": 0.4355551983311025,
                    "explain": 0.15858754542533926,
                    "finished": 0.22909877011394314,
                    "free": 0.15645983461775004,
                    "manage": 0.21777759916555126,
                    "needed": 0.16990871637373117,
                    "non": 0.14488060986736953,
                    "product": 0.3216738082626191,
                    "programmers": 0.13131008021300733,
                    "programming": 0.10403261500067541,
                    "project": 0.1157198636009056,
                    "rarely": 0.1858650106376712,
                    "right": 0.14050354035381002,
                    "software": 0.1157198636009056,
                    "starting": 0.181718751544057,
                    "types": 0.17979870910118,
                    "ways": 0.16447207729090588
                },
                "Max term": "expectations",
                "Max score": 0.4355551983311025
            }
        ],
        "Best Answer": "Pretty much everybody with a computer has encountered the concept of \"bugs\" these days, so you might start there.  \"What's the most annoying way an application has ever failed on you?  Multiply that by ten, and you'll have our users' experience if we don't devote enough resources to testing and maintenance.\" And don't underestimate the value of establishing a good working relationship with the non-programmers.  If you can establish that your judgment may be trusted, they'll take you seriously when you sound the alarm that X is going to fail spectacularly if you don't do Y pronto, even if they don't completely understand your reasoning. ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "annoying": 0.20246277078091635,
                "application": 0.1409501147484334,
                "bugs": 0.16628931424631688,
                "completely": 0.1822963237622243,
                "computer": 0.15593166029784236,
                "concept": 0.18871226929974264,
                "days": 0.1690130246922643,
                "encountered": 0.21846978029682376,
                "everybody": 0.2237413517086921,
                "experience": 0.1409501147484334,
                "fail": 0.18645576126500896,
                "failed": 0.21846978029682376,
                "going": 0.12707757872498027,
                "good": 0.10750036865978137,
                "maintenance": 0.21381992477322284,
                "non": 0.14534109627562133,
                "pretty": 0.15395734176333709,
                "programmers": 0.13172743424858116,
                "reasoning": 0.2370246507786521,
                "relationship": 0.2370246507786521,
                "resources": 0.19930283332196366,
                "seriously": 0.1963771882004782,
                "sound": 0.2370246507786521,
                "start": 0.1369990056604495,
                "testing": 0.1445745063055359,
                "underestimate": 0.24583394380503767,
                "understand": 0.13456881435837012,
                "users": 0.15909159775679504,
                "value": 0.18645576126500896,
                "way": 0.10809853378496213,
                "working": 0.13118289950511472
            },
            "Max term": "underestimate",
            "Max score": 0.24583394380503767
        }
    },
    {
        "ID": "9",
        "Question": "Sometimes, the things I have to do for my job are interesting and engaging.  Sometimes, they aren't.  Occasionally, they really aren't. Do you have any particular strategies or tricks for dealing with those dull stretches when your brain would rather be doing anything other than what you're supposed to be doing, particularly when the Internet and its boundless opportunities for interesting Slack beckon? ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "brain": 0.2811329248055001,
                    "dealing": 0.25646457054651806,
                    "interesting": 0.42064365764106854,
                    "internet": 0.2402159409846493,
                    "job": 0.1668218151596955,
                    "occasionally": 0.25646457054651806,
                    "opportunities": 0.2811329248055001,
                    "particular": 0.1959672124039385,
                    "particularly": 0.24379469981241758,
                    "really": 0.14023043535145316,
                    "slack": 0.30071329912722883,
                    "strategies": 0.30071329912722883,
                    "supposed": 0.2402159409846493,
                    "things": 0.14291396709032642,
                    "tricks": 0.2672404281353455
                },
                "Max term": "interesting",
                "Max score": 0.42064365764106854
            }
        ],
        "Best Answer": "Increments. I will pick something that I can do, even if it's a small task (i.e. modify comments in code). Pretty soon, the perfectionist in me wants to do more and more stuff and I'm back rolling. ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "code": 0.1453276306986221,
                "comments": 0.3078790887725531,
                "modify": 0.35409424853035976,
                "pick": 0.3149039360197969,
                "pretty": 0.26001756433534345,
                "rolling": 0.41518736662391226,
                "small": 0.24813297370001144,
                "soon": 0.33166017016196186,
                "stuff": 0.26166392901474644,
                "task": 0.27449020603203417,
                "wants": 0.3227570471082989
            },
            "Max term": "rolling",
            "Max score": 0.41518736662391226
        }
    },
    {
        "ID": "16",
        "Question": "I have read a few articles on Internet about programming language choice in the enterprise. Recently many dynamic typed languages have been popular, i.e. Ruby, Python, PHP and Erlang. But many enterprises still stay with static typed languages like C, C++, C# and Java. And yes, one of the benefits of static typed languages is that programming errors are caught earlier, at compile time, rather than at run time. But there are also advantages with dynamic typed languages. (more on Wikipedia) The main reason why enterprises don't start to use languages like Erlang, Ruby and Python, seem to be the fact that they are dynamic typed. That also seem to be the main reason why people on StackOverflow decide against Erlang. See Why did you decide \"against\" Erlang. However, there seem to be a strong criticism against dynamic typing in the enterprises, but I don't really get it why it is that strong. Really, why is there so much criticism against dynamic typing in the enterprises? Does it really affect the cost of projects that much, or what? But maybe I'm wrong. ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "advantages": 0.07370698014074469,
                    "affect": 0.07907574963320235,
                    "articles": 0.0775374896280415,
                    "benefits": 0.07487560099600753,
                    "caught": 0.08499552665210577,
                    "choice": 0.06816644435466233,
                    "compile": 0.07907574963320235,
                    "cost": 0.06602603853414238,
                    "decide": 0.14323542521827617,
                    "dynamic": 0.4382870764206987,
                    "earlier": 0.08274493188170125,
                    "enterprise": 0.07907574963320235,
                    "enterprises": 0.3636612146840368,
                    "erlang": 0.3231815120596438,
                    "errors": 0.06741756397194326,
                    "fact": 0.06149778695303984,
                    "internet": 0.072625006225603,
                    "java": 0.05525711863105612,
                    "language": 0.04279619564600422,
                    "languages": 0.24883391676255925,
                    "like": 0.0648167463579564,
                    "main": 0.1379116479542082,
                    "maybe": 0.06101905663637429,
                    "people": 0.040661935886007874,
                    "php": 0.06415967558507381,
                    "popular": 0.072625006225603,
                    "programming": 0.07719209401761878,
                    "projects": 0.05291612130210246,
                    "python": 0.12299557390607968,
                    "read": 0.05463574968381105,
                    "really": 0.1271885146173848,
                    "reason": 0.11317060710120269,
                    "recently": 0.07161771260913809,
                    "ruby": 0.145250012451206,
                    "run": 0.056241759075314285,
                    "stackoverflow": 0.07487560099600753,
                    "start": 0.05066552653169793,
                    "static": 0.155074979256083,
                    "stay": 0.07161771260913809,
                    "strong": 0.14975120199201505,
                    "time": 0.07166624028535318,
                    "typed": 0.42497763326052884,
                    "typing": 0.16999105330421155,
                    "use": 0.03424460202744565,
                    "wikipedia": 0.07487560099600753,
                    "wrong": 0.058835898321005865,
                    "yes": 0.059247192182635314
                },
                "Max term": "dynamic",
                "Max score": 0.4382870764206987
            }
        ],
        "Best Answer": "Yes, I believe that they do. There are a few reasons that need to be considered in the selection of a language for a new project:  Run-time speed. Compared to C/C++/Fortran, Perl and Python are so slow it's funny. Initialization speed. Compared to the above fast languages, Java falls over and cries as the JVM keeps loading and loading and...while(1).... Prototype-ability. Exhaustively going through and doing the declaration/definition work required for C++ or Java increases the LOC, which is the only known metric that reliably correlates with bugcounts. It also takes a lot of time. It also requires a bit more thinking about types and connections. Internal fiddlability. Dynamically messing around with your internals is great until you begin to debug your self-modifying code. (Python, Lisp, Perl) Correctness verification. A compiler can provide a quick once-over pass of semi-correctness of your code in C++, and this can be really nice.  Static analysis details. C and Java have pretty good static analysis. Perl is not completely statically analyzable at a theoretical level (Possibly Python too). I'm reasonably sure Lisp isn't either.  Weird platforms only take C, in general.  Support chain. If you can have a contract that you will get your bugs looked at and worked on, that's huge.   If you can presume that the organization you are working with has a principle of \"Going forward\"(There's an accounting term for this), and won't just randomly decide to not work on the software, then you have a much better case for using the software. Since there's no Major Business selling (carrying implication of taking responsibility of maintaining it) Python/Perl/$dynamic_language, it considerably reduces risk.  In my experience, open source maintainers often have an issue with fully taking responsibility for bugfixes and releasing updates. \"It's free, YOU work on it!\" is not an answer that is acceptable to most businesses (not their core compentencies, among other things).  Of course, I'm not talking about the webapp/startup world, which tends to play by high risk/high reward rules and be very open to staying on the frothing edge of tech. ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "ability": 0.06687455272488003,
                "acceptable": 0.08431093462292236,
                "accounting": 0.09018303110708102,
                "analysis": 0.15106530099919582,
                "answer": 0.053317700573345395,
                "begin": 0.08431093462292236,
                "believe": 0.06423410413577355,
                "better": 0.045091944512988306,
                "bit": 0.05962213877186483,
                "bugs": 0.06100245624072137,
                "business": 0.05876998876832215,
                "case": 0.05876998876832215,
                "code": 0.06313335758062244,
                "compared": 0.17390276642405772,
                "compiler": 0.07427251937934795,
                "completely": 0.06687455272488003,
                "considered": 0.06840042289518929,
                "contract": 0.0701062006199322,
                "core": 0.07553265049959791,
                "correctness": 0.18036606221416204,
                "course": 0.06364290482982787,
                "debug": 0.07104087148429578,
                "decide": 0.07104087148429578,
                "definition": 0.07204005190694873,
                "details": 0.06922821230107847,
                "dynamically": 0.09018303110708102,
                "edge": 0.08207846715052314,
                "experience": 0.051706889561945545,
                "fast": 0.06922821230107847,
                "fortran": 0.08695138321202886,
                "forward": 0.09018303110708102,
                "free": 0.0575789860461042,
                "fully": 0.08207846715052314,
                "funny": 0.08695138321202886,
                "general": 0.06364290482982787,
                "going": 0.09323562936659513,
                "good": 0.03943600684597192,
                "great": 0.05578876276495775,
                "high": 0.12105516366476428,
                "huge": 0.06616795542279008,
                "increases": 0.08695138321202886,
                "initialization": 0.08695138321202886,
                "internal": 0.07843883813876369,
                "internals": 0.09018303110708102,
                "issue": 0.061493431119746436,
                "java": 0.16443615916715834,
                "keeps": 0.09018303110708102,
                "known": 0.06922821230107847,
                "language": 0.04245149592388181,
                "languages": 0.04936593939585659,
                "level": 0.05513035975656272,
                "lisp": 0.1485450387586959,
                "loading": 0.18036606221416204,
                "looked": 0.07843883813876369,
                "lot": 0.04626456858820893,
                "maintaining": 0.08207846715052314,
                "major": 0.0701062006199322,
                "metric": 0.09018303110708102,
                "need": 0.04245149592388181,
                "new": 0.04272220234558655,
                "nice": 0.06549423525602349,
                "open": 0.11225908035843132,
                "organization": 0.07204005190694873,
                "pass": 0.07427251937934795,
                "perl": 0.32057846345402646,
                "platforms": 0.07553265049959791,
                "play": 0.07553265049959791,
                "possibly": 0.07427251937934795,
                "pretty": 0.05647852988282904,
                "principle": 0.08431093462292236,
                "project": 0.04258621663388693,
                "prototype": 0.08695138321202886,
                "provide": 0.06549423525602349,
                "python": 0.24400982496288548,
                "quick": 0.07843883813876369,
                "really": 0.04205469379027711,
                "reasonably": 0.08207846715052314,
                "reasons": 0.06364290482982787,
                "reduces": 0.09018303110708102,
                "releasing": 0.09018303110708102,
                "required": 0.06616795542279008,
                "requires": 0.07553265049959791,
                "responsibility": 0.17390276642405772,
                "risk": 0.14208174296859155,
                "rules": 0.07427251937934795,
                "run": 0.05578876276495775,
                "self": 0.07553265049959791,
                "selling": 0.08207846715052314,
                "semi": 0.08695138321202886,
                "slow": 0.07553265049959791,
                "software": 0.08517243326777386,
                "source": 0.05360448958625346,
                "speed": 0.16028923172701323,
                "startup": 0.08431093462292236,
                "static": 0.15382593593690888,
                "statically": 0.08431093462292236,
                "support": 0.05962213877186483,
                "sure": 0.05303648063256529,
                "takes": 0.05918979705750406,
                "taking": 0.1485450387586959,
                "talking": 0.06687455272488003,
                "tech": 0.07427251937934795,
                "tends": 0.08207846715052314,
                "term": 0.07104087148429578,
                "theoretical": 0.08431093462292236,
                "things": 0.04285947704058909,
                "thinking": 0.05683613748130562,
                "time": 0.07108900829687793,
                "types": 0.06616795542279008,
                "updates": 0.09018303110708102,
                "using": 0.042318016897067774,
                "weird": 0.08431093462292236,
                "work": 0.11455485821263639,
                "worked": 0.05918979705750406,
                "working": 0.04812383238731743,
                "world": 0.05578876276495775,
                "yes": 0.05876998876832215
            },
            "Max term": "perl",
            "Max score": 0.32057846345402646
        }
    },
    {
        "ID": "18",
        "Question": "At first glance, I'd say a good programming team needs to understand the following matters:  The details of the core language / framework HTML, (asynchronous) javascript SQL / data model Usability / UI design Security Project management.  If this team is not complete: what is needed? ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "asynchronous": 0.2571869079221575,
                    "complete": 0.1849477987944835,
                    "core": 0.2234123036523379,
                    "data": 0.1630659137860042,
                    "design": 0.1529398907005491,
                    "details": 0.20476488360486428,
                    "following": 0.19181628633242892,
                    "framework": 0.17507301578675238,
                    "good": 0.11664477650436558,
                    "html": 0.20231642804444822,
                    "javascript": 0.21625632301877687,
                    "language": 0.12556406315825971,
                    "management": 0.17507301578675238,
                    "matters": 0.2667455543624896,
                    "model": 0.20000038776862575,
                    "needed": 0.1849477987944835,
                    "needs": 0.19181628633242892,
                    "programming": 0.11324082459011259,
                    "project": 0.12596254333832546,
                    "say": 0.1389582652694804,
                    "security": 0.1957131816663766,
                    "sql": 0.1978031722859337,
                    "team": 0.31883613494038604,
                    "ui": 0.2234123036523379,
                    "understand": 0.14601577158276388,
                    "usability": 0.24937692511252485
                },
                "Max term": "team",
                "Max score": 0.31883613494038604
            }
        ],
        "Best Answer": "Customer (or an advocate of some sort).   Basically, someone that can say, \"Yes, you're building what I want and it's going to solve my problem.\" or that the team can go to when they have questions about how something is supposed to work.  That may or may not be the same person that is doing Project Management. Also, you're missing out on a QA person there.  You can't really depend on the developers to adequately test - they're usually too close to the code and the normal response for developers is to test happy path stuff, not doing weird crap like copy pasting War & Peace into a textbox and seeing what the application does. ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "adequately": 0.2044257296929528,
                "advocate": 0.1971002719993395,
                "application": 0.11720850917400231,
                "basically": 0.16103452958857312,
                "building": 0.171216436223895,
                "close": 0.174345322027743,
                "code": 0.07155493962085009,
                "copy": 0.1683599872821864,
                "customer": 0.14998866642144346,
                "depend": 0.2044257296929528,
                "developers": 0.23327513031490965,
                "going": 0.10567265999308026,
                "happy": 0.171216436223895,
                "like": 0.07287117864389571,
                "management": 0.13417066720113816,
                "missing": 0.174345322027743,
                "normal": 0.171216436223895,
                "path": 0.171216436223895,
                "person": 0.27878503025810264,
                "problem": 0.1064934140794627,
                "project": 0.0965338856254183,
                "qa": 0.18605440883220983,
                "questions": 0.13139477892189408,
                "really": 0.09532903651112767,
                "response": 0.1816707797213563,
                "say": 0.1064934140794627,
                "seeing": 0.1683599872821864,
                "solve": 0.14560503731058994,
                "sort": 0.14998866642144346,
                "stuff": 0.12883542208455,
                "supposed": 0.16329945886061334,
                "team": 0.12217318802827387,
                "test": 0.23104925929076026,
                "usually": 0.13321905119540353,
                "want": 0.0965338856254183,
                "war": 0.1971002719993395,
                "weird": 0.1911149372537829,
                "work": 0.08655715749224505,
                "yes": 0.13321905119540353
            },
            "Max term": "person",
            "Max score": 0.27878503025810264
        }
    },
    {
        "ID": "38",
        "Question": "Where waterfall commonly includes:  Requirements Functional design Technical design Build Test Review (Deploy)  And iterations across this list. If I forgot a step, let me know. ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "build": 0.2048659348546724,
                    "commonly": 0.2896984039114489,
                    "deploy": 0.3098753475864665,
                    "design": 0.35533714444789466,
                    "functional": 0.20960880444101088,
                    "includes": 0.29877117419083826,
                    "iterations": 0.29877117419083826,
                    "know": 0.13513218691810772,
                    "let": 0.20193788647015914,
                    "list": 0.20797710199613173,
                    "requirements": 0.20639720847425183,
                    "review": 0.24088992151165672,
                    "step": 0.2595355915670949,
                    "technical": 0.1978455158989649,
                    "test": 0.175116091403606,
                    "waterfall": 0.29877117419083826
                },
                "Max term": "design",
                "Max score": 0.35533714444789466
            }
        ],
        "Best Answer": "It depends on many factors, including:  The domain (eg, I'd spend more time on a defense contract's requirements than I would on a Twitter clone) The developers (if they have experience building similar systems with similar technology, for example, I might spend less time on the design). The customers (How likely the requirements are to change affects how long that phase will take) The criticality of the system (I'll spend more time testing the space shuttle's launch system than I will the StackExchange rep system).  I'd give you a rough breakdown of what percent of the total effort I'd give to each section, but it'd have a margin of error +/- 10% on each based on the above factors so it'd be kinda meaningless. ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "10": 0.1279445408806021,
                "based": 0.11248191394618755,
                "breakdown": 0.1761746887357594,
                "building": 0.14755482298386313,
                "change": 0.1089846703355908,
                "clone": 0.16986158797805284,
                "contract": 0.13695412452923733,
                "customers": 0.1387800262158209,
                "depends": 0.13523895353876544,
                "design": 0.10101063428721664,
                "developers": 0.10051859307228798,
                "domain": 0.14509312697352744,
                "effort": 0.1387800262158209,
                "error": 0.13064102377153078,
                "example": 0.09401104717295104,
                "experience": 0.10101063428721664,
                "factors": 0.2814638977069848,
                "including": 0.13523895353876544,
                "kinda": 0.1761746887357594,
                "launch": 0.16986158797805284,
                "likely": 0.11916974411255986,
                "long": 0.09773356032271527,
                "percent": 0.1761746887357594,
                "phase": 0.15656440663249835,
                "requirements": 0.23468768485195257,
                "rough": 0.1761746887357594,
                "section": 0.15656440663249835,
                "similar": 0.22961713198504966,
                "space": 0.1428285861634229,
                "spend": 0.3696549121804857,
                "stackexchange": 0.16986158797805284,
                "systems": 0.12215056765558564,
                "technology": 0.13064102377153078,
                "testing": 0.10360802195690084,
                "time": 0.20831109393016814,
                "total": 0.15323212941781758,
                "twitter": 0.16986158797805284
            },
            "Max term": "spend",
            "Max score": 0.3696549121804857
        }
    },
    {
        "ID": "39",
        "Question": "What's your favourite quote about programming? One quote per answer, and please check for duplicates before posting! ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "answer": 0.2568630771287415,
                    "check": 0.29388511608537904,
                    "favourite": 0.4188965317759343,
                    "posting": 0.39542079668817315,
                    "programming": 0.18444247049543658,
                    "quote": 0.6941195591838353
                },
                "Max term": "quote",
                "Max score": 0.6941195591838353
            }
        ],
        "Best Answer": " Debugging is twice as hard as writing the code in the first place. Therefore, if you write the code as cleverly as possible, you are, by definition, not smart enough to debug it.    â€” Brian W. Kernighan ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "code": 0.3070972832402754,
                "debug": 0.34556151403778534,
                "debugging": 0.4101105970339659,
                "definition": 0.35042179083950215,
                "hard": 0.2900177899525213,
                "place": 0.30415425224085396,
                "possible": 0.25798341382504536,
                "smart": 0.3815471727790933,
                "write": 0.21627574188358165,
                "writing": 0.24446544604639014
            },
            "Max term": "debugging",
            "Max score": 0.4101105970339659
        }
    },
    {
        "ID": "42",
        "Question": "We've all had them, managers who have either come from sales or last looked at code 10 or more years ago but think they know how to write code. What can I do to give the impression that I'm grateful for their intervention, but keep it as short as possible so I can get on with my work? Or, should I be engaging more with the manager to educate them with modern coding techniques and practices? After all, a manager who understands these will be able to talk sensibly to clients and more senior management when discussing the project and its timescales. ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "10": 0.18365242042851015,
                    "able": 0.15937424378566745,
                    "ago": 0.18365242042851015,
                    "clients": 0.19920574606971583,
                    "code": 0.17703228206475757,
                    "coding": 0.1435908323911054,
                    "come": 0.16843610939229647,
                    "discussing": 0.2438204205923203,
                    "know": 0.11027833170039272,
                    "looked": 0.21995038835817565,
                    "management": 0.16597414187355036,
                    "manager": 0.383603325511916,
                    "managers": 0.22473356059673175,
                    "modern": 0.20200754843213245,
                    "possible": 0.14871962396544824,
                    "practices": 0.19412286747576799,
                    "project": 0.11941603304676977,
                    "sales": 0.21180114603072778,
                    "senior": 0.21180114603072778,
                    "short": 0.18184723315770496,
                    "talk": 0.20200754843213245,
                    "techniques": 0.2082676116763449,
                    "think": 0.10735548594930518,
                    "understands": 0.2438204205923203,
                    "work": 0.1070744465796862,
                    "write": 0.12467641438215608,
                    "years": 0.14871962396544824
                },
                "Max term": "manager",
                "Max score": 0.383603325511916
            }
        ],
        "Best Answer": "I say, go ahead and try to engage and educate. If they're honestly trying to help you, the chance to learn something could be valuable to them.  If they're just shoving their nose in for ego or political reasons (\"See, I'm helping, I'm helping!\"), they'll likely get the notion you'll embarrass them if they keep this nonsense up -- or bore them to death with a wall of jargon they're only pretending to understand. And if you've got the dreaded egomaniac who truly thinks they're an expert at your job no matter what evidence you can bring to the contrary, then smile, nod, and make whatever trivial cosmetic changes will make them go the hell away.  And update your resume. ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "ahead": 0.1985942927242112,
                "away": 0.1549420210582306,
                "bring": 0.1985942927242112,
                "chance": 0.17371960895549954,
                "changes": 0.14884492518678785,
                "death": 0.22346897649292288,
                "evidence": 0.2033862781176271,
                "expert": 0.1943674620489358,
                "got": 0.14363483895247542,
                "hell": 0.22346897649292288,
                "help": 0.121270729874548,
                "honestly": 0.1943674620489358,
                "job": 0.12397024141807618,
                "learn": 0.121270729874548,
                "likely": 0.15116099217691903,
                "make": 0.2028232492789914,
                "matter": 0.16229139272854942,
                "nonsense": 0.21546111693633593,
                "notion": 0.22346897649292288,
                "political": 0.2033862781176271,
                "reasons": 0.15770388984232564,
                "resume": 0.2033862781176271,
                "say": 0.11641379137214812,
                "thinks": 0.21546111693633593,
                "trivial": 0.1943674620489358,
                "truly": 0.22346897649292288,
                "try": 0.1281270494703221,
                "trying": 0.13824172421182573,
                "understand": 0.12232629370490894,
                "update": 0.1694927782802241,
                "valuable": 0.2033862781176271
            },
            "Max term": "death",
            "Max score": 0.22346897649292288
        }
    },
    {
        "ID": "44",
        "Question": "I am finishing my college degree in programming soon and I'm exploring the next steps to take to further my career. One option I've been considering is getting a certification or a series of certifications in the area of development I want to work in. Are these certifications worth the time and money? Do employers place a lot of value in them? ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "area": 0.28385661260114353,
                    "career": 0.21427184340784522,
                    "college": 0.2640865385969208,
                    "considering": 0.2543020357619512,
                    "degree": 0.2461566453190886,
                    "development": 0.1534677933408895,
                    "employers": 0.27634037930006955,
                    "getting": 0.18454028270113115,
                    "lot": 0.15576275819544536,
                    "money": 0.21427184340784522,
                    "option": 0.2640865385969208,
                    "place": 0.21051929985162535,
                    "programming": 0.12889787963263008,
                    "series": 0.27634037930006955,
                    "soon": 0.24254321455899688,
                    "steps": 0.25005944786007084,
                    "time": 0.11967062859981681,
                    "value": 0.23028937385584808,
                    "want": 0.14337854575160935,
                    "work": 0.12856044574635173,
                    "worth": 0.203783227225752
                },
                "Max term": "area",
                "Max score": 0.28385661260114353
            }
        ],
        "Best Answer": "The main purpose of certifications is to make money for the certifying body. Having said that, I think certifications are more important the earlier on in your career you are. As a hiring manager, I never use certifications or the lack thereof to filter potential employees, but I do think some companies may look for these as proof that you know what you are doing. Personally, I want the job candidate to show me they can do something (which is a whole other question, I realize!) The more experience you have, the more you can prove by examples that you know what you are doing and the less important certifications become. ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "body": 0.22422634920991596,
                "candidate": 0.2022745776134976,
                "career": 0.16411948465855183,
                "companies": 0.1672334954792579,
                "earlier": 0.21166029059054448,
                "employees": 0.2174172781458237,
                "examples": 0.17063097251665324,
                "experience": 0.13333942080258293,
                "filter": 0.2325599786781498,
                "hiring": 0.1983397316683508,
                "important": 0.296964242669818,
                "job": 0.12901350851188922,
                "know": 0.20283213074662415,
                "lack": 0.1885413460421445,
                "look": 0.13400043796584904,
                "main": 0.17638796007193244,
                "make": 0.10553717851132928,
                "manager": 0.17638796007193244,
                "money": 0.16411948465855183,
                "personally": 0.17245311412678566,
                "potential": 0.1885413460421445,
                "proof": 0.22422634920991596,
                "prove": 0.21166029059054448,
                "purpose": 0.17638796007193244,
                "question": 0.1193050061896053,
                "realize": 0.1885413460421445,
                "said": 0.14751202796825327,
                "think": 0.19745621489447407,
                "use": 0.08759717666635258,
                "want": 0.10981943621522586
            },
            "Max term": "important",
            "Max score": 0.296964242669818
        }
    },
    {
        "ID": "49",
        "Question": "During my four years at university we have been using much functional programming in several functional programming languages. But I have also used much object oriented programming to, and in fact I use object oriented languages more when doing my own small project to prepare for my first job. But I often wish that I was coding in a functional programming language when doing these projects. However, when looking for a job, it is very rare to see a job where knowledge of a functional programming language is required. Why isn't functional programming languages used more in the industry? There is quite much news about functional programming languages these days, so I wonder if functional programming is catching on in the industry now? ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "coding": 0.07430680339466691,
                    "days": 0.08997018229731327,
                    "fact": 0.08852027791394888,
                    "functional": 0.6196419453976422,
                    "industry": 0.19203180212646126,
                    "job": 0.21779190647035968,
                    "knowledge": 0.08195563702666037,
                    "language": 0.12320219376794225,
                    "languages": 0.28653840806412145,
                    "looking": 0.07736897763363625,
                    "object": 0.18820820768430552,
                    "oriented": 0.19623836556226434,
                    "prepare": 0.11910354386788073,
                    "programming": 0.4444430249444303,
                    "project": 0.061796589253054736,
                    "projects": 0.07616777766925485,
                    "quite": 0.08355250199584843,
                    "rare": 0.12234306327855508,
                    "required": 0.09601590106323063,
                    "small": 0.07820970086727252,
                    "university": 0.10609426272914234,
                    "use": 0.04929188250037064,
                    "used": 0.12771712657130874,
                    "using": 0.06140740631350234,
                    "wish": 0.1308640252979215,
                    "wonder": 0.10453686308259699,
                    "years": 0.07696090115857489
                },
                "Max term": "functional",
                "Max score": 0.6196419453976422
            }
        ],
        "Best Answer": "I was a professor and, just like programmers, professors are always looking for the Next Big Thing. When they think they've found one, they make it a bandwagon, and everyone piles on. Since they are preaching to students who think professors must be really smart, else why would they be professors, they get no resistance. Functional programming is such a bandwagon. Sure it's got lots of nice interesting questions to investigate, and lots of sort-of-interesting conference articles to write. It's not a particularly new idea, and you can do it in just about any modern language, and ideas don't have to be new to be interesting. It's also a good skill to have. Given that, functional programming is just one arrow to have in your quiver, not the only one, just as OOP is not the only one. My beef with computer science academia is lack of practical interplay with industry to determine what actually makes real-world sense, i.e. quality control. If that quality control were there, there might be a different emphasis, on classifying problems and the ranges of solutions to them, with tradeoffs, rather than just the latest bandwagons. ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "academia": 0.16281731419902543,
                "actually": 0.08951893270561613,
                "articles": 0.13885941421541065,
                "big": 0.10133681322326513,
                "computer": 0.10327448575785017,
                "conference": 0.16281731419902543,
                "control": 0.21855416008824732,
                "determine": 0.14818525626127255,
                "different": 0.08760957269561334,
                "functional": 0.22026884576244782,
                "given": 0.11288924360410663,
                "good": 0.07119814713004664,
                "got": 0.10465094113138444,
                "idea": 0.09428602405618806,
                "ideas": 0.12498528221210461,
                "industry": 0.11946026492708582,
                "interesting": 0.3416280761646487,
                "lack": 0.13199947709203688,
                "language": 0.07664234019646525,
                "latest": 0.14818525626127255,
                "like": 0.05803912064854669,
                "looking": 0.09626029087791788,
                "lots": 0.24415421695088182,
                "make": 0.07388751947358255,
                "makes": 0.09157878590129978,
                "modern": 0.13006180455745187,
                "new": 0.15426215236248675,
                "nice": 0.11824392403980286,
                "oop": 0.13636737574362354,
                "particularly": 0.13199947709203688,
                "practical": 0.14818525626127255,
                "problems": 0.09839589481870635,
                "professor": 0.16281731419902543,
                "programmers": 0.0872438798268313,
                "programming": 0.13824085624602125,
                "quality": 0.2319377423220361,
                "questions": 0.10465094113138444,
                "ranges": 0.16281731419902543,
                "real": 0.09839589481870635,
                "really": 0.0759259497971977,
                "science": 0.13199947709203688,
                "sense": 0.11708166096682691,
                "skill": 0.13636737574362354,
                "smart": 0.14161423493829334,
                "solutions": 0.1282578745850446,
                "sort": 0.11946026492708582,
                "students": 0.14469386249520474,
                "sure": 0.09575257368439553,
                "thing": 0.09289738195957283,
                "think": 0.13824085624602125,
                "world": 0.10072157039267896,
                "write": 0.08027244311488567
            },
            "Max term": "interesting",
            "Max score": 0.3416280761646487
        }
    },
    {
        "ID": "57",
        "Question": "The coding standards for the code hosted in drupal.org suggest to use two spaces to indent the code; other sites suggest to use tabs to indent the code. What is the proper indentation character for everything, and in every situation? Please explain the answer you give. ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "answer": 0.1622716330874569,
                    "character": 0.23408348041332763,
                    "code": 0.2882181600126115,
                    "coding": 0.15584911039484908,
                    "explain": 0.17762390707120435,
                    "indentation": 0.27447072130186484,
                    "org": 0.24980460077246874,
                    "proper": 0.23408348041332763,
                    "sites": 0.20817567538957002,
                    "situation": 0.20138119365713855,
                    "spaces": 0.27447072130186484,
                    "standards": 0.21621184161636306,
                    "suggest": 0.5131981650098005,
                    "tabs": 0.27447072130186484,
                    "use": 0.20676696308864626
                },
                "Max term": "suggest",
                "Max score": 0.5131981650098005
            }
        ],
        "Best Answer": "Tabs Now, of course, consistency matters more than either one, and a good IDE makes the differences negligible.  That said, the point of this thread is to be a holy war, so: I prefer tabs:  They're a character specifically meant for indentation They allow developers with different preferences in indentation size to change how it's the code looks without changing the code (separation of data and presentation for the proverbial win!) It's impossible to half-indent something with tabs.  So when you copy code from some website that used 3 spaces into your 4-space indented file, you don't have to deal with misalignment.  ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "allow": 0.12645648730710693,
                "change": 0.10190716668782411,
                "changing": 0.13159276553256408,
                "character": 0.1404939320887716,
                "code": 0.17298487927496256,
                "consistency": 0.16473384115295667,
                "copy": 0.1356707271785935,
                "course": 0.11625402302458655,
                "data": 0.10070448747790943,
                "deal": 0.12976760145227256,
                "developers": 0.09399087952370493,
                "differences": 0.14639705781509252,
                "different": 0.08864082731567355,
                "file": 0.10972349113936428,
                "good": 0.07203622242146127,
                "half": 0.1404939320887716,
                "holy": 0.16473384115295667,
                "ide": 0.12086643489606505,
                "impossible": 0.1356707271785935,
                "indentation": 0.32946768230591333,
                "looks": 0.12494439654209445,
                "makes": 0.09265676223601313,
                "matters": 0.16473384115295667,
                "meant": 0.1404939320887716,
                "point": 0.09445096740535483,
                "prefer": 0.11963577642771206,
                "preferences": 0.1540075105164576,
                "presentation": 0.15883071542663574,
                "said": 0.10449013248794155,
                "size": 0.1404939320887716,
                "space": 0.1335532464623047,
                "spaces": 0.16473384115295667,
                "specifically": 0.1280602744772284,
                "tabs": 0.4942015234588699,
                "thread": 0.16473384115295667,
                "used": 0.08038623599271252,
                "war": 0.15883071542663574,
                "website": 0.12645648730710693,
                "win": 0.1499295488704282
            },
            "Max term": "tabs",
            "Max score": 0.4942015234588699
        }
    },
    {
        "ID": "73",
        "Question": "We often receive last minute requests from the business asking for an extra feature to be implemented.  The project manager is usually responsible for filtering out these requests as \"must haves\" or \"nice to have\", but there are cases where the business wants to squeeze all these features into a release.   Is there a good way to say NO to the business?  What steps can be taken to stop or minimize scope creep? ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "asking": 0.16187259538395188,
                    "business": 0.44843571980495367,
                    "cases": 0.15903772004486944,
                    "creep": 0.22937610003704723,
                    "extra": 0.19562434771049955,
                    "feature": 0.14365036039836504,
                    "features": 0.144559917720571,
                    "good": 0.10030354203356424,
                    "implemented": 0.18323032559486557,
                    "manager": 0.17397310837727392,
                    "minute": 0.2144407117046427,
                    "nice": 0.16658136318458677,
                    "project": 0.1083159455487278,
                    "release": 0.18068895937809504,
                    "requests": 0.3912486954209991,
                    "responsible": 0.2144407117046427,
                    "say": 0.11949104468340124,
                    "scope": 0.19562434771049955,
                    "steps": 0.18890849670967844,
                    "stop": 0.18890849670967844,
                    "taken": 0.18890849670967844,
                    "usually": 0.1494785732683179,
                    "wants": 0.17831167004711868,
                    "way": 0.10086166180119466
                },
                "Max term": "business",
                "Max score": 0.44843571980495367
            }
        ],
        "Best Answer": "Ask them what they want you to drop so you'll have the time to squeeze this latest request in. I've not had to do this for a while, and when I did, I used it sparingly otherwise it loses it's potency. I found it most effective towards the end of the phase when you were tidying stuff up or doing the little improvements and tweaks you'd agreed on in the planning stage. ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "agreed": 0.2900632263273401,
                "ask": 0.19193558454533616,
                "drop": 0.2991474221096921,
                "effective": 0.25986242941033755,
                "end": 0.172905641840548,
                "improvements": 0.3102655791908014,
                "latest": 0.28238264823137743,
                "little": 0.19680043425924137,
                "phase": 0.27572942885884794,
                "planning": 0.23263081665117946,
                "request": 0.27572942885884794,
                "stage": 0.2900632263273401,
                "stuff": 0.19553897111383173,
                "time": 0.12228726436984151,
                "tweaks": 0.2991474221096921,
                "used": 0.15140229775914354,
                "want": 0.14651356255445713
            },
            "Max term": "improvements",
            "Max score": 0.3102655791908014
        }
    },
    {
        "ID": "94",
        "Question": "I realize there have been lots of discussions about this type of thing and they often devolve into dogma around whether you ask the \"100 logical pirates\" type of questions or whether you get them to write \"fizz buzz\".  I'm interested in what techniques and questions have been effective for you when interviewing potential developers for jobs.  One technique per answer so we can vote on them, please. ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "100": 0.2068727582083137,
                    "answer": 0.15526245031173674,
                    "ask": 0.16245824395281186,
                    "developers": 0.14983826683924298,
                    "discussions": 0.253204558154623,
                    "effective": 0.2199529287459624,
                    "interested": 0.19474033590932902,
                    "interviewing": 0.23338308487522544,
                    "jobs": 0.2068727582083137,
                    "logical": 0.20978239607822155,
                    "lots": 0.196903529129234,
                    "potential": 0.21290775319980948,
                    "questions": 0.3375921971417072,
                    "realize": 0.21290775319980948,
                    "technique": 0.253204558154623,
                    "techniques": 0.2162833960515631,
                    "thing": 0.14983826683924298,
                    "type": 0.367351284154325,
                    "vote": 0.253204558154623,
                    "write": 0.12947494856766253
                },
                "Max term": "type",
                "Max score": 0.367351284154325
            }
        ],
        "Best Answer": "Besides real technical questions, and typically at the end of the interview I try to get a grasp of their level of interest in the industry and it's culture with questions like:  Have you seen anything recently programming-related that you found interesting and would like to recommend to other fellow programmers? A new language, tool, platform, technique, website? Can you name any well known person in our industry whose work you like or find inspiring and why? (developer, web site founder, author, speaker, etc) What are you reading now or what was the last software related book you read? What programming related sites do you frequent?  Although failing to answer these questions at all (sadly it happens very frequently) does not mean a 'no-hire' to me, they say a lot about the way a person approaches the software development profession. ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "answer": 0.09405719246720878,
                "approaches": 0.13568135447779825,
                "author": 0.13837312592978201,
                "book": 0.10225580685552642,
                "culture": 0.13324635100919416,
                "developer": 0.08786017941912692,
                "development": 0.08041234667601597,
                "end": 0.08865862562908508,
                "failing": 0.1487320293194125,
                "fellow": 0.14138227039845083,
                "frequent": 0.15339001678839043,
                "frequently": 0.12708509471893825,
                "grasp": 0.159090932709043,
                "happens": 0.12532245108816775,
                "hire": 0.13837312592978201,
                "industry": 0.23345238265861554,
                "interesting": 0.1112697576503717,
                "interview": 0.12532245108816775,
                "known": 0.12212475816743146,
                "language": 0.074888235608375,
                "level": 0.09725488538794509,
                "like": 0.17013235753851857,
                "lot": 0.08161483682379507,
                "mean": 0.10596494577726646,
                "new": 0.07536578594784184,
                "person": 0.21695982475247724,
                "platform": 0.12708509471893825,
                "profession": 0.15339001678839043,
                "programmers": 0.08524713899800548,
                "programming": 0.1350769533748266,
                "questions": 0.30676742056657924,
                "read": 0.09560604238763598,
                "reading": 0.10677606784920447,
                "real": 0.0961439190816881,
                "recently": 0.12532245108816775,
                "recommend": 0.12367360808785864,
                "related": 0.3578494304243442,
                "say": 0.08287673278074693,
                "seen": 0.10847991237623862,
                "site": 0.11440202620937191,
                "sites": 0.12066446361918984,
                "software": 0.15025178998008787,
                "speaker": 0.15339001678839043,
                "technical": 0.1015744811641892,
                "technique": 0.15339001678839043,
                "tool": 0.1112697576503717,
                "try": 0.09121557777455871,
                "typically": 0.14479375702953043,
                "way": 0.06995574450844899,
                "web": 0.09405719246720878,
                "website": 0.12212475816743146,
                "work": 0.06736167183440171
            },
            "Max term": "related",
            "Max score": 0.3578494304243442
        }
    },
    {
        "ID": "104",
        "Question": "We've often run across scenarios where the business will promise a client a new feature.  The business will promise that the feature be implemented in a specific way.  These technical details promised by the business are usually poor.  Unfortunately, client is now set and want this feature to be implemented in the way described by the business. In the end, the business just wants this feature to be completed without regard to quality and maintainability.  Is there a good way to push back?  How can we explain to the business that providing technical details before the requirements have been gathered is a bad idea? ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "bad": 0.08534217547562133,
                    "business": 0.5644157914049831,
                    "client": 0.20017005037290864,
                    "completed": 0.12828227393341415,
                    "described": 0.13137766390908062,
                    "details": 0.22161819352786488,
                    "end": 0.08044382133245842,
                    "explain": 0.09341626972944976,
                    "feature": 0.3616060374723013,
                    "good": 0.06312265120430285,
                    "idea": 0.08359183560027804,
                    "implemented": 0.2306196510728456,
                    "maintainability": 0.13917742370980418,
                    "new": 0.06838265060336757,
                    "poor": 0.12310958533714635,
                    "promise": 0.2699020587808374,
                    "promised": 0.14435011230607198,
                    "providing": 0.1349510293904187,
                    "push": 0.11888319101776086,
                    "quality": 0.10281535264510305,
                    "requirements": 0.09614659718809848,
                    "run": 0.08929744400558455,
                    "scenarios": 0.1349510293904187,
                    "set": 0.0909739085918307,
                    "specific": 0.09406929856749718,
                    "technical": 0.184325875947904,
                    "unfortunately": 0.12828227393341415,
                    "usually": 0.09406929856749718,
                    "want": 0.06816498711928536,
                    "wants": 0.11221443556075632,
                    "way": 0.19042165516844997
                },
                "Max term": "business",
                "Max score": 0.5644157914049831
            }
        ],
        "Best Answer": "That's an organizational issue.  If the higher-ups don't understand this, there's not much you can do.  Try to explain the issue to your non-technical bosses, but don't be surprised when you get nowhere. It's is a common problem for developers working in non-development companies that, for whatever reason, sell software. It's not a pleasant tactic, but you can just bludgeon them with evidence.  At the start of a project, write down exactly why it's going to fail (because technical details were poor) and email it to relevant people.  Keep emailing them throughout, and when the project eventually ends up a disaster with pissed off customers, cite those emails you sent at every opportunity.  It may generate some ill will, but there's really no good way to try to fix a systemic issue like that. ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "common": 0.11217865283324767,
                "companies": 0.13272332933825245,
                "customers": 0.14539264294856796,
                "details": 0.1416828445760745,
                "developers": 0.10530812185842847,
                "development": 0.0932902565135537,
                "email": 0.15741050829344275,
                "emails": 0.16798224766738407,
                "ends": 0.17795518479844755,
                "eventually": 0.1520065515159013,
                "evidence": 0.16798224766738407,
                "exactly": 0.14743757116237927,
                "explain": 0.11944400966602173,
                "fail": 0.13998868617102653,
                "fix": 0.13146187501089654,
                "generate": 0.1605333626760313,
                "going": 0.09540827897627219,
                "good": 0.08070995108697623,
                "higher": 0.14963410944031064,
                "issue": 0.37755839509029976,
                "like": 0.0657929282923496,
                "non": 0.21824060545238985,
                "opportunity": 0.1545855428797021,
                "organizational": 0.17795518479844755,
                "people": 0.0825486616437617,
                "poor": 0.15741050829344275,
                "problem": 0.09614931014601484,
                "project": 0.1743143759420188,
                "really": 0.0860693703611557,
                "reason": 0.11487502931249971,
                "relevant": 0.13838614979538263,
                "sell": 0.1545855428797021,
                "sent": 0.1845690933657809,
                "software": 0.0871571879710094,
                "start": 0.10285716396762491,
                "surprised": 0.1725512280209061,
                "technical": 0.23568294658075567,
                "try": 0.21164721589100613,
                "understand": 0.10103260630732916,
                "ups": 0.1845690933657809,
                "way": 0.08115904608634376,
                "working": 0.09849050319086655,
                "write": 0.09099653879476259
            },
            "Max term": "issue",
            "Max score": 0.37755839509029976
        }
    },
    {
        "ID": "134",
        "Question": "How do you bill your programming projects? Do you do it per hour? Per job?  Please include what kind of project you are doing in the answer. (Mobile, Web, Desktop, etc... You can be more specific if you want.) BONUS: If you'd like to give specific amounts in your answer, you may. ;-) ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "amounts": 0.3089998381594188,
                    "answer": 0.36537163690215496,
                    "bonus": 0.3089998381594188,
                    "desktop": 0.26353177934764394,
                    "hour": 0.2888799016149589,
                    "include": 0.2343647063664702,
                    "job": 0.1714188033433033,
                    "kind": 0.20738949180117464,
                    "like": 0.11014847515168785,
                    "mobile": 0.3089998381594188,
                    "programming": 0.13117893025438362,
                    "project": 0.14591585452553918,
                    "projects": 0.1798495111179815,
                    "specific": 0.4027346784669454,
                    "want": 0.14591585452553918,
                    "web": 0.18268581845107748
                },
                "Max term": "specific",
                "Max score": 0.4027346784669454
            }
        ],
        "Best Answer": "There's always going to be a struggle between you and the client over costs: you want to charge as much as you can from a client, and a client is going to want to get as much work for as little cost as possible. So, when you charge hourly, it leaves open to negotiation how many hours a project should take to complete. You may think it'll take 10 hours, but your client thinks you should do it in 5. By charging by project, there's very little open to negotiation: it costs $X, and the client can take it or leave it. ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "10": 0.12063029962970463,
                "charge": 0.2889445310811455,
                "client": 0.575837760439602,
                "complete": 0.11516755208792041,
                "cost": 0.12063029962970463,
                "costs": 0.2833236951367024,
                "going": 0.17172567727053611,
                "hourly": 0.14447226554057274,
                "hours": 0.2366186641634655,
                "leave": 0.130846349752863,
                "leaves": 0.15528776335606098,
                "little": 0.21071750218437527,
                "negotiation": 0.33220652234309844,
                "open": 0.20676394566416773,
                "possible": 0.09768503327051174,
                "project": 0.15687451124696736,
                "struggle": 0.15117590192190034,
                "think": 0.07051540299191626,
                "thinks": 0.16015106320551534,
                "want": 0.15687451124696736,
                "work": 0.07033080502535652
            },
            "Max term": "client",
            "Max score": 0.575837760439602
        }
    },
    {
        "ID": "135",
        "Question": "Who in the software engineering and software development fields uses Twitter to tweet about relevant happenings in the field? ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "development": 0.21900149201593702,
                    "engineering": 0.34611383085945135,
                    "field": 0.3628938948177275,
                    "fields": 0.36952558030797733,
                    "relevant": 0.32486536549641315,
                    "software": 0.4092078834147358,
                    "twitter": 0.4177547842541272,
                    "uses": 0.3413133045598469
                },
                "Max term": "twitter",
                "Max score": 0.4177547842541272
            }
        ],
        "Best Answer": "I'll probably get flamed for this but... 140 characters is hardly the format to get any real pearls of programming wisdom.  Most (but not all) programming concepts/thoughts/ideas require more space to be articulated. I would follow the blogs of the list of programmers that everyone is suggesting. ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "blogs": 0.27628571814272973,
                "characters": 0.28380046470483306,
                "concepts": 0.25425173387113154,
                "follow": 0.22046125433525482,
                "format": 0.26403430129495953,
                "hardly": 0.28380046470483306,
                "ideas": 0.23303025769553393,
                "list": 0.20374291814361636,
                "probably": 0.1723702576101313,
                "programmers": 0.16266286268732943,
                "programming": 0.25774476630290544,
                "real": 0.18345536626363784,
                "require": 0.21231747508099133,
                "space": 0.24610795461686802,
                "suggesting": 0.28380046470483306,
                "thoughts": 0.23598566904295312,
                "wisdom": 0.2926885234123914
            },
            "Max term": "wisdom",
            "Max score": 0.2926885234123914
        }
    },
    {
        "ID": "163",
        "Question": "Are there any great programming or software development books that are language agnostic?  Why should I read it? ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "agnostic": 0.5365079880612943,
                    "books": 0.4210561393582145,
                    "development": 0.29006439653819577,
                    "great": 0.35500871863563344,
                    "language": 0.27013775579854465,
                    "programming": 0.24362561588177936,
                    "read": 0.34487128080352614,
                    "software": 0.2709950436153421
                },
                "Max term": "agnostic",
                "Max score": 0.5365079880612943
            }
        ],
        "Best Answer": "The Pragmatic Programmer: From Journeyman to Master - Andrew Hunt and David Thomas This book is all about how to write code that works and is maintainable. A key concept is being practical. Everything in the book is boiled down to 70 tips that are easy to remember that help you deliver better, higher-quality software. ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "70": 0.26565156994329037,
                "better": 0.13282704855470898,
                "book": 0.3414954600419461,
                "code": 0.0929857610195507,
                "concept": 0.20392509606726783,
                "david": 0.2561321256943475,
                "deliver": 0.24835417340731675,
                "easy": 0.16961004582700678,
                "help": 0.14416211272334087,
                "higher": 0.21536940646452996,
                "hunt": 0.2561321256943475,
                "key": 0.20392509606726783,
                "maintainable": 0.24177800845023076,
                "master": 0.2187840787180863,
                "practical": 0.24177800845023076,
                "pragmatic": 0.22249603878772864,
                "programmer": 0.13732179442093506,
                "quality": 0.1892139840288559,
                "remember": 0.18579931177529954,
                "software": 0.12544594218954838,
                "tips": 0.21536940646452996,
                "works": 0.17829570531457528,
                "write": 0.13097194632866932
            },
            "Max term": "book",
            "Max score": 0.3414954600419461
        }
    },
    {
        "ID": "177",
        "Question": "The Actor Model which is used by Erlang seems to be a very different way to do concurrent programming. What are your thoughts about the Actor Model? Will it be a popular solution for concurrency? ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "actor": 0.5841993333103491,
                    "concurrency": 0.25374020765965394,
                    "concurrent": 0.2757298620054475,
                    "different": 0.16301605165851368,
                    "erlang": 0.26923338897153654,
                    "model": 0.454300314663009,
                    "popular": 0.2420073651563271,
                    "programming": 0.12861310624932956,
                    "solution": 0.20657763071762128,
                    "thoughts": 0.23551089212241608,
                    "used": 0.14783533949377287,
                    "way": 0.1332162945110199
                },
                "Max term": "actor",
                "Max score": 0.5841993333103491
            }
        ],
        "Best Answer": "I presume you knows the concept. Well, I don't know very well yet. The short answer is that I believe in popularity of this model to concurrency in short and medium term. I always loved lambda and closures and I see actor like closures specially handled to power concurrency. Thus multi core processors bring to us a new paradigm to programming, concurrency is obligatory to achieve high performance. Actor model seems the ease path to exploit modern hardware. Sooner or later (i hope sooner) almost every mainstream language will support a better model to concurrency. IMHO Actor model so well implemented in Erlang should be the best candidate. One obstacle to Actor model gain popularity is the little impedance with OOP, the dominant paradigm now. But the first step is being given, the main languages are implementing some functional features which will clean the path to Actor model. I am reading a lot about this issue, I think it is very important to every programmer advance in his/her skills. Late Edit: Now I understand better the paradigma. So I can say it's better to a programming languague allow allow the problem be handled by libraries or eventually has a feature to facilitate the adoption of one model. Tie a language with just one model doesn't see a good ideia. ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "achieve": 0.08675056334107002,
                "actor": 0.4337528167053501,
                "advance": 0.08675056334107002,
                "allow": 0.13813665049052234,
                "answer": 0.053194559878471666,
                "believe": 0.06408575129735755,
                "best": 0.04743077276434801,
                "better": 0.1349634052091142,
                "bring": 0.07995951666414704,
                "candidate": 0.07825767854392693,
                "clean": 0.07995951666414704,
                "concept": 0.06906832524526117,
                "concurrency": 0.3014328117360093,
                "core": 0.07535820293400232,
                "edit": 0.05992905492190777,
                "erlang": 0.07995951666414704,
                "eventually": 0.07410098216847716,
                "feature": 0.056348089047226026,
                "features": 0.056704870727711125,
                "functional": 0.06086156710316089,
                "gain": 0.08997474753526666,
                "given": 0.06238391317713744,
                "good": 0.039344926825006316,
                "handled": 0.16377780319184992,
                "hardware": 0.06906832524526117,
                "high": 0.06038778944813232,
                "hope": 0.07535820293400232,
                "imho": 0.0841162130395968,
                "implemented": 0.07187367072480533,
                "implementing": 0.08675056334107002,
                "important": 0.05744600363546764,
                "issue": 0.06135140804379179,
                "know": 0.03923669467914852,
                "knows": 0.06672010159883075,
                "language": 0.08470690286979636,
                "languages": 0.04925192555026815,
                "late": 0.08188890159592496,
                "later": 0.06746123450658728,
                "libraries": 0.06601513622913548,
                "like": 0.03207309525532714,
                "little": 0.057070685808872534,
                "lot": 0.046157717560075265,
                "main": 0.0682424476728073,
                "mainstream": 0.07673533246995039,
                "medium": 0.07825767854392693,
                "model": 0.5396898760526982,
                "modern": 0.07187367072480533,
                "multi": 0.07294445117566203,
                "new": 0.04262353264252735,
                "oop": 0.07535820293400232,
                "paradigm": 0.16377780319184992,
                "path": 0.15071640586800464,
                "performance": 0.06906832524526117,
                "power": 0.07294445117566203,
                "problem": 0.046871389723593,
                "processors": 0.0841162130395968,
                "programmer": 0.04651014781034795,
                "programming": 0.07639351011889682,
                "reading": 0.06038778944813232,
                "say": 0.046871389723593,
                "short": 0.12940138385556285,
                "skills": 0.06238391317713744,
                "sooner": 0.17350112668214004,
                "specially": 0.08997474753526666,
                "step": 0.07535820293400232,
                "support": 0.05948443756721281,
                "term": 0.07087679797428052,
                "think": 0.03819675505944841,
                "understand": 0.04925192555026815
            },
            "Max term": "model",
            "Max score": 0.5396898760526982
        }
    },
    {
        "ID": "188",
        "Question": "For the longest time in places like Java's IRC channel, SO, and other places I've been told something along the lines of \"Worry about how the code looks and its readability/understandability now, and performance later if absolutely necessary\". So for the longest time, I haven't really been OCD about performance for my small desktop or web apps, just removing the obviously inefficient. Most responses are \"What about scalability?\". Thats a legitimate point, but if my app was only built to parse, say, files 10,000 lines long, should I make my code a mess for the small percentage of people that are going to shove in a 1,000,000 line file? My main question is when should I trade the easy but somewhat inefficient ways of doing tasks for big giant complicated beasts that do things extremely quickly but destroy any possible ways of upgrading and make the code excessively difficult and prone to rewriting anyway by the next developer?  ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "000": 0.39176859729226565,
                    "10": 0.10144427407009966,
                    "absolutely": 0.11504099226965801,
                    "app": 0.09102906270154576,
                    "apps": 0.11003548035731635,
                    "big": 0.08693926167868868,
                    "built": 0.11158311477498462,
                    "code": 0.14668125227369333,
                    "complicated": 0.11003548035731635,
                    "desktop": 0.1191307932925151,
                    "developer": 0.07714289788237635,
                    "difficult": 0.10144427407009966,
                    "easy": 0.08918431398284382,
                    "excessively": 0.1305895324307552,
                    "extremely": 0.11504099226965801,
                    "file": 0.09303922488266238,
                    "files": 0.09949245210856084,
                    "going": 0.07220651330296461,
                    "inefficient": 0.27936969073190787,
                    "java": 0.08489860078208732,
                    "later": 0.10473285414394103,
                    "like": 0.04979314167446643,
                    "line": 0.09524741308356037,
                    "lines": 0.2339856284623937,
                    "long": 0.0774906847215652,
                    "looks": 0.10594567933445927,
                    "main": 0.10594567933445927,
                    "make": 0.12677971974804958,
                    "mess": 0.1305895324307552,
                    "necessary": 0.09685036639926055,
                    "obviously": 0.11003548035731635,
                    "people": 0.062474148984540206,
                    "percentage": 0.1346793334536123,
                    "performance": 0.21445569108795,
                    "places": 0.24298843899111291,
                    "point": 0.08008900104764509,
                    "possible": 0.08214840979471802,
                    "prone": 0.1305895324307552,
                    "question": 0.07165936906127247,
                    "quickly": 0.1004471409431845,
                    "readability": 0.11699281423119685,
                    "really": 0.06513867771900775,
                    "removing": 0.1346793334536123,
                    "responses": 0.13968484536595394,
                    "rewriting": 0.1346793334536123,
                    "say": 0.07276733755836536,
                    "small": 0.16696276836803053,
                    "somewhat": 0.11324549011691239,
                    "tasks": 0.10248780183978588,
                    "thats": 0.13968484536595394,
                    "things": 0.06638520960524984,
                    "time": 0.11011003965233454,
                    "told": 0.12413630520485676,
                    "ways": 0.18750281078027697,
                    "web": 0.08258399244767907,
                    "worry": 0.12149421949555646
                },
                "Max term": "000",
                "Max score": 0.39176859729226565
            }
        ],
        "Best Answer": "Worry about performance when it becomes a problem. If you write a small app to process 10,000 line files and you get a 1,000,000 line file every 100th file, it probably doesn't matter that it takes longer to process that one file. However, if you are regularly getting files that are 5-10 times larger than initially and your application is taking too long to do its job, then you start profiling and optimizing. Now, I said \"too long to do its job\". That is up to the user or sponsoring organization to decide. If I'm doing a task and it takes me 5 minutes to do something when it took me 3 without the software or with a different tool, I'd probably file a bug report or maintenance request to have that improved. If you are the user, how long you want your software to take to do its job is up to you - only you can decide if you want it done faster or if you are willing to wait longer to have more readable code. ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "000": 0.37191243647379146,
                "10": 0.1926054686184041,
                "app": 0.08641540116601323,
                "application": 0.0760298189294657,
                "bug": 0.09358053774555775,
                "code": 0.04641564969319466,
                "decide": 0.20891701826588166,
                "different": 0.0713528536096986,
                "faster": 0.0994246379948338,
                "file": 0.3532947260490099,
                "files": 0.1888996746048149,
                "getting": 0.08059565184221872,
                "improved": 0.12397081215793047,
                "initially": 0.11784465636777552,
                "job": 0.2206895822534729,
                "larger": 0.11784465636777552,
                "line": 0.1808399024963503,
                "long": 0.2206895822534729,
                "longer": 0.1988492759896676,
                "maintenance": 0.11533648052032391,
                "matter": 0.09630273430920205,
                "minutes": 0.10592770419100288,
                "organization": 0.10592770419100288,
                "performance": 0.10179317477134207,
                "probably": 0.15059087975789187,
                "problem": 0.06907924217022685,
                "process": 0.1621273801351455,
                "readable": 0.1130928407705474,
                "regularly": 0.12397081215793047,
                "report": 0.1130928407705474,
                "request": 0.11784465636777552,
                "said": 0.08411100564888102,
                "small": 0.07925026458646871,
                "software": 0.12523755990723323,
                "start": 0.07389855348802822,
                "takes": 0.1740653746871611,
                "taking": 0.10921032473016895,
                "task": 0.08766840267159548,
                "times": 0.08766840267159548,
                "took": 0.11533648052032391,
                "tool": 0.09274533728648761,
                "user": 0.16027535947897603,
                "wait": 0.11784465636777552,
                "want": 0.12523755990723323,
                "willing": 0.10592770419100288,
                "worry": 0.11533648052032391,
                "write": 0.06537719231172649
            },
            "Max term": "000",
            "Max score": 0.37191243647379146
        }
    },
    {
        "ID": "192",
        "Question": "If I have some code that has 80% test coverage (all tests pass), is it fair to say that it's of higher quality than code with no test coverage?   Or is it fair to say it's more maintainable? ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "80": 0.22429531912263712,
                    "code": 0.1906562037232672,
                    "coverage": 0.4840568851381865,
                    "fair": 0.5251683505196842,
                    "higher": 0.22079463019089118,
                    "maintainable": 0.24786847324506495,
                    "pass": 0.22429531912263712,
                    "quality": 0.19398034435999117,
                    "say": 0.2837488251335775,
                    "test": 0.30781225505089616,
                    "tests": 0.17274653198178908
                },
                "Max term": "fair",
                "Max score": 0.5251683505196842
            }
        ],
        "Best Answer": "By one definition it's more maintainable, as any breaking change is more likely to be caught by the tests. However, the fact that code passes the unit tests doesn't mean it's intrinsically of higher quality. The code might still be badly formatted with irrelevant comments and inappropriate data structures, but it can still pass the tests. I know which code I'd prefer to maintain and extend. ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "badly": 0.22516467354838382,
                "breaking": 0.20010123906946578,
                "caught": 0.21050350423893507,
                "change": 0.13929071136148163,
                "code": 0.2364425159890983,
                "comments": 0.16696918087741544,
                "data": 0.13764684225851798,
                "definition": 0.17986615187924304,
                "extend": 0.21709604983525152,
                "fact": 0.1523080115679667,
                "formatted": 0.22516467354838382,
                "higher": 0.1825458140874047,
                "irrelevant": 0.20492958635816108,
                "know": 0.09819107905899055,
                "likely": 0.1523080115679667,
                "maintain": 0.18544006976001703,
                "maintainable": 0.20492958635816108,
                "mean": 0.14997437011162973,
                "pass": 0.18544006976001703,
                "passes": 0.22516467354838382,
                "prefer": 0.1635228703192886,
                "quality": 0.16037663528109905,
                "structures": 0.20010123906946578,
                "tests": 0.4284636308971138,
                "unit": 0.14571546597165025
            },
            "Max term": "tests",
            "Max score": 0.4284636308971138
        }
    },
    {
        "ID": "206",
        "Question": "Test driven development. I get it, like it. But writing tests does require overhead. So should TDD be used universally throughout the code base, or are there areas where TDD provides a high ROI and other areas where the ROI is so low that it is not worth following. ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "areas": 0.40683463711513124,
                    "base": 0.18880332214002302,
                    "code": 0.08501236369730295,
                    "development": 0.12275956388950474,
                    "driven": 0.1864388078754661,
                    "following": 0.17464908594350192,
                    "high": 0.16300710108381997,
                    "like": 0.08657614938607086,
                    "low": 0.19132048842116303,
                    "overhead": 0.22104588662837316,
                    "provides": 0.2112439854741118,
                    "require": 0.16986728391704323,
                    "roi": 0.4683383172938277,
                    "tdd": 0.37760664428004603,
                    "test": 0.13725148652836786,
                    "tests": 0.15405311463769,
                    "universally": 0.23416915864691384,
                    "used": 0.11851597594736386,
                    "worth": 0.16300710108381997,
                    "writing": 0.13534854617687156
                },
                "Max term": "roi",
                "Max score": 0.4683383172938277
            }
        ],
        "Best Answer": "I'd say avoid TDD in places where the code is likely to change structurally a lot.  Ie, it's great to have a pile of tests for a method whose signature changes rarely but gets refactored internally more frequently, but it sucks to have to fix your tests every time a highly volatile interface changes dramatically. The apps I've been working on recently have been data-driven webapps built on a Gui->Presenter->BusinessLogic->Data Access Layer-based architecture.  My data access layer is tested like nobody's business.  The business logic layer is pretty well tested.  The Presenters are only tested in the more stable areas, and the GUI, which is changing hourly, has almost no tests. ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "access": 0.1958928015561073,
                "apps": 0.11222603215784774,
                "architecture": 0.11733119223000617,
                "areas": 0.11932187045043789,
                "avoid": 0.098778433090196,
                "based": 0.09095976730880628,
                "built": 0.11380447639566835,
                "business": 0.18568248141179042,
                "change": 0.088131681851492,
                "changes": 0.1897828411293637,
                "changing": 0.11380447639566835,
                "code": 0.04986711219922241,
                "data": 0.26127473091098385,
                "dramatically": 0.13736048734536754,
                "driven": 0.10936250383201725,
                "fix": 0.10147311661239149,
                "frequently": 0.11380447639566835,
                "gets": 0.11380447639566835,
                "great": 0.088131681851492,
                "gui": 0.2532151435998225,
                "highly": 0.11733119223000617,
                "hourly": 0.12391288827771578,
                "interface": 0.10936250383201725,
                "internally": 0.13318926784762086,
                "layer": 0.35199357669001846,
                "like": 0.050784407907820635,
                "likely": 0.09636795654023303,
                "logic": 0.106817842926421,
                "lot": 0.0730859412851804,
                "method": 0.0996418701664344,
                "pile": 0.13736048734536754,
                "places": 0.12391288827771578,
                "pretty": 0.08922133383821856,
                "rarely": 0.10805481266010107,
                "recently": 0.11222603215784774,
                "refactored": 0.14246564741752596,
                "say": 0.0742159668712991,
                "signature": 0.14246564741752596,
                "stable": 0.14246564741752596,
                "sucks": 0.14246564741752596,
                "tdd": 0.11074949618229656,
                "tested": 0.3464998373521473,
                "tests": 0.2710964717895879,
                "time": 0.05615103787795272,
                "working": 0.07602309273826749
            },
            "Max term": "layer",
            "Max score": 0.35199357669001846
        }
    },
    {
        "ID": "215",
        "Question": "Having taken a course in Operating Systems I'm interested in expanding my knowledge of the Linux kernel and practice working with a big system. What are some interesting but not overly difficult projects I can try my hand at?  EDIT: a bit of background on what I did do with the kernel.   Implemented a new scheduling policy Implemented User Threads and a corresponding mutex library (not really kernel hacking but contained kernel related theory)  ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "background": 0.14101260662642048,
                    "big": 0.10986905977853897,
                    "bit": 0.11670554057515709,
                    "course": 0.12457586669875219,
                    "difficult": 0.1281996970849636,
                    "edit": 0.11757785795514643,
                    "hacking": 0.17020033817213687,
                    "hand": 0.125733091783415,
                    "implemented": 0.28202521325284097,
                    "interested": 0.1309015574959868,
                    "interesting": 0.1234640348631759,
                    "kernel": 0.706104115877486,
                    "knowledge": 0.11055217905024452,
                    "library": 0.1281996970849636,
                    "linux": 0.15055094783406184,
                    "new": 0.08362527447029013,
                    "operating": 0.17020033817213687,
                    "practice": 0.1281996970849636,
                    "projects": 0.102744778763802,
                    "really": 0.08231868016839816,
                    "related": 0.13235562380602012,
                    "systems": 0.12239416910187702,
                    "taken": 0.14538248212149,
                    "theory": 0.1535377159497585,
                    "threads": 0.15687663863129647,
                    "try": 0.10121207695813861,
                    "user": 0.10668052513138775,
                    "working": 0.09419853076388505
                },
                "Max term": "kernel",
                "Max score": 0.706104115877486
            }
        ],
        "Best Answer": "I've not done much work on kernels before (they scare me), but I've heard that http://kernelnewbies.org/ is a fantastic resource if you want to get involved in kernel work. As already mentioned SourceForge is a great place to look if you want to get involved in an open-source kernel-related project. Also, a similar question has been asked on Stack Overflow before, so you may want to look here. What are some interesting, small Linux kernel projects to help learn the source? ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "asked": 0.12269168706561738,
                "great": 0.11480328555684374,
                "heard": 0.14618939462019137,
                "help": 0.10070966859572511,
                "http": 0.14075582415994514,
                "interesting": 0.12979684301737243,
                "involved": 0.2695508206232242,
                "kernel": 0.5567415959475859,
                "learn": 0.10070966859572511,
                "linux": 0.15827311786618609,
                "look": 0.21386201275852249,
                "mentioned": 0.1649232706519346,
                "open": 0.11550454446386055,
                "org": 0.16890279037104333,
                "overflow": 0.14618939462019137,
                "place": 0.12867210091395043,
                "project": 0.087634809354056,
                "projects": 0.1080148395833564,
                "question": 0.0952041991175417,
                "related": 0.13914450588509208,
                "resource": 0.17893037919678012,
                "scare": 0.17893037919678012,
                "similar": 0.12093811492410675,
                "small": 0.11091052609836996,
                "source": 0.220616884838499,
                "sourceforge": 0.17893037919678012,
                "stack": 0.14075582415994514,
                "want": 0.262904428062168,
                "work": 0.15715559248274122
            },
            "Max term": "kernel",
            "Max score": 0.5567415959475859
        }
    },
    {
        "ID": "220",
        "Question": "How would someone implement Agile process concepts as a solo developer?  Agile seems useful for getting applications developed at a faster pace, but it also seems very team oriented... ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "agile": 0.5024573299491326,
                    "applications": 0.24435015351377048,
                    "concepts": 0.29261110127112405,
                    "developed": 0.29261110127112405,
                    "developer": 0.19294234823687842,
                    "faster": 0.2619476759467048,
                    "getting": 0.2123401615259182,
                    "implement": 0.2537225978224759,
                    "oriented": 0.2619476759467048,
                    "process": 0.2135732716267775,
                    "solo": 0.30386958035231765,
                    "team": 0.20879555656683008,
                    "useful": 0.22609257345502137
                },
                "Max term": "agile",
                "Max score": 0.5024573299491326
            }
        ],
        "Best Answer": " By doing test-driven development By developing in small sprints By having a lot of contact with the customer  I remember reading a thesis about Cowboy Development, that is essentially Agile for solo developers. The thesis can be read here: Cowboy: An Agile Programming Methodology For a Solo Programmer (PDF) ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "agile": 0.34266743633067537,
                "contact": 0.19955584273120777,
                "cowboy": 0.45944783980837484,
                "customer": 0.17481449437903884,
                "developers": 0.13594318467576944,
                "developing": 0.17133371816533768,
                "development": 0.2408584323006212,
                "driven": 0.18289963552371596,
                "essentially": 0.21174056852534423,
                "lot": 0.12223012051278336,
                "methodology": 0.19955584273120777,
                "pdf": 0.22972391990418742,
                "programmer": 0.12316339005556598,
                "programming": 0.10114871837059775,
                "read": 0.1431839912639995,
                "reading": 0.15991273338286283,
                "remember": 0.16664268920118522,
                "small": 0.14239505291570814,
                "solo": 0.414467871684739,
                "test": 0.13464603827489977
            },
            "Max term": "cowboy",
            "Max score": 0.45944783980837484
        }
    },
    {
        "ID": "221",
        "Question": " Possible Duplicate: Using â€œFooâ€ and â€œBarâ€ in examples   I know AT&T labs used them in their Unix days, but do they have even deeper histories? ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "bar": 0.3523136795615038,
                    "days": 0.2784848076544079,
                    "deeper": 0.3786886229972317,
                    "duplicate": 0.3523136795615038,
                    "examples": 0.29719812783081284,
                    "foo": 0.3686613348786735,
                    "know": 0.17664240153102337,
                    "possible": 0.23821716494060782,
                    "unix": 0.3786886229972317,
                    "used": 0.1976614836115916,
                    "using": 0.19007441464617833
                },
                "Max term": "deeper",
                "Max score": 0.3786886229972317
            }
        ],
        "Best Answer": "From the Jargon file:  When â€˜fooâ€™ is used in connection with â€˜barâ€™ it has generally traced to the WWII-era Army slang acronym FUBAR (â€˜Fucked Up Beyond All Repairâ€™ or â€˜Fucked Up Beyond All Recognitionâ€™), later modified to foobar. Early versions of the Jargon File interpreted this change as a post-war bowdlerization, but it it now seems more likely that FUBAR was itself a derivative of â€˜fooâ€™ perhaps influenced by German furchtbar (terrible) â€” â€˜foobarâ€™ may actually have been the original form. For, it seems, the word â€˜fooâ€™ itself had an immediate prewar history in comic strips and cartoons. The earliest documented uses were in the Smokey Stover comic strip published from about 1930 to about 1952. Bill Holman, the author of the strip, filled it with odd jokes and personal contrivances, including other nonsense phrases such as â€œNotary Sojacâ€ and â€œ1506 nix nixâ€. The word â€œfooâ€ frequently appeared on license plates of cars, in nonsense sayings in the background of some frames (such as â€œHe who foos last foos bestâ€ or â€œMany smoke but foo men chewâ€), and Holman had Smokey say â€œWhere there's foo, there's fireâ€.  ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "actually": 0.06928969667088701,
                "army": 0.1260243165623802,
                "author": 0.1096126493757725,
                "background": 0.10067080464296743,
                "bar": 0.1096126493757725,
                "best": 0.0664345373051432,
                "change": 0.07796079387669332,
                "connection": 0.1096126493757725,
                "documented": 0.11469876982567143,
                "early": 0.09674146050513208,
                "file": 0.1678808420285364,
                "foo": 0.6881926189540286,
                "form": 0.09062387730641602,
                "frequently": 0.10067080464296743,
                "generally": 0.08664283946026342,
                "german": 0.1260243165623802,
                "history": 0.10217060740100996,
                "including": 0.09674146050513208,
                "interpreted": 0.12150832045596606,
                "later": 0.09449046767055122,
                "license": 0.10217060740100996,
                "likely": 0.08524655649725421,
                "nix": 0.2520486331247604,
                "nonsense": 0.24301664091193212,
                "odd": 0.1260243165623802,
                "original": 0.0979683861969722,
                "personal": 0.0924649710496636,
                "phrases": 0.1260243165623802,
                "post": 0.09449046767055122,
                "published": 0.11469876982567143,
                "say": 0.06565103007296004,
                "terrible": 0.11781848296907636,
                "used": 0.06149689936870618,
                "uses": 0.0992745216799582,
                "versions": 0.10555146062959886,
                "war": 0.12150832045596606,
                "word": 0.2075810355727447
            },
            "Max term": "foo",
            "Max score": 0.6881926189540286
        }
    },
    {
        "ID": "247",
        "Question": "Does learning COBOL still make sense? ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "cobol": 0.6765798314252401,
                    "learning": 0.43150882676677993,
                    "make": 0.31844752723259756,
                    "sense": 0.5046097863997434
                },
                "Max term": "cobol",
                "Max score": 0.6765798314252401
            }
        ],
        "Best Answer": "I don't think so, unless you are already in the niche market where COBOL is still maintained. ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "cobol": 0.4629547967137512,
                "maintained": 0.4629547967137512,
                "market": 0.44889627004463434,
                "niche": 0.44889627004463434,
                "think": 0.20384156935266967,
                "unless": 0.3560598327294566
            },
            "Max term": "cobol",
            "Max score": 0.4629547967137512
        }
    },
    {
        "ID": "252",
        "Question": "There is a widely accepted opinion that Singleton is an anti-pattern. As usual, there are always exceptions to the rule. Can you explain why Singleton is a bad choice in general and give an example of some valid use cases for it? ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "accepted": 0.24869363047887386,
                    "bad": 0.16544807634930048,
                    "cases": 0.1940292100146935,
                    "choice": 0.2098209197098933,
                    "example": 0.14933118663069647,
                    "exceptions": 0.26162197166371365,
                    "explain": 0.18110086882985363,
                    "general": 0.19748781481849173,
                    "opinion": 0.20123495790501697,
                    "pattern": 0.22354467428152588,
                    "rule": 0.22354467428152588,
                    "singleton": 0.5596868903035476,
                    "use": 0.10540719793325234,
                    "usual": 0.26162197166371365,
                    "valid": 0.25469448895442587,
                    "widely": 0.26162197166371365
                },
                "Max term": "singleton",
                "Max score": 0.5596868903035476
            }
        ],
        "Best Answer": "The Singleton pattern is basically just a lazily initialized global variable.  Global variables are generally and rightly considered evil because they allow spooky action at a distance between seemingly unrelated parts of a program.  However, IMHO there is nothing wrong with global variables that are set once, from one place, as part of a program's initialization routine (for example, by reading a config file or command line arguments) and treated as constants thereafter.  Such use of global variables is different only in letter, not in spirit, from having a named constant declared at compile time. Similarly, my opinion of Singletons is that they're bad if and only if they are used to pass mutable state between seemingly unrelated parts of a program.  If they don't contain mutable state, or if the mutable state that they do contain is completely encapsulated so that users of the object don't have to know about it even in a multithreaded environment, then there's nothing wrong with them. ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "action": 0.11794771968162167,
                "allow": 0.09054153179717497,
                "arguments": 0.0987869200954032,
                "bad": 0.06973264398073445,
                "basically": 0.09291225514275174,
                "command": 0.11026777832730406,
                "compile": 0.10258783697298646,
                "completely": 0.08746325003494643,
                "config": 0.10734800013399595,
                "considered": 0.08945889051086355,
                "constant": 0.10481877321949874,
                "constants": 0.11794771968162167,
                "different": 0.06346591191829591,
                "environment": 0.07741258533505205,
                "evil": 0.10258783697298646,
                "example": 0.06293973736239815,
                "file": 0.0785608802952529,
                "generally": 0.08109010720975013,
                "global": 0.454884571836769,
                "imho": 0.11026777832730406,
                "initialization": 0.11372114295919225,
                "know": 0.051435305927761944,
                "line": 0.08042544020682699,
                "mutable": 0.3308033349819122,
                "named": 0.10734800013399595,
                "object": 0.08481600986669896,
                "opinion": 0.08481600986669896,
                "parts": 0.1942776637303623,
                "pass": 0.09713883186518114,
                "pattern": 0.09421905367187304,
                "place": 0.08177894915654596,
                "program": 0.21631010197893372,
                "reading": 0.07916223448395132,
                "routine": 0.11372114295919225,
                "set": 0.0743343035728235,
                "similarly": 0.11026777832730406,
                "singleton": 0.11794771968162167,
                "spirit": 0.11794771968162167,
                "state": 0.2963607602862096,
                "time": 0.046487605928263565,
                "treated": 0.11794771968162167,
                "unrelated": 0.23589543936324334,
                "use": 0.04442676378399229,
                "used": 0.05755571024611521,
                "users": 0.07632994404874062,
                "variable": 0.10059219649706934,
                "variables": 0.2963607602862096,
                "wrong": 0.15265988809748124
            },
            "Max term": "global",
            "Max score": 0.454884571836769
        }
    },
    {
        "ID": "262",
        "Question": "Will Java have the same importance it had in the past, or it will be less relevant than nowadays? ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "java": 0.3999116517482759,
                    "nowadays": 0.5988488578919821,
                    "past": 0.48792029032277434,
                    "relevant": 0.4933401529257213
                },
                "Max term": "nowadays",
                "Max score": 0.5988488578919821
            }
        ],
        "Best Answer": "Java is relevant and will continue to be relevant for many years in the Enterprise computing world.   Whether it continues to be relevant in other areas depends a lot on what Oracle does.  If they inject some life (and resources) into ME, desktop applications and other areas, and if they press on with the evolution of the Java language, then Java will do well.   But if Oracle cuts back on R&D and/or tries to stomp other players in the Java space, there's a good chance that someone / some company will develop a better (and more open) Java-like language.  If Oracle win their lawsuit against Google, I predict that the next generation of the Android platform will have a new language, just like happened with C#.  If Google get the openness right ... then, the game is on! ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "applications": 0.1056737339185394,
                "areas": 0.25309014308102706,
                "better": 0.075545652198811,
                "chance": 0.11745376488450039,
                "company": 0.08932683003710547,
                "computing": 0.1456756639192924,
                "continue": 0.12885761282815178,
                "depends": 0.11598281035177588,
                "desktop": 0.12885761282815178,
                "develop": 0.11203956173701117,
                "enterprise": 0.13141400861972205,
                "game": 0.11598281035177588,
                "generation": 0.1456756639192924,
                "good": 0.06606986878637687,
                "google": 0.2172969463163121,
                "happened": 0.12443388675211123,
                "java": 0.4591521103350772,
                "language": 0.21336577836831133,
                "life": 0.11745376488450039,
                "like": 0.10771732805692368,
                "lot": 0.07751023038463427,
                "new": 0.07157545930708899,
                "open": 0.09403769933312199,
                "oracle": 0.41253519221679896,
                "platform": 0.12069367964779239,
                "predict": 0.15108986706678162,
                "relevant": 0.3398523218895202,
                "resources": 0.12249178500967998,
                "right": 0.08662812698183633,
                "space": 0.12249178500967998,
                "win": 0.137511730738933,
                "world": 0.09346677137042739,
                "years": 0.08885568282739877
            },
            "Max term": "java",
            "Max score": 0.4591521103350772
        }
    },
    {
        "ID": "294",
        "Question": "I just started working a year ago, and I want to join an open source project for the same reasons as anyone else: help create something useful and develop my skills further. My problem is, I don't know how to find a project where I'll fit in. How can I find a beginner-friendly project?  What attributes should I be searching for?  What are warning signs that a project might not be the right fit?  Are there any tools out there to help match people with open source projects? There's a similar question here, but that question has to do with employment and is limited to PHP/Drupal. ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "ago": 0.13836711292261428,
                    "attributes": 0.1836987913920225,
                    "beginner": 0.178120418781562,
                    "create": 0.1224608258442932,
                    "develop": 0.14128325573023284,
                    "employment": 0.19052616768663597,
                    "fit": 0.3249820471222553,
                    "friendly": 0.1836987913920225,
                    "help": 0.2067870697594625,
                    "join": 0.1734039719425081,
                    "know": 0.08308572432480159,
                    "limited": 0.16249102356112766,
                    "match": 0.1836987913920225,
                    "open": 0.23716537475128904,
                    "people": 0.08521296747921625,
                    "php": 0.13445587943561937,
                    "problem": 0.09925258478422112,
                    "project": 0.3598809466447515,
                    "projects": 0.11089338530962452,
                    "question": 0.19548269435124047,
                    "reasons": 0.13445587943561937,
                    "right": 0.10923912614487492,
                    "searching": 0.178120418781562,
                    "signs": 0.178120418781562,
                    "similar": 0.12416105998610498,
                    "skills": 0.13210115314051935,
                    "source": 0.2264962232094491,
                    "started": 0.12416105998610498,
                    "tools": 0.12596136401754035,
                    "useful": 0.12329913421469842,
                    "want": 0.08997023666118788,
                    "warning": 0.178120418781562,
                    "working": 0.10166934118972722,
                    "year": 0.13836711292261428
                },
                "Max term": "project",
                "Max score": 0.3598809466447515
            }
        ],
        "Best Answer": "My first open source contribution was for a library that I had previously used (and would've suffered greatly without) on a previous paid project. During my initial use I had spotted a bug in the code so I created a patch, joined the project, and submitted it for review. About 8 months later when I had some free time I decided that I would give back (and work on my development skills) by contributing more to the project. So I cloned the repository and started getting familiar with the codebase. After a few weeks of submitting minor patch fixes to the codebase and monitoring the feature requests, I picked up a feature request to add a pretty substantial module to the project. Since generating many individual patch fixes is pretty tedious for any significant development I cloned the repository to a branch on git hub and started punching away code. A few weeks and several thousand lines of code later the project leader and me worked through integrating and testing my fixes into the library in a way that worked consistently with the rest of the codebase. It was an invaluable process that I learned a lot from:   When I started I didn't know how to use Git, by the end I could proficiently create remote tracking branches and merge or rebase them into the master branch without breaking a sweat.  I started in VS 2008 and ended up migrating to Linux and Monodevelop to work on writing code (because VS is unicode retarded and line endings are such a pain in git). It turns out that theres not much you can't do in *nix that you can do in *dows. I had never really done any unit testing before, Nunit is a piece of cake to use and writing unit tests is pretty elementary stuff. I had to learn to swallow my tongue and listen as well as practice patience. There's no point in standing a firm ground on your position on an open source project because everybody involved is knowledgeable (probably more so than yourself) and capable of accepting/rejecting your ideas based on substance not delivery. It's extremely humbling and rewarding at the same time. Just having one other skilled developer's eyes on a large base of my code pointed out flaws in my style that I had never considered before (as well as I pointed out flaws in his code). For me, I learned that it's easier/better to define constants than it is to use a bunch of magical numbers with detailed commenting.  That particular project was based around generating and decoding networking packets on all levels of networking protocols. I have a personal interest in lower level networking so it was great to have discussions with another developer with shared interest and knowledge in the domain. If you want to just get your feet wet: find a project that you already use; clone the repository; and start seeing if you can fix some bugs and/or add some unit tests. It seems intimidating to look at someone else's codebase with fresh eyes but it's an extremely valuable skill to learn. Submit some patches. You can expect your code to be closely scrutinized at first. Don't worry about it, it's a normal part of the process to gain the trust of the project admin(s). After establishing a base of merit with the projects admin(s) start seeking more responsibilities such as, proposing new features, or asking to be assigned to implementing feature requests.  If you can't find an already existing project on one of the main open source repository networks (github, sourceforge, google code) think of an app that you'd really like to use that doesn't exist yet and start your own. Be prepared to be humbled and expect work to be rejected in favor of further revisions. The myth that anybody can add code to an open source project is completely false. There's always a gatekeeper between you and push access. The better your code, the less it will be scrutinized in the long run as you gain trust of the project admin(s). If it's your project, you'll be that gatekeeper. Update: I just thought about it and realized that I didn't bother to mention which project that a lot of my answer is referencing. For those who want to know, it's SharpPcap. The lead developer Chris Morgan is very professional and on point. He does a hell of a job managing the project and taught me a lot about what it takes to mature a OSS project. Due to personal time constraints I haven't been able to contribute code in over a year but I still try to give back by lurking on Stack Overflow and answering questions about SharpPcap occasionally. ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "2008": 0.050223290073453476,
                "able": 0.03385679250437601,
                "access": 0.03693383541649064,
                "add": 0.10816726134308341,
                "admin": 0.15066987022036044,
                "answer": 0.03176089025606209,
                "answering": 0.050223290073453476,
                "anybody": 0.04889342862728025,
                "app": 0.03500877088750197,
                "asking": 0.037911524580782154,
                "assigned": 0.053721246849549105,
                "away": 0.03724757991586741,
                "base": 0.08352330727751897,
                "based": 0.0685986018601815,
                "better": 0.05372175790436952,
                "bother": 0.04672533329735784,
                "branch": 0.10044658014690695,
                "breaking": 0.04774145024415429,
                "bug": 0.037911524580782154,
                "bugs": 0.03633863233367519,
                "bunch": 0.04889342862728025,
                "capable": 0.051796182320560435,
                "chris": 0.053721246849549105,
                "clone": 0.051796182320560435,
                "code": 0.20684395445206344,
                "codebase": 0.18690133318943136,
                "completely": 0.039836589109770816,
                "considered": 0.040745536691963034,
                "consistently": 0.050223290073453476,
                "constants": 0.053721246849549105,
                "constraints": 0.053721246849549105,
                "contribute": 0.051796182320560435,
                "create": 0.034529368508588176,
                "created": 0.04231842893907,
                "decided": 0.04889342862728025,
                "define": 0.042913632021885445,
                "delivery": 0.051796182320560435,
                "detailed": 0.04581638571516563,
                "developer": 0.08900491636665665,
                "development": 0.05430669683022388,
                "discussions": 0.051796182320560435,
                "domain": 0.04424349346805866,
                "easier": 0.03476574008656823,
                "end": 0.02993792186429938,
                "ended": 0.051796182320560435,
                "everybody": 0.04889342862728025,
                "exist": 0.04123864363755252,
                "existing": 0.038630859631215896,
                "expect": 0.08710592639066099,
                "extremely": 0.08848698693611733,
                "eyes": 0.09345066659471568,
                "false": 0.051796182320560435,
                "familiar": 0.04231842893907,
                "favor": 0.051796182320560435,
                "feature": 0.10093130630969206,
                "features": 0.03385679250437601,
                "fix": 0.038263696862663864,
                "fixes": 0.15066987022036044,
                "flaws": 0.10744249369909821,
                "free": 0.03429930093009075,
                "fresh": 0.051796182320560435,
                "gain": 0.10744249369909821,
                "gatekeeper": 0.10744249369909821,
                "generating": 0.10044658014690695,
                "getting": 0.03265106302582109,
                "git": 0.14322435073246287,
                "google": 0.038630859631215896,
                "great": 0.033232880500197626,
                "greatly": 0.050223290073453476,
                "ground": 0.051796182320560435,
                "hell": 0.053721246849549105,
                "ideas": 0.04123864363755252,
                "implementing": 0.051796182320560435,
                "individual": 0.050223290073453476,
                "initial": 0.051796182320560435,
                "integrating": 0.053721246849549105,
                "involved": 0.039014346005221134,
                "job": 0.029802060427969873,
                "know": 0.046854127811644775,
                "knowledge": 0.03364376876989735,
                "large": 0.03633863233367519,
                "later": 0.08055819507097113,
                "lead": 0.041761653638759486,
                "learn": 0.05830621249945092,
                "learned": 0.07967317821954163,
                "level": 0.032840675557579566,
                "levels": 0.04889342862728025,
                "library": 0.07802869201044227,
                "like": 0.019149891660048043,
                "line": 0.03663110179660237,
                "lines": 0.04499414261061594,
                "linux": 0.04581638571516563,
                "listen": 0.051796182320560435,
                "long": 0.029802060427969873,
                "look": 0.030954038811095833,
                "lot": 0.08267820272853699,
                "lower": 0.04581638571516563,
                "magical": 0.04889342862728025,
                "main": 0.040745536691963034,
                "managing": 0.04774145024415429,
                "master": 0.04424349346805866,
                "mention": 0.04499414261061594,
                "merge": 0.050223290073453476,
                "merit": 0.053721246849549105,
                "minor": 0.04499414261061594,
                "module": 0.051796182320560435,
                "months": 0.04424349346805866,
                "networking": 0.1611637405486473,
                "new": 0.025449244164775408,
                "nix": 0.053721246849549105,
                "normal": 0.04499414261061594,
                "numbers": 0.04499414261061594,
                "occasionally": 0.04581638571516563,
                "open": 0.13374351456158004,
                "oss": 0.053721246849549105,
                "overflow": 0.04231842893907,
                "paid": 0.04424349346805866,
                "pain": 0.04774145024415429,
                "particular": 0.03500877088750197,
                "patch": 0.1611637405486473,
                "personal": 0.07883135049157965,
                "picked": 0.053721246849549105,
                "piece": 0.04774145024415429,
                "point": 0.06160268830799025,
                "position": 0.041761653638759486,
                "practice": 0.039014346005221134,
                "prepared": 0.050223290073453476,
                "pretty": 0.10093130630969206,
                "previous": 0.039014346005221134,
                "previously": 0.053721246849549105,
                "probably": 0.03050383112301542,
                "process": 0.06568135111515913,
                "professional": 0.041761653638759486,
                "project": 0.40589181855481565,
                "projects": 0.031267783310472606,
                "push": 0.04424349346805866,
                "questions": 0.034529368508588176,
                "realized": 0.050223290073453476,
                "really": 0.05010323025419547,
                "remote": 0.04889342862728025,
                "repository": 0.2008931602938139,
                "request": 0.04774145024415429,
                "requests": 0.09163277143033126,
                "responsibilities": 0.050223290073453476,
                "rest": 0.04581638571516563,
                "review": 0.041761653638759486,
                "rewarding": 0.050223290073453476,
                "run": 0.033232880500197626,
                "seeing": 0.04424349346805866,
                "shared": 0.051796182320560435,
                "significant": 0.050223290073453476,
                "skill": 0.04499414261061594,
                "skills": 0.03724757991586741,
                "source": 0.1277269119015494,
                "sourceforge": 0.051796182320560435,
                "stack": 0.040745536691963034,
                "start": 0.08981376559289815,
                "started": 0.14003508355000788,
                "stuff": 0.03385679250437601,
                "style": 0.039836589109770816,
                "submit": 0.051796182320560435,
                "submitting": 0.053721246849549105,
                "substantial": 0.053721246849549105,
                "takes": 0.03525884703215772,
                "taught": 0.050223290073453476,
                "testing": 0.06318673996908176,
                "tests": 0.06815041962768012,
                "theres": 0.053721246849549105,
                "think": 0.02280614687577862,
                "thought": 0.03724757991586741,
                "time": 0.06352065542915139,
                "tracking": 0.04889342862728025,
                "trust": 0.09163277143033126,
                "try": 0.030801344153995124,
                "turns": 0.04672533329735784,
                "unit": 0.10429722025970468,
                "update": 0.040745536691963034,
                "use": 0.12140944227199037,
                "used": 0.026214703650726538,
                "valuable": 0.04889342862728025,
                "vs": 0.08352330727751897,
                "want": 0.05073647731935196,
                "way": 0.023622401071439314,
                "weeks": 0.08247728727510505,
                "work": 0.06823933217047227,
                "worked": 0.07051769406431543,
                "worry": 0.04672533329735784,
                "writing": 0.05987584372859876,
                "year": 0.039014346005221134
            },
            "Max term": "project",
            "Max score": 0.40589181855481565
        }
    },
    {
        "ID": "348",
        "Question": "Elite developers can be 10x more productive than an average developer.  Clearly it's easier to find an elite developer around the whole world than in a company's backyard.  If a company is not located in a programming hot spot, should they consider hiring people who work from home? ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "10x": 0.3079440567980635,
                    "average": 0.255134593800227,
                    "clearly": 0.2515959304522886,
                    "company": 0.377656304182382,
                    "consider": 0.20669289820603598,
                    "developer": 0.35277419805823307,
                    "developers": 0.18223133141975303,
                    "easier": 0.20669289820603598,
                    "hiring": 0.2723923473285104,
                    "home": 0.2589356120677449,
                    "people": 0.14284703072080676,
                    "productive": 0.26304102455181083,
                    "programming": 0.13558947926692988,
                    "spot": 0.2906863032697801,
                    "work": 0.13523452785067774,
                    "world": 0.19757958177264723
                },
                "Max term": "company",
                "Max score": 0.377656304182382
            }
        ],
        "Best Answer": "I have worked as, and managed staff in both situations, and combinations of both.  I've made the following observations:  Junior staff do not work remotely.  They require a good and personal working relationship with a mentor.  I find my junior staff would rather wait for me to be available than to ask the rather senior (and good) remote developer anything. Ensure anyone you consider for working remotely is effective when self-guided and doesn't go off on tangents. Remote staff can get isolated really easily and not feel part of a team unless special effort is made to be inclusive of them.  This isolation can lead to a misunderstanding of the specific business driver for a project, or to misinterpret events in a negative manner. Never get a contractor working remotely, unless they have the right incentive to perform. When working with a remote team member, make sure they get equitable access to resources, including source control, reference material, etc.  Don't make them jump through hoops to get work done. Arrange those face to face meetings as often as practical.  This encourages far better team collaboration as people are more comfortable with those they have met.  ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "access": 0.0795156402762643,
                "ask": 0.07154777567503658,
                "available": 0.08019110748593193,
                "better": 0.05782935793645086,
                "business": 0.07537112788350822,
                "collaboration": 0.10812679002701471,
                "comfortable": 0.10526370301807741,
                "consider": 0.07484790170011349,
                "contractor": 0.11565761561210282,
                "control": 0.0776251996363658,
                "developer": 0.06387352620184972,
                "driver": 0.11565761561210282,
                "easily": 0.08671772628450615,
                "effective": 0.09686884717007332,
                "effort": 0.09110824626335207,
                "ensure": 0.10812679002701471,
                "events": 0.11151310321934674,
                "face": 0.20556716848239254,
                "far": 0.07823421489244552,
                "feel": 0.06950469591429505,
                "following": 0.08316919982339854,
                "good": 0.10115150189733527,
                "guided": 0.11565761561210282,
                "including": 0.08878355350824423,
                "isolated": 0.11565761561210282,
                "junior": 0.23131523122420564,
                "lead": 0.08990955287028972,
                "make": 0.10497230430126483,
                "managed": 0.09110824626335207,
                "manner": 0.10278358424119627,
                "meetings": 0.0937661013364189,
                "member": 0.10278358424119627,
                "met": 0.11151310321934674,
                "misunderstanding": 0.11151310321934674,
                "negative": 0.11565761561210282,
                "people": 0.05172795295020836,
                "perform": 0.10526370301807741,
                "personal": 0.08485884606208276,
                "practical": 0.10526370301807741,
                "project": 0.054615820885056704,
                "really": 0.05393415534353944,
                "reference": 0.09686884717007332,
                "relationship": 0.11151310321934674,
                "remote": 0.31579110905423224,
                "require": 0.08089206996551236,
                "resources": 0.0937661013364189,
                "right": 0.06631286932851148,
                "self": 0.09686884717007332,
                "senior": 0.09686884717007332,
                "situations": 0.09525275865610815,
                "source": 0.068746496713871,
                "special": 0.09525275865610815,
                "specific": 0.07537112788350822,
                "staff": 0.4626304624484113,
                "sure": 0.0680180385946058,
                "team": 0.2073651830467167,
                "unless": 0.17153008095506725,
                "wait": 0.10278358424119627,
                "work": 0.0979426069776131,
                "worked": 0.07590952213733768,
                "working": 0.24687073120994707
            },
            "Max term": "staff",
            "Max score": 0.4626304624484113
        }
    },
    {
        "ID": "368",
        "Question": "For a long time in SO and in other places Java has the reputation of being slow. From jokes to many comments in questions and answers, people still believe Java is slow based solely on experience with it in the 90s. This is my issue: we have disproved (most) of the reasons that people believe Java is slow. Outside of small things, Java is pretty fast. So why is it that people still refuse to believe Java is fast now? Is it part of their mindset that anything thats not C/C++ is slow? Is it because people don't check over time? Is it because people are just biased? ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "answers": 0.10897498173920536,
                    "based": 0.09859180641917185,
                    "believe": 0.3299618556356082,
                    "biased": 0.148885809393297,
                    "check": 0.1044537733256269,
                    "comments": 0.11450849362544785,
                    "experience": 0.08853708611935092,
                    "fast": 0.23707727331176448,
                    "issue": 0.10529446371553332,
                    "java": 0.46927010142031705,
                    "long": 0.08566468974384119,
                    "outside": 0.11853863665588224,
                    "people": 0.34532077042556875,
                    "places": 0.1343098806798976,
                    "pretty": 0.0967075085446741,
                    "questions": 0.09925312538333318,
                    "reasons": 0.10897498173920536,
                    "reputation": 0.1343098806798976,
                    "slow": 0.5173346019272028,
                    "small": 0.09228731041938883,
                    "thats": 0.15441932127953947,
                    "things": 0.0733877678955516,
                    "time": 0.1217248552957265
                },
                "Max term": "slow",
                "Max score": 0.5173346019272028
            }
        ],
        "Best Answer": "It's the applications. As you note, we have proved, time and time again, that in contrived scenarios Java code can meet or even beat the performance of so-called \"performant\" languages like C, C++, Lisp, VB6, or JavaScript. And when presented with such evidence, most sane, open-minded opponents will hang their heads in shame and promise never again to spread such slander. ...but then, they fire up Eclipse, or NetBeans, or Guiffy, or enable the Java support in their browser, or try to run an app on their favorite feature phone. And they wait for it to become responsive... ...and wait...   ...and wait...     ...and wait...         ...and wait...             ...and...      ...what did I promise never to do again? Sorry, must have dozed off... ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "app": 0.09668487166483242,
                "applications": 0.10376704744827775,
                "beat": 0.1483637307351939,
                "browser": 0.13503058668563114,
                "called": 0.11687219423324528,
                "code": 0.051931612574534124,
                "eclipse": 0.1430472168384368,
                "evidence": 0.13503058668563114,
                "favorite": 0.1290428866488525,
                "feature": 0.09291510051271404,
                "hang": 0.1430472168384368,
                "java": 0.18034702495075933,
                "javascript": 0.12028164801029853,
                "languages": 0.08121389190523327,
                "like": 0.05288688436097514,
                "lisp": 0.1221887081300024,
                "meet": 0.126532616276416,
                "netbeans": 0.1430472168384368,
                "note": 0.11124010575829646,
                "open": 0.09234096351841885,
                "performance": 0.11389011572388352,
                "phone": 0.1483637307351939,
                "presented": 0.1430472168384368,
                "promise": 0.27740661738404643,
                "responsive": 0.1483637307351939,
                "run": 0.0917803368915586,
                "scenarios": 0.13870330869202321,
                "sorry": 0.1430472168384368,
                "spread": 0.1483637307351939,
                "support": 0.09808677790062396,
                "time": 0.11695138603920609,
                "try": 0.08506508315310496,
                "vb6": 0.1430472168384368,
                "wait": 0.6592456508658655
            },
            "Max term": "wait",
            "Max score": 0.6592456508658655
        }
    },
    {
        "ID": "370",
        "Question": "I've been told that to be taken seriously as a job applicant, I should drop years of relevant experience off my rÃ©sumÃ©, remove the year I got my degree, or both. Or not even bother applying, because no one wants to hire programmers older than them.1 Or that I should found a company, not because I want to, or because I have a product I care about, but because that way I can get a job if/when my company is acquired. Or that I should focus more on management jobs (which I've successfully done in the past) becauseâ€¦ well, they couldn't really explain this one, except the implication was that over a certain age you're a loser if you're still writing code. But I like writing code. Have you seen this? Is this only a local (Northern California) issue? If you've ever hired programmers:2  Of the rÃ©sumÃ©s you've received, how old was the eldest applicant? What was the age of the oldest person you've interviewed? How old (when hired) was the oldest person you hired?  How old is \"too old\" to employed as a programmer? 1 I'm assuming all applicants have equivalent applicable experience. This isn't about someone with three decades of COBOL applying for a Java guru job. 2 Yes, I know that (at least in the US) you aren't supposed to ask how old an applicant is. In my experience, though, you can get a general idea from a rÃ©sumÃ©. ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "age": 0.2405944584367864,
                    "applicable": 0.1274391547533562,
                    "applying": 0.24713843179723685,
                    "ask": 0.0817660686796087,
                    "assuming": 0.11070343886855832,
                    "bother": 0.11496285467781371,
                    "care": 0.11496285467781371,
                    "certain": 0.09414387252978858,
                    "cobol": 0.1274391547533562,
                    "code": 0.09253057777352161,
                    "company": 0.15628877755494255,
                    "decades": 0.12356921589861843,
                    "degree": 0.10715756582727418,
                    "drop": 0.1274391547533562,
                    "equivalent": 0.12356921589861843,
                    "experience": 0.22735057421563437,
                    "explain": 0.08553751130898385,
                    "focus": 0.10715756582727418,
                    "general": 0.09327738901845939,
                    "got": 0.08495594346448389,
                    "guru": 0.13217557711942313,
                    "hire": 0.11496285467781371,
                    "idea": 0.0765416731336615,
                    "issue": 0.09012704105781368,
                    "java": 0.08033456690026143,
                    "job": 0.2199746711452902,
                    "jobs": 0.10412012184813656,
                    "know": 0.05763987013625449,
                    "like": 0.047116329764831634,
                    "local": 0.11070343886855832,
                    "management": 0.08675074999827599,
                    "old": 0.46638694509229695,
                    "older": 0.1174629054350082,
                    "past": 0.09801381138452632,
                    "person": 0.18025408211562735,
                    "product": 0.08675074999827599,
                    "programmer": 0.06832478886737445,
                    "programmers": 0.14164967924913782,
                    "really": 0.061636910559264235,
                    "received": 0.1274391547533562,
                    "relevant": 0.09910255764376444,
                    "remove": 0.11272648306894126,
                    "seen": 0.09012704105781368,
                    "seriously": 0.10558455753397826,
                    "successfully": 0.1202972292183932,
                    "supposed": 0.10558455753397826,
                    "taken": 0.10885654421420349,
                    "told": 0.1174629054350082,
                    "want": 0.06241593004601077,
                    "wants": 0.10275023375059326,
                    "way": 0.058120477049020264,
                    "writing": 0.14731832681590784,
                    "year": 0.09599076718414339,
                    "years": 0.07773222245844431,
                    "yes": 0.08613546348349639
                },
                "Max term": "old",
                "Max score": 0.46638694509229695
            }
        ],
        "Best Answer": "Having just got a new job at nearly 50 in the UK I can say that it's possible and you're never too old. There are two approaches - both rely on your skills being relevant to the job.  Stick with what you know and become a guru. This is risky as the number of jobs requiring \"old\" technologies are becoming fewer and further between as each year passes. However, as people retire from such jobs there will be openings. Keep refreshing your skills. I moved into Silverlight last year, which is what got me this job. That and my previous team leadership roles which my new employer saw as relevant.  ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "50": 0.14931018095091197,
                "approaches": 0.15461827955757773,
                "employer": 0.16500249196913247,
                "fewer": 0.16500249196913247,
                "got": 0.23305511640305113,
                "guru": 0.1812951116485771,
                "job": 0.3017224016287955,
                "jobs": 0.2856271866059812,
                "know": 0.07906019341470419,
                "moved": 0.16949042539398998,
                "nearly": 0.1747985240006557,
                "new": 0.1717690423361267,
                "number": 0.11353889146503766,
                "old": 0.25588289493315675,
                "passes": 0.1812951116485771,
                "people": 0.08108437093250102,
                "possible": 0.10661933358961526,
                "previous": 0.13166318039344146,
                "relevant": 0.27186276987393015,
                "rely": 0.1812951116485771,
                "risky": 0.1812951116485771,
                "roles": 0.1747985240006557,
                "saw": 0.15768573913940284,
                "say": 0.09444376412095011,
                "skills": 0.2514016168834755,
                "stick": 0.15768573913940284,
                "team": 0.10834938340353187,
                "technologies": 0.15768573913940284,
                "year": 0.26332636078688293
            },
            "Max term": "job",
            "Max score": 0.3017224016287955
        }
    },
    {
        "ID": "404",
        "Question": "Joel Spolsky wrote a famous blog post \"Human Task Switches considered harmful\". While I agree with the premise and it seems like common sense, I'm wondering if there are any studies or white papers on this to calculate the overhead on task switches, or is the evidence merely anecdotal?  ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "agree": 0.21406245433796836,
                    "blog": 0.2232443733174113,
                    "common": 0.16736326459937018,
                    "considered": 0.20885402822038343,
                    "evidence": 0.25061860393478397,
                    "famous": 0.2753651004862825,
                    "human": 0.23484625536908502,
                    "joel": 0.20885402822038343,
                    "like": 0.09815877609912199,
                    "merely": 0.2753651004862825,
                    "overhead": 0.25061860393478397,
                    "post": 0.20646314802443663,
                    "sense": 0.19801458767352725,
                    "spolsky": 0.26549757844324207,
                    "task": 0.3641007855375253,
                    "white": 0.26549757844324207,
                    "wondering": 0.21406245433796836,
                    "wrote": 0.21406245433796836
                },
                "Max term": "task",
                "Max score": 0.3641007855375253
            }
        ],
        "Best Answer": "The abstract of a study that says 'maybe' Another study [PDF] that says interruptions make things seem like they took longer. A study[PDF] that says interruptions increase resumption lag time, but that cues seen in the task before the interruption can speed recovery time. Task switching[PDF] takes a significant portion of our work week. More reading on the psychology of interruptions than you can shake a stick at. ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "abstract": 0.14888512944692728,
                "increase": 0.1343092673003139,
                "interruptions": 0.44665538834078183,
                "like": 0.05504525567261994,
                "longer": 0.11577993554547536,
                "make": 0.07007613752571351,
                "maybe": 0.10364017826201787,
                "pdf": 0.44665538834078183,
                "psychology": 0.154418616062183,
                "reading": 0.10364017826201787,
                "says": 0.3556142859059045,
                "seen": 0.10529398284641191,
                "significant": 0.14436394168124844,
                "speed": 0.13723003667711317,
                "stick": 0.1343092673003139,
                "study": 0.41169011003133954,
                "switching": 0.14436394168124844,
                "takes": 0.10134951591689835,
                "task": 0.20417961212430105,
                "things": 0.07338743274106933,
                "time": 0.12172429939067551,
                "took": 0.1343092673003139,
                "week": 0.11853809530196817,
                "work": 0.0653833374610166
            },
            "Max term": "interruptions",
            "Max score": 0.44665538834078183
        }
    },
    {
        "ID": "408",
        "Question": "\"Regular\" golf vs. code golf: Both are competitions.  Both have a well-defined set of rules, which I'll leave out for simplicity.  Both have well-defined goals; in short, \"use fewer hits/characters than your competitors.\" To win matches, athletic golfers rely on  equipment  Some situations call for a sand wedge; others, a 9-iron.   techniques  The drive works better when your feet are about shoulder width apart and your arms are relaxed.   and strategies  Sure, you could take that direct shortcut to the hole... but do you really want to risk the water hazard or sand bunker when those trees are in the way and the wind is so strong?  It might be better to go around the long way.    What do code golfers have that's analagous to athletic golfers' equipment, techniques and strategies? Sample answer to get this started: use the right club!  Choose GolfScript instead of C#. ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "answer": 0.09327873318930834,
                    "apart": 0.14021212766682853,
                    "better": 0.15777572610912097,
                    "characters": 0.1475010567046917,
                    "choose": 0.11966579069739294,
                    "code": 0.11045111761725351,
                    "defined": 0.26911679013831596,
                    "drive": 0.13455839506915798,
                    "equipment": 0.315548450378819,
                    "fewer": 0.1435953793128981,
                    "goals": 0.15212049259173893,
                    "golf": 0.30424098518347786,
                    "instead": 0.10210369317481198,
                    "leave": 0.12428522658444018,
                    "long": 0.08752583509908564,
                    "matches": 0.1577742251894095,
                    "really": 0.07357422618075941,
                    "regular": 0.12791093702814554,
                    "relaxed": 0.1577742251894095,
                    "rely": 0.1577742251894095,
                    "right": 0.09046063696732157,
                    "risk": 0.12428522658444018,
                    "rules": 0.12993895918211074,
                    "sample": 0.15212049259173893,
                    "set": 0.09943420002399603,
                    "short": 0.11345518401286106,
                    "situations": 0.12993895918211074,
                    "started": 0.1028174516700656,
                    "strategies": 0.315548450378819,
                    "strong": 0.12993895918211074,
                    "sure": 0.09278674198298362,
                    "techniques": 0.25987791836422147,
                    "use": 0.11885601947393121,
                    "vs": 0.12265003014424755,
                    "want": 0.07450411957413447,
                    "water": 0.1577742251894095,
                    "way": 0.13875351912801318,
                    "win": 0.1435953793128981,
                    "wind": 0.1577742251894095,
                    "works": 0.10589234148554633
                },
                "Max term": "equipment",
                "Max score": 0.315548450378819
            }
        ],
        "Best Answer": "I'd say that thorough knowledge of the syntactical oddities of your language help. Here is one I found in Ruby when doing a bit of code golf: Instead of require \"sequel\" require \"nokogiri\" require \"chronic\"  You can do something like this:  body_of_your_program if %w{sequel nokogiri chronic}.each{|i| require i}  With this kind of thing, you too can write incredibly elaborate Ruby one-liners! In Ruby and Perl, you also get the magic variables like \"$_\" which can be used to do all sorts of magic with strings and regexes. Is your data not strings? Well, you might want to turn it into strings. Obviously, in C, the preprocessor is your friend. ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "bit": 0.10523605049034913,
                "code": 0.055716763460981804,
                "data": 0.09730783635743237,
                "golf": 0.15347353084597443,
                "help": 0.08638146579187497,
                "incredibly": 0.14881300730951405,
                "instead": 0.1030118561738302,
                "kind": 0.10683420268004716,
                "knowledge": 0.09968742391332683,
                "language": 0.07492900892955918,
                "like": 0.11348332470514216,
                "magic": 0.2715104539091232,
                "obviously": 0.12539068360170338,
                "perl": 0.14145924677095947,
                "require": 0.44532135638362913,
                "ruby": 0.3814628607411448,
                "say": 0.08292185548415841,
                "sequel": 0.3183551013247446,
                "sorts": 0.14881300730951405,
                "strings": 0.4775326519871168,
                "thing": 0.09082067098340678,
                "turn": 0.13109470341810125,
                "used": 0.07767489705048837,
                "variables": 0.13331889773462016,
                "want": 0.0751667977062155,
                "write": 0.07847796128790702
            },
            "Max term": "strings",
            "Max score": 0.4775326519871168
        }
    },
    {
        "ID": "487",
        "Question": "If you were to design a programming language, how would you do it? What features would you put in? What would you leave out? Statically or dynamically typed? Strongly or weakly typed? Compiled or interpreted? Justify your answers. ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "answers": 0.21109226588197247,
                    "compiled": 0.2796444674511199,
                    "design": 0.17150261303321968,
                    "dynamically": 0.2991211735448001,
                    "features": 0.18851542174242641,
                    "interpreted": 0.28840236869886626,
                    "justify": 0.2991211735448001,
                    "language": 0.1408041083073198,
                    "leave": 0.23563001361970612,
                    "programming": 0.12698516541552005,
                    "statically": 0.2796444674511199,
                    "strongly": 0.26016776135743974,
                    "typed": 0.5592889349022399
                },
                "Max term": "typed",
                "Max score": 0.5592889349022399
            }
        ],
        "Best Answer": " I definitely think that functional programming languages will catch on, so my language will be functional. See Taming Effects with Functional Programming I think the CPUs soon will have hundreads of cores, and threads will he a hell to manage. So the Actor Model is a must instead of threads. See Erlang - software for a concurrent world I also think that OOP has failed, the communication between objects was assumed to be asynchronous. So I think we need message passing, with immutable messages. Send and Forget. As in the Actor model. See Object Oriented Programming: The Wrong Path? I think that it would be good to have static typing, so errors are catched earlier in the development cycle. But I would use type inference as in Haskell, so that the developer don't need to write the type everywhere in the code as in C, C# and Java. See Learn You A Haskell for Great Good I would also design a great UI library, with declarative layout, as in WPF and Android. But I would like to have it as in Functional Reactive Programming.  So my language would be like the concurrency in Erlang but with the typing as in Haskell and a GUI framework as in WPF.NET. ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "actor": 0.22165507429762799,
                "asynchronous": 0.11082753714881399,
                "catch": 0.11494656969217706,
                "code": 0.04023463615026102,
                "communication": 0.0980326534192524,
                "concurrency": 0.09627331182046696,
                "concurrent": 0.10461655733596076,
                "cycle": 0.10746204250929628,
                "declarative": 0.11494656969217706,
                "definitely": 0.08433714642351837,
                "design": 0.06590518761274149,
                "developer": 0.06348084120694703,
                "development": 0.05809962424578065,
                "earlier": 0.10461655733596076,
                "effects": 0.09997751532641548,
                "erlang": 0.20430337192523093,
                "errors": 0.0852377696896908,
                "failed": 0.10215168596261547,
                "forget": 0.10215168596261547,
                "framework": 0.07544284161903707,
                "functional": 0.31101297002724,
                "good": 0.10052963741968873,
                "great": 0.14221582105813768,
                "gui": 0.10215168596261547,
                "haskell": 0.28400147633920403,
                "hell": 0.11494656969217706,
                "immutable": 0.11494656969217706,
                "instead": 0.07438774786729228,
                "java": 0.06986300415052095,
                "language": 0.10821667390969981,
                "languages": 0.06292143126624263,
                "layout": 0.11494656969217706,
                "learn": 0.062378476967640165,
                "library": 0.08347842809090536,
                "like": 0.08194948871771499,
                "manage": 0.10215168596261547,
                "message": 0.11082753714881399,
                "messages": 0.10746204250929628,
                "model": 0.17236919705036777,
                "need": 0.10821667390969981,
                "net": 0.07026871532392923,
                "object": 0.08265788788008255,
                "objects": 0.09466715877973467,
                "oop": 0.09627331182046696,
                "oriented": 0.08618459852518388,
                "passing": 0.11494656969217706,
                "path": 0.09627331182046696,
                "programming": 0.1951919216326764,
                "send": 0.11494656969217706,
                "software": 0.05428005089361957,
                "soon": 0.09182167360639916,
                "static": 0.0980326534192524,
                "think": 0.24398990204084547,
                "threads": 0.20430337192523093,
                "type": 0.16078951495974342,
                "typing": 0.21492408501859256,
                "ui": 0.09627331182046696,
                "use": 0.04329633598071394,
                "world": 0.07110791052906884,
                "wpf": 0.21492408501859256,
                "write": 0.056671134899004216,
                "wrong": 0.07438774786729228
            },
            "Max term": "functional",
            "Max score": 0.31101297002724
        }
    },
    {
        "ID": "492",
        "Question": "Did you learn to touch-type when you were already working as a programmer?  If so how did it affect your productivity?  Or are you still unable to touch type and do you think it holds you back? According to Steve Yegge it is essential, Personally I did not notice much difference, possibly because I was spending less than 25% of my work time actually typing (I was working on a large legacy project at the time and I was spending more time on reading and debugging existing code.) ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "25": 0.18372361609772486,
                    "actually": 0.10804886729046677,
                    "affect": 0.17092761514044152,
                    "code": 0.06878757069281212,
                    "debugging": 0.18372361609772486,
                    "difference": 0.161848707977105,
                    "essential": 0.19651961705500817,
                    "existing": 0.1413169311295693,
                    "holds": 0.19651961705500817,
                    "large": 0.1329316523593779,
                    "learn": 0.10664602205166612,
                    "legacy": 0.17092761514044152,
                    "notice": 0.15932265445601906,
                    "personally": 0.1457276533166612,
                    "possibly": 0.161848707977105,
                    "productivity": 0.18372361609772486,
                    "programmer": 0.10158579698463521,
                    "project": 0.09280046237053079,
                    "reading": 0.13189684419502112,
                    "spending": 0.37895493911580186,
                    "steve": 0.17885880231426787,
                    "think": 0.08342798265796213,
                    "time": 0.23236718453277544,
                    "touch": 0.3674472321954497,
                    "type": 0.27489549267079844,
                    "typing": 0.18372361609772486,
                    "unable": 0.17464470893438833,
                    "work": 0.0832095816377679,
                    "working": 0.20973517957598237
                },
                "Max term": "spending",
                "Max score": 0.37895493911580186
            }
        ],
        "Best Answer": "Well, I said my piece on this here:  When you're a fast, efficient typist, you spend less time between thinking that thought and expressing it in code. Which means, if you're me at least, that you might actually get some of your ideas committed to screen before you completely lose your train of thought. Again.  Personally, I can't take slow typists seriously as programmers. When was the last time you saw  a hunt-and-peck pianist? ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "actually": 0.1404878694029807,
                "code": 0.08943933879529653,
                "committed": 0.2555197753413533,
                "completely": 0.18947877974987612,
                "efficient": 0.23888209133366684,
                "fast": 0.19614751286693174,
                "hunt": 0.24636339709603117,
                "ideas": 0.19614751286693174,
                "lose": 0.21792108842295366,
                "means": 0.16535978997982537,
                "personally": 0.18947877974987612,
                "piece": 0.2270774666682758,
                "programmers": 0.13691748130674786,
                "said": 0.16207535131725948,
                "saw": 0.2222444073259804,
                "screen": 0.20715534399802343,
                "seriously": 0.20411442876638497,
                "slow": 0.21401017075682216,
                "spend": 0.17871303532494595,
                "thinking": 0.1610364710767986,
                "thought": 0.3543288292904329,
                "time": 0.20141979268460838,
                "train": 0.2555197753413533
            },
            "Max term": "thought",
            "Max score": 0.3543288292904329
        }
    },
    {
        "ID": "500",
        "Question": "Rather than slavishly pair program all the time, we use pair programming selectively on our team. I think it works best in the following circumstances:  Ramping up brand new team members on a project (instead of letting them wade through documentation or code on their own). Having junior and senior people work together (helps to show some of the skills and tricks of the more experienced developers, plus it allows the old dogs to learn new tricks sometimes). When someone is trying to track down a defect, it often helps to pair with a fresh set of eyes.  When to use pair program and why? When to avoid pair programming? Why? ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "allows": 0.12122258090048302,
                    "avoid": 0.10811946789165908,
                    "best": 0.08220372291186905,
                    "circumstances": 0.13858028383141127,
                    "code": 0.05458282205540187,
                    "defect": 0.1559379867623395,
                    "developers": 0.08897229873574818,
                    "documentation": 0.11213474800130968,
                    "experienced": 0.13299235159523676,
                    "eyes": 0.13563077613583804,
                    "following": 0.11213474800130968,
                    "fresh": 0.15035005452616498,
                    "helps": 0.24244516180096604,
                    "instead": 0.10091537027398155,
                    "junior": 0.1559379867623395,
                    "learn": 0.0846234397571307,
                    "letting": 0.1559379867623395,
                    "members": 0.12456645693451264,
                    "new": 0.14774429606194453,
                    "old": 0.11004671642813399,
                    "pair": 0.5985221344228234,
                    "people": 0.06974337833010297,
                    "plus": 0.13563077613583804,
                    "program": 0.1906548760756141,
                    "programming": 0.13239992882425014,
                    "project": 0.07363701135558481,
                    "senior": 0.13060560627802953,
                    "set": 0.09827694573338025,
                    "skills": 0.10811946789165908,
                    "team": 0.18638985421337154,
                    "think": 0.06619996441212507,
                    "time": 0.06146099049156921,
                    "track": 0.13060560627802953,
                    "tricks": 0.27716056766282254,
                    "trying": 0.09646590098751076,
                    "use": 0.11747272641713057,
                    "work": 0.06602666356864544,
                    "works": 0.10465992480699984
                },
                "Max term": "pair",
                "Max score": 0.5985221344228234
            }
        ],
        "Best Answer": "I have never worked in a \"Pair Programming\" setup and yet I can claim to have been a part of the three circumstances you've listed. The scenario you mention seems more \"regular programming\" with phases of helping / training thrown in. Did we not do all of this before \"pair programming\" came into being? Pair Programming, I'd assume would require a more committed approach where the process of sharing within a team doesn't stop the minute you tackle the immediate task or problem at hand. But then this is what I \"think\" not what I \"know\". Personally for Pair Programming I'd like to work in a team where I get a chance to learn and share my knowledge. An unbalanced team where everyone you work with is miles ahead of you, or then way below par can get quite uninteresting quite quickly. Also, I'd be afraid to work with people who are set in their beliefs and hard to convince. ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "afraid": 0.15097216914005526,
                "ahead": 0.13416721919052946,
                "approach": 0.10559141483498266,
                "assume": 0.12644649383410006,
                "came": 0.13416721919052946,
                "chance": 0.11736226924100365,
                "circumstances": 0.13416721919052946,
                "claim": 0.1374046100833739,
                "committed": 0.15097216914005526,
                "convince": 0.14556218361812692,
                "hand": 0.10753200369403519,
                "hard": 0.09981127833760577,
                "know": 0.06583679385457872,
                "knowledge": 0.09454867574951835,
                "learn": 0.08192862127749545,
                "like": 0.053816708514068536,
                "listed": 0.15097216914005526,
                "mention": 0.12644649383410006,
                "minute": 0.14114190359308676,
                "pair": 0.46356984228539355,
                "people": 0.0675224127761671,
                "personally": 0.11195228371907534,
                "phases": 0.15097216914005526,
                "problem": 0.07864734907320635,
                "process": 0.09229175262513839,
                "programming": 0.3204591912400755,
                "quickly": 0.10856383677398973,
                "quite": 0.19278181967389604,
                "regular": 0.12239636478450844,
                "require": 0.10559141483498266,
                "scenario": 0.13416721919052946,
                "set": 0.09514733376954954,
                "setup": 0.13416721919052946,
                "share": 0.11736226924100365,
                "sharing": 0.13416721919052946,
                "stop": 0.12433695364356097,
                "tackle": 0.14556218361812692,
                "task": 0.09981127833760577,
                "team": 0.27068145338292293,
                "think": 0.0640918382480151,
                "training": 0.13131163804611828,
                "way": 0.06638574752442648,
                "work": 0.1917721684177817,
                "worked": 0.09908751062182258
            },
            "Max term": "pair",
            "Max score": 0.46356984228539355
        }
    },
    {
        "ID": "501",
        "Question": "No matter how much you love a programming language, there are always a few details in it that arenâ€™t quite as nice as they could be. In this question, I would like to specifically focus on syntax elements. In a programming language that you use frequently (perhaps your favourite programming language, or perhaps the one you are forced to use at work), which syntax element do you find most unreadable, unclear, inconvenient or unpleasant? ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "details": 0.18317545622373252,
                    "element": 0.23862118228381987,
                    "elements": 0.23007035368584636,
                    "favourite": 0.23007035368584636,
                    "focus": 0.1934552933728247,
                    "forced": 0.23007035368584636,
                    "frequently": 0.1906154866031566,
                    "language": 0.33697557143689955,
                    "like": 0.0850607544781154,
                    "love": 0.20350905402368002,
                    "matter": 0.17329548206258788,
                    "nice": 0.17329548206258788,
                    "programming": 0.30390376526875507,
                    "question": 0.12241444891402051,
                    "quite": 0.1523520063182501,
                    "specifically": 0.18549858295948726,
                    "syntax": 0.3759433795017904,
                    "unclear": 0.23007035368584636,
                    "unreadable": 0.23007035368584636,
                    "use": 0.17976043840094827,
                    "work": 0.101036064721154
                },
                "Max term": "syntax",
                "Max score": 0.3759433795017904
            }
        ],
        "Best Answer": "Semicolon insertion in JavaScript. I haven't really been bitten by it often, but it's just such a phenomenally bad idea it makes my head spin.  Here's the rules (from ECMA-262 Section 7.9)  When the program contains a token that is not allowed by the formal grammar, then a semicolon is inserted if (a) there is a line break at that point, or (b) the unexpected token was a closing brace. When the end of a file is reached, if the program cannot be parsed otherwise, then a semicolon is inserted. When a \"restricted production\" is encountered and contains a line terminator in a place where the grammar contains the annotation \"[no LineTerminator here]\", then a semicolon is inserted.    Example: return 1; // returns 1  return 1; // returns undefined  ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "allowed": 0.15727984592136376,
                "bad": 0.10690877032398308,
                "break": 0.14444946576143317,
                "contains": 0.4398044609240541,
                "encountered": 0.16070014719162287,
                "end": 0.10077256609508425,
                "example": 0.09649440408121422,
                "file": 0.12044354879553301,
                "formal": 0.15727984592136376,
                "grammar": 0.34869716275103674,
                "head": 0.14444946576143317,
                "idea": 0.10471610670041001,
                "javascript": 0.1466014869746847,
                "line": 0.2466042996348277,
                "makes": 0.10170938919027551,
                "place": 0.12537724648916687,
                "point": 0.10367888939136123,
                "production": 0.14244598194332142,
                "program": 0.22108676502224905,
                "reached": 0.17434858137551837,
                "really": 0.08432500935191911,
                "return": 0.28489196388664284,
                "returns": 0.36165689277933555,
                "rules": 0.14892584695747085,
                "section": 0.16070014719162287,
                "unexpected": 0.16070014719162287
            },
            "Max term": "contains",
            "Max score": 0.4398044609240541
        }
    },
    {
        "ID": "502",
        "Question": "I think everyone has their own program or set of features beyond \"Hello World!\", that they use when trying out a new language. Mine is a guessing game: I'm thinking of a number 1-10, guess what it is! Guess: 3 Nope, too low! Guess: 7 Nope, too high! Guess: 5 Yes, You win! Play again (Y/N)? N  What do you write? ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "10": 0.1652153832898299,
                    "features": 0.14337451535971268,
                    "game": 0.17463469242875823,
                    "guess": 0.7377408819577722,
                    "hello": 0.21934306200842335,
                    "high": 0.152686531768059,
                    "language": 0.10708790083392479,
                    "low": 0.1792072961175926,
                    "new": 0.10777078330512449,
                    "number": 0.14247241647698344,
                    "play": 0.19053823217273347,
                    "program": 0.13907153022676186,
                    "set": 0.14337451535971268,
                    "think": 0.09657796895894845,
                    "thinking": 0.14337451535971268,
                    "trying": 0.14073241389027724,
                    "use": 0.08568945184628149,
                    "win": 0.20705067182028397,
                    "world": 0.14073241389027724,
                    "write": 0.112160033291627,
                    "yes": 0.14825283755648316
                },
                "Max term": "guess",
                "Max score": 0.7377408819577722
            }
        ],
        "Best Answer": "It usually goes like this:  Hello World Hello [user inputted name] A few problems from Project Euler A linked list A simple blog engine (either terminal or web-based, depending on what language) And from there I dive into a project that I want to work on (but don't care if the design gets mangled as I learn my way through a new language).  ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "based": 0.1542622075070762,
                "blog": 0.19588085074036957,
                "care": 0.21014868715970772,
                "depending": 0.23295499349955717,
                "design": 0.13853003456440688,
                "engine": 0.19898653281938997,
                "euler": 0.23295499349955717,
                "gets": 0.1930054382547116,
                "goes": 0.17374353187995406,
                "hello": 0.46590998699911434,
                "language": 0.2274670647361543,
                "learn": 0.13111703165429764,
                "like": 0.08612725276883779,
                "linked": 0.2198997655376987,
                "list": 0.1621619106153089,
                "new": 0.11445879297209469,
                "problems": 0.1460147571115708,
                "project": 0.22818893622259107,
                "simple": 0.14946594737392477,
                "terminal": 0.2416130330450464,
                "user": 0.1460147571115708,
                "usually": 0.15745307142623527,
                "want": 0.11409446811129553,
                "way": 0.10624250748798306,
                "web": 0.14284562397572925,
                "work": 0.10230286268206501,
                "world": 0.14946594737392477
            },
            "Max term": "hello",
            "Max score": 0.46590998699911434
        }
    },
    {
        "ID": "507",
        "Question": "I have seen this on the SO on many times. Whenever a question is vague and the question is asking some magical answer somebody or the other leaves a comment saying answer is 42. Even a book I am reading right now uses '42' as the number whenever it wants demonstrate some basic concept using an integer. So is there any history behind it or it is just a coincidence? ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "answer": 0.32299431528402517,
                    "asking": 0.1927717835460551,
                    "basic": 0.19642944443341484,
                    "book": 0.1755742620673633,
                    "comment": 0.22496845591035178,
                    "concept": 0.20968945387812118,
                    "demonstrate": 0.27316075214646035,
                    "history": 0.22145726099697624,
                    "leaves": 0.25537440949864243,
                    "magical": 0.24861235585709882,
                    "number": 0.17107118172377064,
                    "question": 0.2802670124999684,
                    "reading": 0.18333559624213752,
                    "right": 0.15661807626674448,
                    "saying": 0.2151799251984398,
                    "seen": 0.18626111465239462,
                    "somebody": 0.2375880668508245,
                    "times": 0.1805930458487822,
                    "uses": 0.2151799251984398,
                    "using": 0.12817956086687807,
                    "wants": 0.21234884496987902
                },
                "Max term": "answer",
                "Max score": 0.32299431528402517
            }
        ],
        "Best Answer": "It's the answer to Life, The Universe, and Everything from Douglas Adams' Hitchhiker's Guide to the Galaxy. ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "answer": 0.4428629235628544,
                "guide": 0.6817531426329035,
                "life": 0.582310126516379
            },
            "Max term": "guide",
            "Max score": 0.6817531426329035
        }
    },
    {
        "ID": "558",
        "Question": "I am a moderately capable web developer. I can put stuff where I want it to go and put some JQuery stuff in there if I need to. However, if I am making my own website (which I am starting to do) I have no idea how to design it. If someone was to sit next to me a point to the screen and say \"put this picture there, text there\" I can do that quite easily. But designing my own site with my choice of colours and text will look like a toddler has invented it. Does anyone know any websites/books I can look at or has anyone got any tips on the basics of non-toddler web design? ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "basics": 0.20430289146271388,
                    "books": 0.15546969025309132,
                    "capable": 0.20430289146271388,
                    "choice": 0.1588753402920552,
                    "design": 0.24298330068629173,
                    "designing": 0.18430162744677628,
                    "developer": 0.11702253559645634,
                    "easily": 0.1588753402920552,
                    "got": 0.1361963278109376,
                    "idea": 0.1227070688664399,
                    "invented": 0.1980988351086285,
                    "jquery": 0.18071640917565673,
                    "know": 0.09240481981509686,
                    "like": 0.07553410429232563,
                    "look": 0.24418786668165848,
                    "making": 0.14221694382305114,
                    "need": 0.09974497292375273,
                    "non": 0.1252764474915303,
                    "point": 0.12149165034314587,
                    "quite": 0.13528885800499804,
                    "say": 0.11038499438622398,
                    "screen": 0.17178865147833738,
                    "sit": 0.20430289146271388,
                    "site": 0.1523740933936507,
                    "starting": 0.1571299268885996,
                    "stuff": 0.267086889203085,
                    "text": 0.3338384030276091,
                    "tips": 0.17178865147833738,
                    "want": 0.1000615156810639,
                    "web": 0.2505528949830606,
                    "website": 0.1626601374404396,
                    "websites": 0.18430162744677628
                },
                "Max term": "text",
                "Max score": 0.3338384030276091
            }
        ],
        "Best Answer": "You have a few things to do. Tips: Learn to use Photoshop. (In particular, layer styles are excellent. Just note that they can be difficult effects to reimplement in CSS2) It goes a long way towards making good mockups.  Look at professionally designed sites. What sites have you been to that look nice to you?   Find sites that bother you and consider what could make it better. Look at product advertisements as well. Food packaging. Newspaper ads. You name it.  Also, once you start getting the hang of it, practice, practice, practice. Graphics takes time to develop as a skill, especially from a programmer who has coding to consider. (Gradients vs \"tileability\")  Tools: (Photoshop is a personal favorite. Paint.NET is a good Windows alternative, but is not quite as powerful.) Nathan Smith's 960 grid system. It has templates for many of the mainstream graphics programs. Check it out. References: Look at some of these sites: (I've seen more, I'll try to add as I come across them)  A List Apart John McCain BarackObama.com  Hayon2010.com (Okay, I made this one, but I think that it's nice. edit: I'd appreciate comments on it too. ;-D)  ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "add": 0.08637844588328661,
                "alternative": 0.11437376406963992,
                "apart": 0.11437376406963992,
                "appreciate": 0.12408764933078702,
                "better": 0.06435036674145671,
                "bother": 0.11193946181560879,
                "check": 0.08705613549420946,
                "coding": 0.07307775457682282,
                "com": 0.20009603797163025,
                "come": 0.08572227390199033,
                "comments": 0.09543615916313741,
                "consider": 0.1665759432959184,
                "designed": 0.10433944322096454,
                "develop": 0.09543615916313741,
                "difficult": 0.0934663187337682,
                "edit": 0.08572227390199033,
                "effects": 0.11193946181560879,
                "especially": 0.09442777959514351,
                "excellent": 0.11713354834789626,
                "favorite": 0.11193946181560879,
                "getting": 0.0782218587839289,
                "goes": 0.0925476038677537,
                "good": 0.11255764331147546,
                "graphics": 0.22874752813927984,
                "grid": 0.12869950915346473,
                "hang": 0.12408764933078702,
                "john": 0.12869950915346473,
                "layer": 0.10599374040071197,
                "learn": 0.06984183511500093,
                "list": 0.08637844588328661,
                "long": 0.07139652881816555,
                "look": 0.2966252523856875,
                "mainstream": 0.10976190424696222,
                "make": 0.05840464532655987,
                "making": 0.08637844588328661,
                "net": 0.0786761118252815,
                "nice": 0.1869326374675364,
                "note": 0.0964962726289558,
                "okay": 0.12869950915346473,
                "particular": 0.08387019835756894,
                "personal": 0.09442777959514351,
                "powerful": 0.11437376406963992,
                "practice": 0.2803989562013046,
                "product": 0.08446930353393094,
                "programmer": 0.06652792431010329,
                "programs": 0.08923369306285604,
                "quite": 0.08217052754513099,
                "references": 0.11713354834789626,
                "seen": 0.08775680196285121,
                "sites": 0.390454866927136,
                "skill": 0.107792063817593,
                "start": 0.07172201084239073,
                "styles": 0.12031948548453676,
                "takes": 0.08446930353393094,
                "templates": 0.12408764933078702,
                "things": 0.06116442960481619,
                "think": 0.054636481480309626,
                "time": 0.050725288126273665,
                "tips": 0.10433944322096454,
                "tools": 0.08508629506484024,
                "try": 0.07379050387620303,
                "use": 0.04847658528465515,
                "vs": 0.10004801898581513,
                "way": 0.05659197433437895,
                "windows": 0.0925476038677537
            },
            "Max term": "sites",
            "Max score": 0.390454866927136
        }
    },
    {
        "ID": "566",
        "Question": "goto is almost universally discouraged. Is using this statement ever worthwhile? ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "goto": 0.5470513116585977,
                    "statement": 0.5341622322222705,
                    "universally": 0.5795291979495328,
                    "using": 0.2820487206209244
                },
                "Max term": "universally",
                "Max score": 0.5795291979495328
            }
        ],
        "Best Answer": "This has been discussed several times on Stack Overflow, and Chris Gillum summarized the possible uses of goto:  Cleanly exiting a function Often in a function, you may allocate resources and need to exit in multiple places.  Programmers can simplify their code by putting the resource cleanup code at the end of the function all all \"exit points\" of the function would goto the cleanup label.  This way, you don't have to write cleanup code at every \"exit point\" of the function. Exiting nested loops If you're in a nested loop and need to break out of all loops, a goto can make this much cleaner and simpler than break statements and if-checks. Low-level performance improvements This is only valid in perf-critical code, but goto statements execute very quickly and can give you a boost when moving through a function.  This is a double-edged sword, however, because a compiler typically cannot optimize code that contains gotos.  I'd argue, as many others would argue, that in all of these cases, the usage of goto is used as a means to get out of a corner one coded oneself into, and is generally a symptom of code that could be refactored. ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "argue": 0.20823995342525037,
                "break": 0.16634633888101508,
                "cases": 0.072191495560463,
                "chris": 0.10411997671262518,
                "code": 0.2186700859481794,
                "coded": 0.09253021810103465,
                "compiler": 0.0857506439208441,
                "contains": 0.08441229084580888,
                "critical": 0.09253021810103465,
                "double": 0.09734040253243463,
                "end": 0.05802426246853589,
                "execute": 0.10038890780259145,
                "exit": 0.31235993013787555,
                "function": 0.43314897336277797,
                "generally": 0.071583410828917,
                "goto": 0.47381464026049036,
                "improvements": 0.10411997671262518,
                "level": 0.06365024221902928,
                "loop": 0.10038890780259145,
                "loops": 0.2007778156051829,
                "low": 0.08201957501081035,
                "make": 0.04725029917603876,
                "means": 0.06738131112906301,
                "moving": 0.09056082835224408,
                "multiple": 0.07347832166937664,
                "need": 0.09802395667456386,
                "nested": 0.2007778156051829,
                "optimize": 0.10411997671262518,
                "overflow": 0.08201957501081035,
                "performance": 0.07992678627186883,
                "places": 0.09056082835224408,
                "point": 0.05969770666368002,
                "points": 0.07561575793090552,
                "possible": 0.06123277362262782,
                "programmers": 0.055791552517472476,
                "putting": 0.10038890780259145,
                "quickly": 0.07487250280053118,
                "refactored": 0.10411997671262518,
                "resource": 0.10038890780259145,
                "resources": 0.08441229084580888,
                "simpler": 0.09734040253243463,
                "stack": 0.07897106974065354,
                "times": 0.06883618375071497,
                "typically": 0.09476292805209807,
                "usage": 0.09476292805209807,
                "used": 0.05080809723732104,
                "uses": 0.08201957501081035,
                "valid": 0.09476292805209807,
                "way": 0.04578381913477866,
                "write": 0.05133339134664005
            },
            "Max term": "goto",
            "Max score": 0.47381464026049036
        }
    },
    {
        "ID": "568",
        "Question": "Managed OSes like Microsoft Singularity and JNode are quite an interesting concept. Essentially, the OS is bootstrapped with code written in a low-level language (C/C++/Assembly), which essentially implements a virtual machine. The rest of the OS (and all userland apps) run on the virtual machine. There are some great things about this. For example, you suddenly make arbitrary pointers obsolete. And if well written, you get rid of a ton of legacy crud that most modern OSes currently have.  However, as a disadvantage, you're that much farther away from the hardware, and as a developer, you lose the ability to drop down to a lower level of abstraction and get your hands dirty.  What are your opinions on this? ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "ability": 0.12395127288209531,
                    "abstraction": 0.13766332546707563,
                    "apps": 0.13167350043233664,
                    "assembly": 0.15626942145517123,
                    "away": 0.11589558859136713,
                    "code": 0.05850850371764241,
                    "concept": 0.12831375589713895,
                    "crud": 0.1671532898930255,
                    "currently": 0.12395127288209531,
                    "developer": 0.09231272826439196,
                    "dirty": 0.1671532898930255,
                    "drop": 0.16116346485828648,
                    "essentially": 0.2970943878098598,
                    "example": 0.08919701197722366,
                    "great": 0.1034038789864095,
                    "hands": 0.16116346485828648,
                    "hardware": 0.12831375589713895,
                    "interesting": 0.11690864928722657,
                    "language": 0.07868339661517595,
                    "legacy": 0.14538555301731695,
                    "level": 0.2043670720127736,
                    "like": 0.05958475612147689,
                    "lose": 0.1425573688701909,
                    "low": 0.13167350043233664,
                    "lower": 0.1425573688701909,
                    "machine": 0.2566275117942779,
                    "make": 0.07585521246804988,
                    "managed": 0.13167350043233664,
                    "microsoft": 0.12395127288209531,
                    "modern": 0.1335254707286647,
                    "obsolete": 0.1671532898930255,
                    "opinions": 0.15626942145517123,
                    "os": 0.27102949055064424,
                    "pointers": 0.1671532898930255,
                    "quite": 0.10672203881551753,
                    "rest": 0.1425573688701909,
                    "run": 0.1034038789864095,
                    "suddenly": 0.1485471939049299,
                    "things": 0.07943958527988026,
                    "virtual": 0.30426313343352057,
                    "written": 0.2279548423310579
                },
                "Max term": "virtual",
                "Max score": 0.30426313343352057
            }
        ],
        "Best Answer": "I think that this is another case where \"it depends\". If you're writing applications such as web browsers, word processors etc. where lightning fast performance is not necessarily an issue then this approach has it's merits. By using this approach you can offer your customers a safer, more controlled experience. Not only are you limiting the damage that can be done by malware, but you are also running in a more consistent environment. It's like the difference between console games and PC games. The former know exactly what hardware they need to work with so can make use of that knowledge whereas the latter have to be able to cope with a wider variety of graphics cards, sound cards, hard disk speeds etc. However, there will be applications (such as games!) that require the low level access and will still need to be run \"natively\". Like managed languages you will have to use the appropriate tool for the job. ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "able": 0.09678898070608927,
                "access": 0.10558555666685039,
                "applications": 0.21482652236888194,
                "approach": 0.21482652236888194,
                "appropriate": 0.13648210491188506,
                "browsers": 0.14807367504248473,
                "cards": 0.3071540060480338,
                "case": 0.10008222868531823,
                "consistent": 0.14357712867477088,
                "console": 0.14807367504248473,
                "cope": 0.1535770030240169,
                "customers": 0.12097890258110691,
                "depends": 0.11789203843998115,
                "difference": 0.12648223056263908,
                "disk": 0.14807367504248473,
                "environment": 0.10079714032784932,
                "exactly": 0.1226804547789822,
                "experience": 0.08805413875686316,
                "fast": 0.11789203843998115,
                "games": 0.35816162039925975,
                "graphics": 0.13648210491188506,
                "hard": 0.10153339574041086,
                "hardware": 0.11789203843998115,
                "issue": 0.10472010910590193,
                "job": 0.08519741057548963,
                "know": 0.06697272448616891,
                "knowledge": 0.09617999359888682,
                "languages": 0.08406762259830074,
                "level": 0.0938841301197291,
                "like": 0.10949049554345848,
                "low": 0.12097890258110691,
                "make": 0.06969420824471145,
                "managed": 0.12097890258110691,
                "necessarily": 0.11514891121824099,
                "need": 0.14458537127976687,
                "offer": 0.12648223056263908,
                "pc": 0.13648210491188506,
                "performance": 0.11789203843998115,
                "processors": 0.14357712867477088,
                "require": 0.10741326118444097,
                "run": 0.09500535613719623,
                "running": 0.11268058042973622,
                "safer": 0.1535770030240169,
                "sound": 0.14807367504248473,
                "think": 0.06519766187699763,
                "tool": 0.10741326118444097,
                "use": 0.11569412710001889,
                "using": 0.07206537781209128,
                "variety": 0.14807367504248473,
                "web": 0.09079726597860333,
                "wider": 0.1535770030240169,
                "word": 0.12648223056263908,
                "work": 0.06502698490010615,
                "writing": 0.0855858079683584
            },
            "Max term": "games",
            "Max score": 0.35816162039925975
        }
    },
    {
        "ID": "570",
        "Question": "All but the most trivial programs are filled with bugs and so anything that promises to remove them is extremely alluring. At the moment, correctness proofs are code are extremely esoteric, mainly because of the difficultly of learning this and the extra effort it takes to prove a program correct. Do you think that code proving will ever take off? ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "bugs": 0.19278904233560526,
                    "code": 0.19952343393141372,
                    "correct": 0.2091138217275474,
                    "correctness": 0.28500983851286726,
                    "effort": 0.22451393639132972,
                    "extra": 0.24307180975328005,
                    "extremely": 0.469454142190385,
                    "learning": 0.1752597369185757,
                    "mainly": 0.2747967038090045,
                    "moment": 0.2347270710951925,
                    "program": 0.17423116897365498,
                    "programs": 0.1976113243712919,
                    "prove": 0.2593965891452221,
                    "remove": 0.24307180975328005,
                    "takes": 0.18706040697321427,
                    "think": 0.12099451556606886,
                    "trivial": 0.24789409178896663
                },
                "Max term": "extremely",
                "Max score": 0.469454142190385
            }
        ],
        "Best Answer": "Not really in that sense, but pure functional programming is good in this domain. If you use Haskell, it's likely that your program is correct if the code compiles. Except from IO, a good type system is a good help. Also programming to contract can be helpful. See Microsoft Code Contracts ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "code": 0.20052727886368052,
                "contract": 0.22267476624910518,
                "contracts": 0.2545592750102155,
                "correct": 0.21016591794537962,
                "domain": 0.2359080330310508,
                "functional": 0.1937590051080568,
                "good": 0.37577576000010315,
                "haskell": 0.2359080330310508,
                "help": 0.15544549973394628,
                "helpful": 0.21016591794537962,
                "io": 0.28644378377132584,
                "likely": 0.1937590051080568,
                "microsoft": 0.21241024708722153,
                "program": 0.17510776312889215,
                "programming": 0.2432065295371103,
                "pure": 0.2761792646094422,
                "really": 0.13357618907627955,
                "sense": 0.2059812504742213,
                "type": 0.20034158991940593,
                "use": 0.10789331369315618
            },
            "Max term": "good",
            "Max score": 0.37577576000010315
        }
    },
    {
        "ID": "604",
        "Question": "on a widescreen monitor one can easily see more than 80 characters at a time, without scrollbars. even linus torvalds sees the 80 character limit as outdated. so, is the 80 character limit still relevant in times of widescreen monitors? ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "80": 0.6519391679270236,
                    "character": 0.4500774244109327,
                    "characters": 0.24668433235034573,
                    "easily": 0.1978409273602667,
                    "monitor": 0.24015238307964062,
                    "monitors": 0.2544099885801375,
                    "outdated": 0.2638654276278456,
                    "relevant": 0.1978409273602667,
                    "time": 0.10399922991955367,
                    "times": 0.17444768655474477
                },
                "Max term": "80",
                "Max score": 0.6519391679270236
            }
        ],
        "Best Answer": "If I keep my lines to less than about 100 characters, I can have two editor windows side-by-side on a widescreen monitor.  It's very useful to have both the class header file and implementation both visible at the same time, or have code on one side that calls into the code on the other.  And, if I keep the lines short, I don't need a horizontal scrollbar on my editor windows, which gives me more vertical space. 80 characters may be outdated, but there's some merit in keeping things within reason. ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "100": 0.16795212378585808,
                "80": 0.17559226270816974,
                "calls": 0.17031434810157345,
                "characters": 0.3986494037146118,
                "class": 0.14200997136278873,
                "code": 0.14925748045956214,
                "editor": 0.3636694214774989,
                "file": 0.14200997136278873,
                "gives": 0.17285170667263955,
                "implementation": 0.17285170667263955,
                "keeping": 0.17559226270816974,
                "lines": 0.35714283345712466,
                "merit": 0.21320728881019732,
                "monitor": 0.19404678725070962,
                "need": 0.10036221050411463,
                "outdated": 0.21320728881019732,
                "reason": 0.13269932199954587,
                "short": 0.15331700824899916,
                "space": 0.17285170667263955,
                "things": 0.10132674392809803,
                "time": 0.08403296350278078,
                "useful": 0.13797723660614217,
                "windows": 0.3066340164979983
            },
            "Max term": "characters",
            "Max score": 0.3986494037146118
        }
    },
    {
        "ID": "616",
        "Question": "When I am in a code or design rut, I tend to find a non-dev coworker to discuss the problem with. It forces me to explain the problem in great detail and I'll usually find something I missed in the process. What are your \"unsticking\" methods? ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "code": 0.1187949297606482,
                    "coworker": 0.32722427119683484,
                    "design": 0.19458861524381338,
                    "dev": 0.30160835339831876,
                    "discuss": 0.30160835339831876,
                    "explain": 0.21963383115844248,
                    "forces": 0.31728746705081917,
                    "great": 0.20994993480691357,
                    "methods": 0.23531294481094295,
                    "missed": 0.2951889975216939,
                    "non": 0.20065058274530603,
                    "problem": 0.3535990027404093,
                    "process": 0.2074721657753329,
                    "tend": 0.2574114143400682,
                    "usually": 0.22116918710845734
                },
                "Max term": "problem",
                "Max score": 0.3535990027404093
            }
        ],
        "Best Answer": "Some of my tactics:  Explain the problem to someone, or even no one.  My girlfriend used to explain problems to a potato she kept. Work on something else for a bit (if opportunity allows)- some other functionality or even another project.  Get your ming off the current project.  A lot of times problems that seem impossible at 4:30pm seem trivial at 9:30 am the next day. Go to the pub (if possible).  Same principle as above. Beat your head against it.  This isn't often that productive for solving the problem, but at least for me, I tend to learn a lot.  If my gridview isn't auto-sorting, I'll try and read everything I can about the problem.  It'll still take me 3 hours to solve a stupid error on my part, but by the end, I'll have learned everything there is to know about gridviews and how they bind to data- I'll be able to solve any number of similar problems in the future. Get another input- preferably someone who knows at least something about the context of the project.  Most of my errors are stupid ones that only require a few minutes from a second set of eyes to solve where it would take me hours. Isolate the problem.  I keep a folder labeled \"proof of bugs\" where I keep a pile of project that each reproduce a specific issue outside the overall context of the large, complex project.  This can be a little time consuming, but it allows you to narrow down the cause of the issue independent of the bazillion interfering factors of a large project.  ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "30": 0.09896447825069331,
                "able": 0.07446791095530308,
                "allows": 0.18370925740324595,
                "auto": 0.1181597171758964,
                "beat": 0.1181597171758964,
                "bit": 0.07811818884575547,
                "bugs": 0.07992671002463866,
                "cause": 0.09185462870162298,
                "complex": 0.08669465644352588,
                "consuming": 0.1181597171758964,
                "context": 0.1946268555419171,
                "current": 0.08669465644352588,
                "data": 0.07223296485683756,
                "day": 0.07494831915552357,
                "end": 0.06584836703858803,
                "error": 0.0876204551924398,
                "errors": 0.0876204551924398,
                "explain": 0.15293427673204144,
                "eyes": 0.10277222684029415,
                "factors": 0.09438840161132699,
                "folder": 0.11046597200809527,
                "functionality": 0.08669465644352588,
                "future": 0.0957946085604614,
                "girlfriend": 0.1181597171758964,
                "head": 0.09438840161132699,
                "hours": 0.16832176706764373,
                "impossible": 0.09731342777095855,
                "input": 0.09896447825069331,
                "issue": 0.16113999141717,
                "kept": 0.1075409458484637,
                "know": 0.05152775498912043,
                "knows": 0.0876204551924398,
                "large": 0.15985342004927733,
                "learn": 0.06412216750876344,
                "learned": 0.0876204551924398,
                "little": 0.07494831915552357,
                "lot": 0.12123363503177705,
                "minutes": 0.09438840161132699,
                "number": 0.07399936590667,
                "ones": 0.08192593743535632,
                "opportunity": 0.09896447825069331,
                "outside": 0.09070426981297222,
                "overall": 0.10277222684029415,
                "pile": 0.11392554366671322,
                "possible": 0.06948952008618797,
                "preferably": 0.1181597171758964,
                "principle": 0.11046597200809527,
                "problem": 0.24621620199423888,
                "problems": 0.21422349017811987,
                "productive": 0.09731342777095855,
                "project": 0.33478417732999216,
                "proof": 0.11392554366671322,
                "read": 0.07100833929668514,
                "reproduce": 0.11392554366671322,
                "require": 0.0826420643233247,
                "second": 0.0876204551924398,
                "set": 0.07446791095530308,
                "similar": 0.0770016838650071,
                "solve": 0.2524826506014656,
                "solving": 0.09731342777095855,
                "sorting": 0.11392554366671322,
                "specific": 0.0770016838650071,
                "stupid": 0.22093194401619054,
                "tend": 0.08961968260315743,
                "time": 0.046571162066510456,
                "times": 0.07811818884575547,
                "trivial": 0.10277222684029415,
                "try": 0.06774746170851507,
                "used": 0.05765916003205694,
                "work": 0.05003073372512841
            },
            "Max term": "project",
            "Max score": 0.33478417732999216
        }
    },
    {
        "ID": "648",
        "Question": "We, as programmers, are constantly being asked 'How long will it take'? And you know, the situation is almost always like this:  The requirements are unclear. Nobody has done an in depth analysis of all the implications. The new feature will probably break some assumptions you made in your code and you start thinking immediately of all the things you might have to refactor.  You have other things to do from past assignments and you will have to come up with an estimate that takes that other work into account. The 'done' definition is probably unclear: When will it be done? 'Done' as in just finished coding it, or 'done' as in \"the users are using it\"? No matter how conscious you are of all these things, sometimes your \"programmer's pride\" makes you give/accept shorter times than you originally suppose it might take. Specially when you feel the pressure of deadlines and management expectations.  Many of these are organizational or cultural issues that are not simple and easy to solve, but in the end the reality is that you are being asked for an estimate and they expect you to give a reasonable answer. It's part of your job. You cannot simply say: I don't know.  As a result, I always end up giving estimates that I later realize I cannot fulfill. It has happened countless of times, and I always promise it won't happen again. But it does. What is your personal process for deciding and delivering an estimate? What techniques have you found useful? ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "accept": 0.10893302112307536,
                    "account": 0.10893302112307536,
                    "analysis": 0.10893302112307536,
                    "answer": 0.07689466958161306,
                    "asked": 0.1719738327539044,
                    "assignments": 0.12540109212991252,
                    "assumptions": 0.13006176756081023,
                    "break": 0.10389600317453268,
                    "code": 0.045525394179946235,
                    "coding": 0.07385126790423964,
                    "come": 0.08662962692212123,
                    "conscious": 0.12540109212991252,
                    "constantly": 0.11312431849435657,
                    "cultural": 0.12540109212991252,
                    "deadlines": 0.12540109212991252,
                    "deciding": 0.13006176756081023,
                    "definition": 0.10389600317453268,
                    "depth": 0.12540109212991252,
                    "easy": 0.08304028604476048,
                    "end": 0.1449623477903654,
                    "estimate": 0.31168800952359804,
                    "estimates": 0.10544385523217137,
                    "expect": 0.10544385523217137,
                    "expectations": 0.1155843873479139,
                    "feature": 0.08145321060538198,
                    "feel": 0.07816090238889442,
                    "finished": 0.1215930430275834,
                    "giving": 0.10711566281468707,
                    "happen": 0.09864693828146025,
                    "happened": 0.10711566281468707,
                    "immediately": 0.11312431849435657,
                    "implications": 0.13006176756081023,
                    "issues": 0.09644633170411986,
                    "job": 0.0721522467092249,
                    "know": 0.11343613631621777,
                    "later": 0.09751766625765683,
                    "like": 0.04636282484059232,
                    "long": 0.0721522467092249,
                    "makes": 0.0731549886078845,
                    "management": 0.08536339411483988,
                    "matter": 0.09445564091017902,
                    "new": 0.06161386552376914,
                    "organizational": 0.12540109212991252,
                    "originally": 0.10893302112307536,
                    "past": 0.09644633170411986,
                    "personal": 0.09542727864130587,
                    "pressure": 0.1215930430275834,
                    "probably": 0.14770253580847928,
                    "process": 0.07950888263766621,
                    "programmer": 0.06723210900211028,
                    "programmers": 0.06969217785566759,
                    "promise": 0.1215930430275834,
                    "reality": 0.11312431849435657,
                    "realize": 0.10544385523217137,
                    "reasonable": 0.1215930430275834,
                    "refactor": 0.1155843873479139,
                    "requirements": 0.08662962692212123,
                    "result": 0.10711566281468707,
                    "say": 0.06775429731650688,
                    "shorter": 0.13006176756081023,
                    "simple": 0.08045842999694199,
                    "simply": 0.08729274435180394,
                    "situation": 0.09542727864130587,
                    "solve": 0.09263828260179076,
                    "specially": 0.13006176756081023,
                    "start": 0.0724811738951827,
                    "suppose": 0.11837338338742902,
                    "takes": 0.08536339411483988,
                    "techniques": 0.10711566281468707,
                    "things": 0.18543552835384647,
                    "thinking": 0.08196895149122352,
                    "times": 0.1719738327539044,
                    "unclear": 0.25080218425982503,
                    "useful": 0.08416955806856391,
                    "users": 0.08416955806856391,
                    "using": 0.061030950165842306,
                    "work": 0.05507025419642619
                },
                "Max term": "estimate",
                "Max score": 0.31168800952359804
            }
        ],
        "Best Answer": "From The Pragmatic Programmer: From Journeyman to Master:  What to Say When Asked for an Estimate You say \"I'll get back to you.\" You almost always get better results if you slow the process down and spend some time going through the steps we describe in this section. Estimates given at the coffee machine will (like the coffee) come back to haunt you.  In the section, the authors recommend the following process:  Determine the accuracy that you need. Based on the duration, you can quote the estimate in different precision. Saying \"5 to 6 months\" is different than saying \"150 days\". If you slip a little into the 7th month, you're still pretty accurate. But if you slip into the 180th or 210th day, not so much. Make sure you understand what is being asked. Determine the scope of the problem. Model the system. A model might be a mental model, diagrams, or existing data records. Decompose this model and build estimates from the components. Assign values and error ranges (+/-) to each value. Calculate the estimate based on your model. Track your estimates. Record information about the problem you are estimating, your estimate, and the actual values. Other things to include in your estimate are developing and documenting requirements or changes to requirements specifications, creating or updating design documents and specifications, testing (unit, integration, and acceptance), creating or updating user's manuals or READMEs with the changes. If 2 or more people working together, there's overhead of communication (phone calls, emails, meetings) and merging source code. If it's a long task, account for things like other work, time off (holidays, vacation, sick time), meetings, and other overhead tasks when picking a delivery date.  ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "acceptance": 0.08762078435547146,
                "account": 0.07611414375184886,
                "accuracy": 0.09087731131185928,
                "accurate": 0.0849600080931359,
                "actual": 0.07259465715115265,
                "asked": 0.12016228773273512,
                "assign": 0.09087731131185928,
                "authors": 0.0849600080931359,
                "based": 0.11604452358049332,
                "better": 0.04543908791775095,
                "build": 0.06008114386636756,
                "calls": 0.07259465715115265,
                "changes": 0.12106044262317103,
                "code": 0.0318096970160868,
                "coffee": 0.1699200161862718,
                "come": 0.060530221311585516,
                "communication": 0.07750508768871354,
                "components": 0.0849600080931359,
                "creating": 0.1395223408132844,
                "data": 0.055554784584508875,
                "date": 0.07367617892303666,
                "day": 0.05764317903755536,
                "days": 0.06247896048439473,
                "delivery": 0.08762078435547146,
                "design": 0.05210495857152329,
                "determine": 0.16542070763582115,
                "developing": 0.06534972404461627,
                "diagrams": 0.08076161464510136,
                "different": 0.09779945641439498,
                "documents": 0.08271035381791057,
                "emails": 0.08271035381791057,
                "error": 0.06738939102195562,
                "estimate": 0.3629732857557633,
                "estimates": 0.22102853676910997,
                "estimating": 0.09087731131185928,
                "existing": 0.06534972404461627,
                "following": 0.06534972404461627,
                "given": 0.06300970498893123,
                "going": 0.04697670510344994,
                "include": 0.0689270082076546,
                "information": 0.060530221311585516,
                "integration": 0.08271035381791057,
                "like": 0.06478966025685871,
                "little": 0.05764317903755536,
                "long": 0.0504145246448276,
                "machine": 0.0697611704066422,
                "make": 0.041240694469716406,
                "master": 0.07484431142637799,
                "meetings": 0.1473523578460733,
                "mental": 0.0849600080931359,
                "model": 0.34068979228502294,
                "month": 0.07158778446999016,
                "months": 0.07484431142637799,
                "need": 0.04277831165541539,
                "overhead": 0.16542070763582115,
                "people": 0.04064494377566414,
                "phone": 0.09087731131185928,
                "picking": 0.09087731131185928,
                "pragmatic": 0.07611414375184886,
                "precision": 0.08762078435547146,
                "pretty": 0.05691333369027776,
                "problem": 0.0946831414861345,
                "process": 0.11110956916901775,
                "programmer": 0.04697670510344994,
                "quote": 0.07259465715115265,
                "ranges": 0.09087731131185928,
                "recommend": 0.07064591797834344,
                "record": 0.0849600080931359,
                "requirements": 0.12106044262317103,
                "results": 0.07259465715115265,
                "say": 0.0946831414861345,
                "saying": 0.14317556893998032,
                "scope": 0.07750508768871354,
                "section": 0.1615232292902027,
                "sick": 0.08762078435547146,
                "slow": 0.07611414375184886,
                "source": 0.05401716739880988,
                "specifications": 0.18175462262371855,
                "spend": 0.06356048225627875,
                "steps": 0.07484431142637799,
                "sure": 0.053444785589520816,
                "task": 0.06008114386636756,
                "tasks": 0.06667735393242928,
                "testing": 0.053444785589520816,
                "things": 0.08637886728505124,
                "time": 0.1074544378006518,
                "track": 0.07611414375184886,
                "understand": 0.04974598644120518,
                "unit": 0.05881131154089668,
                "user": 0.05492016871324894,
                "vacation": 0.08762078435547146,
                "value": 0.0689270082076546,
                "values": 0.1550101753774271,
                "work": 0.03847892219588616,
                "working": 0.04849431698729622
            },
            "Max term": "estimate",
            "Max score": 0.3629732857557633
        }
    },
    {
        "ID": "678",
        "Question": "I know some people are massive proponents of test driven development. I have used unit tests in the past, but only to test operations that can be tested easily or which I believe will quite possibly be correct. Complete or near complete code coverage sounds like it would take a lot of time.  What projects do you use test-driven development for? Do you only use it for projects above a certain size? Should I be using it or not? Convince me!  ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "believe": 0.1534004078312853,
                    "certain": 0.1534004078312853,
                    "code": 0.07538583226875124,
                    "complete": 0.2986535237476093,
                    "convince": 0.20765258308928655,
                    "correct": 0.15801872671507244,
                    "coverage": 0.19139703004119055,
                    "development": 0.2177173175824272,
                    "driven": 0.3306541328254286,
                    "easily": 0.16148021481553843,
                    "know": 0.09391986274460956,
                    "like": 0.07677253980763916,
                    "lot": 0.11048653647552355,
                    "massive": 0.21537022952863386,
                    "operations": 0.1773736073187286,
                    "past": 0.15970618411439994,
                    "people": 0.09632449226081873,
                    "possibly": 0.1773736073187286,
                    "projects": 0.2507071247727227,
                    "quite": 0.13750701532809512,
                    "size": 0.18367938360184324,
                    "sounds": 0.1653270664127143,
                    "test": 0.36512868571348406,
                    "tested": 0.1746052489492656,
                    "tests": 0.13660862673936033,
                    "time": 0.08488545930377031,
                    "unit": 0.1393769851088233,
                    "use": 0.16224480370117256,
                    "used": 0.10509560133802957,
                    "using": 0.10106159551785648
                },
                "Max term": "test",
                "Max score": 0.36512868571348406
            }
        ],
        "Best Answer": "Ok, some advantages to TDD:  It means you end up with more tests.  Everyone likes having tests, but few people like writing them.  Building test-writing into your development flow means you end up with more tests. Writing to a test forces you to think about the testability of your design, and testable design is almost always better design.  It's not entirely clear to me why this happens to be the case, but my experience and that of most TDD evangelists seems to bear it out. Here's a study saying that although TDD takes a bit longer to write, there's a good return on investment because you get higher quality code, and therefore fewer bugs to fix. It gives you confidence in refactoring.  It's a great feeling to be able to change one system without worrying about breaking everything else because it's pretty well covered by unit tests. You almost never get a repeat bug, since every one you find should get a test before it gets a fix.  You asked to be convinced, so these were benefits.  See this question for a more balanced view. ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "able": 0.08589128317131453,
                "advantages": 0.11048949466422338,
                "asked": 0.0901015134291637,
                "benefits": 0.11224130063301367,
                "better": 0.06814335291845226,
                "bit": 0.0901015134291637,
                "breaking": 0.12111526575944481,
                "bug": 0.09617773133126348,
                "bugs": 0.09218746162757646,
                "building": 0.11414562213828792,
                "case": 0.08881373666419978,
                "change": 0.0843084810609864,
                "clear": 0.11224130063301367,
                "code": 0.04770384946810193,
                "confidence": 0.1362854093421379,
                "convinced": 0.13140171391939376,
                "covered": 0.12111526575944481,
                "design": 0.2344197524717648,
                "development": 0.06888531858032036,
                "end": 0.15189900366816325,
                "entirely": 0.11623157033670069,
                "experience": 0.07813991749058827,
                "feeling": 0.11414562213828792,
                "fewer": 0.12403771925233006,
                "fix": 0.19414231410064123,
                "flow": 0.1362854093421379,
                "forces": 0.12741144421570674,
                "gets": 0.10886757566963698,
                "gives": 0.11048949466422338,
                "good": 0.059596048944518504,
                "great": 0.0843084810609864,
                "happens": 0.10735760521026955,
                "higher": 0.11048949466422338,
                "like": 0.04858135238477149,
                "likes": 0.12741144421570674,
                "longer": 0.1021840261997125,
                "means": 0.1763943838477789,
                "ok": 0.10461829831683381,
                "people": 0.0609537487431332,
                "pretty": 0.0853508633457226,
                "quality": 0.09707115705032061,
                "question": 0.06991543298866117,
                "refactoring": 0.11224130063301367,
                "repeat": 0.12111526575944481,
                "return": 0.10735760521026955,
                "saying": 0.10735760521026955,
                "study": 0.12111526575944481,
                "takes": 0.08944815473414072,
                "tdd": 0.31783536653025524,
                "test": 0.23105195413465018,
                "testability": 0.1362854093421379,
                "testable": 0.13140171391939376,
                "tests": 0.34578154382039666,
                "think": 0.05785690475850331,
                "unit": 0.08819719192388945,
                "view": 0.11224130063301367,
                "write": 0.06719164250205495,
                "writing": 0.22784850550224486
            },
            "Max term": "tests",
            "Max score": 0.34578154382039666
        }
    },
    {
        "ID": "724",
        "Question": "When learning a new programming language you sometimes come across a language feature which  makes you wish you had it in your other programming languages that you know. What are some language feature which were at the time of learning very new to you and that you wish your other programming languages had.   An example of this is generators in Python or C#. Other examples may include list comprehensions in Python, template in C++ or LINQ in .NET or lazy evaluation in Haskell. What other semi-unique language features have you come across which were completely new and enlightening to you?  Are there other features of older programming languages which were unique and have fallen out of fashion? ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "come": 0.22161957815216562,
                    "completely": 0.12336654390654452,
                    "example": 0.08877623309998496,
                    "examples": 0.12206305156841789,
                    "fashion": 0.16636475928993869,
                    "feature": 0.2083770508411909,
                    "features": 0.20969644100385176,
                    "generators": 0.16636475928993869,
                    "haskell": 0.13701391111739122,
                    "include": 0.1261813863494624,
                    "know": 0.07254928126439911,
                    "language": 0.31324885908918537,
                    "languages": 0.2732028140070532,
                    "learning": 0.2046037715596999,
                    "linq": 0.16040319071578177,
                    "list": 0.11165799661346344,
                    "makes": 0.0935740940543396,
                    "net": 0.10170149437068687,
                    "new": 0.23643479784307764,
                    "older": 0.14784643588532007,
                    "programming": 0.2825056645424262,
                    "python": 0.22506803827723137,
                    "semi": 0.16040319071578177,
                    "template": 0.14784643588532007,
                    "time": 0.06557057136074648,
                    "unique": 0.29569287177064013,
                    "wish": 0.33272951857987737
                },
                "Max term": "wish",
                "Max score": 0.33272951857987737
            }
        ],
        "Best Answer": "Practically anything in Haskell  Monads. Yes - the big scary word that makes increadibly easy parsers, IO, operations on Lists and other things so easy (once you notice common pattern) Arrows. The same for advanced users ;) Standard stuff like lambdas etc.  Currying functions Algebraic data types Pattern matching  And many more. PS. Yes. I am Haskell fanboy if anyone asked. ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "advanced": 0.2049746654271033,
                "asked": 0.15248719848660588,
                "big": 0.14355466795681127,
                "common": 0.14018511556163757,
                "data": 0.14099920405411565,
                "easy": 0.2945234255170006,
                "functions": 0.18169129276186227,
                "haskell": 0.3799128524400862,
                "io": 0.23064851492778976,
                "like": 0.0822187557334258,
                "lists": 0.2006120365136694,
                "makes": 0.12973135609647118,
                "notice": 0.18699168151924564,
                "operations": 0.1899564262200431,
                "pattern": 0.3684935133291158,
                "practically": 0.23064851492778976,
                "standard": 0.15138145860256672,
                "stuff": 0.14536183296754948,
                "things": 0.10961568499794395,
                "types": 0.16922851745749776,
                "users": 0.14926433751229648,
                "word": 0.1899564262200431,
                "yes": 0.30061554741138113
            },
            "Max term": "haskell",
            "Max score": 0.3799128524400862
        }
    },
    {
        "ID": "729",
        "Question": "As programmers we have a lot of inputs:  Ebooks  Code snippets  Interesting emails  Documents Web articles  Blog posts StackOverflow questions Podcasts ...  Which tools do you use to store, organize, search and consult all of this stuff? Is there a silver bullet solution to handle this huge amount of data?  ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "articles": 0.23789385870680851,
                    "blog": 0.2261414188597423,
                    "code": 0.09763657836043341,
                    "data": 0.1705196712700307,
                    "documents": 0.2538708852736833,
                    "emails": 0.2538708852736833,
                    "handle": 0.21684034598157323,
                    "huge": 0.204659248681233,
                    "inputs": 0.2689429444549313,
                    "interesting": 0.19509233311161955,
                    "lot": 0.1430975430225098,
                    "organize": 0.27893851747781884,
                    "posts": 0.2607759666334913,
                    "programmers": 0.14946615854479542,
                    "questions": 0.1792879247238043,
                    "search": 0.2261414188597423,
                    "solution": 0.19020082049359752,
                    "stackoverflow": 0.2297268808853685,
                    "store": 0.24788943172969602,
                    "stuff": 0.17579568721056293,
                    "tools": 0.18441286341477742,
                    "use": 0.10506634345873671,
                    "web": 0.1649130681313667
                },
                "Max term": "organize",
                "Max score": 0.27893851747781884
            }
        ],
        "Best Answer": "I've started blogging about things I've learned.  Just a simple free blog, I keep it private, if it's worth sharing I'll spend some time to transform it into a post that's intelligible enough someone else can read it and walk away with something. You can tag ideas and search by grouping later too. Also helpful for creating an online identity for employment sake. ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "away": 0.17828778879482166,
                "blog": 0.20846888633024618,
                "creating": 0.19739125612036856,
                "employment": 0.2571399895977334,
                "free": 0.16417567352957088,
                "grouping": 0.24792555207089353,
                "helpful": 0.18866550791486517,
                "ideas": 0.19739125612036856,
                "identity": 0.2571399895977334,
                "later": 0.192798330803593,
                "learned": 0.19068023752284938,
                "online": 0.2285173323237113,
                "post": 0.192798330803593,
                "private": 0.20846888633024618,
                "read": 0.15452883659937058,
                "search": 0.20846888633024618,
                "sharing": 0.2285173323237113,
                "simple": 0.15907118779383392,
                "spend": 0.17984622905622413,
                "started": 0.16757159429029977,
                "tag": 0.24039680842143682,
                "things": 0.12220575583998115,
                "time": 0.10134848335418763,
                "walk": 0.2571399895977334,
                "worth": 0.1725830410853493
            },
            "Max term": "employment",
            "Max score": 0.2571399895977334
        }
    },
    {
        "ID": "739",
        "Question": "What is the recommended  User Account Control (UAC) setting when developing on Windows? Even on Win7 I find it annoying enough to turn it off (because it makes me more productive with it off) but sometimes I feel bad because I know I'll find more problems in my code if I leave it on. ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "account": 0.2714569276561673,
                    "annoying": 0.26692814017043226,
                    "bad": 0.1916185794037356,
                    "code": 0.11344754333455571,
                    "control": 0.21753018454930523,
                    "developing": 0.2330662139505312,
                    "feel": 0.1947739831923966,
                    "know": 0.14133925935458955,
                    "leave": 0.2553139150233609,
                    "makes": 0.18229943726413017,
                    "problems": 0.1958697757129375,
                    "productive": 0.26692814017043226,
                    "recommended": 0.31249473156402807,
                    "setting": 0.26692814017043226,
                    "turn": 0.26692814017043226,
                    "uac": 0.3241089567110994,
                    "user": 0.1958697757129375,
                    "windows": 0.2330662139505312
                },
                "Max term": "uac",
                "Max score": 0.3241089567110994
            }
        ],
        "Best Answer": "The recommendation (even from Microsoft) is to leave it ON, and also to run your IDE unelevated whenever possible. First of all, it forces the programmer to live with the same \"annoyances\" a real world user will have (if you don't know it, would you program correctly around it?). Then, disabling UAC and working as an administrator is as bad as in Unix to work as root (decades of common wisdom will tell you why that's bad). ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "administrator": 0.23351755415427994,
                "bad": 0.2953500417639257,
                "common": 0.15181395657623625,
                "correctly": 0.23351755415427994,
                "decades": 0.23351755415427994,
                "forces": 0.23351755415427994,
                "ide": 0.18326660928176283,
                "know": 0.10892617063323909,
                "leave": 0.19676321497556978,
                "live": 0.20571396988909954,
                "microsoft": 0.1852236848911607,
                "possible": 0.14689612081349504,
                "program": 0.1526955765296181,
                "programmer": 0.12911822308160525,
                "real": 0.15095129766936127,
                "recommendation": 0.2408308534215215,
                "root": 0.24978160833505125,
                "run": 0.15451916751287387,
                "tell": 0.1779103856239192,
                "uac": 0.24978160833505125,
                "unix": 0.23351755415427994,
                "user": 0.15095129766936127,
                "wisdom": 0.2408308534215215,
                "work": 0.10576156946484717,
                "working": 0.13328946815590845,
                "world": 0.15451916751287387
            },
            "Max term": "bad",
            "Max score": 0.2953500417639257
        }
    },
    {
        "ID": "745",
        "Question": "What methods do you use to stay awake and alert while working? Personally I drink coffee non stop throughout the day.  But I've also heard of this thing called exercise that should help too.  Does anyone else have tips and tricks to stay more awake and alert while working?  Redbull? Maybe a magic pill that won't require me to sleep? ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "called": 0.2043310081005981,
                    "coffee": 0.24249897144369353,
                    "day": 0.16452931139116966,
                    "drink": 0.2593885642823365,
                    "exercise": 0.2305156146183477,
                    "heard": 0.2043310081005981,
                    "help": 0.14076334444851346,
                    "magic": 0.22122060093924106,
                    "maybe": 0.1740922029149948,
                    "methods": 0.1798468361024188,
                    "non": 0.1533548122388366,
                    "personally": 0.19234765127525225,
                    "require": 0.18141890422981263,
                    "sleep": 0.2593885642823365,
                    "stay": 0.4086620162011962,
                    "stop": 0.21362602177970472,
                    "thing": 0.14799727320539266,
                    "tips": 0.21029185389380142,
                    "tricks": 0.2305156146183477,
                    "use": 0.09770256266714306,
                    "working": 0.2768319413856993
                },
                "Max term": "stay",
                "Max score": 0.4086620162011962
            }
        ],
        "Best Answer": "Caffeine is a major cause of the problem, not the solution.  It might seem to work in the short-term but it makes things worse overall by interfering with your sleep. If you don't sleep properly you will be tired and unfocused.  If you try to solve that with a high caffeine intake you won't sleep properly. Exercise, eat well, try to restrict the coffee to a couple of cups a day and don't work stupid long hours. ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "cause": 0.15056034943641233,
                "coffee": 0.1810664914927461,
                "couple": 0.14521539430367686,
                "day": 0.12284895471498436,
                "eat": 0.19367742876735705,
                "exercise": 0.1721188891018847,
                "high": 0.12998927043028952,
                "hours": 0.1379494121618014,
                "long": 0.10744327010546761,
                "major": 0.15056034943641233,
                "makes": 0.10893647196095435,
                "overall": 0.16845555421813513,
                "problem": 0.10089420079628467,
                "properly": 0.35254407131212767,
                "short": 0.13927311823942493,
                "sleep": 0.581032286302071,
                "solution": 0.1320635321207331,
                "solve": 0.1379494121618014,
                "stupid": 0.1810664914927461,
                "term": 0.1525676522242146,
                "things": 0.09204517978197667,
                "tired": 0.1867371291642979,
                "try": 0.2220918347271871,
                "work": 0.1640123063734585,
                "worse": 0.16517858949882552
            },
            "Max term": "sleep",
            "Max score": 0.581032286302071
        }
    },
    {
        "ID": "750",
        "Question": "I'm freshly out of college, and starting university somewhere next week. We've seen unit tests, but we kinda not used them much; and everyone talks about them, so I figured maybe I should do some. The problem is, I don't know what to test. Should I test the common case? The edge case? How do I know that a function is adequately covered? I always have the terrible feeling that while a test will prove that a function works for a certain case, it's utterly useless to prove that the function works, period. ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "adequately": 0.18167419732944212,
                    "case": 0.35517736780883985,
                    "certain": 0.12939994549735392,
                    "college": 0.1580154579345805,
                    "common": 0.11041917332599774,
                    "covered": 0.16145175626211342,
                    "edge": 0.16534750999771447,
                    "feeling": 0.15216092742975323,
                    "figured": 0.18167419732944212,
                    "function": 0.377890941509463,
                    "kinda": 0.18167419732944212,
                    "know": 0.15845101446715767,
                    "maybe": 0.12193313654132365,
                    "period": 0.16534750999771447,
                    "problem": 0.09464124478272683,
                    "prove": 0.33069501999542894,
                    "seen": 0.12387884508392934,
                    "starting": 0.13471914326800763,
                    "terrible": 0.1698448276320113,
                    "test": 0.3080019975097444,
                    "tests": 0.11523534457602934,
                    "unit": 0.11757057579992308,
                    "university": 0.14728715534078884,
                    "used": 0.08865273096346446,
                    "useless": 0.15216092742975323,
                    "week": 0.1394606030420186,
                    "works": 0.2438662730826473
                },
                "Max term": "function",
                "Max score": 0.377890941509463
            }
        ],
        "Best Answer": "My personal philosophy has thusfar been:  Test the common case of everything you can.  This will tell you when that code breaks after you make some change (which is, in my opinion, the single greatest benefit of automated unit testing). Test the edge cases of a few unusually complex code that you think will probably have errors. Whenever you find a bug, write a test case to cover it before fixing it Add edge-case tests to less critical code whenever someone has time to kill.  ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "add": 0.13422999752600648,
                "automated": 0.1705673213364708,
                "benefit": 0.16471168665136438,
                "breaks": 0.1705673213364708,
                "bug": 0.14113874533288037,
                "case": 0.3909967261944144,
                "cases": 0.13866698198353652,
                "change": 0.12372087668489828,
                "code": 0.21001310911420676,
                "common": 0.12155486017001839,
                "complex": 0.1467384657344813,
                "cover": 0.1675062373674662,
                "critical": 0.17773403898527834,
                "edge": 0.3640453528463561,
                "errors": 0.14830546298168792,
                "fixing": 0.1705673213364708,
                "kill": 0.19999589734006118,
                "make": 0.09075939393820831,
                "opinion": 0.14381671852480124,
                "personal": 0.1467384657344813,
                "probably": 0.11356104773298573,
                "single": 0.13126323689249073,
                "tell": 0.14244982829658157,
                "test": 0.3390637568789735,
                "testing": 0.11761723248439163,
                "tests": 0.12685673850526052,
                "think": 0.08490375925310192,
                "time": 0.07882586020239023,
                "unit": 0.1294274759626676,
                "unusually": 0.19999589734006118,
                "write": 0.09860228545974056
            },
            "Max term": "case",
            "Max score": 0.3909967261944144
        }
    },
    {
        "ID": "756",
        "Question": "I'm trying to find places where I can hone my craft outside the context of school or work. Are there places online, or books available, where I can access lists of programming puzzles or challenges? ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "access": 0.22180362048718588,
                    "available": 0.22368779160250518,
                    "books": 0.2367081397010792,
                    "challenges": 0.3110584274977606,
                    "context": 0.26570127157265094,
                    "lists": 0.28060579078654424,
                    "online": 0.2867080115577238,
                    "outside": 0.24765585159633868,
                    "places": 0.5612115815730885,
                    "programming": 0.13696075399067953,
                    "school": 0.25079675235875765,
                    "trying": 0.1995777890663007,
                    "work": 0.13660221279808266
                },
                "Max term": "places",
                "Max score": 0.5612115815730885
            }
        ],
        "Best Answer": "Moderator note: this is intended to be a canonical list; please check to see if your suggestion has already been added to the answer. If it hasn't, edit the answer to add yours, preferably with an explanation or reason why you're suggesting it. On Stack Exchange Pick a tag, follow the new questions posted, and try to solve them. If you find a good one, bookmark it for later use:  Stack Overflow Code Review Community Challenges Programming Puzzles and Code Golf Solve algorithmic and datatypes problems  Books  Algorithms for Interviews by Adnan Aziz Cracking the Coding Interview (6th Edition) by Gayle Laakmann Programming Challenges by Steven S. Skiena The Art of Computer Programming by Donald E. Knuth  Communities and Blogs  Algorithm Geeks Google Group CodeKata LessThanDot's Programmer Puzzles forum The Daily WTF's Bring Your Own Code series /r/dailyprogrammer  Game sites and ongoing contests  Codingame - fun games (solo and multiplayer) to practice your coding skills. Supports 25+ programming languages. CodeChef Code Combat - Javascript and Python solo and multiplayer games in the style of a strategy game. Hacker.org Challenge â€”Â \"The hacker.org challenges are a series of puzzles, tricks, tests, and brainteasers designed to probe the depths your hacking skills. To master this series you will need to crack cryptography, write clever code, and dissect the impenetrable; and in the process you will enrich your understanding of the world of hacking.\" Pex for fun â€”Â game from Microsoft research where you duel against other programmers Rankk â€”Â \"You start with the easy levels and progress to the intermediate and hard levels by solving the minimum number of required challenges at each level. The journey to the top is an arduous yet rewarding one. You need to be sufficiently determined and persevering to go far. Only a few are expected to reach the apex and attain Geb.\" TopCoder Google Code Jamâ€”algorithmic puzzles  Language specific  4Clojure (Clojure) â€”Â \"4Clojure is a resource to help fledgling clojurians learn the language through interactive problems. The first few problems are easy enough that even someone with no prior experience should find the learning curve forgiving. See 'Help' for more information.\"  Prolog Problems (Prolog) â€”Â \"The purpose of this problem collection is to give you the opportunity to practice your skills in logic programming. Your goal should be to find the most elegant solution of the given problems. Efficiency is important, but logical clarity is even more crucial. Some of the (easy) problems can be trivially solved using built-in predicates. However, in these cases, you learn more if you try to find your own solution.\"  Python Challenge (Python) â€”Â \"Python Challenge is a game in which each level can be solved by a bit of (Python) programming.\"  Ruby Quiz (Ruby) - \"Ruby Quiz is a weekly programming challenge for Ruby programmers in the spirit of the Perl Quiz of the Week. A new Ruby Quiz is sent to the Ruby Talk mailing list each Friday.\"  IOCCC (C) - \"A contest to write the most obscure/obfuscated C program. (Fun to try to understand the previous year's entries, or to submit a new one.)\"  Underhanded C Contest (C) - \"contest to turn out code that is malicious, but passes a rigorous inspection, and looks like an honest mistake. (Try to understand previous year's entries, and learn to find similar mistakes in other people's code)\"  CheckiO - Python programming challenges. Custom \"Missions\" can be created by members.  109 Python Problems for CCPS 109 Python problems of various levels of difficulty, with an automated pseudorandom fuzz tester to verify that the functions are correct.   Online judges / automatic assessment  Codingbat has lots of coding challenges ranging from warm-ups to Harder recursion problems. It is available in Java and Python. Cyber-dojo has a nice variety of katas and supports a good selection of languages. It is intended to support doing deliberate practice of TDD, but could be used for personal development too. LeetCode Peking University JudgeOnline for ACIP/ICPC Sphere Online Judge University of Valladolid Online Judge Codewars â€” Training with code challenges. Rosalind algorithms and bioinformatics Quizful - interactive programming quizzes in \"Duolingo style\". This site looks fun and has a good set of questions, at least in Java. Plus, as they say, it has adaptive learning algorithm, that makes learning more effective. exercism - Challenges in more than 30 languages that will be evaluated automatically.  Problem lists and contest archives  ACM/ICPC Problem Index @ HIT â€”Â List of problems from the ACM International Collegiate Programming Contest Algorithmist â€”Â Includes lists of algorithms and other puzzle sites Career Cup â€”Â Collects community-subumitted interview questions from various tech companies Educational Computing Organization of Ontairo's past computer programming puzzles Engineering Puzzles at Facebook â€”Â Puzzles provided for the purposes of evaluating potential hires Google Code Jam contest archives Ninth Annual ICFP Programming Contest Task archive Ponder this at IBM Research â€”Â Puzzles provided for the purposes of evaluating potential hires Programming Praxis Project Euler Rosetta Code TopCoder Match List International Olympiad in Informatics - yearly contents for teams of students. (previous year's problem sets)  Security oriented  Smashthestack gera's insecure programming challenges  ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "25": 0.040445153635252265,
                "30": 0.03623408597706946,
                "add": 0.02903594127297727,
                "added": 0.03507349449088977,
                "algorithm": 0.06815863148511168,
                "algorithms": 0.1036759103774396,
                "answer": 0.051154517520460296,
                "art": 0.039374207259070815,
                "automated": 0.036896243885091835,
                "available": 0.029995726883589344,
                "bit": 0.02860158736794252,
                "blogs": 0.039374207259070815,
                "books": 0.031741708649943884,
                "bring": 0.03844651131119731,
                "built": 0.03455863679247987,
                "canonical": 0.04326208177778825,
                "career": 0.030530405992395412,
                "cases": 0.029995726883589344,
                "challenge": 0.16178061454100906,
                "challenges": 0.37540632916514505,
                "check": 0.029263745275964894,
                "clojure": 0.04326208177778825,
                "code": 0.16657282914164873,
                "coding": 0.07369482173090024,
                "collection": 0.04326208177778825,
                "communities": 0.040445153635252265,
                "community": 0.07689302262239461,
                "companies": 0.031109691351587615,
                "computer": 0.05488199176352567,
                "computing": 0.04171181435168279,
                "contents": 0.04326208177778825,
                "correct": 0.031741708649943884,
                "crack": 0.04326208177778825,
                "created": 0.03407931574255584,
                "curve": 0.04326208177778825,
                "daily": 0.03507349449088977,
                "designed": 0.03507349449088977,
                "development": 0.02186677429444677,
                "donald": 0.04326208177778825,
                "easy": 0.08286437389926342,
                "edit": 0.028815370378015404,
                "effective": 0.03623408597706946,
                "elegant": 0.04326208177778825,
                "engineering": 0.03455863679247987,
                "euler": 0.04171181435168279,
                "evaluated": 0.04326208177778825,
                "expected": 0.040445153635252265,
                "experience": 0.024804529823885157,
                "explanation": 0.039374207259070815,
                "far": 0.029263745275964894,
                "follow": 0.03141851551047851,
                "fun": 0.13283902947742834,
                "functions": 0.03407931574255584,
                "game": 0.13283902947742834,
                "games": 0.06726188168921271,
                "given": 0.029995726883589344,
                "goal": 0.03455863679247987,
                "golf": 0.04171181435168279,
                "good": 0.056754038943338275,
                "google": 0.09332907405476285,
                "group": 0.03507349449088977,
                "hacker": 0.08342362870336557,
                "hacking": 0.08342362870336557,
                "hard": 0.02860158736794252,
                "harder": 0.03762822549271628,
                "help": 0.046954385484921354,
                "hit": 0.03762822549271628,
                "honest": 0.04171181435168279,
                "ibm": 0.04171181435168279,
                "important": 0.027621457966421143,
                "includes": 0.04171181435168279,
                "index": 0.04171181435168279,
                "information": 0.028815370378015404,
                "intended": 0.0865241635555765,
                "interactive": 0.0865241635555765,
                "intermediate": 0.04326208177778825,
                "interview": 0.06815863148511168,
                "interviews": 0.036896243885091835,
                "java": 0.052588241769993334,
                "javascript": 0.03507349449088977,
                "judge": 0.0865241635555765,
                "knuth": 0.04326208177778825,
                "language": 0.04072917190081489,
                "languages": 0.0710446282730853,
                "later": 0.0324370284330121,
                "learn": 0.07043157822738202,
                "learning": 0.07980883513166268,
                "level": 0.05289363426685782,
                "levels": 0.11812262177721246,
                "like": 0.015421536684600187,
                "list": 0.11614376509190907,
                "lists": 0.07525645098543256,
                "logic": 0.0324370284330121,
                "logical": 0.03455863679247987,
                "looks": 0.06562531005225065,
                "lots": 0.0324370284330121,
                "makes": 0.024333339143094077,
                "malicious": 0.04171181435168279,
                "master": 0.035629583168661313,
                "match": 0.04171181435168279,
                "members": 0.03455863679247987,
                "microsoft": 0.032080673418500884,
                "minimum": 0.04326208177778825,
                "mistake": 0.03623408597706946,
                "mistakes": 0.039374207259070815,
                "need": 0.04072917190081489,
                "new": 0.061483343005207365,
                "nice": 0.03141851551047851,
                "note": 0.0324370284330121,
                "number": 0.02709355350430617,
                "obscure": 0.04171181435168279,
                "ongoing": 0.04326208177778825,
                "online": 0.1153395339335919,
                "opportunity": 0.03623408597706946,
                "org": 0.07874841451814163,
                "organization": 0.03455863679247987,
                "oriented": 0.0324370284330121,
                "overflow": 0.03407931574255584,
                "passes": 0.04326208177778825,
                "past": 0.032080673418500884,
                "people": 0.01934899763310804,
                "perl": 0.03844651131119731,
                "personal": 0.031741708649943884,
                "pick": 0.03281265502612533,
                "plus": 0.03762822549271628,
                "posted": 0.04171181435168279,
                "potential": 0.07014698898177954,
                "practice": 0.09425554653143553,
                "preferably": 0.04326208177778825,
                "previous": 0.09425554653143553,
                "prior": 0.040445153635252265,
                "problem": 0.09014768924873559,
                "problems": 0.26144708682775986,
                "process": 0.02644681713342891,
                "program": 0.02644681713342891,
                "programmer": 0.02236322827446241,
                "programmers": 0.046363028185886855,
                "programming": 0.25712321076893474,
                "progress": 0.03762822549271628,
                "project": 0.0204292133897589,
                "prolog": 0.08089030727050453,
                "provided": 0.07525645098543256,
                "purpose": 0.03281265502612533,
                "purposes": 0.07874841451814163,
                "python": 0.26337370748368405,
                "questions": 0.0834201988090937,
                "reach": 0.039374207259070815,
                "reason": 0.026926138183352932,
                "required": 0.031741708649943884,
                "research": 0.07246817195413892,
                "resource": 0.04171181435168279,
                "review": 0.033630940844606355,
                "rewarding": 0.040445153635252265,
                "ruby": 0.2073518207548792,
                "say": 0.022536922312183898,
                "security": 0.031741708649943884,
                "sent": 0.04326208177778825,
                "series": 0.11812262177721246,
                "set": 0.027265102951909932,
                "sets": 0.04171181435168279,
                "similar": 0.028192798899783447,
                "site": 0.031109691351587615,
                "sites": 0.06562531005225065,
                "skills": 0.08998718065076804,
                "solo": 0.07525645098543256,
                "solution": 0.058998545807147404,
                "solve": 0.061628025404140745,
                "solved": 0.08089030727050453,
                "solving": 0.035629583168661313,
                "specific": 0.028192798899783447,
                "spirit": 0.04326208177778825,
                "stack": 0.06562531005225065,
                "start": 0.024109210040816943,
                "strategy": 0.04171181435168279,
                "students": 0.03844651131119731,
                "style": 0.06416134683700177,
                "submit": 0.04171181435168279,
                "sufficiently": 0.04171181435168279,
                "suggesting": 0.040445153635252265,
                "suggestion": 0.040445153635252265,
                "support": 0.02860158736794252,
                "supports": 0.07874841451814163,
                "tag": 0.040445153635252265,
                "talk": 0.03455863679247987,
                "task": 0.02860158736794252,
                "tdd": 0.033630940844606355,
                "teams": 0.036896243885091835,
                "tech": 0.035629583168661313,
                "tester": 0.039374207259070815,
                "tests": 0.027440995881762836,
                "training": 0.03762822549271628,
                "tricks": 0.03844651131119731,
                "try": 0.09921811929554063,
                "turn": 0.035629583168661313,
                "understand": 0.0473630855153902,
                "understanding": 0.03455863679247987,
                "university": 0.07014698898177954,
                "ups": 0.04326208177778825,
                "use": 0.016295306879468535,
                "used": 0.021110877346059487,
                "using": 0.02030055416413058,
                "variety": 0.04171181435168279,
                "various": 0.06815863148511168,
                "verify": 0.04326208177778825,
                "week": 0.033209757369357086,
                "weekly": 0.04326208177778825,
                "world": 0.026762662414323346,
                "write": 0.042658276432370065,
                "year": 0.09425554653143553
            },
            "Max term": "challenges",
            "Max score": 0.37540632916514505
        }
    },
    {
        "ID": "775",
        "Question": "On any team, you are going to have the need for more grizzled and grey developers and some young pups. Some reasons include:  Money. There are often tasks that don't require the same level of experience to deliver, so it makes sense not to pay top dollar to have those tasks fulfilled. Energy. There's an energy and enthusiasm that new people can bring to a team that stops it from getting too stale and set in its ways. There's also calmness and wisdom that the more senior people can bring. Knowledge transfer and career growth. Both in terms of the project and skills, it's useful and often fun to teach people and to learn new stuff. It's satisfying to help \"bring on\" new team members.  I realise there are some cutting edge projects where it may be important for there to be more senior people than junior, but in general, is there an ideal mix of experiences on a team, or is it totally dependent on the project? ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "bring": 0.3612293667954661,
                    "career": 0.09561751160700262,
                    "cutting": 0.13549156888254688,
                    "deliver": 0.12666929316724468,
                    "dependent": 0.12666929316724468,
                    "developers": 0.07730634845995434,
                    "edge": 0.12331521960593948,
                    "energy": 0.27098313776509375,
                    "experience": 0.07768476511358356,
                    "experiences": 0.10984591123407032,
                    "fun": 0.10400891365549436,
                    "general": 0.09561751160700262,
                    "getting": 0.08234998281854937,
                    "going": 0.07003890611988833,
                    "help": 0.07352770710324714,
                    "ideal": 0.12331521960593948,
                    "important": 0.08650704082888577,
                    "include": 0.10276523750121759,
                    "junior": 0.13549156888254688,
                    "knowledge": 0.08485370837578181,
                    "learn": 0.07352770710324714,
                    "level": 0.08282820886344548,
                    "makes": 0.07620905331332534,
                    "members": 0.10823343965521462,
                    "mix": 0.13549156888254688,
                    "money": 0.09561751160700262,
                    "need": 0.06377940188446568,
                    "new": 0.192558338886881,
                    "pay": 0.11348074235712896,
                    "people": 0.24239481207402253,
                    "project": 0.1279636143000365,
                    "projects": 0.07886118183519054,
                    "realise": 0.13549156888254688,
                    "reasons": 0.09561751160700262,
                    "require": 0.09476413128334549,
                    "satisfying": 0.13549156888254688,
                    "senior": 0.22696148471425792,
                    "sense": 0.09743176276927422,
                    "set": 0.08539098034332503,
                    "skills": 0.09394296178591541,
                    "stale": 0.13063632019549962,
                    "stuff": 0.08539098034332503,
                    "tasks": 0.19882232787982485,
                    "teach": 0.12666929316724468,
                    "team": 0.3239012417115294,
                    "terms": 0.10276523750121759,
                    "totally": 0.11784701745194245,
                    "transfer": 0.12666929316724468,
                    "useful": 0.08768345755049274,
                    "ways": 0.09093703019804876,
                    "wisdom": 0.13063632019549962,
                    "young": 0.13549156888254688
                },
                "Max term": "bring",
                "Max score": 0.3612293667954661
            }
        ],
        "Best Answer": "I really like what Eric Brechner has to say on this subject  Think of your team as a river instead of a lake. A lake stagnates. Thereâ€™s no energy or impetus to change. The same is true of groups that stagnate. They cultivate mediocrity and complacency; they abhor risk. A river is always running and changing with lots of great energy. You want a river. A river depends on the flow of water, and your team depends on the flow of people and information. You can think of the people divided into three groups: new blood, new leaders, and elders ready for a new challenge. Hereâ€™s how those groups should balance and flow:  The largest group should be the new blood. Not all of them will become technical or organizational leaders.  Sometimes youâ€™ll have more new leaders than elders, sometimes the reverse, but ideally you should maintain a balance.  For flow, you want a steady stream of new blood becoming your new leaders, and new leaders becoming elders.  The key to flow is new blood coming in and elders moving out. For this to work, you WANT your elders to transfer before they clog the stream and disrupt the flow of opportunitiesfor others.   Not all technologies flow at the same rate. Central engines, like the Windows kernel, flow slowly, while web-based services, like MSN Search, flow quickly. You need to adjust for your situation, but even the most conservative technologies do change and flow. How do you successfully encourage and maintain a healthy flow?  Keep a constant supply of new people.  Instill information sharing as a way of life.  Shape the organization and roles to create growth opportunities.  Find new challenges for your elders.    ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "based": 0.04523293430491206,
                "challenge": 0.06623303446036305,
                "challenges": 0.06830731964265019,
                "change": 0.0876531392574044,
                "changing": 0.05659326707525345,
                "coming": 0.05933698476712513,
                "constant": 0.06296005527682763,
                "create": 0.04553634082870901,
                "depends": 0.10876868087096361,
                "encourage": 0.06162002939133709,
                "energy": 0.14169207905877804,
                "eric": 0.06830731964265019,
                "flow": 0.7793064348232792,
                "great": 0.0438265696287022,
                "group": 0.05743639868969845,
                "ideally": 0.06296005527682763,
                "information": 0.09437617354340976,
                "instead": 0.04584806088621433,
                "kernel": 0.07084603952938902,
                "key": 0.05438434043548181,
                "life": 0.05507407102426626,
                "like": 0.07576298361042236,
                "lots": 0.05311891855747345,
                "maintain": 0.11669410041560334,
                "moving": 0.06162002939133709,
                "need": 0.03334907156462699,
                "new": 0.36917906605074874,
                "opportunities": 0.06623303446036305,
                "organization": 0.05659326707525345,
                "organizational": 0.06830731964265019,
                "people": 0.09505782857678106,
                "quickly": 0.050945269683560425,
                "rate": 0.05933698476712513,
                "ready": 0.06162002939133709,
                "really": 0.033037351507121664,
                "risk": 0.055808330321062846,
                "roles": 0.06830731964265019,
                "running": 0.0519802620062275,
                "say": 0.03690649232278756,
                "search": 0.05743639868969845,
                "services": 0.05834705020780167,
                "sharing": 0.06296005527682763,
                "situation": 0.0519802620062275,
                "slowly": 0.06296005527682763,
                "subject": 0.06162002939133709,
                "successfully": 0.06447925132781483,
                "team": 0.08468098924223577,
                "technical": 0.04523293430491206,
                "technologies": 0.12324005878267418,
                "think": 0.06015218476218316,
                "transfer": 0.06623303446036305,
                "true": 0.05507407102426626,
                "want": 0.10036471662176975,
                "water": 0.07084603952938902,
                "way": 0.031152545002784457,
                "web": 0.041885351113894465,
                "windows": 0.050945269683560425,
                "work": 0.029997358015831706
            },
            "Max term": "flow",
            "Max score": 0.7793064348232792
        }
    },
    {
        "ID": "778",
        "Question": "What question have you found especially valuable in interviewing software developers?  What is it about the question that has made it particularly useful? I'm looking for a particular question you like to ask, not just an interviewing approach like \"make them write code\". ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "approach": 0.20857176864484755,
                    "ask": 0.18447848004766607,
                    "code": 0.10438254291323541,
                    "developers": 0.1701479410765336,
                    "especially": 0.21879968723603369,
                    "interviewing": 0.5300335116157316,
                    "like": 0.21260527846824062,
                    "looking": 0.1763073399359474,
                    "make": 0.13533007114402174,
                    "particular": 0.1943365950966826,
                    "particularly": 0.24176611629553846,
                    "question": 0.4589535707668374,
                    "software": 0.14082119993768327,
                    "useful": 0.1929875109340637,
                    "valuable": 0.2714114834982802,
                    "write": 0.14702449771000808
                },
                "Max term": "interviewing",
                "Max score": 0.5300335116157316
            }
        ],
        "Best Answer": "Take a look at this sample code and tell me how you'd improve it. ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "code": 0.21835336253624973,
                "improve": 0.5137586522246709,
                "look": 0.3594405417370524,
                "sample": 0.6014610224801964,
                "tell": 0.44432082072107965
            },
            "Max term": "sample",
            "Max score": 0.6014610224801964
        }
    },
    {
        "ID": "779",
        "Question": "It doesn't have to be programming or software development related, but just asked during an interview for an IT related job. I know some \"left field\" questions are meant to see how the candidate copes with unexpected and novel situations, but here I'm looking for a question that appeared to be completely unrelated to the job they were interviewing you for, or something that made you think \"what useful information could they possibly get from my answer to that question?\". ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "answer": 0.14770455436988497,
                    "asked": 0.1651695655134885,
                    "candidate": 0.2172969484428515,
                    "completely": 0.18526072772635346,
                    "development": 0.12627710353738678,
                    "field": 0.2092460170346646,
                    "information": 0.16640412800240406,
                    "interview": 0.19680256559829723,
                    "interviewing": 0.22202241739552395,
                    "job": 0.2771899666116883,
                    "know": 0.10894795474896553,
                    "left": 0.2172969484428515,
                    "looking": 0.14770455436988497,
                    "meant": 0.2130698724229134,
                    "possibly": 0.20575511057090776,
                    "programming": 0.10606036965661181,
                    "question": 0.25633091498520394,
                    "questions": 0.16057940905044718,
                    "related": 0.3746372412067061,
                    "situations": 0.20575511057090776,
                    "software": 0.11797542059329243,
                    "think": 0.10606036965661181,
                    "unexpected": 0.22202241739552395,
                    "unrelated": 0.24983156209208388,
                    "useful": 0.16167865904973164
                },
                "Max term": "related",
                "Max score": 0.3746372412067061
            }
        ],
        "Best Answer": " Where do you see yourself in 5 years?  Do they really think people are dumb enough to say that they want to do something completely different? Or don't want to work for them? I guess it can be useful as an indicator of who not to hire but it's so stupid easy to fake that you can't use it as an indicator of who to hire in any way if they answer correctly. ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "answer": 0.1777087828941165,
                "completely": 0.22289399661897658,
                "correctly": 0.2810097475207917,
                "different": 0.16173845301752146,
                "easy": 0.19191171825676645,
                "fake": 0.30058154277856275,
                "guess": 0.24368788212405906,
                "hire": 0.5228759045260414,
                "people": 0.1344353142701611,
                "really": 0.14016899393802917,
                "say": 0.15658476429478874,
                "stupid": 0.2810097475207917,
                "think": 0.12760513232230708,
                "use": 0.1132185110055328,
                "useful": 0.19452154229266386,
                "want": 0.2838811368341941,
                "way": 0.13217224421601076,
                "work": 0.12727108264025414,
                "years": 0.17677147215370226
            },
            "Max term": "hire",
            "Max score": 0.5228759045260414
        }
    },
    {
        "ID": "811",
        "Question": "Literate programming has good ideals. Why do you think that this isn't mainstream? It is because it has failed to deliver? ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "deliver": 0.5449768073902389,
                    "failed": 0.5180461713318036,
                    "good": 0.2549101039296775,
                    "mainstream": 0.4971571471461307,
                    "programming": 0.2474712647271232,
                    "think": 0.2474712647271232
                },
                "Max term": "deliver",
                "Max score": 0.5449768073902389
            }
        ],
        "Best Answer": "I first saw it in a book of Knuth's writings, and thought it looked neat.  Then I tried to use the literary programming display to comprehend what was going on in the program, and found it harder than it looked.  It may have been that I was too used to going through program listings, but it seemed confusing. Then I looked at the source code, and that turned me off then and there.  I'd have to learn to write programs in an entirely new way, with less correspondence between the program text and what the compiler saw, and saw no corresponding benefit. In addition, people can write long and convincing arguments that the code is doing X when it's actually doing Y, and I've run into my share of misleading comments.  I developed a fondness for reading the code to see what it's doing fairly early.  Literate programming is the antithesis of that. ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "actually": 0.08884889139974537,
                "addition": 0.1436108417123655,
                "arguments": 0.13534667797880653,
                "benefit": 0.13308865366990913,
                "book": 0.1038676380787568,
                "code": 0.1696926460610072,
                "comments": 0.11983226449440221,
                "compiler": 0.13308865366990913,
                "confusing": 0.15107645293821154,
                "convincing": 0.15580786303100702,
                "developed": 0.13534667797880653,
                "display": 0.15107645293821154,
                "early": 0.1240497784122166,
                "entirely": 0.13782006376270461,
                "fairly": 0.12729787572024825,
                "going": 0.16706858054847534,
                "harder": 0.14055426489575518,
                "knuth": 0.1615986409806679,
                "learn": 0.08769532776323102,
                "long": 0.08964744390745828,
                "looked": 0.42166279468726553,
                "new": 0.07655375688748402,
                "people": 0.07227511005847563,
                "program": 0.2963636652284685,
                "programming": 0.13720613564509115,
                "programs": 0.11204427758499642,
                "reading": 0.10845915075026921,
                "run": 0.0999676783330272,
                "saw": 0.42166279468726553,
                "share": 0.12562304244406308,
                "source": 0.09605368727643891,
                "text": 0.12729787572024825,
                "thought": 0.11204427758499642,
                "tried": 0.12116337209915054,
                "turned": 0.13782006376270461,
                "use": 0.06086853285541705,
                "used": 0.07885633212371947,
                "way": 0.07105843839655607,
                "write": 0.1593432219340852
            },
            "Max term": "looked",
            "Max score": 0.42166279468726553
        }
    },
    {
        "ID": "812",
        "Question": "I originally tried asking this on StackOverflow, but it was too subjective :-(. I am interested in methods of defining the power of programming languages. Turing completeness is one, but it is almost universally satisfied. What would be nice is to define a measure of power that discriminates among programming languages that are actually in used. For example, can anyone propose a non-subjective method that would discriminate between assembly and Java? Turing completeness means that a language is maximally powerful in what it can output (which pretty much means it can do anything non-time based in the real world). So if we want to define a stronger measure of power, we need to take another approach. Shortness was suggested in the original question, but this is not easy to define at all. Does anyone have any other suggestions? ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "actually": 0.08501419891967049,
                    "approach": 0.10814560430888495,
                    "asking": 0.10911948893756653,
                    "assembly": 0.14455603688268598,
                    "based": 0.0987225449198774,
                    "define": 0.37055066867898984,
                    "defining": 0.1490832406830094,
                    "easy": 0.0987225449198774,
                    "example": 0.08251113002874845,
                    "interested": 0.11466033858415561,
                    "java": 0.09397847620330034,
                    "language": 0.07278557684058024,
                    "languages": 0.16928159053086145,
                    "means": 0.2001301626738393,
                    "measure": 0.2981664813660188,
                    "method": 0.10814560430888495,
                    "methods": 0.10720847893943404,
                    "need": 0.07278557684058024,
                    "nice": 0.1122937034160099,
                    "non": 0.18283264264716254,
                    "original": 0.1202011882307447,
                    "originally": 0.1295051544654368,
                    "output": 0.12535705535831182,
                    "power": 0.3760711660749355,
                    "powerful": 0.1374126392801716,
                    "pretty": 0.09683574835620921,
                    "programming": 0.13128435847613174,
                    "propose": 0.14455603688268598,
                    "question": 0.07932331331765842,
                    "real": 0.09344445830811028,
                    "satisfied": 0.1490832406830094,
                    "stackoverflow": 0.12734458583325908,
                    "subjective": 0.309248180659197,
                    "suggested": 0.1490832406830094,
                    "suggestions": 0.1318717896335825,
                    "time": 0.060943134786001614,
                    "tried": 0.11593399596930432,
                    "universally": 0.1490832406830094,
                    "used": 0.07545291561466462,
                    "want": 0.07301656339068151,
                    "world": 0.0956531022216667
                },
                "Max term": "power",
                "Max score": 0.3760711660749355
            }
        ],
        "Best Answer": "If I understand your question correctly, you are nonetheless looking for something that is relatively measurable and not just a subjective judgement call. If so, I would personally favour the amount of time taken to solve any particular problem (averaged over all problems and all programmers). In this measure, you might need to consider not just the language itself but also the framework/API used with it. Succinct syntax is a very small factor: a much more important one is that the most commonly required functionality is easily accessible. If you are looking for something more subjective, Iâ€™d say how fun it is. Programmers tend to be people who want problems solved, so a programming language that is fun for programmers to use is inevitably going to be the one that will solve the most problems. This measure takes into account that different people have different preferences on how to use things, so the â€œbestâ€ programming language will be the one that is most appealing to the widest range of programmers. However, you might need to consider not just the programming language and API here, but also the environment (IDE), which is of course what the programmer actually interacts with. ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "accessible": 0.13652391159789917,
                "account": 0.11434537931329786,
                "actually": 0.07506250127735478,
                "api": 0.2632633392164171,
                "best": 0.07196946704809333,
                "commonly": 0.1276344168508695,
                "consider": 0.1767030776298528,
                "correctly": 0.1276344168508695,
                "course": 0.0963460443296045,
                "different": 0.1469229684406283,
                "easily": 0.10236285033700673,
                "environment": 0.08960469083569962,
                "factor": 0.12132721995344248,
                "framework": 0.08960469083569962,
                "fun": 0.20960276496031263,
                "functionality": 0.10016860140826903,
                "going": 0.07057254932086705,
                "ide": 0.10016860140826903,
                "important": 0.08716615869255002,
                "inevitably": 0.1276344168508695,
                "language": 0.2570614096937601,
                "looking": 0.16143039217733984,
                "measure": 0.2632633392164171,
                "need": 0.12853070484688006,
                "particular": 0.08896916252115136,
                "people": 0.12212083810200094,
                "personally": 0.10123828631929514,
                "preferences": 0.1276344168508695,
                "problem": 0.07112068266250263,
                "problems": 0.24751776268839212,
                "programmer": 0.07057254932086705,
                "programmers": 0.29261938868187887,
                "programming": 0.1738744665780391,
                "question": 0.0700377864273808,
                "range": 0.12132721995344248,
                "required": 0.10016860140826903,
                "say": 0.07112068266250263,
                "small": 0.08159228071269824,
                "solve": 0.19448206712391222,
                "solved": 0.1276344168508695,
                "subjective": 0.27304782319579834,
                "syntax": 0.10754548321672215,
                "taken": 0.11243772520641279,
                "takes": 0.08960469083569962,
                "tend": 0.10354823045938309,
                "things": 0.064882976129665,
                "time": 0.053809177653284905,
                "understand": 0.07473280797165387,
                "use": 0.10284752579869665,
                "used": 0.06662045454380501,
                "want": 0.06446929986318961
            },
            "Max term": "programmers",
            "Max score": 0.29261938868187887
        }
    },
    {
        "ID": "827",
        "Question": "For decades, the accepted degree to get to become a software developer was \"Compter Science.\" We've had a few questions already about whether that degree really prepares students to develop software. Some schools have, in the last 8 years or so, started offering multiple distinct majors in programming.  Using the curriculum from my school:  Computer Science, which starts out with some intro programming courses in the first year, and then focuses on theoretical computer science, algorithms, and a bit of OS stuff.  Most classes involve several smaller projects and homeworks, done solo or in pairs. Software Engineering, which starts out with the same intro programming courses, does a few classes of theory, and then goes into software development practices (testing, process methodologies, sofware metrics, requirements gathering) and software design (distributed system design, info system design, real-time/embedded design, subsystem design, etc)  Different schools do it differently, so the above is just a real-world example I'm familiar with.  What I ask is: Is there a need for distinct majors in programming? ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "accepted": 0.10402738934958423,
                    "algorithms": 0.09350769790015084,
                    "ask": 0.07241358989561848,
                    "bit": 0.07738929654911382,
                    "classes": 0.19281086341741716,
                    "computer": 0.14849800751107897,
                    "courses": 0.2341144239977273,
                    "decades": 0.109435254357988,
                    "degree": 0.18980156809138907,
                    "design": 0.33557667440051503,
                    "develop": 0.0868029007181021,
                    "developer": 0.06464647276493299,
                    "development": 0.05916644620718524,
                    "different": 0.06298674299235954,
                    "differently": 0.10653752054943026,
                    "distinct": 0.2341144239977273,
                    "distributed": 0.10402738934958423,
                    "embedded": 0.11705721199886365,
                    "engineering": 0.09350769790015084,
                    "example": 0.06246454106506168,
                    "familiar": 0.09221076572650586,
                    "gathering": 0.11705721199886365,
                    "goes": 0.08417564726697213,
                    "info": 0.10653752054943026,
                    "involve": 0.109435254357988,
                    "methodologies": 0.09640543170870858,
                    "metrics": 0.11705721199886365,
                    "multiple": 0.08260823473589937,
                    "need": 0.05510187112839847,
                    "offering": 0.11705721199886365,
                    "os": 0.09490078404569453,
                    "pairs": 0.109435254357988,
                    "practices": 0.08985794139041083,
                    "process": 0.07155898543635081,
                    "programming": 0.19877602447997883,
                    "projects": 0.06813169377767789,
                    "questions": 0.07523860384358554,
                    "real": 0.14148309934079653,
                    "really": 0.05458682355343046,
                    "requirements": 0.0779677440510254,
                    "school": 0.09099756670030482,
                    "schools": 0.2341144239977273,
                    "science": 0.2847023521370836,
                    "smaller": 0.109435254357988,
                    "software": 0.2763836903432169,
                    "solo": 0.10181329671711235,
                    "started": 0.0762832092686687,
                    "starts": 0.21307504109886052,
                    "students": 0.10402738934958423,
                    "stuff": 0.07377307806882268,
                    "testing": 0.06884113874713572,
                    "theoretical": 0.109435254357988,
                    "theory": 0.10181329671711235,
                    "time": 0.04613662355790583,
                    "using": 0.05492861588794619,
                    "world": 0.07241358989561848,
                    "year": 0.08501125418998946,
                    "years": 0.06884113874713572
                },
                "Max term": "design",
                "Max score": 0.33557667440051503
            }
        ],
        "Best Answer": "Yes, they should be. The relationship between computer science and software engineering is the same as the relationship between physics and mechanical engineering. One provides the theoretical background while the other takes those theories, along with good engineering principles, and applies them to the design and implementation of software. You need both in order to produce new and better software. A good computer science education trains people to produce new and better algorithms, data structures, programming languages and paradigms, compilers, and a number of other things that can be used to enhance software systems. A good software engineering education, on the other hand, trains you to take these tools and knowledge obtained through a scientific study of computation, along with a knowledge of the software development lifecycle and process models to actually build the system that a customer wants and needs. ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "actually": 0.07416687544465678,
                "algorithms": 0.10775684391190969,
                "background": 0.10775684391190969,
                "better": 0.13489622780524108,
                "build": 0.08918224419983176,
                "computer": 0.17112683742559676,
                "customer": 0.09897341625563222,
                "data": 0.08246348265779553,
                "design": 0.07734268757737368,
                "development": 0.06818250958951023,
                "education": 0.2522230337636154,
                "engineering": 0.43102737564763877,
                "good": 0.17696404382242703,
                "hand": 0.09608077937145772,
                "implementation": 0.10936221512425084,
                "knowledge": 0.16896012614813527,
                "languages": 0.07384111595193076,
                "models": 0.11987957578291017,
                "need": 0.06349855530372776,
                "needs": 0.09700273119135841,
                "new": 0.12780695093536834,
                "number": 0.08448006307406764,
                "order": 0.10486420702773518,
                "paradigms": 0.1173280892255302,
                "people": 0.060331862345231066,
                "physics": 0.13006107548070045,
                "principles": 0.11504570672552547,
                "process": 0.08246348265779553,
                "produce": 0.20710184042797203,
                "programming": 0.05726661420483025,
                "provides": 0.1173280892255302,
                "relationship": 0.2601221509614009,
                "science": 0.2187244302485017,
                "scientific": 0.13489494453808518,
                "software": 0.382200415780702,
                "structures": 0.11987957578291017,
                "study": 0.11987957578291017,
                "systems": 0.09352929281407775,
                "takes": 0.08853555145881102,
                "theoretical": 0.1261115168818077,
                "things": 0.06410880968789752,
                "tools": 0.08918224419983176,
                "used": 0.06582555697098039,
                "wants": 0.10486420702773518,
                "yes": 0.08790760609934999
            },
            "Max term": "engineering",
            "Max score": 0.43102737564763877
        }
    },
    {
        "ID": "843",
        "Question": "I was instructed by my project manager that frequent deployment in PROD or to test server should be avoided. But I don't understand why? We roll our testing copy to PROD on every sprint end but suddenly client would ask a simple change to the existing application which would require a re-deployment. When every thing was well tested and QA approved. why should we avoid frequent deployment? How it was done universally? ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "application": 0.1175047290937086,
                    "ask": 0.12678085088286017,
                    "avoid": 0.1420966164829715,
                    "avoided": 0.19159794016685588,
                    "change": 0.12678085088286017,
                    "client": 0.1420966164829715,
                    "copy": 0.1687854818325901,
                    "deployment": 0.5463897435221982,
                    "end": 0.1142108403031115,
                    "existing": 0.1473737208651763,
                    "frequent": 0.39519680318083533,
                    "manager": 0.1554410491577808,
                    "project": 0.09677785477109223,
                    "qa": 0.18652462232126168,
                    "require": 0.14333870428737508,
                    "roll": 0.2049423728416652,
                    "server": 0.14597302349832433,
                    "simple": 0.12678085088286017,
                    "sprint": 0.19159794016685588,
                    "suddenly": 0.1821299145073994,
                    "test": 0.11581659391281099,
                    "tested": 0.16615116262164084,
                    "testing": 0.12052624595310926,
                    "thing": 0.11693234213592817,
                    "understand": 0.11218488260093873,
                    "universally": 0.19759840159041767
                },
                "Max term": "deployment",
                "Max score": 0.5463897435221982
            }
        ],
        "Best Answer": "If you are talking about a hosted web application, the users don't get a say-so in when they get upgrades. That is, they are forced to upgrade each time you do a push to production. If your changes dramatically change the system rules or UI, you should definitely consider bundling your releases and doing it less frequently. It is very frustrating to users to have to continually re-learn how to use the tools they rely on and violates the UI principle of making them feel they are in control of their computer/software. ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "application": 0.13187436687430676,
                "change": 0.1422848643702652,
                "changes": 0.1531981759714821,
                "computer": 0.14589125389602417,
                "consider": 0.14884772365488558,
                "control": 0.1543708507744524,
                "definitely": 0.16875618128787462,
                "dramatically": 0.22176268398806548,
                "feel": 0.1382218543897024,
                "forced": 0.22176268398806548,
                "frequently": 0.1837325028696543,
                "frustrating": 0.2300047485123709,
                "learn": 0.12481752127052154,
                "making": 0.1543708507744524,
                "principle": 0.21502842693059118,
                "production": 0.18118417155932282,
                "push": 0.18942623608362824,
                "releases": 0.21502842693059118,
                "rely": 0.2300047485123709,
                "rules": 0.18942623608362824,
                "say": 0.11981853243405584,
                "software": 0.10861280583195458,
                "talking": 0.1705583022941396,
                "time": 0.09065347036241621,
                "tools": 0.15206158925518415,
                "ui": 0.3852802033678536,
                "use": 0.08663471120033749,
                "users": 0.29769544730977116,
                "web": 0.13598261403599357
            },
            "Max term": "ui",
            "Max score": 0.3852802033678536
        }
    },
    {
        "ID": "866",
        "Question": "I know this is obviously not true for some games, minesweeper, card games, etc.  But what about any game involving simulating the real world environment.  Obviously these games have some form of a physics engineer powering the graphics.  For someone like me who personally did not enjoy physics but loves video games, do I have a chance at ever getting involved in the development cycle of a video game such as this while disliking physics?  ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "card": 0.16784689030296965,
                    "chance": 0.13048028681847898,
                    "cycle": 0.15691785939409789,
                    "development": 0.08483803634628152,
                    "engineer": 0.15691785939409789,
                    "enjoy": 0.16784689030296965,
                    "environment": 0.11016289042191944,
                    "form": 0.12069842081270563,
                    "game": 0.2576923843283296,
                    "games": 0.5219211472739159,
                    "getting": 0.10201511907046028,
                    "graphics": 0.14916358856072431,
                    "involved": 0.12189658725755016,
                    "know": 0.07319561730451968,
                    "like": 0.05983200229472737,
                    "obviously": 0.2644397558315315,
                    "personally": 0.1244656070823922,
                    "physics": 0.48549663170064866,
                    "real": 0.10143543421745499,
                    "true": 0.13048028681847898,
                    "video": 0.29832717712144863,
                    "world": 0.10383295204205016
                },
                "Max term": "games",
                "Max score": 0.5219211472739159
            }
        ],
        "Best Answer": "There are many aspects to game programing and you don't need to be an expert at all of them.  If you're on a bigger team you may not even be doing the core game programming but just network communication for example.  For core game programming I would think that above a sound physics understanding you would need a strong mathematical background.  Having a strong mathematical background will allow you to do things like modelling transformations, clippings, keyframe animation, ray tracing, image processing, texture mapping, etc. Having a strong physics background may help you with coming up with new computer graphics methods, but it is not required if you want to become a game programmer.  ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "allow": 0.11300674413407233,
                "aspects": 0.1308264621831021,
                "background": 0.35279020399290395,
                "bigger": 0.1280419848655126,
                "coming": 0.1232979824995914,
                "communication": 0.12555118502847473,
                "computer": 0.09337670148881724,
                "core": 0.2465959649991828,
                "example": 0.07855637799359791,
                "expert": 0.1280419848655126,
                "game": 0.4520269765362893,
                "graphics": 0.1308264621831021,
                "help": 0.07988860272979811,
                "image": 0.14193769256977248,
                "like": 0.05247667517977297,
                "mathematical": 0.28387538513954497,
                "methods": 0.10206998489477125,
                "need": 0.13859393962435143,
                "network": 0.13762747729495625,
                "new": 0.06973886554104407,
                "physics": 0.28387538513954497,
                "processing": 0.14193769256977248,
                "programmer": 0.07609798492402986,
                "programming": 0.12499190940064317,
                "required": 0.10801124223485771,
                "sound": 0.14193769256977248,
                "strong": 0.3637229092609754,
                "team": 0.08798049960420276,
                "things": 0.06996294999763479,
                "think": 0.062495954700321585,
                "understanding": 0.11759673466430132,
                "want": 0.0695168851949231
            },
            "Max term": "game",
            "Max score": 0.4520269765362893
        }
    },
    {
        "ID": "870",
        "Question": "One per answer please. I'll add my favourite as an answer. ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "add": 0.40266589231428795,
                    "answer": 0.7094028483399994,
                    "favourite": 0.5784529176465737
                },
                "Max term": "answer",
                "Max score": 0.7094028483399994
            }
        ],
        "Best Answer": " Code Complete by Steve McConnell. I don't even think it needs explanation. It's the definitive book on software construction. Incredibly well written and covers all aspects of the practical (programming) side of creating software.  ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "aspects": 0.29757925451535244,
                "book": 0.21522646855349153,
                "code": 0.11720798260415291,
                "complete": 0.2321694671439528,
                "covers": 0.3228529766663499,
                "creating": 0.25704633537791993,
                "explanation": 0.3047596997409433,
                "incredibly": 0.3130489154169877,
                "needs": 0.240791646494904,
                "practical": 0.3047596997409433,
                "programming": 0.14215395952478058,
                "software": 0.31624768456372,
                "steve": 0.3047596997409433,
                "think": 0.14215395952478058,
                "written": 0.228326871281914
            },
            "Max term": "covers",
            "Max score": 0.3228529766663499
        }
    },
    {
        "ID": "874",
        "Question": "In my current job it feels like we have a lot requirement changes. We are an \"Agile\" shop, so I get that we are supposed to adjust and what not, but sometime the change is large and nothing trivial.  My question is, how do you effectively communicate the cost of the change? Because of being agile, if a change is big enough something will get dropped from the current sprint, but it usually just get added next time around. Since our model is SaaS, the end customer is effectively the business itself, and they know they will get the cut feature n weeks later. I guess what I am trying to get at is the removal of a feature really isn't anything to use for communication as it was only delayed by n weeks. What other ways do you have to get the business to understand what a change costs? ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "added": 0.13433943183423827,
                    "agile": 0.23831433516248834,
                    "big": 0.10313321092032586,
                    "business": 0.21596961699939038,
                    "change": 0.4100282467201077,
                    "changes": 0.11036939834099563,
                    "communicate": 0.15976570119740402,
                    "communication": 0.14132097506361083,
                    "cost": 0.12034003409181857,
                    "costs": 0.14132097506361083,
                    "current": 0.2431558741082381,
                    "customer": 0.12157793705411905,
                    "cut": 0.15976570119740402,
                    "dropped": 0.1657035767423752,
                    "effectively": 0.2882492609873883,
                    "end": 0.09234373779598533,
                    "feature": 0.20754889907445268,
                    "feels": 0.15081213631225274,
                    "guess": 0.13433943183423827,
                    "job": 0.09192467220720246,
                    "know": 0.07226094905501156,
                    "large": 0.11208677580547712,
                    "later": 0.12424116938828958,
                    "like": 0.05906798014546782,
                    "lot": 0.08500717260663489,
                    "model": 0.12424116938828958,
                    "question": 0.08500717260663489,
                    "really": 0.0772718891160347,
                    "requirement": 0.14412463049369414,
                    "shop": 0.15976570119740402,
                    "sprint": 0.15491410361803468,
                    "supposed": 0.13236741017845957,
                    "time": 0.06530997459973452,
                    "trivial": 0.14412463049369414,
                    "trying": 0.10250706168002692,
                    "understand": 0.09070567518880475,
                    "use": 0.06241471799512221,
                    "usually": 0.10798480849969519,
                    "ways": 0.111214234851827,
                    "weeks": 0.2544017926420858
                },
                "Max term": "change",
                "Max score": 0.4100282467201077
            }
        ],
        "Best Answer": "From what you described, you don't have a problem. They ask for a change and are either willing to wait until you say it can be done or are willing to postpone another feature. Seems like a balance between: time, resources and requirements.  ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "ask": 0.2296816483268417,
                "change": 0.2296816483268417,
                "described": 0.3379160370825435,
                "feature": 0.2325214110450399,
                "like": 0.1323502090567839,
                "problem": 0.1934156394733737,
                "requirements": 0.24729833164987672,
                "resources": 0.3010066002603142,
                "say": 0.1934156394733737,
                "time": 0.14633628525100895,
                "wait": 0.3299543951817854,
                "willing": 0.5931760106331783
            },
            "Max term": "willing",
            "Max score": 0.5931760106331783
        }
    },
    {
        "ID": "937",
        "Question": "I know that they are implemented extremely unsafely in C/C++. Can't they be implemented in a safer way? Are the disadvantages of macros really bad enough to outweigh the massive power they provide? ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "bad": 0.19449640408742258,
                    "disadvantages": 0.3075559041945248,
                    "extremely": 0.27093700190473524,
                    "implemented": 0.5255864711156523,
                    "know": 0.14346196379489157,
                    "massive": 0.3289765888516238,
                    "outweigh": 0.3289765888516238,
                    "power": 0.26670835296333784,
                    "provide": 0.23891490272032562,
                    "really": 0.15341034270513254,
                    "safer": 0.3289765888516238,
                    "way": 0.14465816377514465
                },
                "Max term": "implemented",
                "Max score": 0.5255864711156523
            }
        ],
        "Best Answer": "I think the main reason is that macros are lexical. This has several consequences:  The compiler has no way of checking that a macro is semantically closed, i.e. that it represents a â€œunit of meaningâ€ like a function does. (Consider #define TWO 1+1 â€” what does TWO*TWO equal? 3.) Macros are not typed like functions are. The compiler cannot check that the parameters and return type make sense. It can only check the expanded expression that uses the macro. If the code doesnâ€™t compile, the compiler has no way of knowing whether the error is in the macro itself or the place where the macro is used. The compiler will either report the wrong place half of the time, or it has to report both even though one of them is probably fine. (Consider #define min(x,y) (((x)<(y))?(x):(y)): What should the compiler do if the types of x and y donâ€™t match or donâ€™t implement operator<?) Automated tools cannot work with them in semantically useful ways. In particular, you canâ€™t have things like IntelliSense for macros that work like functions but expand to an expression. (Again, the min example.) The side-effects of a macro are not as explicit as they are with functions, causing potential confusion for the programmer. (Consider again the min example: in a function call, you know that the expression for x is evaluated only once, but here you canâ€™t know without looking at the macro.)  Like I said, these are all consequences of the fact that macros are lexical. When you try to turn them into something more proper, you end up with functions and constants. ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "automated": 0.08906216046219721,
                "causing": 0.10442836623754298,
                "check": 0.1412768402989628,
                "checking": 0.09280428030217668,
                "closed": 0.09504360324320442,
                "code": 0.03655295961058763,
                "compile": 0.09082905748284399,
                "compiler": 0.4300231296241359,
                "confusion": 0.10442836623754298,
                "consequences": 0.20885673247508596,
                "consider": 0.2027426568363341,
                "constants": 0.10442836623754298,
                "define": 0.16683903461567623,
                "effects": 0.09082905748284399,
                "end": 0.05819612261777282,
                "equal": 0.09762871186019348,
                "error": 0.07743807452683091,
                "evaluated": 0.10442836623754298,
                "example": 0.11145097102202686,
                "expand": 0.10068624639756353,
                "expression": 0.31328509871262894,
                "fact": 0.0706384201494814,
                "fine": 0.0874638076857123,
                "function": 0.14481063434025637,
                "functions": 0.32905002433939085,
                "half": 0.08906216046219721,
                "implement": 0.07583972175034598,
                "intellisense": 0.10442836623754298,
                "know": 0.09107942026286302,
                "knowing": 0.0874638076857123,
                "like": 0.18612672052133802,
                "looking": 0.06173977847124932,
                "main": 0.07920497154747767,
                "make": 0.0473902482787488,
                "match": 0.10068624639756353,
                "meaning": 0.10068624639756353,
                "operator": 0.09280428030217668,
                "parameters": 0.10442836623754298,
                "particular": 0.06805331153249235,
                "place": 0.14481063434025637,
                "potential": 0.08466230882596086,
                "probably": 0.05929618977540825,
                "programmer": 0.053981576857412394,
                "proper": 0.08906216046219721,
                "reason": 0.06499577699512232,
                "report": 0.17812432092439442,
                "return": 0.08226250608484771,
                "said": 0.06623856851324506,
                "sense": 0.07509426519711518,
                "things": 0.04962957121977655,
                "think": 0.04433271374137877,
                "time": 0.041159123300454264,
                "tools": 0.06904006737299649,
                "try": 0.05987452333208464,
                "turn": 0.08600462592482717,
                "type": 0.07303822289059457,
                "typed": 0.09762871186019348,
                "types": 0.07661986293048863,
                "unit": 0.06758088561211137,
                "used": 0.050958584064764736,
                "useful": 0.06758088561211137,
                "uses": 0.08226250608484771,
                "way": 0.09183884943724449,
                "ways": 0.07008853445566388,
                "work": 0.0884333156756486,
                "wrong": 0.06758088561211137
            },
            "Max term": "compiler",
            "Max score": 0.4300231296241359
        }
    },
    {
        "ID": "940",
        "Question": "This is more a discussion question than an actual attempt to determine the \"best\", since that clearly varies by the needs of the organization. I'm more curious about the arguments in favor of different systems across categories (centralized vs distributed, open vs proprietary, etc). So, what do you think is the best version control system? ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "actual": 0.20603358540469613,
                    "arguments": 0.2160223706897536,
                    "attempt": 0.24112814593219487,
                    "best": 0.2719307939223247,
                    "clearly": 0.20317594275319897,
                    "control": 0.17310807489297433,
                    "curious": 0.22921252997664232,
                    "determine": 0.23474331880530874,
                    "different": 0.13878412989631542,
                    "discussion": 0.21241841253158225,
                    "distributed": 0.22921252997664232,
                    "favor": 0.24867979359887163,
                    "needs": 0.18547147239892964,
                    "open": 0.1605297345590235,
                    "organization": 0.20603358540469613,
                    "proprietary": 0.24867979359887163,
                    "question": 0.13231604768611693,
                    "systems": 0.17883017764146217,
                    "think": 0.10949509488468441,
                    "version": 0.18547147239892964,
                    "vs": 0.4010055931520594
                },
                "Max term": "vs",
                "Max score": 0.4010055931520594
            }
        ],
        "Best Answer": "Mercurial Because of it's sophisticated ability to branch and merge code, it is the best I've used. The whole DVCS paradigm just makes so much sense. I've not used Git, but I suppose that it qualifies as well.  ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "ability": 0.2668784700429563,
                "best": 0.18972171452038297,
                "branch": 0.3364624109356627,
                "code": 0.12597417996279853,
                "git": 0.3198357460696042,
                "makes": 0.2024285536911523,
                "mercurial": 0.3198357460696042,
                "merge": 0.3364624109356627,
                "paradigm": 0.3275532298020608,
                "sense": 0.2588008899661142,
                "suppose": 0.3275532298020608,
                "used": 0.3512419190135652
            },
            "Max term": "used",
            "Max score": 0.3512419190135652
        }
    },
    {
        "ID": "966",
        "Question": "There are a lot of questions about what programming books should be on the programmer's bookshelf. How about non-programming related books that can help you become a better programmer or developer? It would also be interesting to know why they would help. My first choice would be Sun Tzu's \"Art of War\" (however clichÃ©), because it made it obvious that the success of any project depends on the strength of its weakest link (and warfare is a big project). ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "art": 0.22582425682666904,
                    "better": 0.12406243941959483,
                    "big": 0.1544304144197611,
                    "books": 0.3640986455482678,
                    "choice": 0.1860372144473583,
                    "depends": 0.19046907352277803,
                    "developer": 0.13702911043281799,
                    "help": 0.2692991159699485,
                    "interesting": 0.17353932133658267,
                    "know": 0.1082026653620979,
                    "link": 0.20434758437589465,
                    "lot": 0.12728870532729178,
                    "non": 0.14669413947024287,
                    "obvious": 0.1928847017196842,
                    "programmer": 0.2565211978540697,
                    "programming": 0.21066966722922784,
                    "project": 0.2343367525314647,
                    "questions": 0.15948092005549053,
                    "related": 0.1860372144473583,
                    "strength": 0.2481225184284298,
                    "success": 0.22582425682666904,
                    "sun": 0.2481225184284298,
                    "war": 0.2392312158790379
                },
                "Max term": "books",
                "Max score": 0.3640986455482678
            }
        ],
        "Best Answer": "The Design of Everyday Things by Donald Norman  ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "design": 0.3587255147124199,
                "donald": 0.6256604202319488,
                "everyday": 0.6256604202319488,
                "things": 0.29734505579321807
            },
            "Max term": "donald",
            "Max score": 0.6256604202319488
        }
    },
    {
        "ID": "991",
        "Question": "What are the first 5 things you do before starting a new project? Do you always spend a day researching new frameworks? Or, using similar or competing products? ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "day": 0.2914831620563677,
                    "frameworks": 0.3485418854217384,
                    "new": 0.4353913711240234,
                    "products": 0.3919184960330456,
                    "project": 0.21700275539667005,
                    "similar": 0.29946894806356605,
                    "spend": 0.3214050761811263,
                    "starting": 0.34076664597792233,
                    "things": 0.21839518388368423,
                    "using": 0.21563611411020017
                },
                "Max term": "new",
                "Max score": 0.4353913711240234
            }
        ],
        "Best Answer": "This is pretty project-dependent.  Is this a project I'm starting with the intent of selling, or a project for a specific customer?  Also, what constitutes \"starting\"? Is that before or after requirements gathering? A rough list, though:  Get a context for the project.  That is, figure out what your customer or potential user is trying to accomplish and why.  If you're building a hotel registration system, what's wrong with OTS options, for example. Gather requirements.  Meet with stakeholders.  Meet with users.  Meet with anyone who has a say in the project, if you can.  Look at existing solutions that this project will replace, either that the customer is using or that exist in the market place.  From there, write it all down in a non-technical language as you can- a good reqs doc should describe what's to be done but not how to do it.  Then discuss this doc with the customer and iterate until they agree with it.  This step can be less formal for smaller projects (possibly even entirely verbal). Start making technical decisions.  Pick languages, frameworks, ORMs, databases, etc that best solve the problem, whether this means sticking with something you know or learning something new. Analyze the risks for this project.  If this is a government contract, you probably want a 100 page leather-bound risk report.  If it's a 3-man 4-month project, you might be fine with some notes in a text file or a spreadsheet.  Either way, you want to figure out what can go wrong with the project, how likely it is to happen, how much it'll hurt, and what you are going to do to prepare for it, handle it, and/or mitigate it's effects after the fact.  A common one, for example, is \"One of the devs gets hit by a bus, quits, gets sick, etc.\"  So you might mitigate that by pair programming to share knowledge, using good source control practices to keep code centralized, etc.  Overall, the process of sitting and thinking about what could go wrong and being prepared for the possibilities is more important than actually writing out all the contingency plans. Set up the technology.  It's the sort of thing that no one wants to do once you're in the thick of actually coding, so set up your repo, your build server, your build system, your wikis, your bug tracker, or whatever you intend to use for your project.  ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "100": 0.07083376876924506,
                "accomplish": 0.07991097335328348,
                "actually": 0.0988783480196327,
                "agree": 0.06990182271483446,
                "best": 0.04740197760846345,
                "bound": 0.08669789719525599,
                "bug": 0.06345736912188141,
                "build": 0.11889664929653075,
                "building": 0.07531245307427631,
                "code": 0.031474653668067995,
                "coding": 0.051058164835342756,
                "common": 0.05465226158964975,
                "constitutes": 0.0899201239917325,
                "context": 0.07405599556572158,
                "contract": 0.06990182271483446,
                "control": 0.06035112810551996,
                "customer": 0.263900234128615,
                "databases": 0.0840651462041706,
                "decisions": 0.0782101684166087,
                "dependent": 0.0840651462041706,
                "devs": 0.0899201239917325,
                "discuss": 0.07991097335328348,
                "effects": 0.0782101684166087,
                "entirely": 0.07668874655680696,
                "example": 0.09596707766645833,
                "exist": 0.06902639396149306,
                "existing": 0.06466141222809879,
                "fact": 0.060824618130796024,
                "figure": 0.13640203555631936,
                "file": 0.05989267207638542,
                "fine": 0.07531245307427631,
                "formal": 0.0782101684166087,
                "frameworks": 0.06820101777815968,
                "gathering": 0.0899201239917325,
                "gets": 0.14366007263943129,
                "going": 0.04648191156458686,
                "good": 0.07864208114979125,
                "handle": 0.06990182271483446,
                "happen": 0.06820101777815968,
                "hit": 0.0782101684166087,
                "important": 0.05741112824691248,
                "intend": 0.08669789719525599,
                "intent": 0.08669789719525599,
                "know": 0.039212874136622375,
                "knowledge": 0.056313880201083605,
                "language": 0.04232773871369972,
                "languages": 0.049222024775071406,
                "learning": 0.055294151797378246,
                "likely": 0.060824618130796024,
                "list": 0.06035112810551996,
                "look": 0.051811735042817594,
                "making": 0.06035112810551996,
                "man": 0.0840651462041706,
                "market": 0.0840651462041706,
                "means": 0.05819186713971065,
                "meet": 0.23006623967042086,
                "mitigate": 0.179840247983465,
                "month": 0.07083376876924506,
                "new": 0.042597655955405045,
                "non": 0.053162265535482124,
                "notes": 0.08183918695816468,
                "options": 0.07531245307427631,
                "overall": 0.0782101684166087,
                "page": 0.07083376876924506,
                "pair": 0.06902639396149306,
                "pick": 0.06820101777815968,
                "place": 0.06234603999059778,
                "possibly": 0.07405599556572158,
                "potential": 0.07290016670125651,
                "practices": 0.06902639396149306,
                "prepare": 0.08183918695816468,
                "prepared": 0.0840651462041706,
                "pretty": 0.056313880201083605,
                "probably": 0.051058164835342756,
                "problem": 0.04684293416837103,
                "process": 0.054969640343234136,
                "programming": 0.0381735658628126,
                "project": 0.4246206667761048,
                "projects": 0.05233688935214875,
                "replace": 0.0782101684166087,
                "report": 0.07668874655680696,
                "requirements": 0.11978534415277084,
                "risk": 0.07083376876924506,
                "risks": 0.08669789719525599,
                "rough": 0.0899201239917325,
                "say": 0.04684293416837103,
                "selling": 0.08183918695816468,
                "server": 0.06404684492727256,
                "set": 0.1133408905598178,
                "share": 0.06990182271483446,
                "sick": 0.08669789719525599,
                "sitting": 0.0899201239917325,
                "smaller": 0.0840651462041706,
                "solutions": 0.07083376876924506,
                "solve": 0.06404684492727256,
                "sort": 0.06597505853215375,
                "source": 0.053448218483432376,
                "specific": 0.05859865888479009,
                "stakeholders": 0.08669789719525599,
                "start": 0.050110930106142815,
                "starting": 0.13335919183671585,
                "step": 0.07531245307427631,
                "sticking": 0.0899201239917325,
                "technical": 0.11482225649382496,
                "technology": 0.06667959591835793,
                "text": 0.07083376876924506,
                "thing": 0.05130501105122715,
                "thinking": 0.0566704452799089,
                "tracker": 0.08669789719525599,
                "trying": 0.05562612393471061,
                "use": 0.03386975279209631,
                "user": 0.05434170871753949,
                "users": 0.05819186713971065,
                "using": 0.08438929762629778,
                "want": 0.08492413335522096,
                "wants": 0.06990182271483446,
                "way": 0.039539834942309914,
                "write": 0.04433255807909046,
                "writing": 0.050110930106142815,
                "wrong": 0.17457560141913192
            },
            "Max term": "project",
            "Max score": 0.4246206667761048
        }
    },
    {
        "ID": "1007",
        "Question": "Tester and blogger Lanette Creamer recently posted this question on Twitter:  If you are a professional software developer who works with testers, think of the best testers you know. What traits do they have in common?  I thought it would make an excellent question for here. My thoughts are:  They want to remove ambiguity from requirements even if it means asking awkward questions. They create new features by seeing the way software \"should\" work, rather than just how it's documented. They demonstrate honesty and integrity and encourage but not demand it from those around them. In other words, they model behavior.  What are the traits of the best testers you've worked with? ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "asking": 0.12336095605592606,
                    "awkward": 0.16342241965325627,
                    "behavior": 0.14908271844374613,
                    "best": 0.18429863568690855,
                    "common": 0.10624385053481511,
                    "create": 0.11235570076192762,
                    "demand": 0.16854048054691992,
                    "demonstrate": 0.17480448083156616,
                    "developer": 0.09653820483419506,
                    "documented": 0.1590951608253429,
                    "encourage": 0.15204035847494637,
                    "excellent": 0.1590951608253429,
                    "features": 0.11016719423739853,
                    "know": 0.07622972257017852,
                    "make": 0.07932737095591486,
                    "means": 0.11312483426859879,
                    "model": 0.13106484204980187,
                    "new": 0.08280972938394614,
                    "posted": 0.16854048054691992,
                    "professional": 0.13588895662521858,
                    "question": 0.1793520087688259,
                    "questions": 0.11235570076192762,
                    "recently": 0.13770065726543623,
                    "remove": 0.14908271844374613,
                    "requirements": 0.11643119452204478,
                    "seeing": 0.14396465755008248,
                    "software": 0.16509228838024056,
                    "tester": 0.1590951608253429,
                    "testers": 0.44724815533123835,
                    "think": 0.07420931006225123,
                    "thought": 0.12120053519346273,
                    "thoughts": 0.13588895662521858,
                    "traits": 0.3496089616631323,
                    "twitter": 0.16854048054691992,
                    "want": 0.08254614419012028,
                    "way": 0.07686533350300749,
                    "words": 0.14396465755008248,
                    "work": 0.07401504204198814,
                    "worked": 0.11472936336412803,
                    "works": 0.11732243181798459
                },
                "Max term": "testers",
                "Max score": 0.44724815533123835
            }
        ],
        "Best Answer": "Some of the best testers I've worked with really understand how the users are going to use the software.  They understand what business function the software is supposed to play and how that software will effect the user's role/job/function.  It makes for a successful project when the tester has as much knowledge of the business as the developer and the business owner. ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "best": 0.12164312198321703,
                "business": 0.4511282547947585,
                "developer": 0.1274367396472371,
                "effect": 0.20070320980301967,
                "function": 0.31998525506213155,
                "going": 0.11928204525911187,
                "job": 0.12801126850336098,
                "knowledge": 0.1445128778219077,
                "makes": 0.129790315841224,
                "owner": 0.21001600997300734,
                "play": 0.19326708247998908,
                "project": 0.10896630514423593,
                "really": 0.10760628575425721,
                "role": 0.20070320980301967,
                "software": 0.32689891543270777,
                "successful": 0.22248444930550637,
                "supposed": 0.18433049233241292,
                "tester": 0.21001600997300734,
                "testers": 0.19679893166491194,
                "understand": 0.2526274668720105,
                "use": 0.08691667897194993,
                "user": 0.1394518844109124,
                "users": 0.1493321745218308,
                "worked": 0.1514502577921233
            },
            "Max term": "business",
            "Max score": 0.4511282547947585
        }
    },
    {
        "ID": "1009",
        "Question": "I'd like to sell my software on the 'net but am not sure how to do the whole Merchant setup.  I have access to Commerce Server 2009, and I want to seem professional so a plain old PayPal account is out. What do I need to know/do to sell a few things using ASP.NET, accept credit cards, and what not?  ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "2009": 0.25882020989879806,
                    "accept": 0.2167744443331701,
                    "access": 0.1779411982308449,
                    "account": 0.2167744443331701,
                    "asp": 0.2167744443331701,
                    "cards": 0.25882020989879806,
                    "credit": 0.24196762437446204,
                    "know": 0.11286777491219749,
                    "like": 0.09226105627953193,
                    "need": 0.12183339759883449,
                    "net": 0.3164420425622498,
                    "old": 0.18265154524543276,
                    "plain": 0.25882020989879806,
                    "professional": 0.20120083941416106,
                    "sell": 0.4335488886663402,
                    "server": 0.18434825388982506,
                    "setup": 0.23001052465647956,
                    "software": 0.12222003843373656,
                    "sure": 0.15221170636097942,
                    "things": 0.12300428037982622,
                    "using": 0.12145032032461783,
                    "want": 0.12222003843373656
                },
                "Max term": "sell",
                "Max score": 0.4335488886663402
            }
        ],
        "Best Answer": "Definately use a 3rd party vendor at first.  There's a lot of shareware and software sales services that will handle the whole process of purchase and download.  Then once you get sales going and have an idea of what type of revenue you are generating, you might look at implementing a store of your own on your site.  What you dont want to do is bite off too much to chew at one time.  Releasing a new product is tough enough, you dont want to compound that by having to learn all about credit card processing & sales/vat taxes, and maintaining your own store.  Nor do you want to invest a large amount of time up front doing all that if it turns out no one is buying your software. ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "3rd": 0.15682731200535818,
                "bite": 0.1661379918229065,
                "buying": 0.1661379918229065,
                "card": 0.17231270085833925,
                "credit": 0.16109288719201095,
                "download": 0.17231270085833925,
                "generating": 0.16109288719201095,
                "going": 0.08907264989413094,
                "handle": 0.13395190455944408,
                "idea": 0.09978471600665526,
                "implementing": 0.1661379918229065,
                "invest": 0.17231270085833925,
                "large": 0.11655738185768305,
                "learn": 0.09350956597059115,
                "look": 0.09928611755701547,
                "lot": 0.08839770264557252,
                "maintaining": 0.15682731200535818,
                "new": 0.08162930412089993,
                "party": 0.14191248904256337,
                "process": 0.10533756819135477,
                "processing": 0.1661379918229065,
                "product": 0.11309393429153308,
                "purchase": 0.17231270085833925,
                "releasing": 0.17231270085833925,
                "sales": 0.43296066402294947,
                "services": 0.14191248904256337,
                "site": 0.12390977778636703,
                "software": 0.16273895249340783,
                "store": 0.30626460541778333,
                "time": 0.13582975500602917,
                "tough": 0.15313230270889167,
                "turns": 0.14987307352568266,
                "type": 0.12051719188581113,
                "use": 0.06490414294298556,
                "vendor": 0.1661379918229065,
                "want": 0.24410842874011177
            },
            "Max term": "sales",
            "Max score": 0.43296066402294947
        }
    },
    {
        "ID": "1025",
        "Question": "I'm considering learning iPhone development and Objective C but don't want to avoid developing something for the most saturated markets and app categories. What categories should I avoid?  Are there too many dating applications, or should I just stick to coming up with a creative game or two? ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "app": 0.21057559166141607,
                    "applications": 0.22600027320848382,
                    "avoid": 0.44808377900177815,
                    "coming": 0.2706369849994081,
                    "considering": 0.2706369849994081,
                    "creative": 0.32312997724153963,
                    "developing": 0.23236223143545068,
                    "development": 0.16332571133315682,
                    "game": 0.24804789094700905,
                    "iphone": 0.29409094922610707,
                    "learning": 0.1987007715149484,
                    "objective": 0.2871618704993098,
                    "stick": 0.2810499899092591,
                    "want": 0.1525883865599044
                },
                "Max term": "avoid",
                "Max score": 0.44808377900177815
            }
        ],
        "Best Answer": "The iOS market has way to many apps in general. Try to make an iPad app. There are less iPad apps out than iPhone/iPod touch.  Alternatively, try to make something for a particular (local) business. That way you are guaranteed to get paid (by the business) and you get an app out there that is unique. Games are always good, provided that the gameplay attracts people. Like the speakers at the WWDC 2010 said, watch play testers as they do their thing. It helps a lot with your game development. ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "2010": 0.17872116500518773,
                "app": 0.26781224988149427,
                "apps": 0.32373012186121797,
                "business": 0.26781224988149427,
                "development": 0.10385967782524061,
                "game": 0.15773495690728268,
                "games": 0.15973543395321865,
                "general": 0.14500895685603024,
                "good": 0.08985407298099159,
                "helps": 0.15973543395321865,
                "ios": 0.20548005000588399,
                "iphone": 0.18701397954200666,
                "like": 0.07324700982711758,
                "local": 0.17209948048104245,
                "lot": 0.10541280050476581,
                "make": 0.18649627370322197,
                "market": 0.19210060750553584,
                "paid": 0.16922829947920318,
                "particular": 0.13390612494074713,
                "people": 0.09190110225477072,
                "play": 0.17209948048104245,
                "provided": 0.17872116500518773,
                "said": 0.13033531846566984,
                "speakers": 0.1981168114572898,
                "testers": 0.17524450343095713,
                "thing": 0.11723912032558874,
                "touch": 0.19210060750553584,
                "try": 0.2356260179417069,
                "unique": 0.18260774197955132,
                "watch": 0.18260774197955132,
                "way": 0.18070809737578303
            },
            "Max term": "apps",
            "Max score": 0.32373012186121797
        }
    },
    {
        "ID": "1058",
        "Question": "I'm not exactly sure when to use Enterprise Library, and when not to... and that is making me not learn it at all.  I feel that I have enough of a reason to start learning then perhaps one day I'll use it. Are there times when I should use EntLib? When shouldn't I use it?   ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "day": 0.23069892086101512,
                    "enterprise": 0.3163438766030281,
                    "exactly": 0.29053756827212895,
                    "feel": 0.21857124259031208,
                    "learn": 0.19737487130090978,
                    "learning": 0.22365335207927178,
                    "library": 0.26413828618150087,
                    "making": 0.24410777023990954,
                    "reason": 0.22637046587592877,
                    "start": 0.20268829758195764,
                    "sure": 0.2138961550527572,
                    "times": 0.2404561178875297,
                    "use": 0.5479844431871932
                },
                "Max term": "use",
                "Max score": 0.5479844431871932
            }
        ],
        "Best Answer": "I've used EntLib for many years (since they were indiviual App Blocks).  I've found that at times it can be pretty heavy as far as the size of the components, especially if you only need one block and it needs to be downloaded.  Often I'll use the Data and Logging components together and that feels like enough functionality to justify the size.  If your app is strictly on the server side then this really isn't too much of an issue.  One of the things that is nice about it is that if you need more than one block you don't have to go to multiple implementations from multiple vendors that are configured in different ways.  They also provide a tool to help with the configuration (that's a plus and a minus, a plus that they make it easy, a minus that they NEED a tool to help configure it). I've had the pleasure of being invinted to a couple of Patterns and Practices workshops where I was working side by side with the team members who wrote EntLib.  The intent in creating EntLib was to implement Microsoft's Best Practices in common components that everyone needs that are not part of the base Framework.  They are very stable, provide very good performance and very good flexibility. I would start by using some of the easier blocks, like Data and Logging.  They're not too hard to configure and get started with.  Then once you understand those it will be a bit easier to move on to some of the other blocks.  I have not found a situation where you shouldn't use them, other than when you don't need them. ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "app": 0.149350498432099,
                "base": 0.0890794453529936,
                "best": 0.06040674920914252,
                "bit": 0.07575802148158219,
                "block": 0.19194897321629248,
                "blocks": 0.3437693522213149,
                "common": 0.06964615457244085,
                "components": 0.32138546492278985,
                "configuration": 0.10183461471338262,
                "couple": 0.08591708792992056,
                "creating": 0.08796384200010471,
                "data": 0.14010121289697572,
                "different": 0.06165905676170295,
                "easier": 0.14831370764128707,
                "easy": 0.07316191856953154,
                "especially": 0.08407537018241919,
                "far": 0.07751190221466288,
                "feels": 0.10429183530898323,
                "flexibility": 0.11048353670161595,
                "framework": 0.0752086726397157,
                "functionality": 0.08407537018241919,
                "good": 0.10021760088870822,
                "hard": 0.07575802148158219,
                "heavy": 0.11048353670161595,
                "help": 0.12436971761253163,
                "implement": 0.08321931724775722,
                "implementations": 0.11458978407377164,
                "intent": 0.11048353670161595,
                "issue": 0.07813575245214632,
                "justify": 0.11458978407377164,
                "like": 0.08169512358886896,
                "logging": 0.20858367061796645,
                "make": 0.05200156349388486,
                "members": 0.0915366659485942,
                "microsoft": 0.08497319798083791,
                "multiple": 0.16173390121736445,
                "need": 0.21576155477631803,
                "needs": 0.16480264786565973,
                "nice": 0.08321931724775722,
                "patterns": 0.09966719254142158,
                "performance": 0.08796384200010471,
                "plus": 0.19933438508284315,
                "practices": 0.17592768400020942,
                "pretty": 0.07176363961855434,
                "provide": 0.16643863449551444,
                "really": 0.05343619771433981,
                "server": 0.0816181495868186,
                "situation": 0.08407537018241919,
                "size": 0.19545673468245386,
                "stable": 0.11458978407377164,
                "start": 0.06385890505585513,
                "started": 0.0746752492160495,
                "strictly": 0.11048353670161595,
                "team": 0.06848354782341678,
                "things": 0.05445878408948546,
                "times": 0.07575802148158219,
                "tool": 0.16029043624272168,
                "understand": 0.06272612781503568,
                "use": 0.08632389473651485,
                "used": 0.05591711672864644,
                "using": 0.0537707854696898,
                "vendors": 0.11048353670161595,
                "ways": 0.0769085098109507,
                "working": 0.06114786223493982,
                "wrote": 0.0890794453529936,
                "years": 0.06739004876097182
            },
            "Max term": "blocks",
            "Max score": 0.3437693522213149
        }
    },
    {
        "ID": "1059",
        "Question": "I have often heard it said that objects have not delivered in terms of code reuse. Do you agree? If you believe that they haven't, why not? ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "agree": 0.34198108024799406,
                    "believe": 0.3133367395018764,
                    "code": 0.15398362508726285,
                    "delivered": 0.40038231444616185,
                    "heard": 0.3465404451692833,
                    "objects": 0.3623045634406831,
                    "reuse": 0.40038231444616185,
                    "said": 0.2790377307041959,
                    "terms": 0.3336602226945654
                },
                "Max term": "delivered",
                "Max score": 0.40038231444616185
            }
        ],
        "Best Answer": "No, not necessarily. Objects deliver better semantics, organization of code/functionality and, possibly, ease-of-use. Well designed libraries deliver on the promise of code reuse, not objects per se. ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "better": 0.1323839618038036,
                "code": 0.1853511550403775,
                "deliver": 0.49505141857650403,
                "designed": 0.21465097349780263,
                "functionality": 0.19426033137256493,
                "libraries": 0.19426033137256493,
                "necessarily": 0.19851571198103668,
                "objects": 0.4361085100579641,
                "organization": 0.21150002695595665,
                "possibly": 0.21805425502898204,
                "promise": 0.24752570928825202,
                "reuse": 0.24097148121522663,
                "se": 0.25527771574839697,
                "semantics": 0.25527771574839697,
                "use": 0.09972782968722735
            },
            "Max term": "deliver",
            "Max score": 0.49505141857650403
        }
    },
    {
        "ID": "1060",
        "Question": "Aspect oriented programming promises to deal with cross cutting concerns, but I'm not completely sold on it yet. Have there been any other attempts to deal with this problem? ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "aspect": 0.3314784395344036,
                    "completely": 0.25494099763484596,
                    "concerns": 0.3129017757438891,
                    "cross": 0.3129017757438891,
                    "cutting": 0.343798215963542,
                    "deal": 0.5416479037568841,
                    "oriented": 0.25777290523623925,
                    "problem": 0.17909803148252212,
                    "programming": 0.14595179875206127,
                    "sold": 0.3129017757438891
                },
                "Max term": "deal",
                "Max score": 0.5416479037568841
            }
        ],
        "Best Answer": "When possible, you can encapsulate cross-cutting concerns into separate modules that are then used throughout the app via dependency injection.  This allows you to somewhat decouple the cross-cutting concern implementation from it's use throughout the code. This doesn't always work elegantly, though.  That's the reason people are trying to address the issue with things like AOP. ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "address": 0.21717604737036172,
                "allows": 0.18058615545997064,
                "app": 0.15138527311776057,
                "code": 0.08131242476377139,
                "concern": 0.2239775635726372,
                "concerns": 0.21142544735973454,
                "cross": 0.4228508947194691,
                "cutting": 0.4646038932745818,
                "dependency": 0.21717604737036172,
                "encapsulate": 0.2323019466372909,
                "implementation": 0.18833215395078787,
                "injection": 0.21717604737036172,
                "issue": 0.15840057247090714,
                "like": 0.08280815080448418,
                "people": 0.1038972150886893,
                "possible": 0.13661636277346761,
                "reason": 0.14458375691548508,
                "separate": 0.19131815178170158,
                "somewhat": 0.18833215395078787,
                "things": 0.11040147826217127,
                "trying": 0.14370595035109784,
                "use": 0.08749998505841915,
                "used": 0.11335788064707929,
                "work": 0.09836039822893321
            },
            "Max term": "cutting",
            "Max score": 0.4646038932745818
        }
    },
    {
        "ID": "1063",
        "Question": "I have often wondered if it would be possible to write a programming language that would work as a conversation. I would tell the computer that I want to store coordinates and it would ask what representation I would use. I would then ask to find the shortest path between points and it would ask if I want to use Djkstra's, brute force or use Floyd's? What research has been done towards producing a system like this? ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "ask": 0.5108716678690572,
                    "computer": 0.17460678509326547,
                    "conversation": 0.25053769093239686,
                    "force": 0.25053769093239686,
                    "language": 0.12957965876593028,
                    "like": 0.09812708523036712,
                    "path": 0.23055713030640335,
                    "points": 0.1999157031080437,
                    "possible": 0.16188944377452355,
                    "producing": 0.27527619799986225,
                    "programming": 0.11686231744718835,
                    "research": 0.23055713030640335,
                    "store": 0.2446347708015026,
                    "tell": 0.1960692577235253,
                    "use": 0.31106062898647874,
                    "want": 0.2599817650452518,
                    "work": 0.11655639072404839,
                    "write": 0.13571709528272152
                },
                "Max term": "ask",
                "Max score": 0.5108716678690572
            }
        ],
        "Best Answer": "I think such a language would need an artificial intelligence in place, or at least a system that can learn. The problem is that humans don't know what they want. Also, even writing in classical imperative language we still make logical errors. Imagine trying telling a non-intelligent software what he has to do. ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "artificial": 0.30353139980859833,
                "errors": 0.22508144105352593,
                "humans": 0.30353139980859833,
                "imagine": 0.27625365573220556,
                "imperative": 0.2697448415909641,
                "intelligence": 0.30353139980859833,
                "know": 0.1323656824394693,
                "language": 0.28576023279690177,
                "learn": 0.16471849906108865,
                "logical": 0.24246709751457132,
                "make": 0.1377444550325092,
                "need": 0.14288011639845088,
                "non": 0.1794527871921631,
                "place": 0.21045323283371936,
                "problem": 0.15812146100437924,
                "software": 0.14333354943556526,
                "telling": 0.27625365573220556,
                "think": 0.1288574277665649,
                "trying": 0.18776970620482764,
                "want": 0.14333354943556526,
                "writing": 0.16915280012544057
            },
            "Max term": "artificial",
            "Max score": 0.30353139980859833
        }
    },
    {
        "ID": "1065",
        "Question": "I'm comparing different STS's for claims based authentication and am trying when it's appropriate to use each one.   It appears that ADFSv2 should be used in all Windows Environments.  Ping and Siteminder are more for the Unix side... although a sales rep said Ping was better for Windows, I didn't really understand \"why\" Any comparative information is much appreciated! ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "appreciated": 0.28867208767108693,
                    "appropriate": 0.2660741292694605,
                    "based": 0.19115792634813278,
                    "better": 0.1497018825792803,
                    "claims": 0.28867208767108693,
                    "comparing": 0.29940091693200577,
                    "different": 0.16110317582701444,
                    "environments": 0.2660741292694605,
                    "information": 0.19942055394437,
                    "really": 0.13961843738821786,
                    "said": 0.18990901479792857,
                    "sales": 0.25076274926967584,
                    "trying": 0.18521451897638627,
                    "understand": 0.16389122586464908,
                    "unix": 0.27990599587992027,
                    "use": 0.1127738107116751,
                    "used": 0.14610059837422035,
                    "windows": 0.4305974069384327
                },
                "Max term": "windows",
                "Max score": 0.4305974069384327
            }
        ],
        "Best Answer": "We are in the middle of doing SSO where I'm at right now.  We couldn't get Site Minder to let us pay for a developer license; they literally didn't return the numerous calls we made begging to use their software (one of our clients was using it and we figured it would be the easiest path). We went with Ping Identity's Pingfederate product (or is it the other way around)? The documentation isn't amazing, but it's working for us.  When you can get past first-level support, they have been very helpful and getting us going.  Your application will be dependent upon their APIs, but your application will also support numerous open standards for SSO.  They also have consulting available to do the heavy lifting if you have the budget. ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "amazing": 0.1820457049554849,
                "apis": 0.17651753154356256,
                "application": 0.21651218907941613,
                "available": 0.13091238851744924,
                "budget": 0.17651753154356256,
                "calls": 0.15082660620188884,
                "clients": 0.14873467278231317,
                "dependent": 0.17651753154356256,
                "developer": 0.10427385454905902,
                "documentation": 0.1357741393193279,
                "easiest": 0.1820457049554849,
                "figured": 0.18881164239650416,
                "getting": 0.11475721799909777,
                "going": 0.09760135634427754,
                "heavy": 0.1820457049554849,
                "helpful": 0.13853249534894727,
                "identity": 0.18881164239650416,
                "let": 0.12304374744063945,
                "level": 0.11542364060914145,
                "license": 0.15307363463053852,
                "literally": 0.17651753154356256,
                "middle": 0.18881164239650416,
                "numerous": 0.37762328479300833,
                "open": 0.11751557402871714,
                "past": 0.14001186231502463,
                "path": 0.158138882895348,
                "pay": 0.158138882895348,
                "product": 0.12392267878281163,
                "return": 0.14873467278231317,
                "right": 0.10825609453970807,
                "site": 0.1357741393193279,
                "software": 0.08916060380084262,
                "standards": 0.14873467278231317,
                "support": 0.24965570144435253,
                "use": 0.07111871479211106,
                "using": 0.0885990876023129,
                "way": 0.08302458720175503,
                "went": 0.14493960010304174,
                "working": 0.10075442929695495
            },
            "Max term": "numerous",
            "Max score": 0.37762328479300833
        }
    },
    {
        "ID": "1070",
        "Question": "Dcpromo.exe is famous among MCSEs for being they only way to create a Windows Domain Controller (in other words an Active Directory Domain) ... which in turn is often used by the ASP.NET Membership system. I'm trying to determine if I should put content on \"www.dcpromo.com\" geared for developers or more towards sysadmins. To me, a logical extension of this \"domain controller on the internet\" is to use WIF for the ASP.NET Membership system.  We'd then have a website that will serve the developer's interests in the SSO, SAML, user managment and identity areas we all struggle with. So my question is:  Q:  Do programmers see a connection between the utility dcpromo.exe and ASP.NET Membership?  If so does it make sense to have a purpose of http://www.dcpromo.com  help developers in the areas of membership and cloud computing?   ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "active": 0.1451193785707897,
                    "areas": 0.24308899729243266,
                    "asp": 0.364633495938649,
                    "com": 0.2256248906924319,
                    "computing": 0.13991912383846958,
                    "connection": 0.12622103412111163,
                    "content": 0.13567020634595064,
                    "controller": 0.27983824767693916,
                    "create": 0.09327558078541077,
                    "determine": 0.13207779779306672,
                    "developer": 0.08014419440069723,
                    "developers": 0.16559922275031844,
                    "directory": 0.13991912383846958,
                    "domain": 0.35855021920099134,
                    "famous": 0.1451193785707897,
                    "help": 0.07875246593245952,
                    "http": 0.11006756750882477,
                    "identity": 0.1451193785707897,
                    "internet": 0.11592433118077985,
                    "logical": 0.11592433118077985,
                    "make": 0.06585608516448309,
                    "net": 0.2661415384926534,
                    "programmers": 0.07776063428425105,
                    "purpose": 0.11006756750882477,
                    "question": 0.07444732518908864,
                    "sense": 0.10435510476958541,
                    "serve": 0.1451193785707897,
                    "struggle": 0.13207779779306672,
                    "trying": 0.08977332525085412,
                    "turn": 0.1195167397336638,
                    "use": 0.0546613734428035,
                    "used": 0.07081484005509037,
                    "user": 0.08770044623480788,
                    "utility": 0.12896591195850282,
                    "way": 0.06381214816993777,
                    "website": 0.11139961726026286,
                    "windows": 0.10435510476958541,
                    "words": 0.1195167397336638,
                    "www": 0.25244206824222326
                },
                "Max term": "asp",
                "Max score": 0.364633495938649
            }
        ],
        "Best Answer": "I've been a Microsoft developer for 11 years, mostly as a web developer.  Been coding since 1.1 and I've used .NET membership in many of my applications, and I've never heard of dcpromo. ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "11": 0.41342694638905453,
                "applications": 0.29990163045816315,
                "coding": 0.24347558428741,
                "developer": 0.47361316527599884,
                "heard": 0.33777738181520484,
                "microsoft": 0.3179678241203205,
                "net": 0.26212781724135525,
                "used": 0.20924061186092074,
                "web": 0.253509183203824,
                "years": 0.2521720693237961
            },
            "Max term": "developer",
            "Max score": 0.47361316527599884
        }
    },
    {
        "ID": "1090",
        "Question": "Language shortcuts can often be used to make code more concise. For example, ternary and null coalescing operators can reduce the amount of code, but arguably to the detriment of readability: In C#: Person newGuy = new Person(); if (boss == null) {     newGuy.Boss = GetDefaultBoss(); } else {     newGuy.Boss = boss; }  is functionally equivalent to: Person newGuy = new Person(); newGuy.Boss = boss ?? GetDefaultBoss();  but obviously a lot more verbose. Where do you draw the line when it comes to conciseness vs readability? ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "arguably": 0.14932463038286026,
                    "boss": 0.6643833820004122,
                    "code": 0.10453591068991219,
                    "comes": 0.11462774190468566,
                    "concise": 0.14932463038286026,
                    "draw": 0.13960164118738358,
                    "equivalent": 0.13960164118738358,
                    "example": 0.0796832108615903,
                    "language": 0.07029098335036355,
                    "line": 0.10182052832119788,
                    "lot": 0.07660465078018815,
                    "make": 0.06776445484054756,
                    "new": 0.14147843549018993,
                    "null": 0.287947366594893,
                    "obviously": 0.11762913428661426,
                    "operators": 0.13590513225365805,
                    "person": 0.4072821132847915,
                    "readability": 0.25013320087451846,
                    "reduce": 0.12506660043725923,
                    "shortcuts": 0.1439736832974465,
                    "used": 0.0728669039310247,
                    "vs": 0.11608151075214912
                },
                "Max term": "boss",
                "Max score": 0.6643833820004122
            }
        ],
        "Best Answer": "Both. Your first example is certainly more verbose, and arguably more explicit... but it also requires me to scan five lines instead of one. Worse, it deemphasizes its purpose - assigning a value to newGuy.Boss. Your second example may cost me a second if I'm unfamiliar with the null coalescing operator, but there can be no doubt as to its purpose, and if I'm scanning through a larger routine looking for the source of a value, it will be much easier for me to pick this one out. Now, contrast this: if (boss == null) {     newGuy.Boss = GetDefaultBoss();     newGuy.IsTemp = true;     newGuy.AddTask(\"orientation\"); } else {     newGuy.Boss = boss;     newGuy.IsTemp = false; }  ...with: newGuy.Boss = boss ?? GetDefaultBoss(); newGuy.IsTemp = boss == null; if ( boss == null ) newGuy.AddTask(\"orientation\");  The latter example is again much shorter, but now it obscures its purpose by making tasks triggered by the same test appear to be distinct. Here, I feel the verbosity of the former is justified. ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "appear": 0.09774600139019629,
                "arguably": 0.1045538247605695,
                "boss": 0.6977799662125812,
                "certainly": 0.08127772291821084,
                "contrast": 0.1045538247605695,
                "cost": 0.07593083434571014,
                "distinct": 0.1045538247605695,
                "doubt": 0.1045538247605695,
                "easier": 0.0676620761774644,
                "example": 0.16737729958054842,
                "false": 0.10080720919931213,
                "feel": 0.0628318486266583,
                "instead": 0.0676620761774644,
                "justified": 0.10080720919931213,
                "larger": 0.09291577383939018,
                "lines": 0.08756888526688947,
                "looking": 0.06181395162647582,
                "making": 0.07017273766912696,
                "null": 0.4032288367972485,
                "operator": 0.09291577383939018,
                "pick": 0.07930012709864373,
                "purpose": 0.2379003812959312,
                "requires": 0.08756888526688947,
                "routine": 0.10080720919931213,
                "scan": 0.1045538247605695,
                "second": 0.15506221471390694,
                "shorter": 0.1045538247605695,
                "source": 0.06214644087451676,
                "tasks": 0.0767119127746458,
                "test": 0.05908523306540093,
                "true": 0.08127772291821084,
                "unfamiliar": 0.10080720919931213,
                "value": 0.15860025419728746,
                "worse": 0.0891691582781328
            },
            "Max term": "boss",
            "Max score": 0.6977799662125812
        }
    },
    {
        "ID": "1095",
        "Question": "I used ad-hoc MUML (made-up modeling language) to design and explain system fairly frequently.  It looks similar to UML and tends to be pretty well understood. However, I've had a professor or two that harped on the use of strict, formal UML, as close to the spec as possible.  I always suspected that strict UML wasn't really as common as they claimed.  So, how 'bout it- how often do you actually draw out complete diagrams that use all the proper line endings, multiplicity, member type symbols, etc? ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "actually": 0.11915638519081222,
                    "ad": 0.20261056425087529,
                    "close": 0.18483225109523646,
                    "common": 0.13172076726509063,
                    "complete": 0.15026401441833165,
                    "design": 0.12425863995765953,
                    "diagrams": 0.19259833750389851,
                    "draw": 0.20261056425087529,
                    "explain": 0.14025178767135488,
                    "fairly": 0.17072081006671416,
                    "formal": 0.188499123222353,
                    "frequently": 0.17312197558726697,
                    "hoc": 0.21672200527939758,
                    "language": 0.10201667886733357,
                    "line": 0.14777702124424985,
                    "looks": 0.16437545544685392,
                    "member": 0.19259833750389851,
                    "possible": 0.12745382689570053,
                    "pretty": 0.1357255361810301,
                    "professor": 0.21672200527939758,
                    "proper": 0.18483225109523646,
                    "really": 0.10106310974198619,
                    "similar": 0.14123222140310585,
                    "spec": 0.197245643362766,
                    "strict": 0.43344401055879517,
                    "tends": 0.197245643362766,
                    "type": 0.1515774946711996,
                    "understood": 0.21672200527939758,
                    "use": 0.16326313660544942,
                    "used": 0.10575523607822375
                },
                "Max term": "strict",
                "Max score": 0.43344401055879517
            }
        ],
        "Best Answer": "Never. Heck, it's been years since I last created any UML. Line diagrams on whiteboards and scraps of paper don't count. In fact, we just removed the sole UML question from the guide we use during interviews, because none of us really cared about the answers. ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "answers": 0.26851849276477,
                "count": 0.3557198583105184,
                "created": 0.2997315692403544,
                "diagrams": 0.3381415652290313,
                "fact": 0.25737806356428755,
                "guide": 0.34630075963113094,
                "interviews": 0.3245067818349341,
                "line": 0.2594495566058715,
                "paper": 0.3133663526344516,
                "question": 0.19519681351653018,
                "really": 0.1774347512962143,
                "use": 0.14331913055804638,
                "years": 0.22376847629886643
            },
            "Max term": "count",
            "Max score": 0.3557198583105184
        }
    },
    {
        "ID": "1106",
        "Question": "This goes back to a conversation I've had with my girlfriend. I tried to tell her that I simply don't feel adequate enough in my programming language (C++) to call myself good. She then asked me, \"Well, when do you consider yourself good enough?\" That's an interesting question. I didn't know what to tell her. So I'm asking you. For any programming language, framework or the like, when do you reach a point were you sit back, look at what you've done and say, \"Hey, I'm actually pretty good at this.\"? How do you define \"good\" so that you can tell others, honestly, \"Yeah, I'm good at X\". Additionally, do you reach these conclusions by comparing what others can do? Additional Info I have read the canonical paper on how it takes ten-thousand hours before you are an expert on the field. (Props to anybody that knows what this paper is called again) I have also read various articles from Coding Horror about interviewing people. Some people, it was said, \"Cannot function outside of a framework.\" So they may be \"good\" for that framework, but not otherwise in the language. Is this true?  ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "actually": 0.07791297777784081,
                    "additional": 0.11868761160139304,
                    "additionally": 0.13663034370716418,
                    "anybody": 0.1289733269726957,
                    "articles": 0.12085656214856251,
                    "asked": 0.09368675933644248,
                    "asking": 0.10000475714363079,
                    "called": 0.11162949144221361,
                    "canonical": 0.14170836715349422,
                    "coding": 0.08046440382283745,
                    "comparing": 0.14170836715349422,
                    "consider": 0.09170666262359309,
                    "conversation": 0.1289733269726957,
                    "define": 0.11319954541409404,
                    "expert": 0.12325422574079643,
                    "feel": 0.08515995177134032,
                    "field": 0.11868761160139304,
                    "framework": 0.2790222081759351,
                    "function": 0.09825337347584588,
                    "girlfriend": 0.14170836715349422,
                    "goes": 0.10190225210905336,
                    "good": 0.3718046777931757,
                    "honestly": 0.12325422574079643,
                    "hours": 0.100933733329942,
                    "info": 0.1289733269726957,
                    "interesting": 0.09911222092736478,
                    "interviewing": 0.12593458559489257,
                    "know": 0.06179698290682014,
                    "knows": 0.10508278058996083,
                    "language": 0.2001174310759276,
                    "like": 0.0505144619206563,
                    "look": 0.08165198229689069,
                    "outside": 0.10878118428391338,
                    "paper": 0.2334150297770873,
                    "people": 0.1267583411601948,
                    "point": 0.08124919733191392,
                    "pretty": 0.08874707526100342,
                    "programming": 0.12031819901277951,
                    "question": 0.07269745085315896,
                    "reach": 0.2579466539453914,
                    "read": 0.17031990354268065,
                    "said": 0.08988515022101588,
                    "say": 0.07382146975563333,
                    "simply": 0.09510951987222464,
                    "sit": 0.13663034370716418,
                    "takes": 0.0930074027253117,
                    "tell": 0.302801199989826,
                    "tried": 0.1062500495968645,
                    "true": 0.11016080403629089,
                    "various": 0.11162949144221361
                },
                "Max term": "good",
                "Max score": 0.3718046777931757
            }
        ],
        "Best Answer": "You can't call yourself good at X.  Only other people can. ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "good": 0.6990986085887331,
                "people": 0.7150252691124261
            },
            "Max term": "people",
            "Max score": 0.7150252691124261
        }
    },
    {
        "ID": "1135",
        "Question": "Planning Poker Summary, in case you don't want to read the wiki article:  Get a list of tasks you want to do for the upcoming iteration For each task: 2.1 Discuss with the group what it entails 2.2 Everyone writes down / selects an estimation of how much effort is required for the task 2.3 Everyone reveals their estimation 2.4 The highest and lowest outliers explain their reasoning 2.5 Repeat until a consensus is reached  Usually something similar to numbers from the Fibonacci sequence like 0, Â½, 1, 2, 3, 5, 8, 13, 20, 40, 100 are the allowed values, so you don't get long arguments over close values like 23 vs 27. Further, the numbers represent a unit-less value of effort, whose value is determined by a baseline task that everyone agrees equals about a 1, and all else is relative to that. Ultimately, the goal is to get a good feel for a given team's \"velocity\", which is the number of these points that can be completed in a given iteration.  With that, it's possible to make reasonably accurate estimates of how long any given feature will take.  We did this at iteration planning meetings at one company I worked at, and I thought it was one of the few good things about that particular company.  So, what I'm wondering is, has anyone used this?  Do you think it's a useful tool for estimation?  Does it work in all situations, or does it lend itself to certain teams, projects, etc? ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "100": 0.09052515658475033,
                    "20": 0.09316600147571086,
                    "40": 0.10743478224691927,
                    "accurate": 0.10743478224691927,
                    "allowed": 0.09995215368954391,
                    "arguments": 0.09624888984151657,
                    "article": 0.09052515658475033,
                    "baseline": 0.11079942314994772,
                    "case": 0.07488875522750942,
                    "certain": 0.08185150623127523,
                    "close": 0.09800778514212569,
                    "company": 0.1358821504380865,
                    "completed": 0.10212577279647261,
                    "discuss": 0.10212577279647261,
                    "effort": 0.18105031316950065,
                    "estimates": 0.09316600147571086,
                    "estimation": 0.3137700566925012,
                    "explain": 0.07436887767389985,
                    "feature": 0.07196882096878292,
                    "feel": 0.0690598682234532,
                    "given": 0.23903366137303958,
                    "goal": 0.09179838088967837,
                    "good": 0.10050413572412503,
                    "group": 0.09316600147571086,
                    "highest": 0.11491741080429464,
                    "iteration": 0.3323982694498432,
                    "like": 0.08192870031176305,
                    "list": 0.07712840099778229,
                    "long": 0.12750171754601305,
                    "make": 0.05215024256128425,
                    "meetings": 0.09316600147571086,
                    "number": 0.07196882096878292,
                    "numbers": 0.19249777968303314,
                    "particular": 0.07488875522750942,
                    "planning": 0.17232547156900163,
                    "points": 0.08345725183369454,
                    "poker": 0.11079942314994772,
                    "possible": 0.06758272546006681,
                    "projects": 0.0668862491165245,
                    "reached": 0.11079942314994772,
                    "read": 0.0690598682234532,
                    "reasonably": 0.1045900188975004,
                    "reasoning": 0.11079942314994772,
                    "repeat": 0.10212577279647261,
                    "represent": 0.11491741080429464,
                    "required": 0.08431575233230303,
                    "sequence": 0.11079942314994772,
                    "similar": 0.07488875522750942,
                    "situations": 0.09464314423909724,
                    "summary": 0.10743478224691927,
                    "task": 0.22792386982895751,
                    "tasks": 0.08431575233230303,
                    "team": 0.0686793509750621,
                    "teams": 0.09800778514212569,
                    "things": 0.054614488662312034,
                    "think": 0.04878560165825581,
                    "thought": 0.07967788712434652,
                    "tool": 0.08037436346788886,
                    "ultimately": 0.1045900188975004,
                    "unit": 0.07436887767389985,
                    "used": 0.056076990859505134,
                    "useful": 0.07436887767389985,
                    "usually": 0.07488875522750942,
                    "value": 0.17432103136344376,
                    "values": 0.19601557028425137,
                    "vs": 0.08933413478865058,
                    "want": 0.10853256297642472,
                    "wiki": 0.11491741080429464,
                    "wondering": 0.08933413478865058,
                    "work": 0.0486578888113968,
                    "worked": 0.0754237037764186
                },
                "Max term": "iteration",
                "Max score": 0.3323982694498432
            }
        ],
        "Best Answer": "We use it in our company for the project I'm involved in.  Some notes about planning poker are expressed in my recent blog post, and here's a bigger list of why it's cool:  It makes everyone agree.  People are not forced to accept any result; instead they're forced to make their own estimate!  The time to defend their own estimates is also allocated, if it's necessary. It keeps everyone busy.  You can't slack during the meeting, while trying to show that you're so involved. Also, necessity of moving your hands constitutes a good physical exercise to keep you off of sleeping. However, a downside of this is that sometimes you do need to do something else (for example, take some notes and write down the details of the agreement you've just reached).   It keeps meetings faster.  There's no need for a constant involvement of a meeting leader to keep everything on pace.  The game with clear rules is way better for that.  Yes, you need to make some extra moves to put cards on, reveal them, et cetera, but these pay their way. A lot of people just like to play cards, especially poker :-)  This increases motivation.  A company that sells decks of such cards accompanied their site with an article about Planning Poker, which is also worth reading. ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "accept": 0.10002814713260284,
                "agree": 0.09284188101615316,
                "article": 0.09407966883536407,
                "better": 0.05971541618633348,
                "bigger": 0.10387682135285908,
                "blog": 0.09682420772555125,
                "cards": 0.3582890886832266,
                "clear": 0.09835935118450613,
                "company": 0.14121762608478958,
                "constant": 0.1061357886219477,
                "constitutes": 0.11942969622774223,
                "cool": 0.11165325879030065,
                "details": 0.09167915808563089,
                "especially": 0.08762644944558892,
                "estimate": 0.09540288688303047,
                "estimates": 0.09682420772555125,
                "example": 0.06373055565750246,
                "exercise": 0.1061357886219477,
                "extra": 0.10185610627280565,
                "faster": 0.08954595555949978,
                "forced": 0.23030002775720035,
                "game": 0.09167915808563089,
                "good": 0.05222523860899349,
                "hands": 0.11515001387860017,
                "increases": 0.11515001387860017,
                "instead": 0.07728900614127003,
                "involved": 0.17346847905361662,
                "keeps": 0.23885939245548446,
                "like": 0.04257283436028269,
                "list": 0.08015688342808003,
                "lot": 0.06126832625570838,
                "make": 0.10839589203596102,
                "makes": 0.06717483723953445,
                "meeting": 0.2000562942652057,
                "meetings": 0.09682420772555125,
                "moving": 0.10387682135285908,
                "necessary": 0.08280647630962301,
                "need": 0.16865598329410186,
                "notes": 0.21739358897765,
                "pay": 0.10002814713260284,
                "people": 0.10683003751427594,
                "physical": 0.108696794488825,
                "planning": 0.17909191111899955,
                "play": 0.10002814713260284,
                "poker": 0.34545004163580056,
                "post": 0.08954595555949978,
                "project": 0.05639707219460037,
                "reached": 0.11515001387860017,
                "reading": 0.08015688342808003,
                "recent": 0.11515001387860017,
                "result": 0.09835935118450613,
                "reveal": 0.11515001387860017,
                "rules": 0.09835935118450613,
                "site": 0.0858816967464222,
                "slack": 0.11942969622774223,
                "time": 0.047071708290368976,
                "trying": 0.07388124914574229,
                "use": 0.04498497230320433,
                "way": 0.10503167180884482,
                "worth": 0.08015688342808003,
                "write": 0.05888141285115792,
                "yes": 0.0778292969280939
            },
            "Max term": "cards",
            "Max score": 0.3582890886832266
        }
    },
    {
        "ID": "1180",
        "Question": "I've been in workplaces where, at the start of a project, the \"Should we use VB.Net or C#\" question has been raised. Granted, it's probably less common to have to make that decision now than it was in the early days of .Net, particularly given the trend towards language convergence, but it can still be a heated debate. So, between VB.Net and C#, Which language do you prefer and why? ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "common": 0.15879260804604822,
                    "days": 0.17962110594347386,
                    "debate": 0.24425199293235964,
                    "decision": 0.24425199293235964,
                    "early": 0.20055677116270132,
                    "given": 0.18114694622857397,
                    "granted": 0.25190147319265027,
                    "language": 0.24596720529175584,
                    "make": 0.11856309857103937,
                    "net": 0.47914426409254973,
                    "particularly": 0.2118120506046269,
                    "prefer": 0.1897392972621048,
                    "probably": 0.14834992954407877,
                    "project": 0.12337389368054838,
                    "question": 0.13403021957194136,
                    "start": 0.14559773103103618,
                    "use": 0.09840885305193761,
                    "vb": 0.46436401719446097
                },
                "Max term": "net",
                "Max score": 0.47914426409254973
            }
        ],
        "Best Answer": "I prefer C# over VB.NET because  it's easier to find programmers/jobs:    it's easier to find help:   (from stackoverflow) ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "easier": 0.5650655830854477,
                "help": 0.23692026893046994,
                "jobs": 0.3439116737364432,
                "net": 0.26688825603389466,
                "prefer": 0.3170601879787833,
                "programmers": 0.23393642559242345,
                "stackoverflow": 0.3595562092452725,
                "vb": 0.38798326099752073
            },
            "Max term": "easier",
            "Max score": 0.5650655830854477
        }
    },
    {
        "ID": "1189",
        "Question": "By now I work with asp.net and C#. I have done a decent work in Java as well. I am planning my career in such a way I should be language-agnostic someday. What are the things that I need to learn?  First would OOP paradigms as its speaks about the Class design. Are there any others? ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "agnostic": 0.32427895791300726,
                    "asp": 0.2905156881721685,
                    "career": 0.24478503232203794,
                    "class": 0.23103431284572226,
                    "decent": 0.31569238217686924,
                    "design": 0.1988764131137023,
                    "java": 0.21081957548539243,
                    "language": 0.1632780720746743,
                    "learn": 0.18823416189504308,
                    "need": 0.1632780720746743,
                    "net": 0.21204385517945387,
                    "oop": 0.2905156881721685,
                    "paradigms": 0.30169354432265794,
                    "planning": 0.2600718462565964,
                    "things": 0.16484725989077104,
                    "way": 0.15252381099776705,
                    "work": 0.29373596051495116
                },
                "Max term": "agnostic",
                "Max score": 0.32427895791300726
            }
        ],
        "Best Answer": "To be language agnostic you need to have experience in all of the common styles and types of languages.  An imperative language (You tell it what to do, step by step. Eg - C) A declarative language (You tell it your goal, it figures out what to do. Eg - SQL/HTML/Prolog)  Also:  A functional language (Functions are key, avoiding state and side effects are the goals. Eg - Haskell/OCaml/Lisp/F#) An object oriented language (Architecture where objects encapsulate related data and the methods that act on them). Eg - Java/C#)  Some typing styles:  A statically typed language (Data types are defined and checked at compile time. Eg - C#) A dynamically typed language (Data types are checked at runtime. Eg - Python/Javascript) Experience of strong vs. weak typing is also useful.  Some different runtime styles:  Something compiled (Eg - C++) Something interpreted (Eg - PHP) Something Managed (Eg - C#/Java)  Lower level stuff:  Something fairly low level (Eg - C) Some dialect of assembly (Eg - NASM)  On top of that I would say you need experience of some concurrent programming and something event driven. You should probably also make sure you know something about the various domains such as web programming (client & server), rich client development/desktop, games. You might also want to learn about embedded programming, or dedicated hardware (like games consoles), and mobile development is becoming an increasingly relevant domain. Others have also mentioned that it's worth getting some experience of Generic programming and Meta programming approaches. When you learn these paradigms avoid just learning the syntax and writing in your old style. I've seen many C# devs write JavaScript as if it's statically typed. Don't do this, try to learn the language paradigms and embrace them. If you've done all of this, the differences between languages will become largely syntactical so switching will become a fairly simple exercise of learning some new syntax. Don't forget though that modern programming is almost always dependant on a framework, so familiarising yourself with the common and popular frameworks for each language you learn is also critical. Knowing C# is irrelevant without .net.  ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "agnostic": 0.07529662814050252,
                "approaches": 0.06868963289523976,
                "architecture": 0.06633149422168255,
                "assembly": 0.07529662814050252,
                "avoid": 0.05584295990877657,
                "avoiding": 0.07529662814050252,
                "client": 0.11168591981755314,
                "common": 0.09790338097929029,
                "compile": 0.07005236098404953,
                "compiled": 0.07529662814050252,
                "concurrent": 0.07330285030069063,
                "critical": 0.07157576137813554,
                "data": 0.14770789399054143,
                "declarative": 0.0805408952969555,
                "dedicated": 0.07330285030069063,
                "defined": 0.06868963289523976,
                "desktop": 0.06868963289523976,
                "development": 0.081418623725843,
                "devs": 0.0805408952969555,
                "differences": 0.07157576137813554,
                "different": 0.04333785664135861,
                "domain": 0.06633149422168255,
                "driven": 0.06182651137458579,
                "dynamically": 0.0805408952969555,
                "effects": 0.07005236098404953,
                "embedded": 0.0805408952969555,
                "embrace": 0.0805408952969555,
                "encapsulate": 0.0805408952969555,
                "event": 0.07330285030069063,
                "exercise": 0.07157576137813554,
                "experience": 0.1847140920954433,
                "fairly": 0.12689073147757352,
                "figures": 0.0805408952969555,
                "forget": 0.07157576137813554,
                "framework": 0.052861377455765815,
                "frameworks": 0.06108722706522955,
                "functional": 0.054480231819966786,
                "functions": 0.06344536573878676,
                "games": 0.12522125491863112,
                "generic": 0.0805408952969555,
                "getting": 0.04895169048964514,
                "goal": 0.06433771638187066,
                "goals": 0.07765476681405972,
                "hardware": 0.06182651137458579,
                "haskell": 0.06633149422168255,
                "html": 0.06108722706522955,
                "imperative": 0.07157576137813554,
                "interpreted": 0.07765476681405972,
                "irrelevant": 0.07330285030069063,
                "java": 0.09790338097929029,
                "javascript": 0.13059245100588027,
                "key": 0.06182651137458579,
                "know": 0.03512272725981532,
                "knowing": 0.06745689539051195,
                "language": 0.34121422864022966,
                "languages": 0.0881757223572706,
                "learn": 0.1748296933327686,
                "learning": 0.099053255105744,
                "level": 0.09847192932702761,
                "like": 0.028710231232336268,
                "lisp": 0.06633149422168255,
                "low": 0.06344536573878676,
                "lower": 0.06868963289523976,
                "make": 0.03654996398232685,
                "managed": 0.06344536573878676,
                "mentioned": 0.07157576137813554,
                "methods": 0.05584295990877657,
                "mobile": 0.0805408952969555,
                "modern": 0.06433771638187066,
                "need": 0.07582538414227326,
                "net": 0.049235964663513807,
                "new": 0.038154455264268236,
                "object": 0.057916824408465115,
                "objects": 0.06633149422168255,
                "old": 0.05683837049352399,
                "oriented": 0.06038792409913379,
                "paradigms": 0.14010472196809906,
                "php": 0.05683837049352399,
                "popular": 0.06433771638187066,
                "probably": 0.04573248040045106,
                "programming": 0.2051509518526179,
                "prolog": 0.07529662814050252,
                "python": 0.054480231819966786,
                "related": 0.06038792409913379,
                "relevant": 0.06038792409913379,
                "runtime": 0.15059325628100503,
                "say": 0.04195692453230857,
                "seen": 0.054918712938194454,
                "server": 0.05736636030286259,
                "simple": 0.049823972929718345,
                "sql": 0.05972449897641978,
                "state": 0.06745689539051195,
                "statically": 0.15059325628100503,
                "step": 0.1349137907810239,
                "strong": 0.06633149422168255,
                "stuff": 0.05075936505759981,
                "style": 0.05972449897641978,
                "styles": 0.22588988442150756,
                "sure": 0.04736595766530019,
                "switching": 0.07529662814050252,
                "syntax": 0.12689073147757352,
                "tell": 0.11473272060572517,
                "time": 0.031744177944101525,
                "try": 0.04617852302386082,
                "typed": 0.22588988442150756,
                "types": 0.17728034767625303,
                "typing": 0.15059325628100503,
                "useful": 0.05212209314640958,
                "various": 0.06344536573878676,
                "vs": 0.06261062745931556,
                "want": 0.038033008792205475,
                "weak": 0.07765476681405972,
                "web": 0.04761711029931282,
                "worth": 0.054056129751853324,
                "write": 0.03970839629650102,
                "writing": 0.044884048150144705
            },
            "Max term": "language",
            "Max score": 0.34121422864022966
        }
    },
    {
        "ID": "1200",
        "Question": "Coming from a procedural/OO programming background, I tend to write Scheme programs in a procedural fashion. I would be intersted in learning Scheme or Lisp in a functional way from the ground up, to kind of reset my programmer's mind. Is there a tutorial or book out there that's the de-facto standard for describing best practices, design methodologies, and other helpful information on functional programming concepts? What about that book makes it special? ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "background": 0.1554864943857914,
                    "best": 0.1026084309979775,
                    "book": 0.2502165493714197,
                    "coming": 0.1630246887248128,
                    "concepts": 0.1630246887248128,
                    "describing": 0.1946451035048778,
                    "design": 0.11160073848870587,
                    "facto": 0.1946451035048778,
                    "fashion": 0.1946451035048778,
                    "functional": 0.26332735245787664,
                    "ground": 0.18767012793240162,
                    "helpful": 0.14281254881178923,
                    "information": 0.12964634431068617,
                    "kind": 0.1306387386411425,
                    "learning": 0.1196921825953517,
                    "lisp": 0.16030490486614504,
                    "makes": 0.10948075361825514,
                    "methodologies": 0.16030490486614504,
                    "mind": 0.13166367622893832,
                    "oo": 0.1946451035048778,
                    "practices": 0.1494176053231265,
                    "procedural": 0.37534025586480324,
                    "programmer": 0.10061681507940795,
                    "programming": 0.1652644001959025,
                    "programs": 0.13495701371814067,
                    "scheme": 0.3639423158617512,
                    "special": 0.16030490486614504,
                    "standard": 0.12775135225839596,
                    "tend": 0.14763095929214284,
                    "way": 0.08558968697173182,
                    "write": 0.09596422883862962
                },
                "Max term": "procedural",
                "Max score": 0.37534025586480324
            }
        ],
        "Best Answer": "Use it. If you do functional programming daily, maybe smaller applications or exercises from books, then you will be better on it. I have used it since the first programming lecture in university. At the beginning it was very hard, because it is so different, but now I prefer it to imperative programming. If you are looking for a good book, I would recommend Real World Functional Programming: With Examples in F# and C# by Tomas Petricek and Jon Skeet ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "applications": 0.17619112775622695,
                "beginning": 0.24288684198821758,
                "better": 0.12595820327735205,
                "book": 0.16191790392955832,
                "books": 0.18483116817439346,
                "daily": 0.20423207301793347,
                "different": 0.1355511782472043,
                "examples": 0.18483116817439346,
                "functional": 0.340804100003863,
                "good": 0.11015911201880409,
                "hard": 0.16654632121916782,
                "imperative": 0.223873064813453,
                "jon": 0.24288684198821758,
                "looking": 0.14893573208323285,
                "maybe": 0.16907555304326574,
                "prefer": 0.18294922268204075,
                "programming": 0.4277777044103499,
                "real": 0.15223997865739455,
                "recommend": 0.19583211955174645,
                "smaller": 0.23551110861228666,
                "university": 0.20423207301793347,
                "use": 0.0948871605970627,
                "used": 0.12292810585876927,
                "world": 0.1558383076364436
            },
            "Max term": "programming",
            "Max score": 0.4277777044103499
        }
    },
    {
        "ID": "1217",
        "Question": "I think weâ€™ve all seen this. Beginners ask questions on Stack Overflow that follow the basic outline...  Iâ€™m trying to do (very vague description of the goal) but it doesnâ€™t work/I get an error/exception. Please help!  Isnâ€™t it bizarre that so many of them seem to consider it unnecessary to paste the error message? I wonder what the psychology of this is. What is it about error messages that makes people initially assume that they are useless and not worth paying any attention to? The answer Iâ€™m looking for is not â€œthey donâ€™t understand the error messageâ€. That doesnâ€™t explain why they wouldnâ€™t consider telling anyone else who might understand it. ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "answer": 0.10386444286697255,
                    "ask": 0.10867814441564295,
                    "assume": 0.14713981619695815,
                    "attention": 0.15989125881820254,
                    "basic": 0.12633061229455408,
                    "consider": 0.2273818016962027,
                    "description": 0.15989125881820254,
                    "error": 0.5210943522361905,
                    "exception": 0.15280115486616058,
                    "explain": 0.11369090084810135,
                    "follow": 0.12758468918792853,
                    "goal": 0.1403361318091729,
                    "help": 0.09533646928840266,
                    "initially": 0.15612405985137456,
                    "looking": 0.10386444286697255,
                    "makes": 0.09881311898522702,
                    "message": 0.33876768415421377,
                    "messages": 0.16424017086328238,
                    "overflow": 0.13838969907095547,
                    "paying": 0.16938384207710688,
                    "people": 0.07857264447439377,
                    "psychology": 0.17567918686040418,
                    "questions": 0.11291791866597252,
                    "seen": 0.11979100551129164,
                    "stack": 0.13324602785713097,
                    "telling": 0.15989125881820254,
                    "think": 0.07458064683004213,
                    "trying": 0.10867814441564295,
                    "understand": 0.19233259262192004,
                    "unnecessary": 0.16424017086328238,
                    "useless": 0.14713981619695815,
                    "wonder": 0.1403361318091729,
                    "work": 0.07438540670993511,
                    "worth": 0.11790950280118216
                },
                "Max term": "error",
                "Max score": 0.5210943522361905
            }
        ],
        "Best Answer": "I think the real reason is that ordinary computer users, even if they should go on to become programmers, are conditioned to believe they can't do anything about errors. Think about it. What do non-programmer types do when they encounter a cryptic error message*? They might read it, but nine times out of ten they'll simply dismiss it and try again. Only if it consistently fails will they look it up. Therefore, when beginning to learn how to program, people don't immediately realise that the error they're getting contains useful information on how to fix it; and yea, though compiler errors can be nigh unreadable even to the trained professional (I'm looking at you, C++ template metaprogramming), at least they provide a general starting point, and once you've seen the same error a couple of times, you'll always know what you've done to cause it. *Honestly, though, most error messages look to Joe Average like \"Error X2412: Unable to establish frobnicatory interplatforming dongledash: please verify bandersnatch settings or contact your system administrator.\" ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "administrator": 0.13138514937313442,
                "average": 0.11226293508635218,
                "beginning": 0.13549986751548934,
                "believe": 0.10009861003763067,
                "cause": 0.1092493361819342,
                "compiler": 0.11574187970538252,
                "computer": 0.08914144264074543,
                "consistently": 0.13138514937313442,
                "contact": 0.1177055931454511,
                "contains": 0.11393543845280085,
                "couple": 0.10537093923108103,
                "cryptic": 0.14053587551743796,
                "encounter": 0.13138514937313442,
                "error": 0.5210666408999278,
                "errors": 0.20842665635997115,
                "fix": 0.10009861003763067,
                "general": 0.09917732017803696,
                "getting": 0.08541584564780681,
                "honestly": 0.12223442322883085,
                "immediately": 0.12223442322883085,
                "information": 0.09360606651418232,
                "joe": 0.14053587551743796,
                "know": 0.06128567615022421,
                "learn": 0.07626511950350326,
                "like": 0.050096506472494945,
                "look": 0.16195279150169686,
                "looking": 0.08308713555829193,
                "message": 0.13549986751548934,
                "messages": 0.13138514937313442,
                "non": 0.08308713555829193,
                "ordinary": 0.14053587551743796,
                "people": 0.06285477284058456,
                "point": 0.08057694341902559,
                "professional": 0.1092493361819342,
                "program": 0.08591187589137848,
                "programmer": 0.07264643160472001,
                "programmers": 0.07530461422557522,
                "provide": 0.10206232347769922,
                "read": 0.08445534036987877,
                "real": 0.08493048355266018,
                "realise": 0.14053587551743796,
                "reason": 0.08746893927429675,
                "seen": 0.09582770810534748,
                "settings": 0.12790620475410405,
                "simply": 0.09432258598257845,
                "starting": 0.10421332817998558,
                "template": 0.12489260584968609,
                "think": 0.11932268911564668,
                "times": 0.18582319466679134,
                "trained": 0.13549986751548934,
                "try": 0.08057694341902559,
                "types": 0.10311220894204864,
                "unable": 0.12489260584968609,
                "unreadable": 0.13549986751548934,
                "useful": 0.09094788389332709,
                "users": 0.09094788389332709,
                "verify": 0.14053587551743796
            },
            "Max term": "error",
            "Max score": 0.5210666408999278
        }
    },
    {
        "ID": "1224",
        "Question": "I've never found the ideal way to perform code reviews and yet often my customers require them. Each customer seems to do them in a different way and I've never felt satisfied in any of them.  What has been the most effective way for you to perform code reviews? For example:  Is one person regarded as the gatekeeper for quality and reviews the code, or do the team own the standard?   Do you do review code as a team exercise using a projector? Is it done in person, via email or using a tool?  Do you eschew reviews and use things like pair programming and collective code ownership to ensure code quality?  ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "code": 0.3337086550585421,
                    "customer": 0.1165829510646847,
                    "customers": 0.12516866194408066,
                    "different": 0.08549941298560443,
                    "effective": 0.13308283807039906,
                    "email": 0.13551485343035993,
                    "ensure": 0.1485495131677672,
                    "example": 0.084790566073972,
                    "exercise": 0.1412087734857678,
                    "felt": 0.15320178459863862,
                    "gatekeeper": 0.15889570465404648,
                    "ideal": 0.14461607371924262,
                    "like": 0.05664119334187645,
                    "ownership": 0.15320178459863862,
                    "pair": 0.12197489306451227,
                    "perform": 0.28923214743848524,
                    "person": 0.21669358302595296,
                    "programming": 0.06745559700837322,
                    "quality": 0.22635130166241973,
                    "require": 0.1111332132351991,
                    "review": 0.12352184231748911,
                    "reviews": 0.5323313522815962,
                    "satisfied": 0.15320178459863862,
                    "standard": 0.10428796189623359,
                    "team": 0.18992516089576283,
                    "things": 0.07551516867271946,
                    "tool": 0.1111332132351991,
                    "use": 0.0598504316659229,
                    "using": 0.14912231340810322,
                    "way": 0.20960969545506872
                },
                "Max term": "reviews",
                "Max score": 0.5323313522815962
            }
        ],
        "Best Answer": "I like code reviews, though they can be a pain.  The reason I like them is that they get more eyes on the code and a different perspective.  I believe that even with pair programming, code should be reviewed.  It's easy enough for two people working on the same code to collectively make the same mistake that a different set of eyes may not miss. If done as a group with a projector, it really should be reviewed individually before the meeting.  Otherwise, it is just an annoying waste of time.   I've only done code reviews via email and in a group.  Generally speaking, I don't think they should be done in person.  You feel a little more pressure to rush through the code with someone looking over your shoulder.  I do believe that a tool designed for code reviewing would be a good asset, as it can help with some of the mundane aspects and it should make it easier to flag problem bits of code then it is via email. The problem with having one person do all code reviews is that it can be a bottleneck.  With well documented and designed coding standards it should not be necessary.  Depending on the environment/release-schedule it may be a good idea to always have someone as a standby code reviewer. I do believe that code ownership is a good idea as this person can make it their priority to understand that code and potentially play a gatekeeper role. ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "annoying": 0.09399076940376706,
                "aspects": 0.10142182023079332,
                "believe": 0.2438619123250773,
                "bits": 0.11003568314518289,
                "code": 0.47936595421556427,
                "coding": 0.06480226429417618,
                "depending": 0.11003568314518289,
                "designed": 0.18504761715972526,
                "different": 0.12281823401770878,
                "documented": 0.10386908029276572,
                "easier": 0.07385625328133281,
                "easy": 0.07286535107717002,
                "email": 0.19466443569954983,
                "environment": 0.07490380847151593,
                "eyes": 0.19852636774429752,
                "feel": 0.06858383881295113,
                "flag": 0.11003568314518289,
                "gatekeeper": 0.1141252855262013,
                "generally": 0.07846214970194978,
                "good": 0.1497170416449794,
                "group": 0.18504761715972526,
                "help": 0.061932787674184954,
                "idea": 0.13217782727197394,
                "like": 0.08136396609034205,
                "little": 0.0723892924574284,
                "looking": 0.06747275764448966,
                "make": 0.15537231340957425,
                "meeting": 0.09558544660782133,
                "miss": 0.11003568314518289,
                "mistake": 0.09558544660782133,
                "necessary": 0.07912866774971454,
                "ownership": 0.11003568314518289,
                "pain": 0.10142182023079332,
                "pair": 0.0876072737669239,
                "people": 0.051042617201514186,
                "person": 0.23345706941898794,
                "perspective": 0.09926318387214876,
                "play": 0.09558544660782133,
                "pressure": 0.10669423469917504,
                "priority": 0.11003568314518289,
                "problem": 0.11890471230537707,
                "programming": 0.0484493226905169,
                "really": 0.0532195899562694,
                "reason": 0.07103109887492352,
                "release": 0.08990116702274865,
                "reviews": 0.28675633982346393,
                "role": 0.09926318387214876,
                "schedule": 0.10386908029276572,
                "set": 0.07192528725895898,
                "speaking": 0.10669423469917504,
                "standards": 0.08990116702274865,
                "think": 0.0484493226905169,
                "time": 0.04498104172182046,
                "tool": 0.07982034328445467,
                "understand": 0.062471862607187505,
                "waste": 0.10142182023079332,
                "working": 0.060899994648620996
            },
            "Max term": "code",
            "Max score": 0.47936595421556427
        }
    },
    {
        "ID": "1262",
        "Question": "I'm considering whether I should start using VIM again instead of an IDE. What are the most useful features of VIM that aren't standard in an IDE? ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "considering": 0.28648290150986316,
                    "features": 0.21557010734509574,
                    "ide": 0.5019283112962413,
                    "instead": 0.22135748155778634,
                    "standard": 0.22449715041979088,
                    "start": 0.1906182054647368,
                    "useful": 0.22135748155778634,
                    "using": 0.16050526741253346,
                    "vim": 0.6395549744388159
                },
                "Max term": "vim",
                "Max score": 0.6395549744388159
            }
        ],
        "Best Answer": "I don't think its necessarily the advanced features of VIM that make it so powerful. Its the fact that you never have to take your hands off the keyboard to do anything. Finding something in a huge file is as simple as a couple of keystrokes. Opening and closing multiple files in the same window is incredibly fast as well. While it may not seem intuitive at first, its well worth your time. Even if you don't use it as your standard IDE (I generally use Visual Studio or Eclipse, for example), you'll find your self using VIM to quickly open and edit files because it becomes way faster than waiting for the IDE to load. Invest the time to learn how to use VIM well and you'll never regret it. I'd say its comparable to learning to touch-type. ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "advanced": 0.1433824418431361,
                "couple": 0.12097067287106394,
                "eclipse": 0.1555600649182958,
                "edit": 0.10746405919568865,
                "example": 0.08609577230109725,
                "fact": 0.10913622880319322,
                "fast": 0.12385248861968105,
                "faster": 0.12097067287106394,
                "features": 0.10168249094712463,
                "file": 0.10746405919568865,
                "files": 0.22983559410351453,
                "finding": 0.1433824418431361,
                "generally": 0.11092380900802981,
                "hands": 0.1555600649182958,
                "huge": 0.11837754686409843,
                "ide": 0.23675509372819686,
                "incredibly": 0.1508361796992047,
                "invest": 0.16134163316685982,
                "keyboard": 0.14033072623154957,
                "keystrokes": 0.16134163316685982,
                "learn": 0.0875558563893826,
                "learning": 0.09921303885641336,
                "load": 0.1308031109343051,
                "make": 0.07321784615574578,
                "multiple": 0.11386011402228433,
                "necessarily": 0.12097067287106394,
                "open": 0.10041835554037469,
                "opening": 0.16134163316685982,
                "powerful": 0.1433824418431361,
                "quickly": 0.11602050118076146,
                "say": 0.08404921129498841,
                "self": 0.13513142150386082,
                "simple": 0.09980868891143352,
                "standard": 0.10589329729595734,
                "studio": 0.13287698837548098,
                "think": 0.06849396093665469,
                "time": 0.12718153912138974,
                "touch": 0.1508361796992047,
                "type": 0.11284391961058139,
                "use": 0.18231518111353112,
                "using": 0.07570889861141059,
                "vim": 0.4525085390976141,
                "visual": 0.1308031109343051,
                "waiting": 0.16134163316685982,
                "way": 0.07094542646901703,
                "window": 0.14684219165547727,
                "worth": 0.10828665642078322
            },
            "Max term": "vim",
            "Max score": 0.4525085390976141
        }
    },
    {
        "ID": "1280",
        "Question": "What best practices should be undertaken for a website that needs to \"scale out\" to handle capacity?  This is especially relevant now that people are considering the cloud, but may be missing out on the fundamentals. I'm interested in hearing about anything you consider a best practice from development-level tasks, to infrastructure, to management. ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "best": 0.28312223866308206,
                    "capacity": 0.268537180196209,
                    "consider": 0.17378401205815824,
                    "considering": 0.22491287694493095,
                    "development": 0.1357318387769431,
                    "especially": 0.19702771076175707,
                    "fundamentals": 0.268537180196209,
                    "handle": 0.20875458717275377,
                    "hearing": 0.25891433205647524,
                    "infrastructure": 0.2510518926389112,
                    "interested": 0.19913173903302003,
                    "level": 0.16416116391842456,
                    "management": 0.17624891293945413,
                    "missing": 0.22902303554474765,
                    "needs": 0.19310464150199352,
                    "people": 0.1201034497300974,
                    "practice": 0.19502158043320336,
                    "practices": 0.20614020945118172,
                    "relevant": 0.20134371235499623,
                    "scale": 0.2444042948307824,
                    "tasks": 0.19702771076175707,
                    "website": 0.20614020945118172
                },
                "Max term": "best",
                "Max score": 0.28312223866308206
            }
        ],
        "Best Answer": "Design for Concurrency That is, as you're coding, plan around having multiple threads going.  Plan the shared state (often just the db).  Plan for multiple processes. Plan for physical distribution. This allows you to distribute your system across multiple machines, and across multiple processes with load balancing.  It allows you to have redundant processes running in case of failure, and in case you need to modify the system in-place, you don't have to kill all service to do so. ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "allows": 0.23727128296731914,
                "case": 0.1989043838023955,
                "coding": 0.08665465223890138,
                "concurrency": 0.12781842926505924,
                "db": 0.13562292394041564,
                "design": 0.08749982110087545,
                "distribute": 0.15261020639717174,
                "failure": 0.1327363599444504,
                "going": 0.07888794857821692,
                "kill": 0.15261020639717174,
                "load": 0.1237243566044223,
                "machines": 0.13015424046179866,
                "modify": 0.13015424046179866,
                "multiple": 0.43079309810570227,
                "need": 0.07183758934782149,
                "physical": 0.13889544029332693,
                "place": 0.10581215426133367,
                "plan": 0.5027440028562199,
                "processes": 0.39046272138539595,
                "redundant": 0.14714152291855473,
                "running": 0.11197123461021019,
                "service": 0.1327363599444504,
                "shared": 0.14714152291855473,
                "state": 0.12781842926505924,
                "threads": 0.13562292394041564
            },
            "Max term": "plan",
            "Max score": 0.5027440028562199
        }
    },
    {
        "ID": "1323",
        "Question": "I recently saw that Microsoft released a coding standards document (All-In-One Code Framework Coding Standards) and it got me thinking...  The company that I work for has no formal coding standards at all.  There are only a few developers and we have been together long enough to have evolved into similar styles and its never been an issue. Does the company you work for have a documented coding standards?  If no, why not?  Does having a standard make a difference?  Is it worth writing a standard from scratch or should you adopt another standard as your own (ie. make Microsoft's standards yours)? ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "code": 0.05527743587598775,
                    "coding": 0.3586840970383286,
                    "company": 0.18673271230566207,
                    "developers": 0.09010454851734463,
                    "difference": 0.13006101955205043,
                    "document": 0.13226767606025217,
                    "documented": 0.14373026807321207,
                    "formal": 0.13735679556929858,
                    "framework": 0.1036491749129827,
                    "got": 0.1015047529182486,
                    "issue": 0.10768314329474443,
                    "long": 0.08760805398000265,
                    "make": 0.14333238338473148,
                    "microsoft": 0.23421240001463403,
                    "recently": 0.12440197602456517,
                    "released": 0.13735679556929858,
                    "saw": 0.13735679556929858,
                    "scratch": 0.1403438383122021,
                    "similar": 0.10291403499092718,
                    "standard": 0.31094752473894804,
                    "standards": 0.6220098801228259,
                    "styles": 0.14763961432945025,
                    "thinking": 0.0995276052299172,
                    "work": 0.13373382042491913,
                    "worth": 0.10599181325642139,
                    "writing": 0.08800744099810913
                },
                "Max term": "standards",
                "Max score": 0.6220098801228259
            }
        ],
        "Best Answer": "It's important for a team to have a single coding standard for each language to avoid several problems:  A lack of standards can make your code unreadable. Disagreement over standards can cause check-in wars between developers. Seeing different standards in the same class can be extremely irritating.  I'm a big fan of what Uncle Bob has to say about standards:   Let them evolve during the first few iterations. Let them be team specific instead of company specific. Don't write them down if you can avoid it. Rather, let the code be   the way the standards are captured. Don't legislate good design. (e.g. don't tell people not to use goto) Make sure everyone knows that the standard is about communication, and   nothing else. After the first few iterations, get the team together to decide.   ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "avoid": 0.20217727525161247,
                "big": 0.09074381281183469,
                "cause": 0.11333967685628302,
                "check": 0.0986217854715287,
                "class": 0.09711071665311904,
                "code": 0.10206678273484268,
                "coding": 0.08278633773142642,
                "communication": 0.12434407881923959,
                "company": 0.08619795253866472,
                "decide": 0.11485074567469267,
                "design": 0.08359377775962677,
                "developers": 0.08318657722812266,
                "different": 0.07845151640697515,
                "extremely": 0.12007530391490007,
                "fan": 0.14579759726261096,
                "good": 0.06375561980110832,
                "goto": 0.13269506636270956,
                "important": 0.0930871109041737,
                "instead": 0.09435301056718916,
                "iterations": 0.2811460780448071,
                "knows": 0.10811511861607562,
                "lack": 0.11820122874901981,
                "language": 0.06863071721947828,
                "let": 0.2850377631485226,
                "make": 0.1323277301304015,
                "people": 0.06520808172933287,
                "problems": 0.08811031625012426,
                "say": 0.07595171077730149,
                "seeing": 0.12007530391490007,
                "single": 0.09569128568321164,
                "specific": 0.19002517543234843,
                "standard": 0.19138257136642328,
                "standards": 0.5742537283734633,
                "sure": 0.08574330834269187,
                "team": 0.2614038451694406,
                "tell": 0.10384634371173611,
                "unreadable": 0.14057303902240356,
                "use": 0.05491683460556922,
                "way": 0.06411037568496954,
                "write": 0.07188135604696029
            },
            "Max term": "standards",
            "Max score": 0.5742537283734633
        }
    },
    {
        "ID": "1338",
        "Question": "Have you ever had to work to coding standards that:  Greatly decreased your productivity? Were originally included for good reasons but were kept long after the original concern became irrelevant? Were in a list so long that it was impossible to remember them all? Made you think the author was just trying to leave their mark rather than encouraging good coding practice? You had no idea why they were included?  If so, what is your least favorite rule and why?  Some examples here ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "author": 0.19161952894821094,
                    "coding": 0.250191035073409,
                    "concern": 0.21241496544108493,
                    "examples": 0.16164278755826422,
                    "favorite": 0.19161952894821094,
                    "good": 0.1926777406380044,
                    "greatly": 0.20596457011573,
                    "idea": 0.12757928977915908,
                    "impossible": 0.18144156026495473,
                    "included": 0.3832390578964219,
                    "irrelevant": 0.20051083857655852,
                    "kept": 0.20051083857655852,
                    "leave": 0.17354691442279063,
                    "list": 0.14786382606250778,
                    "long": 0.244435143760296,
                    "mark": 0.22030961128324905,
                    "original": 0.17126359158169852,
                    "originally": 0.1845199553228737,
                    "practice": 0.15999694547209845,
                    "productivity": 0.20596457011573,
                    "reasons": 0.1554742998973703,
                    "remember": 0.15408670147385028,
                    "rule": 0.17598782872578325,
                    "standards": 0.17354691442279063,
                    "think": 0.09352748954510991,
                    "trying": 0.13628728695232542,
                    "work": 0.09328264964269249
                },
                "Max term": "included",
                "Max score": 0.3832390578964219
            }
        ],
        "Best Answer": "Had a professor once who demanded we have at least one comment for each line of code. //Set x to 3 var x = 3;  //if x is greater than 2 if(x>2){      //Print x     Print(x); }  It was pretty ridiculous. ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "code": 0.12069655851590129,
                "comment": 0.2839841828448656,
                "greater": 0.3324623658257755,
                "line": 0.23512278744275353,
                "pretty": 0.2159480961610452,
                "print": 0.6447329934100773,
                "professor": 0.3448187110041498,
                "set": 0.2173154242452562,
                "var": 0.3324623658257755
            },
            "Max term": "print",
            "Max score": 0.6447329934100773
        }
    },
    {
        "ID": "1371",
        "Question": "Having worked on a failed project is one of the few things that most programmers have in common, regardless of language used, industry or experience. These projects can be great learning experiences, soul-crushing disasters (or both!), and can occur for a multitude of reasons:  upper management change of heart under-skilled / under-resourced team emergence of superior competitor during dev cycle over/under management  Once you've worked on a couple of such projects, is it possible to recognise at an early stage exactly when a project is doomed to fail?  For me, a big sign is having a hard & fast external deadline combined with feature creep. I've seen projects which were well planned out and proceeding right on schedule go horribly off the rails once the late feature requests started to roll in and get added to the final \"deliverable\". The proposers of these requests earned the nickname of Columbo, due to rarely leaving the room without asking for \"just one more thing\". What are the warning signs you look out for that set off the alarm bells of impending doom in your head? ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "added": 0.11791640840326632,
                    "asking": 0.10264263296182034,
                    "big": 0.09052515447457717,
                    "change": 0.08997555210889509,
                    "combined": 0.14544628008510058,
                    "common": 0.08840032457231967,
                    "couple": 0.10905266063776196,
                    "creep": 0.14544628008510058,
                    "cycle": 0.13597582229013502,
                    "deadline": 0.12404445652346047,
                    "dev": 0.1292564255503396,
                    "doomed": 0.14544628008510058,
                    "early": 0.11165056033853872,
                    "exactly": 0.11618546680430368,
                    "experience": 0.08339234830803544,
                    "experiences": 0.11791640840326632,
                    "external": 0.13597582229013502,
                    "fail": 0.11031550996040851,
                    "failed": 0.1292564255503396,
                    "fast": 0.11165056033853872,
                    "feature": 0.18217600307487733,
                    "final": 0.13237532133906468,
                    "great": 0.08997555210889509,
                    "hard": 0.09615798214620544,
                    "head": 0.11618546680430368,
                    "horribly": 0.14023431105822146,
                    "industry": 0.10671500900933817,
                    "language": 0.068465343095921,
                    "late": 0.13237532133906468,
                    "learning": 0.08943858540640999,
                    "leaving": 0.14023431105822146,
                    "look": 0.08380575773478172,
                    "management": 0.19092141160755546,
                    "occur": 0.13597582229013502,
                    "possible": 0.08553669933374436,
                    "programmers": 0.07793580089088654,
                    "project": 0.13736523858778893,
                    "projects": 0.253965592892046,
                    "rails": 0.1265053644951695,
                    "rarely": 0.11031550996040851,
                    "reasons": 0.10264263296182034,
                    "regardless": 0.1292564255503396,
                    "requests": 0.24808891304692093,
                    "right": 0.08339234830803544,
                    "roll": 0.14544628008510058,
                    "room": 0.13237532133906468,
                    "schedule": 0.13237532133906468,
                    "seen": 0.09917598351087373,
                    "set": 0.09166474745393849,
                    "sign": 0.1265053644951695,
                    "signs": 0.13597582229013502,
                    "soul": 0.14544628008510058,
                    "stage": 0.13597582229013502,
                    "started": 0.09478364324266357,
                    "superior": 0.13597582229013502,
                    "team": 0.0869246535235068,
                    "thing": 0.08298612897611275,
                    "things": 0.06912333091293706,
                    "upper": 0.13597582229013502,
                    "used": 0.07097436029751202,
                    "warning": 0.13597582229013502,
                    "worked": 0.19092141160755546
                },
                "Max term": "projects",
                "Max score": 0.253965592892046
            }
        ],
        "Best Answer": "Heroic Coding Coding late into the night, working long hours, and clocking lots of overtime are a sure sign that something went wrong.  Further, my experience is that if you see someone working late at any point in the project, it only ever gets worse.  He might be doing it just to get his one feature back on schedule, and he might succeed; however, cowboy coding like that is almost always the result of a planning failure that will inevitably cause more of it soon.  So, the earlier in the project you see it, the worse it will eventually become. ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "cause": 0.152939117941288,
                "coding": 0.33513249255921224,
                "cowboy": 0.18968747036109845,
                "earlier": 0.17905703428471048,
                "eventually": 0.16202808739752356,
                "experience": 0.11280038015415121,
                "failure": 0.1711170568537591,
                "feature": 0.12320987967567458,
                "gets": 0.15715788186588503,
                "hours": 0.14012893497869813,
                "inevitably": 0.183927239816349,
                "late": 0.35811406856942096,
                "like": 0.07013054522440537,
                "long": 0.10914081310363713,
                "lots": 0.14750971553556655,
                "night": 0.19673742277893888,
                "planning": 0.14750971553556655,
                "point": 0.11280038015415121,
                "project": 0.18580662910982249,
                "result": 0.16202808739752356,
                "schedule": 0.17905703428471048,
                "sign": 0.1711170568537591,
                "soon": 0.15715788186588503,
                "succeed": 0.19673742277893888,
                "sure": 0.11570092937469166,
                "went": 0.1510237558497633,
                "working": 0.20996763231177465,
                "worse": 0.335576635884546,
                "wrong": 0.1273187520161082
            },
            "Max term": "late",
            "Max score": 0.35811406856942096
        }
    },
    {
        "ID": "1376",
        "Question": "I have a tester that while testing will have an error occur (ok so far), but then he frequently reports it right away.  We (the developers) then later find that the tester has not tried to reproduce the issue and (when asked) cannot find a way to make it happen again. Now these are still bugs, I don't want to ignore them.  But without repro steps I am kind of stuck.  Sometimes there is a stack trace (though frequently it is not useful because this is compact framework and there are no line numbers).  But when there is one I can take the stack trace and crack open the code and start guessing, but that does not lead to testable \"fixes\". What do you do in scenarios like this? ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "asked": 0.11925341874245093,
                    "away": 0.12506623959417656,
                    "bugs": 0.12201426530887344,
                    "code": 0.06313819734802659,
                    "crack": 0.18037988897424845,
                    "developers": 0.10291792077704226,
                    "error": 0.13375935858036636,
                    "far": 0.12201426530887344,
                    "fixes": 0.16863479570275552,
                    "framework": 0.1183886690275879,
                    "frequently": 0.28818229782596416,
                    "happen": 0.13681133286566946,
                    "ignore": 0.1568897024312626,
                    "issue": 0.1229962903426354,
                    "kind": 0.12106444368498907,
                    "later": 0.1352451696026633,
                    "lead": 0.14022314984306217,
                    "like": 0.06429961205446863,
                    "line": 0.1229962903426354,
                    "make": 0.08185752617768717,
                    "numbers": 0.151076881579537,
                    "occur": 0.16863479570275552,
                    "ok": 0.13846703859318105,
                    "open": 0.11226768607589603,
                    "reproduce": 0.17391609771155267,
                    "right": 0.10342170676557724,
                    "scenarios": 0.16863479570275552,
                    "stack": 0.2736226657313389,
                    "start": 0.10052259280440311,
                    "steps": 0.14855642613716238,
                    "stuck": 0.16863479570275552,
                    "testable": 0.17391609771155267,
                    "tester": 0.32833903695715044,
                    "testing": 0.10608109275821229,
                    "trace": 0.3607597779484969,
                    "tried": 0.1352451696026633,
                    "useful": 0.11673296330007632,
                    "want": 0.08517896253822703,
                    "way": 0.07931696176942243
                },
                "Max term": "trace",
                "Max score": 0.3607597779484969
            }
        ],
        "Best Answer": "A bug without context is not a bug, it's a fluke. The problem could be your code, it could be a third party library, it could be the hardware, or it could be solar radiation causing a single bit to flip on it's own. If you can't reproduce it with at least some regularity (even if only \"it happens once every 10 or 20 times I do X\"), it's not much better than your tester telling you \"Something somewhere went wrong somehow - fix it\". You may have to explain to your tester that his job is not to just generate input until something breaks. If it were, you could replace him with a random number generator. Part of his job is to identify bugs, which entails identifying how to produce them. ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "10": 0.14968646796461504,
                "20": 0.1670997952709356,
                "better": 0.10305722147026457,
                "bit": 0.13626584584687979,
                "breaks": 0.17578387580019397,
                "bug": 0.2909105388510945,
                "bugs": 0.13942054863522926,
                "causing": 0.20611248217484068,
                "code": 0.07214535195386752,
                "context": 0.16974915500987597,
                "explain": 0.13338582784491126,
                "fix": 0.14680644996264655,
                "generate": 0.1792712379393702,
                "happens": 0.1623632536824587,
                "hardware": 0.1582204379109826,
                "identify": 0.19269186005710545,
                "input": 0.1726291730118445,
                "job": 0.22868332397184568,
                "library": 0.14968646796461504,
                "number": 0.129081156852154,
                "party": 0.16974915500987597,
                "problem": 0.10737210988146888,
                "produce": 0.1582204379109826,
                "random": 0.18758957632964415,
                "replace": 0.1792712379393702,
                "reproduce": 0.19872658084742342,
                "single": 0.1352777328637531,
                "telling": 0.18758957632964415,
                "tester": 0.3751791526592883,
                "times": 0.13626584584687979,
                "went": 0.1582204379109826,
                "wrong": 0.13338582784491126
            },
            "Max term": "tester",
            "Max score": 0.3751791526592883
        }
    },
    {
        "ID": "1380",
        "Question": "We are starting a push for code coverage here at my work, and it has got me to thinking.... How much code coverage is enough? When do you get to the point of diminishing returns on code coverage?  What is the sweet spot between good coverage and not enough?  Does it vary by the type of project your are making (ie WPF, WCF, Mobile, ASP.NET)  (These are C# classes we are writing.) ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "asp": 0.1695369376784234,
                    "classes": 0.16670850825369937,
                    "code": 0.21255912586370684,
                    "coverage": 0.7195549291619171,
                    "good": 0.0885161554732812,
                    "got": 0.13010589950734236,
                    "making": 0.1358572855721099,
                    "mobile": 0.20242047410389638,
                    "net": 0.12374294168701509,
                    "point": 0.11605878590551182,
                    "project": 0.0955869641494649,
                    "push": 0.16670850825369937,
                    "returns": 0.20242047410389638,
                    "spot": 0.18422936144830296,
                    "starting": 0.15010338976057488,
                    "thinking": 0.12757164794715778,
                    "type": 0.14157486359204446,
                    "vary": 0.20242047410389638,
                    "work": 0.08570809987070757,
                    "wpf": 0.18924025006711648,
                    "writing": 0.11280542974790894
                },
                "Max term": "coverage",
                "Max score": 0.7195549291619171
            }
        ],
        "Best Answer": "I'm of the opinion that code coverage alone is a poor metric.  It's easy to produce tons of useless tests that cover the code, but don't adequately check the output, or don't test edge cases, for example.  Covering code just means it doesn't throw an exception, not that it's right.  You need quality tests- the quantity isn't that important. ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "adequately": 0.24512253043243556,
                "cases": 0.16995549390414824,
                "check": 0.1658080933048773,
                "code": 0.2574000037737065,
                "cover": 0.20530197525459373,
                "coverage": 0.2178375554673028,
                "easy": 0.15650290953956147,
                "edge": 0.22309387159611713,
                "example": 0.13080327223509594,
                "exception": 0.21320115605699916,
                "important": 0.15650290953956147,
                "means": 0.15863120612673365,
                "metric": 0.24512253043243556,
                "need": 0.11538554397388275,
                "opinion": 0.17626720563845855,
                "output": 0.19872607529323846,
                "poor": 0.20905375545772825,
                "produce": 0.1881661590682752,
                "quality": 0.1745918933144519,
                "right": 0.1405422223518433,
                "test": 0.13852311833974457,
                "tests": 0.3109608262807751,
                "throw": 0.22309387159611713,
                "tons": 0.24512253043243556,
                "useless": 0.20530197525459373
            },
            "Max term": "tests",
            "Max score": 0.3109608262807751
        }
    },
    {
        "ID": "1386",
        "Question": "Sometimes I feel like a musician who can't play live shows. Programming is a pretty cool skill, and a very broad world, but a lot of it happens \"off camera\"- in your head, in your office, away from spectators.  You can of course talk about programming with other programmers, and there is peer programming, and you do get to create something that you can show to people, but when it comes to explaining to non programmers what is it that you do, or how was your day at work, it's sort of tricky.  How do you get the non programmers in your life to understand what is it that you do?  NOTE: this is not a repeat of Getting non-programmers to understand the development process, because that question was about managing client expectations.  ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "away": 0.13096688979175816,
                    "client": 0.13096688979175816,
                    "comes": 0.14499994116772555,
                    "cool": 0.1765910190913488,
                    "course": 0.13330139764311716,
                    "create": 0.12140933747260235,
                    "day": 0.11981246186733097,
                    "development": 0.0954743797420311,
                    "expectations": 0.16786457715501898,
                    "explaining": 0.18212149398519323,
                    "feel": 0.11351400591909852,
                    "getting": 0.11480499357395303,
                    "happens": 0.1487965938066895,
                    "head": 0.15088939813724947,
                    "life": 0.14683890609760222,
                    "like": 0.06733328061126505,
                    "live": 0.15556534803393204,
                    "lot": 0.09690210826570762,
                    "managing": 0.16786457715501898,
                    "non": 0.33502512296766546,
                    "note": 0.14162606375385414,
                    "office": 0.16786457715501898,
                    "people": 0.0844813013010411,
                    "play": 0.15820471906817463,
                    "pretty": 0.11829546420516568,
                    "process": 0.11547169362818582,
                    "programmers": 0.40485910719204626,
                    "programming": 0.24056731722178445,
                    "question": 0.09690210826570762,
                    "repeat": 0.16786457715501898,
                    "shows": 0.16786457715501898,
                    "skill": 0.15820471906817463,
                    "sort": 0.13859016901616253,
                    "talk": 0.15088939813724947,
                    "understand": 0.20679598880750524,
                    "work": 0.07997918357845876,
                    "world": 0.11685073252444872
                },
                "Max term": "programmers",
                "Max score": 0.40485910719204626
            }
        ],
        "Best Answer": "I don't even try. If they aren't tech oriented enough to have at least a basic understanding of programming, I am only going to bore them with the details. Usually I just go with something very high level like \"I create web sites\" or \"I write computer programs to do X\" ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "basic": 0.2608256931050015,
                "computer": 0.23006710961749943,
                "create": 0.2331334730758373,
                "details": 0.2784327843634954,
                "going": 0.18749477289347502,
                "high": 0.24343923640675807,
                "level": 0.22173184977278146,
                "like": 0.12929517522518844,
                "oriented": 0.2719541742697251,
                "programming": 0.15398127617959498,
                "programs": 0.25148614192860685,
                "sites": 0.2751034522677027,
                "tech": 0.2987207626067987,
                "try": 0.20796280523459326,
                "understanding": 0.2897418779342074,
                "usually": 0.23637027543928607,
                "web": 0.21444141532836355,
                "write": 0.1788248940079867
            },
            "Max term": "tech",
            "Max score": 0.2987207626067987
        }
    },
    {
        "ID": "1474",
        "Question": "I've read Peopleware in 2009. It was one of the best book I ever read. But this book is a little old. I'd like to know, in your opinion, what is and what is not relevant in this book? ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "2009": 0.3383035815211637,
                    "best": 0.17833893108959242,
                    "book": 0.6523345818927604,
                    "know": 0.14752933129159893,
                    "like": 0.1205943144335432,
                    "little": 0.21458484672538747,
                    "old": 0.23874361260685975,
                    "opinion": 0.24327354514094587,
                    "read": 0.406608547753683,
                    "relevant": 0.2536531401599331
                },
                "Max term": "book",
                "Max score": 0.6523345818927604
            }
        ],
        "Best Answer": "It's been a while since I read it, but I don't remember anything in the book that wasn't relevant to someone. What stood out the most was the discussion of process improvement using CMM and CMMI, and no mention of agile processes (although the second edition was printed in 1999, which is a few years before the Manifesto for Agile Software Development and agile development went mainstream). But the book is about people, and people haven't changed that much since the first printing of the book in 1987. ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "agile": 0.49002711951513456,
                "book": 0.4380002710389465,
                "changed": 0.18145116528051994,
                "development": 0.22962431651915668,
                "discussion": 0.1870742015443045,
                "improvement": 0.22714886580100915,
                "mainstream": 0.19372484185721722,
                "manifesto": 0.22714886580100915,
                "mention": 0.1902481617806317,
                "people": 0.20318499185138375,
                "process": 0.13885981138774953,
                "processes": 0.19372484185721722,
                "read": 0.13650560545642143,
                "relevant": 0.17031159656992514,
                "remember": 0.1588701431178323,
                "second": 0.1684405438132757,
                "software": 0.10726420135133323,
                "using": 0.10658867220489918,
                "went": 0.17436883316718255,
                "years": 0.13358584507389074
            },
            "Max term": "agile",
            "Max score": 0.49002711951513456
        }
    },
    {
        "ID": "1483",
        "Question": "I've heard it said (by coworkers) that everyone \"codes in English\" regardless of where they're from. I find that difficult to believe, however I wouldn't be surprised if, for most programming languages, the supported character set is relatively narrow. Have you ever worked in a country where English is not the primary language? If so, what did their code look like? ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "believe": 0.1969178761569759,
                    "character": 0.23578655770249382,
                    "code": 0.09677169828006796,
                    "country": 0.2665606057933364,
                    "coworkers": 0.2665606057933364,
                    "difficult": 0.20078096955911043,
                    "english": 0.4809286164202572,
                    "heard": 0.2177848935739614,
                    "language": 0.13014049980906853,
                    "languages": 0.15133761217839078,
                    "like": 0.09855179461272572,
                    "look": 0.15929991299688656,
                    "primary": 0.22084800917857167,
                    "programming": 0.11736811584675835,
                    "regardless": 0.24569358837635083,
                    "said": 0.1753625105861657,
                    "set": 0.17423846152080869,
                    "supported": 0.2764676364671934,
                    "surprised": 0.258465972338661,
                    "worked": 0.18145390651186602
                },
                "Max term": "english",
                "Max score": 0.4809286164202572
            }
        ],
        "Best Answer": "I'm from Canada, but live in the States now. It took me a while to get used to writing boolean variables with an \"Is\" prefix, instead of the \"Eh\" suffix that Canadians use when programming. For example: MyObj.IsVisible  MyObj.VisibleEh  ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "example": 0.24586495601652364,
                "instead": 0.2981718564891746,
                "live": 0.37945875888413855,
                "prefix": 0.4607456612791025,
                "programming": 0.1955992058958913,
                "took": 0.400744507082458,
                "use": 0.17354670962185212,
                "used": 0.22483303491849382,
                "variables": 0.38589677653746574,
                "writing": 0.2567655893266836
            },
            "Max term": "prefix",
            "Max score": 0.4607456612791025
        }
    },
    {
        "ID": "1516",
        "Question": "A few years ago I considered myself somewhat of a web developer, knowing the basic 3 languages (HTML, CSS, JS) and lots of PHP. Moving on from simple text to actual websites was a pain because of the so called \"standards\" out there, which at the time were ridiculously complicated for me. It pretty much boiled down to this (minus the IE related stuff):  Standards are there to replace old ways of doing things in a simpler way. However when trying to actually implement some of the stuff (Entirely CSS based layout for example), it took me 10x longer to actually do it then if I did the simpler and still working solution. If it rendered the same, then why should I use the more complicated example that takes 10x longer and breaks once you change browsers? This sparked many long religious debates in ##php, ##css, and ##js in Freenode IRC and actually got me banned from ##css because I messed with their little world over there. My question: Should I follow every single standard and coding conventions even if they take me 10x longer but get me the same result as the simple one?  For the poll tag, those of you who have websites of any size (huge or small), do you follow all the standards?  ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "10x": 0.31882234238227364,
                    "actual": 0.08804911912022954,
                    "actually": 0.1818073306640356,
                    "ago": 0.08004866139178494,
                    "based": 0.07037444958734755,
                    "basic": 0.07926183362086703,
                    "breaks": 0.0940049166995621,
                    "browsers": 0.10627411412742453,
                    "called": 0.08682789629031812,
                    "change": 0.06818639476560653,
                    "coding": 0.06258699936663496,
                    "complicated": 0.17365579258063624,
                    "considered": 0.0836006752348228,
                    "conventions": 0.10304689307192923,
                    "css": 0.4012732661923679,
                    "developer": 0.06087268865564787,
                    "entirely": 0.0940049166995621,
                    "example": 0.11763625756033531,
                    "follow": 0.1600973227835699,
                    "got": 0.0708464965027541,
                    "html": 0.0836006752348228,
                    "huge": 0.08087209871098558,
                    "implement": 0.08004866139178494,
                    "js": 0.21254822825484906,
                    "knowing": 0.09231785881964738,
                    "languages": 0.060336262444149476,
                    "layout": 0.1102239134811732,
                    "little": 0.069914665028015,
                    "long": 0.06114712376972349,
                    "longer": 0.24793094104562996,
                    "lots": 0.08264364701520999,
                    "moving": 0.09586987266268523,
                    "old": 0.07778591991795099,
                    "pain": 0.09795471605331078,
                    "php": 0.15557183983590198,
                    "pretty": 0.06902944506219867,
                    "question": 0.056545690943294806,
                    "related": 0.08264364701520999,
                    "replace": 0.09586987266268523,
                    "result": 0.09077769564406679,
                    "simple": 0.13637278953121307,
                    "simpler": 0.20609378614385845,
                    "single": 0.07234322233068372,
                    "size": 0.0940049166995621,
                    "small": 0.0658743247592859,
                    "solution": 0.07515878040687429,
                    "somewhat": 0.08936088286512141,
                    "standard": 0.07234322233068372,
                    "standards": 0.26048368887095436,
                    "stuff": 0.13893304368767448,
                    "tag": 0.10304689307192923,
                    "takes": 0.07234322233068372,
                    "text": 0.08682789629031812,
                    "things": 0.05238390450151203,
                    "time": 0.04344336514190545,
                    "took": 0.09586987266268523,
                    "trying": 0.06818639476560653,
                    "use": 0.04151747724155711,
                    "way": 0.048467852937366336,
                    "ways": 0.07397829570837389,
                    "web": 0.06516620192143972,
                    "websites": 0.19173974532537047,
                    "working": 0.05881812878016766,
                    "world": 0.06818639476560653,
                    "years": 0.06482248800939655
                },
                "Max term": "css",
                "Max score": 0.4012732661923679
            }
        ],
        "Best Answer": "The standards writers have thought of things that haven't occurred to you, such as accessibility concerns. Standards exist for a reason. And, with HTML5, standards are fairly easy to follow. There may, occasionally, be reason to not follow the standard, but following it should be your default behaviour. ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "behaviour": 0.24233544751345926,
                "concerns": 0.2287545215886702,
                "default": 0.2287545215886702,
                "easy": 0.1604739204300958,
                "exist": 0.19294057424744637,
                "fairly": 0.19799249588603832,
                "follow": 0.36506779361100633,
                "following": 0.18073970391528732,
                "occasionally": 0.21435815997053953,
                "reason": 0.3128685648366591,
                "standard": 0.16496328670452665,
                "standards": 0.593977487658115,
                "things": 0.1194503199966017,
                "thought": 0.17426784259584405
            },
            "Max term": "standards",
            "Max score": 0.593977487658115
        }
    },
    {
        "ID": "1533",
        "Question": "If you're developer (Senior or Lead Developer) and you'd rather stay with code/design than pursue a management career, what are the available career paths at your company, or any you've heard of? How far can you go? Is it possible to continue being a geek until you bite the dust or is that too naive? Are people like Uncle Bob for example still considered developers, as they claim? ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "available": 0.19031511743240398,
                    "bite": 0.26465065765758233,
                    "career": 0.3874150357650156,
                    "claim": 0.24981914615370004,
                    "code": 0.09607831403383366,
                    "company": 0.16228108168351552,
                    "considered": 0.2081877968419062,
                    "continue": 0.2340971104003336,
                    "design": 0.15737831673854025,
                    "developer": 0.3031781957135167,
                    "developers": 0.15661169826596166,
                    "example": 0.14647270025883752,
                    "far": 0.18567088373358265,
                    "geek": 0.2744867029181594,
                    "heard": 0.21622443099083136,
                    "lead": 0.21337960840366196,
                    "like": 0.09784565569982977,
                    "management": 0.18015376109301776,
                    "people": 0.12276437810743328,
                    "possible": 0.1614251431173354,
                    "senior": 0.22989588998940175,
                    "stay": 0.21622443099083136
                },
                "Max term": "career",
                "Max score": 0.3874150357650156
            }
        ],
        "Best Answer": "At my company, the management and individual contributor tracks are separate and mostly parallel.  Individual contributors can rise very high in the company (up to Technical Fellow) without being a people manager.  It helps to partially avoid the Peter Principle, though never completely. ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "avoid": 0.20069390943179463,
                "company": 0.34226208773407507,
                "completely": 0.21464376544533892,
                "fellow": 0.2572359952803581,
                "helps": 0.22501621721546392,
                "high": 0.19427222386445792,
                "individual": 0.5412168227914623,
                "management": 0.18997840581655873,
                "manager": 0.21954127138131577,
                "people": 0.1294593057753005,
                "peter": 0.2894557733452523,
                "principle": 0.27060841139573116,
                "separate": 0.23838863333083696,
                "technical": 0.18480826969123632
            },
            "Max term": "individual",
            "Max score": 0.5412168227914623
        }
    },
    {
        "ID": "1588",
        "Question": "Use of desktops are decreasing day by day in daily life but for coding purpose are there any reasons for using desktop over laptop?  ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "coding": 0.2283284253937467,
                    "daily": 0.32600428016789307,
                    "day": 0.5101220873128496,
                    "desktop": 0.34294653564624733,
                    "laptop": 0.36597893312310137,
                    "life": 0.31259590242035074,
                    "purpose": 0.30499002558664107,
                    "reasons": 0.2837767714126594,
                    "use": 0.1514630881943035,
                    "using": 0.18869142192277805
                },
                "Max term": "day",
                "Max score": 0.5101220873128496
            }
        ],
        "Best Answer": "Assuming you have an external monitor and keyboard to connect to your laptop the difference is small.  It is always better to work in a desktop like setting (bigger screen realestate, more ergonomic environment), but you can't take your work with you without a laptop. So if portability is important, get a laptop and a good external screen and keyboard to connect it to. Otherwise you might as well stay with a desktop.  ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "assuming": 0.1634413003345355,
                "better": 0.0975721889417182,
                "bigger": 0.16972985347837016,
                "desktop": 0.3328561996489079,
                "difference": 0.16071456603455533,
                "environment": 0.12807782242021581,
                "external": 0.36487237495429337,
                "good": 0.08533359012658515,
                "important": 0.1245922695559246,
                "keyboard": 0.3394597069567403,
                "laptop": 0.5328163904675253,
                "like": 0.06956201435529216,
                "monitor": 0.17760546348917508,
                "screen": 0.3164124272650313,
                "setting": 0.16071456603455533,
                "small": 0.11662516261724426,
                "stay": 0.15372176582567743,
                "work": 0.16525299423116194
            },
            "Max term": "laptop",
            "Max score": 0.5328163904675253
        }
    },
    {
        "ID": "1620",
        "Question": "I am excited about the changes in PHP 6 previewed in PHP 5.3+. However, I wonder why it takes so long to release PHP 6? Books about it have been published since 2008, and announcements on it since 2007, but I am yet to hear about an alpha or a beta. Why does it take so long to release it? Or is that the way it goes with all languages when they transition to a major release where I guess it takes around 4-5 years to release? ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "2008": 0.1805192366110235,
                    "alpha": 0.18617273536237727,
                    "beta": 0.17573927152489482,
                    "books": 0.14167306832092474,
                    "changes": 0.12861191504460942,
                    "goes": 0.13885217953773088,
                    "guess": 0.1565438595653605,
                    "hear": 0.17573927152489482,
                    "languages": 0.10569805368879441,
                    "long": 0.21423706770402678,
                    "major": 0.15010529623720548,
                    "php": 0.4087999491514946,
                    "published": 0.17573927152489482,
                    "release": 0.6084261286336287,
                    "takes": 0.25346408571485673,
                    "transition": 0.18617273536237727,
                    "way": 0.08490677934677221,
                    "wonder": 0.15424589033229877,
                    "years": 0.11355709718016842
                },
                "Max term": "release",
                "Max score": 0.6084261286336287
            }
        ],
        "Best Answer": "The release timetable is not unusual for languages, and it's not even that unusual for PHP: 5.0 was released in 2004, but 4.0 was released in 2000.  Compare this to the last stable releases for C (2000), Fortran (2003), or C++ (2003). One other thing to keep in mind is that 5.3 was a major release in all but name. It adds a lot of stuff that was originally destined for PHP 6. Due to development problems with unicode support (a major part of PHP 6), it was decided to release what was stable at the time as a 5.x branch. ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "branch": 0.1779409299043252,
                "compare": 0.18351368128481377,
                "decided": 0.1732292357474931,
                "development": 0.09620421242683662,
                "fortran": 0.18351368128481377,
                "languages": 0.10418839740048427,
                "lot": 0.09764285490402008,
                "major": 0.2959227669853939,
                "mind": 0.12874763918191304,
                "originally": 0.15941407989542908,
                "php": 0.40296117168720486,
                "problems": 0.11502524670931014,
                "release": 0.4498021089316358,
                "released": 0.3310953641173779,
                "releases": 0.1779409299043252,
                "stable": 0.3806683554999229,
                "stuff": 0.11995448989891702,
                "support": 0.1258344349211606,
                "thing": 0.10859746027247286,
                "time": 0.07501781529820437
            },
            "Max term": "release",
            "Max score": 0.4498021089316358
        }
    },
    {
        "ID": "1674",
        "Question": "i wonder apart from those very simple hello world apps, what other programs should i try developing for learning. i am entering uni next year and wonder what kind of programs will be developed in that environment.  this is not really a language specific thing, but if you want to know what i use currently mainly  windows: C#/WPF - i studied java/vb etc in poly but i think C# is the way to go, maybe even F# web: PHP/MySQL, Zend Framework/Doctrine, + HTML/CSS/JS(jQuery) of course. looking to try google app engine with python too.   for now, i am thinking of   todo lists apps that integrate with api eg. twitter/tumblr which i use text editor - i am currently trying to develop a text editor that uses markdown and generates html files for viewing (link to blog entry). not very pratical after i started developing it. cos when editing theres no formatting and in HTML format, i cannot edit directly  blog software (for web)  ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "apart": 0.11388998810690712,
                    "api": 0.12356278576171097,
                    "app": 0.0835154457944696,
                    "apps": 0.20190611487190077,
                    "blog": 0.2077962204738056,
                    "course": 0.09044013245384565,
                    "css": 0.11663809910233491,
                    "currently": 0.19006497023986305,
                    "develop": 0.09503248511993152,
                    "developed": 0.1073361270048764,
                    "developing": 0.1843122955611301,
                    "directly": 0.11663809910233491,
                    "edit": 0.08535968746512768,
                    "editing": 0.11981056042292598,
                    "editor": 0.2185952708816425,
                    "engine": 0.10554541010203626,
                    "entry": 0.12815513842779683,
                    "environment": 0.08411201688719948,
                    "files": 0.09128025978114655,
                    "format": 0.11146598241805512,
                    "formatting": 0.11981056042292598,
                    "framework": 0.08411201688719948,
                    "generates": 0.12356278576171097,
                    "google": 0.09215614778056505,
                    "hello": 0.12356278576171097,
                    "html": 0.2916024962914962,
                    "integrate": 0.12815513842779683,
                    "java": 0.07789099745967533,
                    "jquery": 0.10929763544082124,
                    "js": 0.12356278576171097,
                    "kind": 0.08601308398271028,
                    "know": 0.055886614586882204,
                    "language": 0.06032595345051512,
                    "learning": 0.07880582636309695,
                    "link": 0.10554541010203626,
                    "lists": 0.11146598241805512,
                    "looking": 0.07576743888232862,
                    "mainly": 0.12356278576171097,
                    "maybe": 0.08601308398271028,
                    "mysql": 0.12356278576171097,
                    "php": 0.09044013245384565,
                    "programs": 0.1777125081845891,
                    "python": 0.08668790711506066,
                    "really": 0.059762075393453865,
                    "simple": 0.07927895666280507,
                    "software": 0.060517399125248506,
                    "specific": 0.0835154457944696,
                    "started": 0.0835154457944696,
                    "studied": 0.12356278576171097,
                    "text": 0.20190611487190077,
                    "theres": 0.12815513842779683,
                    "thing": 0.07312045959716632,
                    "think": 0.05440538113449626,
                    "thinking": 0.0807673347990418,
                    "try": 0.14695677242459934,
                    "trying": 0.07927895666280507,
                    "twitter": 0.12356278576171097,
                    "use": 0.09654307990023335,
                    "uses": 0.10095305743595039,
                    "vb": 0.11388998810690712,
                    "want": 0.060517399125248506,
                    "way": 0.05635260268224119,
                    "web": 0.15153487776465724,
                    "windows": 0.09215614778056505,
                    "wonder": 0.20474589756289038,
                    "world": 0.07927895666280507,
                    "wpf": 0.11981056042292598,
                    "year": 0.09307097668398667
                },
                "Max term": "html",
                "Max score": 0.2916024962914962
            }
        ],
        "Best Answer": "Have a look at Project Euler.  There's nothing else like it for sharpening your foundational programming skills. ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "euler": 0.6395679625279995,
                "like": 0.2364586856199084,
                "look": 0.3822137201522418,
                "programming": 0.28160532759315166,
                "project": 0.3132414781475625,
                "skills": 0.4599249930903479
            },
            "Max term": "euler",
            "Max score": 0.6395679625279995
        }
    },
    {
        "ID": "1701",
        "Question": "I am currently reading the recently published Being Geek by Michael \"Rands\" Lopp and I can't get enough of it.  Is there any other career guidance books aimed directly or indirectly at programmers that are worth reading? ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "books": 0.2531097108121169,
                    "career": 0.2434507328176042,
                    "currently": 0.2558126300371382,
                    "directly": 0.3139715735755576,
                    "geek": 0.3449736474071473,
                    "indirectly": 0.3449736474071473,
                    "programmers": 0.18485036180502834,
                    "published": 0.3139715735755576,
                    "reading": 0.46306761742480296,
                    "recently": 0.27174988742417255,
                    "worth": 0.23153380871240148
                },
                "Max term": "reading",
                "Max score": 0.46306761742480296
            }
        ],
        "Best Answer": " Code complete  The Pragmatic Programmer   ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "code": 0.27918012076652754,
                "complete": 0.5530092612757972,
                "pragmatic": 0.6680213217351826,
                "programmer": 0.412294471002418
            },
            "Max term": "pragmatic",
            "Max score": 0.6680213217351826
        }
    },
    {
        "ID": "1719",
        "Question": "In chapter one of \"The Pragmatic Programmer\" the first learning goal is:  Learn at least one new language every year. Different languages solve the same problems in different ways. By learning several different approaches, you can help broaden your thinking and avoid getter struck in a rut. [...]  To achieve this over a career, the list of languages is likely to get quite long (particularly if you do not want to \"progress\" into management). Clearly the education of a programmer (or whatever form) is going to get you started with a core of commercially useful languages (the usual list from job posting: C, C++, Ruby, Python, JavaScript, C#, Java, VB, ...). Additionally a formal or informal learning programme is likely to have covered functional approaches (via something like Haskell, LISP or an ML derived language) But once a reasonable subset of that list is learned- what's next, and why? ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "achieve": 0.1439644728194907,
                    "additionally": 0.1439644728194907,
                    "approaches": 0.25468795268179506,
                    "avoid": 0.1035274795582981,
                    "career": 0.10537287509486878,
                    "chapter": 0.13269458110833315,
                    "clearly": 0.11762160915755251,
                    "core": 0.1250585995086176,
                    "covered": 0.13269458110833315,
                    "derived": 0.1439644728194907,
                    "different": 0.24103266060044,
                    "education": 0.1395927104035813,
                    "form": 0.10737222498276908,
                    "formal": 0.12987034322023625,
                    "functional": 0.10100111267895936,
                    "goal": 0.11927594146929989,
                    "going": 0.07718461589635993,
                    "haskell": 0.12297221392498812,
                    "help": 0.0810293613208309,
                    "java": 0.09075172850417593,
                    "javascript": 0.12105292523950234,
                    "job": 0.0828330916725537,
                    "language": 0.1405729732022236,
                    "languages": 0.24520396954583168,
                    "learn": 0.0810293613208309,
                    "learned": 0.1107234798623044,
                    "learning": 0.2754528196542939,
                    "like": 0.05322600882680939,
                    "likely": 0.20200222535791873,
                    "lisp": 0.12297221392498812,
                    "list": 0.3006446046392051,
                    "long": 0.0828330916725537,
                    "management": 0.09799991230613783,
                    "new": 0.07073469232079012,
                    "particularly": 0.12105292523950234,
                    "posting": 0.13589643794789305,
                    "pragmatic": 0.1250585995086176,
                    "problems": 0.09023604609477166,
                    "programmer": 0.15436923179271986,
                    "progress": 0.12987034322023625,
                    "python": 0.10100111267895936,
                    "quite": 0.09533290978701138,
                    "reasonable": 0.1395927104035813,
                    "ruby": 0.11927594146929989,
                    "solve": 0.10635171744639499,
                    "started": 0.09730484022327114,
                    "thinking": 0.09410298338371124,
                    "useful": 0.09662935026304995,
                    "usual": 0.1395927104035813,
                    "vb": 0.13269458110833315,
                    "want": 0.07050954223608037,
                    "ways": 0.10021486821306837,
                    "year": 0.10843810303002445
                },
                "Max term": "list",
                "Max score": 0.3006446046392051
            }
        ],
        "Best Answer": "Make it interesting and spend each year writing an interpreter or compiler for your own programming language that fills up a niche you've never used a programming language for. Each year, write your next compiler/interpreter using the language you wrote the previous year. ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "compiler": 0.4344092430389009,
                "interesting": 0.18445797989135004,
                "language": 0.372439006329646,
                "make": 0.11968403827598073,
                "niche": 0.24656124227038104,
                "previous": 0.19153316326638548,
                "programming": 0.22392447395894338,
                "spend": 0.18445797989135004,
                "used": 0.1286958677621452,
                "using": 0.12375598566455966,
                "write": 0.13002642696245106,
                "writing": 0.14697426622309068,
                "wrote": 0.20502052305570678,
                "year": 0.5745994897991564
            },
            "Max term": "year",
            "Max score": 0.5745994897991564
        }
    },
    {
        "ID": "1745",
        "Question": "To put it another way... What is the most commonly held and frustrating misunderstanding about programming, you have encountered? Which widespread and longstanding myths/misconceptions do you find hard for programmers to dispel/correct. Please, explain why this is a myth. ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "commonly": 0.366064649702315,
                    "correct": 0.2872907236966706,
                    "encountered": 0.3479751572297804,
                    "explain": 0.25339854174862547,
                    "frustrating": 0.39156035737185513,
                    "hard": 0.25886983036826167,
                    "held": 0.366064649702315,
                    "misunderstanding": 0.37752905692483263,
                    "programmers": 0.20981334160655082,
                    "programming": 0.16622814146447615,
                    "way": 0.17217760845012303
                },
                "Max term": "frustrating",
                "Max score": 0.39156035737185513
            }
        ],
        "Best Answer": "That because you're a programmer, you know how to fix [person]'s virus ridden machine. ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "fix": 0.41479855013717,
                "know": 0.2539616644200393,
                "machine": 0.4470485340681047,
                "person": 0.39710036303324203,
                "programmer": 0.3010394898685269,
                "virus": 0.5614977927073519
            },
            "Max term": "virus",
            "Max score": 0.5614977927073519
        }
    },
    {
        "ID": "1750",
        "Question": "I work for a company that supports several languages: COBOL, VB6, C#, and Java. I use those languages for my primary work, but I often find myself coding some minor programs (e.g. scripts) in Python because I find it to be the best tool for that type of task. For example: an analyst gives me a complex CSV file to populate some DB tables, so I use Python to parse it and create a DB script. What's the problem? The main problem I see is that a few parts of these quick and dirty scripts are slowly gaining importance and:  My company does not support Python They're not version controlled (I back them up in another way) My coworkers do not know Python  The analysts have even started to reference them in emails (\"launch the script that exports...\"), so they are needed more often than I initially thought. I should add that these scripts are just utilities that are not part of the main project; they simply help to get trivial tasks done in less time. For my own small tasks they help a lot. In short, if I were a lottery winner to be in a accident, my coworkers would need to keep the project alive without those scripts; they would spend more time fixing CSV errors by hand, for example. Is this a common scenario? Am I doing something wrong? What should I do? ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "accident": 0.11219030912178694,
                    "add": 0.07809660830363645,
                    "best": 0.06133992510684024,
                    "cobol": 0.11219030912178694,
                    "coding": 0.06607116759899567,
                    "common": 0.07072206270630374,
                    "company": 0.13758790459722056,
                    "complex": 0.08537418380956226,
                    "coworkers": 0.2243806182435739,
                    "create": 0.07479046433931634,
                    "db": 0.2068155536122581,
                    "dirty": 0.1163599906486993,
                    "emails": 0.10590295705135758,
                    "errors": 0.08628588143664642,
                    "example": 0.12418497399846545,
                    "file": 0.07750334912098852,
                    "fixing": 0.09923809527921668,
                    "gives": 0.09433553179293598,
                    "hand": 0.08287900356433373,
                    "help": 0.12629100661415732,
                    "initially": 0.10340777680612905,
                    "java": 0.07072206270630374,
                    "know": 0.0507429201083566,
                    "languages": 0.1273902679018537,
                    "launch": 0.11219030912178694,
                    "lot": 0.059693544364216956,
                    "main": 0.17650931601535777,
                    "minor": 0.09745712023550059,
                    "need": 0.05477367092331332,
                    "needed": 0.08067809860845383,
                    "parts": 0.09583121740690397,
                    "primary": 0.09295074320878731,
                    "problem": 0.12123300413354492,
                    "programs": 0.08067809860845383,
                    "project": 0.10989499262668899,
                    "python": 0.31483728814968537,
                    "quick": 0.10120687185024915,
                    "reference": 0.09745712023550059,
                    "scenario": 0.10340777680612905,
                    "script": 0.2243806182435739,
                    "scripts": 0.4487612364871478,
                    "short": 0.083674276548874,
                    "simply": 0.07809660830363645,
                    "slowly": 0.10340777680612905,
                    "small": 0.06954149576887533,
                    "spend": 0.08138331795036574,
                    "started": 0.07582884783930469,
                    "support": 0.07692834699370525,
                    "supports": 0.10590295705135758,
                    "tables": 0.10878343124947422,
                    "task": 0.07692834699370525,
                    "tasks": 0.1707483676191245,
                    "thought": 0.08067809860845383,
                    "time": 0.09172364511487933,
                    "tool": 0.08138331795036574,
                    "trivial": 0.10120687185024915,
                    "type": 0.08138331795036574,
                    "use": 0.08765744403387249,
                    "utilities": 0.1163599906486993,
                    "vb6": 0.11219030912178694,
                    "version": 0.083674276548874,
                    "way": 0.051166019572674415,
                    "work": 0.09853740085950476,
                    "wrong": 0.07530244416510863
                },
                "Max term": "scripts",
                "Max score": 0.4487612364871478
            }
        ],
        "Best Answer": "You need to get the situation formalised as it shouldn't really have got to this point. However, these things happen so you need to explain to your boss that you created these scripts for personal use, but they've \"escaped\" into wider circulation. Admit (if necessary) that you were at fault for not bringing this to his attention sooner. At the very least the scripts should be put under source control \"just in case\" - then at least if you aren't available (for what ever reason) your co-workers will have access to the scripts. Then you either need to convince your boss that Python is the way to go for these or accept that you are going to have to re-write them in a supported language. If the cost of documenting the scripts and educating your co-workers in Python is lower than that of the re-write you might even win the argument. ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "accept": 0.12517408927875776,
                "access": 0.10275024577843501,
                "admit": 0.14409742188448582,
                "argument": 0.13972162221053494,
                "attention": 0.1360219363018098,
                "available": 0.10362308565707384,
                "boss": 0.22165146272222205,
                "bringing": 0.13972162221053494,
                "case": 0.09739469980649905,
                "control": 0.10030741516417792,
                "convince": 0.14409742188448582,
                "cost": 0.10853824401707036,
                "created": 0.11773023097691157,
                "explain": 0.09671858604127329,
                "fault": 0.14945296785642181,
                "going": 0.07725589474949959,
                "got": 0.0960609982912168,
                "happen": 0.11335443130296069,
                "language": 0.07035139513369905,
                "lower": 0.12746157662279844,
                "necessary": 0.10362308565707384,
                "need": 0.21105418540109713,
                "personal": 0.10965474539423557,
                "point": 0.08568960267571035,
                "python": 0.20218877143044833,
                "really": 0.06969380738364252,
                "reason": 0.09301890013254817,
                "scripts": 0.5763896875379433,
                "situation": 0.10965474539423557,
                "sooner": 0.14409742188448582,
                "source": 0.08883434012748766,
                "supported": 0.14945296785642181,
                "things": 0.0710275088989248,
                "use": 0.05629368433486068,
                "way": 0.06571772166622666,
                "wider": 0.14945296785642181,
                "win": 0.1360219363018098,
                "workers": 0.29890593571284363,
                "write": 0.14736706497861227
            },
            "Max term": "scripts",
            "Max score": 0.5763896875379433
        }
    },
    {
        "ID": "1752",
        "Question": "In fact this question is about cautions to be taken to enhance quality user experience and reduce avoidable support calls. ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "calls": 0.381823288003969,
                    "experience": 0.2740544192069887,
                    "fact": 0.3233223436351216,
                    "quality": 0.34045057150694114,
                    "question": 0.2452092860684236,
                    "reduce": 0.40033459446507264,
                    "support": 0.31600645003847516,
                    "taken": 0.39365570688915247,
                    "user": 0.2888614702341419
                },
                "Max term": "reduce",
                "Max score": 0.40033459446507264
            }
        ],
        "Best Answer": "A lack of proper input validation is one of those things which tends to lead quite quickly to users doing \"bad\" things with your application, when it should really be handled by the programmer. I've seen legacy apps where users have been trained to:  not enter apostrophes in names not enter any symbol other than a-z0-9, ensure there are no spaces before or after the text they've entered check that a correctly formatted email address is being entered in to the email field, otherwise subsequent mailings to that user will use whatever's in the field and will fail make sure \"http://\" is put before web addresses  etc etc All of the above issues are ones which should be handled by an application developer. When your input validation is essentially \"make sure the user knows what format this field should be in and trust what they've entered is right\", then unexpected things are bound to find their way in to the app. Aside from the obvious security implications, users make mistakes. As programmers we often produce our best products by bending over backwards to make sure that the user can't get it wrong, no matter how hard they try! ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "address": 0.11448612744121325,
                "app": 0.0798039833616019,
                "application": 0.14042595007286732,
                "apps": 0.09646666002056982,
                "aside": 0.1114546516700507,
                "backwards": 0.12245986880037632,
                "bad": 0.07240030121849561,
                "best": 0.06455551550779136,
                "bound": 0.11807160226753823,
                "check": 0.08283545913276447,
                "correctly": 0.11448612744121325,
                "developer": 0.0676301650963432,
                "email": 0.20888080275946574,
                "ensure": 0.11448612744121325,
                "enter": 0.24491973760075264,
                "essentially": 0.10882866791257097,
                "fail": 0.09288118519424485,
                "field": 0.3076981896741492,
                "format": 0.10651238608205019,
                "formatted": 0.12245986880037632,
                "handled": 0.2229093033401014,
                "hard": 0.08096112097774799,
                "http": 0.09288118519424485,
                "implications": 0.12245986880037632,
                "input": 0.2051321264494328,
                "issues": 0.09080920049192753,
                "knows": 0.09080920049192753,
                "lack": 0.09928083340479199,
                "lead": 0.09519746702476563,
                "legacy": 0.10651238608205019,
                "make": 0.22229222942861512,
                "matter": 0.08893486233691106,
                "mistakes": 0.1114546516700507,
                "names": 0.09646666002056982,
                "obvious": 0.09519746702476563,
                "ones": 0.0849074438350818,
                "produce": 0.09400524346546403,
                "products": 0.10444040137973287,
                "programmer": 0.0633025015881134,
                "programmers": 0.06561878341863416,
                "proper": 0.10444040137973287,
                "quickly": 0.08806068882454017,
                "quite": 0.07818671639559671,
                "really": 0.057106222986476725,
                "right": 0.07021297503643366,
                "security": 0.0898497094230823,
                "seen": 0.08350215572226255,
                "spaces": 0.12245986880037632,
                "sure": 0.2160552948875439,
                "tends": 0.1114546516700507,
                "text": 0.09646666002056982,
                "things": 0.1745971233439005,
                "trained": 0.11807160226753823,
                "trust": 0.10444040137973287,
                "try": 0.07021297503643366,
                "unexpected": 0.10882866791257097,
                "use": 0.046126331894322595,
                "user": 0.2220196622688154,
                "users": 0.2377499529193185,
                "way": 0.053848268713119186,
                "web": 0.07240030121849561,
                "wrong": 0.0792499843064395
            },
            "Max term": "field",
            "Max score": 0.3076981896741492
        }
    },
    {
        "ID": "1785",
        "Question": "Please, stay on technical issues, avoid behavior, cultural, career or political issues. ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "avoid": 0.2680283737132051,
                    "behavior": 0.3296883013712647,
                    "career": 0.2728060266284982,
                    "cultural": 0.37271808110191895,
                    "issues": 0.573317043281221,
                    "political": 0.35183027165343306,
                    "stay": 0.3045174938145407,
                    "technical": 0.24681297062942234
                },
                "Max term": "issues",
                "Max score": 0.573317043281221
            }
        ],
        "Best Answer": " The bug is in your code, not the compiler or the runtime libraries. If you see a bug that cannot possibly happen, check that you have correctly built and deployed your program.  (Especially if you are using a complicated IDE or build framework that tries to hide the messy details from you ... or if your build involves lots of manual steps.) Concurrent / multi-threaded programs are hard to write and harder to properly test.  It is best to delegate as much as you can to concurrency libraries and frameworks. Writing the documentation is part of your job as a programmer.  Don't leave it for \"someone else\" to do.  EDIT Yes, my point #1 is overstated.  Even the best engineered application platforms do have their share of bugs, and some of the less well engineered ones are rife with them.  But even so, you should always suspect your code first, and only start blaming compiler / library bugs when you have clear evidence that your code is not at fault.   Back in the days when I did C / C++ development, I remember cases where supposed optimizer \"bugs\" turned out to be a due to me / some other programmer having done things that the language spec says have undefined results.  This applies even for supposedly safe languages like Java; e.g. take a long hard look at the Java memory model (JLS chapter 17). ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "application": 0.07413841589050772,
                "best": 0.1363293224438722,
                "bug": 0.18250504668632575,
                "bugs": 0.26239977937750053,
                "build": 0.17097493034287092,
                "built": 0.10329252782944169,
                "cases": 0.08965441757707578,
                "chapter": 0.11491302053965721,
                "check": 0.08746659312583352,
                "clear": 0.10649348621879673,
                "code": 0.13578288581647022,
                "compiler": 0.21298697243759346,
                "complicated": 0.10185988211526562,
                "concurrency": 0.10830028848172804,
                "concurrent": 0.11768581681887379,
                "correctly": 0.12088677520822882,
                "days": 0.08889923884000961,
                "deployed": 0.12467270542555818,
                "details": 0.09926085360027218,
                "development": 0.06535773982962088,
                "documentation": 0.0929839530128242,
                "edit": 0.08612644256079303,
                "engineered": 0.2586126190581786,
                "especially": 0.09487299350858124,
                "evidence": 0.11768581681887379,
                "fault": 0.1293063095290893,
                "framework": 0.08486756461084008,
                "frameworks": 0.09807395189793625,
                "happen": 0.09807395189793625,
                "hard": 0.17097493034287092,
                "harder": 0.11246724088736834,
                "hide": 0.12467270542555818,
                "ide": 0.09487299350858124,
                "java": 0.1571813280467842,
                "job": 0.07173315357136094,
                "language": 0.0608678395982116,
                "languages": 0.07078191275402461,
                "leave": 0.10185988211526562,
                "libraries": 0.18974598701716247,
                "library": 0.09390699949229595,
                "like": 0.04609352842046855,
                "long": 0.07173315357136094,
                "look": 0.07450594985057753,
                "lots": 0.0969512392008003,
                "manual": 0.12088677520822882,
                "memory": 0.10830028848172804,
                "model": 0.0969512392008003,
                "multi": 0.10483138925677611,
                "ones": 0.08965441757707578,
                "platforms": 0.10830028848172804,
                "point": 0.07413841589050772,
                "possibly": 0.10649348621879673,
                "program": 0.07904705880497305,
                "programmer": 0.13368318853356642,
                "programs": 0.08965441757707578,
                "properly": 0.11768581681887379,
                "remember": 0.09043810026734404,
                "results": 0.10329252782944169,
                "runtime": 0.12088677520822882,
                "safe": 0.1293063095290893,
                "says": 0.09926085360027218,
                "share": 0.10051973155022512,
                "spec": 0.11768581681887379,
                "start": 0.07206017019828864,
                "steps": 0.10649348621879673,
                "supposed": 0.10329252782944169,
                "suspect": 0.11768581681887379,
                "test": 0.07307330413640144,
                "things": 0.061452811426185916,
                "threaded": 0.12088677520822882,
                "turned": 0.1102794164361261,
                "using": 0.060676454587694884,
                "write": 0.06375079595884742,
                "writing": 0.07206017019828864,
                "yes": 0.08426563473647848
            },
            "Max term": "bugs",
            "Max score": 0.26239977937750053
        }
    },
    {
        "ID": "1849",
        "Question": "If you've always loved unit testing, good for you! But for the unfortunate ones who weren't born with a liking for it, how have you managed to make this task more enjoyable ?  This is not a \"what is the right way to unit test\" question. I simply want to know little personal tricks that reduce the boredom (dare I say) of writing unit tests. ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "good": 0.12931506927599448,
                    "know": 0.12895934241184906,
                    "little": 0.1875743656056903,
                    "make": 0.1341996959823336,
                    "managed": 0.23295094894621854,
                    "ones": 0.20503736326895197,
                    "personal": 0.21697211314443704,
                    "question": 0.1517066856027114,
                    "reduce": 0.24767999382150063,
                    "right": 0.16955266368283825,
                    "say": 0.1540523136852369,
                    "simply": 0.19847669842268528,
                    "task": 0.19550764953917177,
                    "test": 0.1671167803036286,
                    "testing": 0.1739125412454292,
                    "tests": 0.1875743656056903,
                    "tricks": 0.26280314315205355,
                    "unit": 0.5741266167260725,
                    "want": 0.13964495887534562,
                    "way": 0.13003461810699465,
                    "writing": 0.16479976886210815
                },
                "Max term": "unit",
                "Max score": 0.5741266167260725
            }
        ],
        "Best Answer": "Firstly, I agree with you - if you are writing your unit tests on already completed code, or you are manually unit testing your code, I find that extremely boring too. I find there are two ways of unit testing for me that really make it enjoyable:  By using Test Driven Development (TDD) - writing the tests first allows me to think about the next piece of functionality or behaviour that I need in my code. I find driving towards my end goal in tiny steps and seeing tangible progress towards that goal every few minutes extremely rewarding and enjoyable. When there are bugs, rather than going straight to the debugger, it's a fun challenge to figure out a way to write a failing unit test that reproduces the bug. It's extremely satisfying to finally figure out the circumstances that make your code fail, then fix it and watch the bar turn green for the new failing test (and stay green for all of your existing tests).  ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "agree": 0.10018679928554601,
                "allows": 0.10018679928554601,
                "bar": 0.11209473717458103,
                "behaviour": 0.1242597758890297,
                "boring": 0.12048638508363203,
                "bug": 0.09095028507823931,
                "bugs": 0.08717689427284166,
                "challenge": 0.12048638508363203,
                "circumstances": 0.11453241613911452,
                "code": 0.18044421087495363,
                "completed": 0.11453241613911452,
                "development": 0.06514126789918291,
                "driven": 0.09893209087604415,
                "driving": 0.1242597758890297,
                "end": 0.07182149909076295,
                "existing": 0.09267598006484723,
                "extremely": 0.31842230469019056,
                "fail": 0.09774912032101252,
                "failing": 0.24097277016726407,
                "figure": 0.19549824064202503,
                "finally": 0.10991415903546117,
                "fix": 0.09179515137649502,
                "fun": 0.09893209087604415,
                "functionality": 0.09455876385338248,
                "goal": 0.20590082352486694,
                "going": 0.06662020764934201,
                "green": 0.23459205723200396,
                "make": 0.11697132113140926,
                "minutes": 0.10295041176243347,
                "need": 0.06066623870482449,
                "new": 0.0610530976373699,
                "piece": 0.11453241613911452,
                "progress": 0.11209473717458103,
                "really": 0.06009917993735467,
                "rewarding": 0.12048638508363203,
                "satisfying": 0.12887803299268305,
                "seeing": 0.10614076823006352,
                "stay": 0.10152251112641017,
                "steps": 0.10614076823006352,
                "straight": 0.11453241613911452,
                "tdd": 0.10018679928554601,
                "test": 0.21849383225781946,
                "testing": 0.15158588521300773,
                "tests": 0.24524073465306415,
                "think": 0.05471226976030698,
                "turn": 0.10614076823006352,
                "unit": 0.33361401386977596,
                "using": 0.06047548758224196,
                "watch": 0.11453241613911452,
                "way": 0.05667047515068798,
                "ways": 0.08649826461364717,
                "write": 0.06353964640098106,
                "writing": 0.1436429981815259
            },
            "Max term": "unit",
            "Max score": 0.33361401386977596
        }
    },
    {
        "ID": "1877",
        "Question": "As an example, say there's an interface that contains a table/grid of information that is periodically updated.  The table is meant to represent an event that has happened, perhaps the date and time of a stock price change. The actual frequency of these events could be dozens of events per second.  This is obviously too much information for a user to process/understand, so I'm trying to find out how much information a user COULD process in a given amount of time so that we can throttle the data and come up with an alternate display. I know some studies have been done on this, but I can't seem to find an authoritative source. ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "actual": 0.1428813848332105,
                    "alternate": 0.17245592857907846,
                    "change": 0.11064922180073751,
                    "come": 0.11913606571971706,
                    "contains": 0.14501004463488573,
                    "data": 0.10934337135882854,
                    "date": 0.14501004463488573,
                    "display": 0.16721896745806566,
                    "dozens": 0.17245592857907846,
                    "event": 0.1627911799203289,
                    "events": 0.3449118571581569,
                    "example": 0.0954469025627949,
                    "given": 0.12401620532493417,
                    "grid": 0.17886545098107223,
                    "happened": 0.1473091723709473,
                    "information": 0.3574081971591512,
                    "interface": 0.13730449355980404,
                    "know": 0.07800065330599248,
                    "meant": 0.15254613349196006,
                    "obviously": 0.1408996499689535,
                    "price": 0.1555724839350591,
                    "process": 0.2186867427176571,
                    "represent": 0.17886545098107223,
                    "say": 0.09317805818498104,
                    "second": 0.13263633840484165,
                    "source": 0.10631702091572948,
                    "stock": 0.17886545098107223,
                    "table": 0.3255823598406578,
                    "time": 0.14099512261592045,
                    "trying": 0.11064922180073751,
                    "understand": 0.09791044839311089,
                    "updated": 0.1555724839350591,
                    "user": 0.21618863065043
                },
                "Max term": "information",
                "Max score": 0.3574081971591512
            }
        ],
        "Best Answer": "There is research into this topic but it will give you a complex answer.  You can increase how much a person can take in from a UI if you use different sensory modalities rather than just one.  For example using sights and sounds you may be able to pump more information into a user than using just sight or just sound.  There are also findings that suggest that if your user has to really process or think about the inputs there are more significant bottlenecks that are more difficult to avoid even if you cross sensory modalities.  Training helps.  Expert users can process more but in the typical cases you will run into limits. But to get down to your question of how fast you can change the display in particular table:  You can look into the Psychology literature on the topic of \"Attentional Blink\"  and \"Psychological Refractory Period (PRP)\"  but the general advice that I can give you from that is don't push faster than changes every 500ms for a single watched location.  Typical users can need that much time to process even simple single location changing input.  If you're doing it continuously 500ms is a speedy but perhaps roughly workable rate.  You may be able to push down to 250ms but this will depend on what percentage of your users you're willing to put off.  Also if your users are having to scan multiple locations for possible changes you may have to slow down even from a 500ms change rate.  This doesn't necessarily mean 1000ms if you have two locations.  It's not a linear relationship but the answer for that is going to be more complex and depend a lot more on what your UI looks like exactly. Wikipedia: Attentional Blink ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "able": 0.14018182635105378,
                "advice": 0.09314764659766106,
                "answer": 0.13150388070738564,
                "avoid": 0.07711057949580206,
                "cases": 0.07711057949580206,
                "change": 0.13759855966337897,
                "changes": 0.14815242963494082,
                "changing": 0.08884053785377678,
                "complex": 0.16319801534952494,
                "continuously": 0.11121464764053231,
                "cross": 0.10122001546146407,
                "depend": 0.22242929528106462,
                "different": 0.059842946097059244,
                "difficult": 0.08076816898997377,
                "display": 0.10397311746151798,
                "exactly": 0.08884053785377678,
                "example": 0.059346808333738836,
                "expert": 0.09673158728250367,
                "fast": 0.08537294814039444,
                "faster": 0.08338647932415326,
                "general": 0.07848508914127066,
                "going": 0.057489571709100455,
                "helps": 0.08645569242515772,
                "increase": 0.09673158728250367,
                "information": 0.07407621481747041,
                "input": 0.09314764659766106,
                "inputs": 0.10722934599858877,
                "like": 0.039644434524968346,
                "limits": 0.10722934599858877,
                "literature": 0.11121464764053231,
                "location": 0.18969973678180296,
                "locations": 0.20794623492303596,
                "look": 0.06408158263840219,
                "looks": 0.08435210967481636,
                "lot": 0.057053944967424094,
                "mean": 0.07407621481747041,
                "multiple": 0.07848508914127066,
                "necessarily": 0.08338647932415326,
                "need": 0.05235162428042747,
                "particular": 0.07247575860414596,
                "percentage": 0.10722934599858877,
                "period": 0.10122001546146407,
                "person": 0.07583433590815467,
                "possible": 0.06540513701120797,
                "process": 0.20396199127555667,
                "psychology": 0.11121464764053231,
                "push": 0.18318727970766138,
                "question": 0.057053944967424094,
                "rate": 0.18629529319532212,
                "really": 0.05186228378111049,
                "relationship": 0.10722934599858877,
                "research": 0.09314764659766106,
                "run": 0.06879927983168949,
                "scan": 0.11121464764053231,
                "significant": 0.10397311746151798,
                "simple": 0.06879927983168949,
                "single": 0.14598694106541427,
                "slow": 0.09314764659766106,
                "sound": 0.10722934599858877,
                "sounds": 0.08537294814039444,
                "suggest": 0.10397311746151798,
                "table": 0.10122001546146407,
                "think": 0.047213676851754496,
                "time": 0.043833850513765774,
                "topic": 0.20794623492303596,
                "training": 0.09673158728250367,
                "typical": 0.19346317456500733,
                "ui": 0.18629529319532212,
                "use": 0.041890652005676245,
                "user": 0.1344213890933082,
                "users": 0.2878905282685163,
                "using": 0.10437403312526157,
                "wikipedia": 0.09159363985383069,
                "willing": 0.08884053785377678
            },
            "Max term": "users",
            "Max score": 0.2878905282685163
        }
    },
    {
        "ID": "1885",
        "Question": "As programmers I think we are the most inclined to use new technologies and things that are not so mainstream. I absolutely love OpenId's ability to log in with credentials you already have, but I always use a provider that I already use and that is the fastest to log in, like google. God knows I'd never used it if i had to type in the whole \"https://www.google.com/accounts/o8/id\" I like to click on the google button and then just say yes (the first time, then its just clicking the button). Does any of you ever uses the Generic \"Enter your own provider\" OpenId? Do you think its worth to even offer it to more casual end users? ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "ability": 0.1266638051232375,
                    "absolutely": 0.14067593034050432,
                    "button": 0.3416224980094823,
                    "casual": 0.17081124900474115,
                    "click": 0.15179797982611687,
                    "com": 0.1327847106474926,
                    "end": 0.09519015522049908,
                    "enter": 0.17081124900474115,
                    "fastest": 0.1596891995191286,
                    "generic": 0.17081124900474115,
                    "god": 0.17081124900474115,
                    "google": 0.3684902587358807,
                    "inclined": 0.1596891995191286,
                    "knows": 0.1266638051232375,
                    "like": 0.12177740110608534,
                    "log": 0.28135186068100865,
                    "love": 0.14567707430186175,
                    "mainstream": 0.14567707430186175,
                    "new": 0.0809180247470074,
                    "offer": 0.14067593034050432,
                    "programmers": 0.09152734249764324,
                    "provider": 0.32938068696097206,
                    "say": 0.08898230715386893,
                    "technologies": 0.14856715003351606,
                    "things": 0.08117803000323223,
                    "think": 0.14502814663803795,
                    "time": 0.06732309919412707,
                    "type": 0.11946706174307632,
                    "use": 0.19301579627820714,
                    "used": 0.08335186793802665,
                    "users": 0.11054061167626751,
                    "uses": 0.1345550248162492,
                    "worth": 0.11464231934885682,
                    "www": 0.14856715003351606,
                    "yes": 0.11131334866746903
                },
                "Max term": "google",
                "Max score": 0.3684902587358807
            }
        ],
        "Best Answer": "Yes. I set up delegation on my own site, so I just use one of my own URLs. Easy to remember, and doesn't tie me to a provider. ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "easy": 0.35107803453245207,
                "provider": 0.5301712102660859,
                "remember": 0.3845884061730968,
                "set": 0.34654864226639315,
                "site": 0.39541465580506924,
                "use": 0.20711883921195517,
                "yes": 0.35833997024115444
            },
            "Max term": "provider",
            "Max score": 0.5301712102660859
        }
    },
    {
        "ID": "1890",
        "Question": "What is the best practice, most commonly accepted naming conventions for private variables in C#?  private int myInteger; private int MyInteger; private int mMyInteger; private int _myInteger; private int _MyInteger; Mysterious other option  Which do you use and why?  (My company is fairly new to C# and I would like to pick the most \"industry accepted\" method to try and get into our coding standard.) ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "accepted": 0.24197347130702787,
                    "best": 0.0717674969245423,
                    "coding": 0.0773030340223397,
                    "commonly": 0.1272762324707697,
                    "company": 0.08048868255737504,
                    "conventions": 0.1272762324707697,
                    "fairly": 0.10724367502745041,
                    "industry": 0.09988749518875453,
                    "int": 0.580541114563116,
                    "like": 0.048529796816370374,
                    "method": 0.09521819615101887,
                    "naming": 0.12098673565351394,
                    "new": 0.06449366243796553,
                    "option": 0.1184116845855969,
                    "pick": 0.10325763988316837,
                    "practice": 0.09887044366454671,
                    "private": 0.6622334451206844,
                    "standard": 0.08935323044254782,
                    "try": 0.07805699374179806,
                    "use": 0.05127945081573514,
                    "variables": 0.11402448836697524
                },
                "Max term": "private",
                "Max score": 0.6622334451206844
            }
        ],
        "Best Answer": "The MSDN class design guidlines http://msdn.microsoft.com/en-us/library/ta31s3bc.aspx recommends option 1 - myInteger.  I have always used this style. I have a personal dislike for the _ character. ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "character": 0.24994276721772765,
                "class": 0.1952012631181409,
                "com": 0.22782293083857885,
                "design": 0.16803100182838787,
                "dislike": 0.2739838139520127,
                "en": 0.2825644349381656,
                "http": 0.22227969390413277,
                "library": 0.21283550523512998,
                "microsoft": 0.2173210994972897,
                "msdn": 0.5861325325589095,
                "option": 0.2549013616245707,
                "personal": 0.2150248822317516,
                "style": 0.2173210994972897,
                "used": 0.14300943799865098
            },
            "Max term": "msdn",
            "Max score": 0.5861325325589095
        }
    },
    {
        "ID": "1947",
        "Question": " Possible Duplicate: Really â€œwowâ€ them in the interview   Let's say I appear for an interview. What questions could I expect and how do I prepare? ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "appear": 0.34671179458333434,
                    "duplicate": 0.3225639765204135,
                    "expect": 0.30066381566779365,
                    "interview": 0.5842826473515962,
                    "let": 0.2416797816871491,
                    "possible": 0.2181018803876663,
                    "prepare": 0.337531220234749,
                    "questions": 0.238370272117433,
                    "really": 0.1729414864144485,
                    "say": 0.19319537885082708
                },
                "Max term": "interview",
                "Max score": 0.5842826473515962
            }
        ],
        "Best Answer": "Programming Interviews Exposed is also helpful.  This classic book uncovers what   interviews are really like at   America's top software and computer   companies and provides you with the   tools to succeed in any situation. The   authors take you step-by-step through   new problems and complex brainteasers   they were asked during recent   technical interviews. 50 interview scenarios are presented   along with in-depth analysis of the   possible solutions. The   problem-solving process is clearly   illustrated so you'll be able to   easily apply what you've learned   during crunch time. You'll also find   expert tips on what questions to ask,   how to approach a problem, and how to   recover if you become stuck.  I've used it in preparing for my last round of interviews and while I didn't end up needing it, reading through it certainly made me feel more confident and prepared. The book also has a section on non-programming questions such as salary negotiation, which I found very helpful. ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "50": 0.11413310162950913,
                "able": 0.08733896075681441,
                "america": 0.1385824681943356,
                "analysis": 0.11606952003049832,
                "apply": 0.11606952003049832,
                "approach": 0.09692593655714712,
                "ask": 0.08572948088533519,
                "asked": 0.09162015346567184,
                "authors": 0.12955893445123332,
                "book": 0.17814795425404678,
                "certainly": 0.10773080255088721,
                "clearly": 0.10916709265716051,
                "companies": 0.09965442334493683,
                "complex": 0.10167897957405238,
                "computer": 0.08790240281404484,
                "confident": 0.12053540070813104,
                "depth": 0.13361645922198698,
                "easily": 0.10390631417660069,
                "end": 0.0772296130092259,
                "expert": 0.12053540070813104,
                "exposed": 0.13361645922198698,
                "feel": 0.08328143598606075,
                "helpful": 0.20335795914810476,
                "interview": 0.10916709265716051,
                "interviews": 0.47276250560105115,
                "learned": 0.1027647935785386,
                "like": 0.049400179771252925,
                "negotiation": 0.1385824681943356,
                "new": 0.06565035766783343,
                "non": 0.08193224881882001,
                "possible": 0.08150010373542292,
                "prepared": 0.12955893445123332,
                "presented": 0.13361645922198698,
                "problem": 0.1443861317432011,
                "problems": 0.08374997481839179,
                "process": 0.08471772609233406,
                "programming": 0.11766413884246858,
                "provides": 0.12053540070813104,
                "questions": 0.17814795425404678,
                "reading": 0.09301152978775323,
                "really": 0.06462461056219691,
                "recent": 0.13361645922198698,
                "recover": 0.13361645922198698,
                "salary": 0.12955893445123332,
                "scenarios": 0.12955893445123332,
                "section": 0.12315663537261141,
                "situation": 0.10167897957405238,
                "software": 0.0654413911323871,
                "solutions": 0.10916709265716051,
                "solving": 0.11413310162950913,
                "step": 0.23213904006099664,
                "stuck": 0.12955893445123332,
                "succeed": 0.1385824681943356,
                "technical": 0.08848048135487649,
                "time": 0.054620531769282075,
                "tips": 0.1123517693788713,
                "tools": 0.09162015346567184,
                "used": 0.06762498169625479
            },
            "Max term": "interviews",
            "Max score": 0.47276250560105115
        }
    },
    {
        "ID": "1969",
        "Question": "I'm posting this here since programmers write viruses, and AV software.  They also have the best knowledge of heuristics and how AV systems work (cloaking etc). The EICAR test file was used to functionally test an antivirus system.  As it stands today almost every AV system will flag EICAR as being a \"test\" virus.  For more information on this historic test virus please click here. Currently the EICAR test file is only good for testing the presence of an AV solution, but it doesn't check for engine file or DAT file up-to-dateness. In other words, why do a functional test of a system that could have definition files that are more than 10 years old.  With the increase of zero day threats it doesn't make much sense to functionally test your system using EICAR. That being said, I think EICAR needs to be updated/modified to be effective test that works in conjunction with an AV management solution. This question is about real world testing, without using live viruses... which is the intent of the original EICAR. That being said I'm proposing a new EICAR file format with the appendage of an XML blob that will conditionally cause the Antivirus engine to respond. X5O!P%@AP[4\\PZX54(P^)7CC)7}$EICAR-EXTENDED-ANTIVIRUS-TEST-FILE!$H+H* <?xml version=\"1.0\"?> <engine-valid-from>2010-1-1Z</engine-valid-from> <signature-valid-from>2010-1-1Z</signature-valid-from> <authkey>MyTestKeyHere</authkey>   In this sample, the antivirus engine would only alert on the EICAR file if both the signature  or engine file is equal to or newer than the valid-from date. Also there is a passcode that will protect the usage of EICAR to the system administrator. If you have a backgound in \"Test Driven Design\" TDD for software you may get that all I'm doing is applying the principals of TDD to my infrastructure.   Based on your experience and contacts how can I make this idea happen? ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "10": 0.05616614872477389,
                    "2010": 0.1345342053839795,
                    "administrator": 0.07230285955160046,
                    "applying": 0.07230285955160046,
                    "based": 0.049378237352420105,
                    "best": 0.040769554140415075,
                    "blob": 0.07733861641121116,
                    "cause": 0.060121249987201086,
                    "check": 0.05231411614166079,
                    "click": 0.06872993319920612,
                    "currently": 0.057349873001271486,
                    "date": 0.06270006955662336,
                    "day": 0.049055629485007635,
                    "definition": 0.061779670435559195,
                    "design": 0.044342480492809415,
                    "driven": 0.059368310094055035,
                    "effective": 0.06477483193677892,
                    "engine": 0.3821650580375725,
                    "equal": 0.07230285955160046,
                    "experience": 0.044342480492809415,
                    "file": 0.41210053420156845,
                    "files": 0.055085493127590396,
                    "flag": 0.07456723942528155,
                    "format": 0.06726710269198975,
                    "functional": 0.05231411614166079,
                    "good": 0.03381929137676815,
                    "happen": 0.058658419479984715,
                    "idea": 0.044786088526839254,
                    "increase": 0.06726710269198975,
                    "information": 0.051512566775196056,
                    "infrastructure": 0.07230285955160046,
                    "intent": 0.07456723942528155,
                    "knowledge": 0.04843451483562161,
                    "live": 0.06369417633959543,
                    "make": 0.07019349943530145,
                    "management": 0.05075962688205,
                    "needs": 0.05561407096564857,
                    "new": 0.03663744696631774,
                    "old": 0.05457849601534189,
                    "original": 0.060121249987201086,
                    "posting": 0.07038835364756423,
                    "presence": 0.07456723942528155,
                    "programmers": 0.041441053055974654,
                    "protect": 0.07230285955160046,
                    "question": 0.03967528790671484,
                    "real": 0.04673828703819363,
                    "said": 0.09811125897001527,
                    "sample": 0.07456723942528155,
                    "sense": 0.05561407096564857,
                    "signature": 0.23201584923363344,
                    "software": 0.07304165833020701,
                    "solution": 0.10547032679645396,
                    "systems": 0.053622662620374024,
                    "tdd": 0.12024249997440217,
                    "test": 0.4370543292965576,
                    "testing": 0.0909654062652266,
                    "think": 0.032832369843969623,
                    "today": 0.06092279935366582,
                    "updated": 0.06726710269198975,
                    "usage": 0.07038835364756423,
                    "used": 0.03773942394998848,
                    "using": 0.07258165612551695,
                    "valid": 0.35194176823782114,
                    "version": 0.05561407096564857,
                    "virus": 0.1491344788505631,
                    "words": 0.06369417633959543,
                    "work": 0.032746419988287326,
                    "works": 0.051906876229016456,
                    "world": 0.04784298853752267,
                    "write": 0.038129603826188595,
                    "xml": 0.14077670729512845,
                    "years": 0.0454827031326133,
                    "zero": 0.07456723942528155
                },
                "Max term": "test",
                "Max score": 0.4370543292965576
            }
        ],
        "Best Answer": "As you said in the question, it would have to work in conjunction with an AV solution.  In order for that to happen you would either need to write an AV engine, or become involved with an existing AV vendor. If such a thing did exist... Where does the benefit come in?  Just thinking devil's advocate here..  Couldn't the AV engine just report when it's database was updated? ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "advocate": 0.26701624930020423,
                "benefit": 0.2280811278457807,
                "come": 0.18446026000361393,
                "database": 0.20536294631085225,
                "engine": 0.4561622556915614,
                "exist": 0.21259072497233159,
                "existing": 0.19914724954304955,
                "happen": 0.21004869269859544,
                "involved": 0.2011241731049231,
                "need": 0.13036295456205824,
                "order": 0.21528691149828993,
                "question": 0.14207239866204482,
                "report": 0.23618959780552826,
                "said": 0.17566226526694018,
                "solution": 0.18883823037243697,
                "thing": 0.158011578877761,
                "thinking": 0.17453629481617625,
                "updated": 0.24087534419327145,
                "vendor": 0.26701624930020423,
                "work": 0.11726096219564729,
                "write": 0.13653749125543885
            },
            "Max term": "engine",
            "Max score": 0.4561622556915614
        }
    },
    {
        "ID": "1997",
        "Question": "People make mistakes, even in the real life... Which should we, geeky programmers, avoid? ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "avoid": 0.40220664075671925,
                    "life": 0.4509504902179069,
                    "make": 0.2632496246102516,
                    "mistakes": 0.5279607890680551,
                    "people": 0.2594467995466311,
                    "programmers": 0.3108362383469476,
                    "real": 0.3505691158501456
                },
                "Max term": "mistakes",
                "Max score": 0.5279607890680551
            }
        ],
        "Best Answer": "Learn that what constitutes \"An acceptable degree of precision\" to you is \"Annoying goddamn nitpicking\" to most of the world. ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "acceptable": 0.42599036325333417,
                "annoying": 0.3752701550712813,
                "constitutes": 0.4556597830686055,
                "degree": 0.369413126563458,
                "learn": 0.24727456729976113,
                "precision": 0.4393315230762668,
                "world": 0.28187892142328486
            },
            "Max term": "constitutes",
            "Max score": 0.4556597830686055
        }
    },
    {
        "ID": "2042",
        "Question": "I've been working in the enterprise space for the past 4Â½ years and have noticed that generally speaking, enterprises are not conducive environments for the test-first style of development. Projects are usually fixed-cost, fixed-timeline and waterfall style. Any unit testing, if done at all, usually comes after development in the QA phase and done by another team. Prior to working for an enterprise, I consulted for many small to medium sized companies, and none of them were willing to pay for a test-first style of development project. They usually wanted development started immediately, or after a short design stint: i.e., something more akin to Agile, though some clients wanted everything mapped out similar to waterfall. With what types of shops, companies, and clients does test-driven development work best? What types of projects tend to be conducive to TDD? ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "agile": 0.094781652268068,
                    "best": 0.06948251830094973,
                    "clients": 0.20765836714608119,
                    "comes": 0.10117990690796994,
                    "companies": 0.189563304536136,
                    "cost": 0.09572254440708569,
                    "design": 0.07557176616991496,
                    "development": 0.33310664737514545,
                    "driven": 0.10117990690796994,
                    "enterprise": 0.22928323806292467,
                    "enterprises": 0.1318062447201293,
                    "environments": 0.1171346840068306,
                    "fixed": 0.21371628031223547,
                    "generally": 0.0906179665373832,
                    "immediately": 0.11464161903146233,
                    "medium": 0.11464161903146233,
                    "noticed": 0.11464161903146233,
                    "past": 0.09773993570407537,
                    "pay": 0.1103941051203844,
                    "phase": 0.1171346840068306,
                    "prior": 0.12322393187579582,
                    "project": 0.06224152395904343,
                    "projects": 0.1534323695210629,
                    "qa": 0.11996108796398063,
                    "short": 0.094781652268068,
                    "similar": 0.08589477894792669,
                    "small": 0.07877280978123452,
                    "space": 0.10685814015611773,
                    "speaking": 0.12322393187579582,
                    "started": 0.08589477894792669,
                    "style": 0.2932198071122261,
                    "tdd": 0.1024631232935319,
                    "team": 0.07877280978123452,
                    "tend": 0.09997005831816362,
                    "test": 0.22345818643932955,
                    "testing": 0.07751501872952032,
                    "types": 0.1934144288126969,
                    "unit": 0.08529849760486492,
                    "usually": 0.25768433684378006,
                    "wanted": 0.22482299283474816,
                    "waterfall": 0.25416611426134555,
                    "willing": 0.10528952725068191,
                    "work": 0.05580889401660735,
                    "working": 0.14066995865290233,
                    "years": 0.07751501872952032
                },
                "Max term": "development",
                "Max score": 0.33310664737514545
            }
        ],
        "Best Answer": "Every line of code I write is using test driven development.  If management isn't on board with writing tests first then I don't tell management about it.  I feel that strongly that test driven development is a better process. ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "better": 0.15510585665529608,
                "code": 0.108582071773895,
                "development": 0.31358939329445173,
                "driven": 0.47625806736192483,
                "feel": 0.18642063107806697,
                "line": 0.2115231759356571,
                "management": 0.40719841546034374,
                "process": 0.18963568260608663,
                "strongly": 0.2698114555927979,
                "tell": 0.22095045702885757,
                "test": 0.35060901998587357,
                "tests": 0.19676439547242483,
                "using": 0.1455641874322443,
                "write": 0.15293960194223952,
                "writing": 0.17287397875205368
            },
            "Max term": "driven",
            "Max score": 0.47625806736192483
        }
    },
    {
        "ID": "2051",
        "Question": "See title, but I am asking from a technical perspective, not   Take my 40 year old virgin niece on a date or you're fired.  ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "40": 0.37488868827459854,
                    "asking": 0.282988265002017,
                    "date": 0.3250984397654894,
                    "fired": 0.4009989734732353,
                    "old": 0.282988265002017,
                    "perspective": 0.34877840307596175,
                    "technical": 0.2560250416810908,
                    "title": 0.4009989734732353,
                    "year": 0.29122020832162804
                },
                "Max term": "fired",
                "Max score": 0.4009989734732353
            }
        ],
        "Best Answer": "To market Neal Stephenson's sci-fi thriller Snow Crash, I was asked to write a \"benign\" computer virus. It would \"benignly\" pretend to take over the user's computer and replace the screen with snow, a.k.a., a \"snow crash.\" After a minute or so of snow, the snow would fade out and be replaced by an advertisement for the book. This would be \"benign,\" you see. The virus would spread through normal means, but nobody would mind because after taking over their computer \"you'd just get a fun ad and then be relieved that nothing bad happened to your computer.\" I was actually told to do this at a major worldwide corporation. I had to write a memo explaining all the laws this would break and all 17 bad things that could happen if they really made me implement this. ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "actually": 0.09938064982101585,
                "ad": 0.16898439394255188,
                "asked": 0.11950064402658236,
                "bad": 0.2137293189333862,
                "book": 0.11617965294804483,
                "break": 0.14438986550833413,
                "computer": 0.45860624984428566,
                "crash": 0.33796878788510376,
                "explaining": 0.17427664466379245,
                "fun": 0.138754095797243,
                "happen": 0.137094957612002,
                "happened": 0.14886439973698537,
                "implement": 0.13127008615156574,
                "major": 0.1405138476564022,
                "market": 0.16898439394255188,
                "means": 0.11697496340643546,
                "mind": 0.12226721412767604,
                "minute": 0.16898439394255188,
                "normal": 0.15139008035713228,
                "really": 0.08429021661749492,
                "replace": 0.1572149518175685,
                "screen": 0.1465409987916213,
                "spread": 0.18075383606753526,
                "taking": 0.14886439973698537,
                "things": 0.08590324356847491,
                "told": 0.16063384186196872,
                "user": 0.10923552896860983,
                "virus": 0.3485532893275849,
                "write": 0.17823106952608658
            },
            "Max term": "computer",
            "Max score": 0.45860624984428566
        }
    },
    {
        "ID": "2086",
        "Question": "When writing or using an algorithm, should the Big Oh complexity be mentioned? ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "algorithm": 0.39587784313691743,
                    "big": 0.31278390647737014,
                    "complexity": 0.4209084452575369,
                    "mentioned": 0.44660879018207733,
                    "oh": 0.48453974908456565,
                    "using": 0.2358186900726037,
                    "writing": 0.28006143500044733
                },
                "Max term": "oh",
                "Max score": 0.48453974908456565
            }
        ],
        "Best Answer": "If you can back it up with real analysis, then yes, absolutely. @Casebash test != analysis.  If it should always be documented then just start throwing  // this algorithm is O(n!) on every function.  I've worked with people who would say things like 'This function is O(1) because there are no loops', and then I would point to the call $(someHugeList).each(function(//... ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "absolutely": 0.21915230185008877,
                "algorithm": 0.20961683596192604,
                "analysis": 0.4457410186203505,
                "documented": 0.24218493136730268,
                "function": 0.5534978527046446,
                "like": 0.09485559363681714,
                "loops": 0.25656320721582854,
                "people": 0.11901282565430772,
                "point": 0.1525689981126392,
                "real": 0.16081224026415228,
                "say": 0.13862127934395635,
                "start": 0.14829218885949774,
                "test": 0.15037711106932838,
                "things": 0.12646336933263982,
                "throwing": 0.25656320721582854,
                "worked": 0.1746484484380972,
                "yes": 0.1734097405865423
            },
            "Max term": "function",
            "Max score": 0.5534978527046446
        }
    },
    {
        "ID": "2164",
        "Question": "So I'm sure everyone has run into this person at one point or another, someone catches wind of your project or idea and initially shows some interest. You get to talking about some of your methods and usually around this time they interject stating how you should use method X instead, or just use library Y. But not as a friendly suggestion, but bordering on a commandment. Often repeating the same advice over and over like a overzealous parrot. Personally, I like to reinvent the wheel when I'm learning, or even just for fun, even if it turns out worse than what's been done before. But this person apparently cannot fathom recreating ANY utility for such purposes, or possibly try something that doesn't strictly follow traditional OOP practices, and will settle for nothing except their sense of perfection, and thus naturally heave their criticism sludge down my ears full force. To top it off, they eventually start justifying their advice (retardation) by listing all the incredibly complex things they've coded single-handedly (usually along the lines of \"trust me, I've made/used program X for a long time, blah blah blah\"). Now, I'm far from being a programming master, I'm probably not even that good, and as such I value advice and critique, but I think advice/critique has a time and place. There is also a big difference between being helpful and being narcissistic. In the past I probably would have used a somewhat stronger George Carlin style dismissal, but I don't think burning bridges is the best approach anymore. Do you have any advice on how to deal with this kind of verbal flogging? ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "advice": 0.5122482315753681,
                    "anymore": 0.11435618074408328,
                    "apparently": 0.10870514267624437,
                    "approach": 0.0855524164864969,
                    "best": 0.06448224221076183,
                    "big": 0.07613199723765779,
                    "burning": 0.12232087156256906,
                    "catches": 0.12232087156256906,
                    "coded": 0.10870514267624437,
                    "complex": 0.08974772612398248,
                    "deal": 0.09635716619688127,
                    "difference": 0.1007404518577586,
                    "eventually": 0.1007404518577586,
                    "far": 0.08274143731055658,
                    "follow": 0.08883391742874894,
                    "force": 0.11132814582879293,
                    "friendly": 0.11793758590169172,
                    "fun": 0.09389854345582742,
                    "good": 0.05348951647698571,
                    "helpful": 0.08974772612398248,
                    "idea": 0.07083490288154691,
                    "incredibly": 0.11435618074408328,
                    "initially": 0.10870514267624437,
                    "instead": 0.07916003215294813,
                    "kind": 0.08209733552336068,
                    "learning": 0.07521818854242425,
                    "library": 0.08883391742874894,
                    "like": 0.08720689021779508,
                    "lines": 0.10244964631507363,
                    "listing": 0.12232087156256906,
                    "long": 0.06785795601727032,
                    "master": 0.1007404518577586,
                    "method": 0.0855524164864969,
                    "methods": 0.08481107022078706,
                    "oop": 0.10244964631507363,
                    "past": 0.09070612812904236,
                    "person": 0.1668147543412872,
                    "personally": 0.09070612812904236,
                    "place": 0.08481107022078706,
                    "point": 0.07013328027860076,
                    "possibly": 0.1007404518577586,
                    "practices": 0.09389854345582742,
                    "probably": 0.13891171288017054,
                    "program": 0.07477674649207082,
                    "programming": 0.05192857438029878,
                    "project": 0.05776234255227211,
                    "purposes": 0.11132814582879293,
                    "repeating": 0.11435618074408328,
                    "run": 0.07566977956977554,
                    "sense": 0.08796073614105357,
                    "settle": 0.12232087156256906,
                    "shows": 0.10870514267624437,
                    "single": 0.08028281456950273,
                    "somewhat": 0.09916814537282158,
                    "start": 0.06816730641917201,
                    "strictly": 0.11793758590169172,
                    "style": 0.09070612812904236,
                    "suggestion": 0.11435618074408328,
                    "sure": 0.07193668760017222,
                    "talking": 0.09070612812904236,
                    "things": 0.05813298269045576,
                    "think": 0.10385714876059755,
                    "time": 0.1446336857385254,
                    "traditional": 0.11793758590169172,
                    "trust": 0.10432185701536703,
                    "try": 0.07013328027860076,
                    "turns": 0.10639148992559751,
                    "use": 0.09214795303260244,
                    "used": 0.1193794108052518,
                    "usually": 0.15942680479053242,
                    "utility": 0.10870514267624437,
                    "value": 0.09277576103927282,
                    "wheel": 0.11793758590169172,
                    "wind": 0.12232087156256906,
                    "worse": 0.10432185701536703
                },
                "Max term": "advice",
                "Max score": 0.5122482315753681
            }
        ],
        "Best Answer": "Don't just let them talk. Get them in front of a keyboard. The phrase \"ok, show me\" should do it. My experience is most blow hards aren't that great, and when they actually try to do what they say it doesn't work and things get real quiet. ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "actually": 0.19785120035673454,
                "blow": 0.35985238071449666,
                "experience": 0.206323152812577,
                "great": 0.22261082657832731,
                "keyboard": 0.31299017451739747,
                "let": 0.2345066484595505,
                "ok": 0.2762375216638249,
                "phrase": 0.35985238071449666,
                "quiet": 0.3469573141549718,
                "real": 0.21747071051523725,
                "say": 0.1874612782083195,
                "talk": 0.28745745033486597,
                "things": 0.17101981004521033,
                "try": 0.206323152812577,
                "work": 0.15236731324500086
            },
            "Max term": "blow",
            "Max score": 0.35985238071449666
        }
    },
    {
        "ID": "2185",
        "Question": "When should a project be released to alpha, beta and to the public? Is it a good idea to extend the alpha and beta phases when it is needed? When in a later phase (eg. beta), is it wise to go back to an early phase (eg. alpha) if it didn't work out? ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "alpha": 0.5793191915236812,
                    "beta": 0.5468530743806047,
                    "early": 0.1537458079039214,
                    "extend": 0.19310639717456038,
                    "good": 0.0875816452788002,
                    "idea": 0.1159823035640854,
                    "later": 0.15016843052992349,
                    "needed": 0.13886633413462054,
                    "phase": 0.3559791104093642,
                    "phases": 0.20028341792911858,
                    "project": 0.09457780382184394,
                    "public": 0.16774704976751656,
                    "released": 0.17420127054907752,
                    "work": 0.08480323575126501
                },
                "Max term": "alpha",
                "Max score": 0.5793191915236812
            }
        ],
        "Best Answer": "The right time is when the product is ready for each stage. It's up to you and the customer to define \"ready\". This might be when a certain number of bugs have been found and fixed or how much documentation has been completed. It all depends on the application and what the customer is expecting. I'll ignore the alpha phase for now. A beta phase is usually when you think you're feature complete for this release and require feedback on the fine details of your application. This is often seen as public testing, but that depends on your application. A small scale application will be beta tested by a few select users, a large application (like Visual Studio, or Stack Overflow) will be beta tested by anybody and everybody willing to help. The official release is when you (and your customers/users) are confident that your product can do the job it's designed for. It might not have all it's features, but those you implemented for this release will be. Alpha testing is more nebulous. It means different things to different people. You might release an early version that not feature complete because you need more user feedback on one particular aspect. You might also need to get something \"out there\" to meet a specific demand and can't afford to wait. ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "afford": 0.10888412240859188,
                "alpha": 0.20996466712265005,
                "anybody": 0.09909892975004948,
                "application": 0.3121462665046949,
                "aspect": 0.10498233356132503,
                "beta": 0.29729678925014846,
                "bugs": 0.07365242475219866,
                "certain": 0.07755421359946553,
                "complete": 0.15098942369455284,
                "completed": 0.09676405923537915,
                "confident": 0.09470455748319005,
                "customer": 0.1597781682282717,
                "customers": 0.08577248792541138,
                "define": 0.08697886657683675,
                "demand": 0.10498233356132503,
                "depends": 0.16716788180180728,
                "designed": 0.08827468560248179,
                "details": 0.08358394090090364,
                "different": 0.11717785033467518,
                "documentation": 0.0782983920796646,
                "early": 0.08358394090090364,
                "everybody": 0.09909892975004948,
                "feature": 0.13638076001054733,
                "features": 0.06862214404168683,
                "feedback": 0.1935281184707583,
                "fine": 0.09119571899372374,
                "fixed": 0.08827468560248179,
                "help": 0.05908854644375096,
                "ignore": 0.09470455748319005,
                "implemented": 0.08697886657683675,
                "job": 0.060403869715740965,
                "large": 0.07365242475219866,
                "like": 0.038813677453605956,
                "means": 0.0704644311367646,
                "meet": 0.0928622703881123,
                "need": 0.10250917100170193,
                "number": 0.06819038000527367,
                "overflow": 0.08577248792541138,
                "particular": 0.07095701455635717,
                "people": 0.0486985031739404,
                "phase": 0.1935281184707583,
                "product": 0.1429277554553818,
                "public": 0.09119571899372374,
                "ready": 0.1894091149663801,
                "release": 0.3430899517016455,
                "require": 0.07615462242926908,
                "right": 0.06242925330093898,
                "scale": 0.09909892975004948,
                "seen": 0.07424521219980432,
                "select": 0.09676405923537915,
                "small": 0.06507361074508163,
                "specific": 0.07095701455635717,
                "stack": 0.08258449430997733,
                "stage": 0.10179433994589097,
                "studio": 0.08967427677267824,
                "tested": 0.17654937120496358,
                "testing": 0.12806911851211267,
                "things": 0.05174716892044353,
                "think": 0.04622430479033915,
                "time": 0.04291530339067796,
                "user": 0.06580228097146122,
                "users": 0.1409288622735292,
                "usually": 0.07095701455635717,
                "version": 0.0782983920796646,
                "visual": 0.08827468560248179,
                "wait": 0.09676405923537915,
                "willing": 0.08697886657683675
            },
            "Max term": "release",
            "Max score": 0.3430899517016455
        }
    },
    {
        "ID": "2192",
        "Question": "What things tend to slow a developer down? Please try to refrain from posting answers that:  are slow now but useful in the feature. (TDD, Refactoring, ...) list a distraction.  ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "answers": 0.2477887745648783,
                    "developer": 0.1939113009444715,
                    "feature": 0.21989482953853282,
                    "list": 0.23565950312488157,
                    "posting": 0.31956622419691577,
                    "refactoring": 0.2891743645275812,
                    "slow": 0.5881611770228568,
                    "tdd": 0.27295312160030294,
                    "tend": 0.2663118067007979,
                    "things": 0.1668700905902354,
                    "try": 0.20131681348257902,
                    "useful": 0.2272280059467363
                },
                "Max term": "slow",
                "Max score": 0.5881611770228568
            }
        ],
        "Best Answer": "Oh this ones easy:  Meetings More Meetings Meetings about the last meeting Meetings to prepare for the upcoming meeting Developing a power point presentation for a meeting Developing a power point presentation for a meeting discussing features that haven't been implemented, shouldn't be implemented, and for whatever reason that guy from sales will jump all over.  I can't predict what document you want displayed in the app based upon your current location without an internet connection or access to your hard-drive.  No really, just give up asking for it too.  ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "access": 0.09971918876504794,
                "app": 0.09452162747777887,
                "asking": 0.10235889214889952,
                "based": 0.0926061002164365,
                "connection": 0.12615565858910552,
                "current": 0.10642001069788189,
                "developing": 0.20860210916526137,
                "discussing": 0.13984665345171934,
                "document": 0.12148154530157976,
                "drive": 0.12370155344394397,
                "easy": 0.0926061002164365,
                "features": 0.0914113534283932,
                "guy": 0.11945483665627159,
                "hard": 0.09589216721886291,
                "implemented": 0.23172857754564663,
                "internet": 0.11586428877282332,
                "location": 0.12370155344394397,
                "meeting": 0.48592618120631903,
                "meetings": 0.4703617817296284,
                "oh": 0.13984665345171934,
                "ones": 0.1005662805063887,
                "point": 0.16632364428299012,
                "power": 0.2351808908648142,
                "predict": 0.14504421473898843,
                "prepare": 0.1320093887805987,
                "presentation": 0.2796933069034387,
                "really": 0.0676378910979009,
                "reason": 0.0902749106901065,
                "sales": 0.12148154530157976,
                "want": 0.06849275605997655
            },
            "Max term": "meeting",
            "Max score": 0.48592618120631903
        }
    },
    {
        "ID": "2204",
        "Question": "What steps and measures can I take to prevent deep indentations in my code? ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "code": 0.18894560352573742,
                    "deep": 0.5204564499017569,
                    "measures": 0.539799810854279,
                    "prevent": 0.4521084504754899,
                    "steps": 0.44456580601109125
                },
                "Max term": "measures",
                "Max score": 0.539799810854279
            }
        ],
        "Best Answer": "The best thing you can do is extract methods: int Step1(int state) {     if (state == 100)     {         return Step2(state);     }     else     {         return Step3(state);     } }  int Step2(int state) {     if (state != 100)     {         throw new InvalidStateException(2, state);     }      // .... }  ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "100": 0.21417424807769012,
                "best": 0.07166273295976403,
                "extract": 0.13594204626977122,
                "int": 0.46375492692846965,
                "methods": 0.09425529989169171,
                "new": 0.06439951659103461,
                "return": 0.21417424807769012,
                "state": 0.7970062727024482,
                "thing": 0.07756337376534644,
                "throw": 0.12372521351472088
            },
            "Max term": "state",
            "Max score": 0.7970062727024482
        }
    },
    {
        "ID": "2226",
        "Question": "In an earlier question, I asked for career advice for new software engineers who did well before and during college.  But what about people who weren't fortunate enough to go to MIT or Yale, for whatever reason?  What if you went to what Joel Spolsky calls a JavaSchool? What can/should JavaSchool alumni do to develop their skills and make up for the things they missed in college?  (Or, was Joel wrong about those schools being disadvantageous?) ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "advice": 0.20554256656856632,
                    "asked": 0.16224622526044633,
                    "calls": 0.1960383631018722,
                    "career": 0.17318769983679394,
                    "college": 0.4269020086825541,
                    "develop": 0.18198179349299978,
                    "earlier": 0.22335531305395007,
                    "engineers": 0.2180928371012835,
                    "joel": 0.37226810877839844,
                    "make": 0.11136850223280197,
                    "missed": 0.21345100434127706,
                    "mit": 0.2366156933971555,
                    "new": 0.11625742061865327,
                    "people": 0.10975970627643239,
                    "question": 0.12589705386889025,
                    "reason": 0.15274202179375224,
                    "schools": 0.24540978705336133,
                    "skills": 0.17015466303315713,
                    "software": 0.11588737068641182,
                    "spolsky": 0.2366156933971555,
                    "things": 0.11663097818546853,
                    "went": 0.18838666909210358,
                    "wrong": 0.15881710443712135
                },
                "Max term": "college",
                "Max score": 0.4269020086825541
            }
        ],
        "Best Answer": "Despite the claims made by Joel in that article- and he concedes the point himself- a lot of the subject areas that may be missed by a \"JavaSchool\" are not necessary of many jobs. I attended something that I suppose resembles a JavaSchool in that we spend most of our time focusing on high level languages like C# and Java, but that doesn't change the fact that \"Algorithms & Data Structures\" is still part of the required class list- not to mention all of the other theory-oriented classes. Granted not all \"JavaSchools\" are the same, but that isn't the point. In my opinion, more important than an understanding of some of the grittier development topics is being able to problem solve effectively when unique challenges arise. As software engineers we do the vast majority of our learning on the job and as such, two of the biggest aspects of our job description are being able to problem solve and being able to pick up unfamiliar concepts. If, during an interview, one is unable to make a discernible and logical attempt at solving a problem which is new to them, then their incompatibility for a given position will likely reveal itself. Obviously, when hiring someone for a position that requires constant exposure to and use of some intricate topic that may be missed by a JavaSchool, it is often the logical choice to go with someone who has a prior understanding, but lack of experience shouldn't always preclude job eligibility.  More than likely, the 50 year old Java guy at your company that has been there for as long as anyone can remember did not have any understanding of Java until his job (current or previous) asked him to learn it- and he did so. Strictly speaking, it's bad practice to fire \"the old guy\" so that a younger and more \"up-to-date\" candidate can take his place; that being said, if the job description for any employee young or old changes, it is the responsibility of that employee to get caught up or find a new job. Just because an individual (especially a programmer with past experience) doesn't understand some concept, doesn't mean they are unwilling or incapable of learning it. In fact, if they are unwilling to learn then they probably do not belong at any job- much less yours. It's fair to say that some \"JavaSchools\" are better than others, and that fact should certainly be considered when selecting a candidate for a position, but there are a lot more important personal traits than just where someone went to school. It is our aptitude to tackle a problem and find a solution that defines us as engineers, most everything else is secondary. ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "50": 0.06807786495550001,
                "able": 0.15628726173736504,
                "algorithms": 0.06603159507838312,
                "areas": 0.06923289560408272,
                "article": 0.06511575069276153,
                "asked": 0.054649390455411395,
                "aspects": 0.07346020279451206,
                "attempt": 0.0772790322651593,
                "bad": 0.04887077010045892,
                "better": 0.04133107823443094,
                "biggest": 0.07969925584143285,
                "candidate": 0.1437933888522945,
                "caught": 0.0772790322651593,
                "certainly": 0.06425903548485279,
                "challenges": 0.07969925584143285,
                "change": 0.05113573484896864,
                "changes": 0.05505786817519351,
                "choice": 0.06197781295299056,
                "claims": 0.07969925584143285,
                "class": 0.05505786817519351,
                "classes": 0.06807786495550001,
                "company": 0.04887077010045892,
                "concept": 0.06345427524913025,
                "concepts": 0.06923289560408272,
                "considered": 0.06269552711648797,
                "constant": 0.07346020279451206,
                "current": 0.06064925723937109,
                "data": 0.050532245544090214,
                "date": 0.06701533975756528,
                "defines": 0.08266137010417134,
                "description": 0.1504655247760848,
                "despite": 0.0752327623880424,
                "development": 0.04178110365150472,
                "effectively": 0.07189669442614725,
                "employee": 0.1593985116828657,
                "engineers": 0.1469204055890241,
                "especially": 0.06064925723937109,
                "experience": 0.09478861560863848,
                "exposure": 0.0772790322651593,
                "fact": 0.16774375014930676,
                "fair": 0.07969925584143285,
                "focusing": 0.08266137010417134,
                "given": 0.05731318927747593,
                "granted": 0.07969925584143285,
                "guy": 0.13615572991100003,
                "high": 0.055479315586723574,
                "hiring": 0.07049808853177357,
                "important": 0.10555329128666256,
                "incapable": 0.08266137010417134,
                "individual": 0.0772790322651593,
                "interview": 0.06511575069276153,
                "java": 0.15072146106162138,
                "job": 0.3209969060587396,
                "jobs": 0.06511575069276153,
                "joel": 0.06269552711648797,
                "lack": 0.06701533975756528,
                "languages": 0.04524860316677233,
                "learn": 0.08971629836305682,
                "learning": 0.10166112196952833,
                "level": 0.050532245544090214,
                "like": 0.029466112102707116,
                "likely": 0.1118291667662045,
                "list": 0.055479315586723574,
                "logical": 0.13206319015676624,
                "long": 0.045856700865534235,
                "lot": 0.0848118006199834,
                "majority": 0.07969925584143285,
                "make": 0.0375122487637837,
                "mean": 0.05505786817519351,
                "mention": 0.06923289560408272,
                "missed": 0.1437933888522945,
                "necessary": 0.05731318927747593,
                "new": 0.07831796594995001,
                "obviously": 0.06511575069276153,
                "old": 0.17500442087812743,
                "opinion": 0.05944165433019973,
                "oriented": 0.06197781295299056,
                "past": 0.061296921222114296,
                "personal": 0.06064925723937109,
                "pick": 0.06269552711648797,
                "place": 0.05731318927747593,
                "point": 0.09478861560863848,
                "position": 0.19277710645455834,
                "practice": 0.060031728294423436,
                "previous": 0.060031728294423436,
                "prior": 0.0772790322651593,
                "probably": 0.04693652180330735,
                "problem": 0.17224625350441294,
                "programmer": 0.04272968412880462,
                "remember": 0.057814172447906015,
                "required": 0.06064925723937109,
                "requires": 0.06923289560408272,
                "responsibility": 0.07969925584143285,
                "reveal": 0.07969925584143285,
                "said": 0.05243183460889397,
                "say": 0.043061563376103236,
                "school": 0.06425903548485279,
                "software": 0.03903433906906842,
                "solution": 0.056364608800176026,
                "solve": 0.1177533952916815,
                "solving": 0.06807786495550001,
                "speaking": 0.0772790322651593,
                "spend": 0.057814172447906015,
                "strictly": 0.07969925584143285,
                "structures": 0.07346020279451206,
                "subject": 0.07189669442614725,
                "suppose": 0.0752327623880424,
                "tackle": 0.07969925584143285,
                "theory": 0.07189669442614725,
                "time": 0.03257993634184544,
                "topic": 0.0772790322651593,
                "topics": 0.07969925584143285,
                "traits": 0.08266137010417134,
                "unable": 0.07346020279451206,
                "understand": 0.04524860316677233,
                "understanding": 0.19809478523514937,
                "unfamiliar": 0.07969925584143285,
                "unique": 0.07346020279451206,
                "unwilling": 0.16532274020834267,
                "use": 0.031135635123697974,
                "vast": 0.0772790322651593,
                "went": 0.06345427524913025,
                "year": 0.060031728294423436,
                "young": 0.08266137010417134
            },
            "Max term": "job",
            "Max score": 0.3209969060587396
        }
    },
    {
        "ID": "2247",
        "Question": "How can I track that I'm developing software more or less productive than the previous days?  ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "days": 0.3892286406687395,
                    "developing": 0.4071127954236104,
                    "previous": 0.4111541812798542,
                    "productive": 0.46626175231505407,
                    "software": 0.26734415579426046,
                    "track": 0.47417249708558695
                },
                "Max term": "track",
                "Max score": 0.47417249708558695
            }
        ],
        "Best Answer": "There's a simple answer: you can't. And moreover, you shouldn't. You want to measure your own productivity, but you can generalize: how can you measure productivity of programmers? First of all you have to define what you mean for \"productivity\": amount of code produced? Amount of design (or specification) implemented? Number of issues fixed? Quality of produced code? (Yes, quality is a productivity counter, you can produce a lot of bad code or few good code, what has been more productive?). All these values can hardly be mapped to a daily base, and any attempt to track daily productivity is dangerous for the project, for the company, and for the programmer. My advice is to clearly define what you mean as \"productivity\", then define a measure unit, and apply it on a weekly and monthly base. ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "advice": 0.09552105351244872,
                "answer": 0.06742730323827781,
                "apply": 0.09552105351244872,
                "attempt": 0.10662235794100201,
                "bad": 0.06742730323827781,
                "base": 0.1773171759941526,
                "clearly": 0.08984060325883221,
                "code": 0.15968100650489686,
                "company": 0.06742730323827781,
                "counter": 0.1099615553517728,
                "daily": 0.18492295603940714,
                "dangerous": 0.1099615553517728,
                "define": 0.2733125982364355,
                "design": 0.06539021909253892,
                "fixed": 0.09246147801970357,
                "good": 0.04987206056368207,
                "hardly": 0.10662235794100201,
                "implemented": 0.09110419941214516,
                "issues": 0.0845717406605286,
                "lot": 0.05850768247392808,
                "mean": 0.15192736130290838,
                "measure": 0.3298846660553184,
                "number": 0.07142459108158618,
                "produce": 0.08754825533121839,
                "produced": 0.22809680537664098,
                "productive": 0.09392745059537991,
                "productivity": 0.6397341476460121,
                "programmer": 0.05895440900780239,
                "programmers": 0.06111159115681724,
                "project": 0.0538559186136319,
                "quality": 0.16246508649951566,
                "simple": 0.07055228908580674,
                "specification": 0.10662235794100201,
                "track": 0.09552105351244872,
                "unit": 0.07380649850243932,
                "values": 0.09726664800615069,
                "want": 0.0538559186136319,
                "weekly": 0.11404840268832049,
                "yes": 0.07432244472997536
            },
            "Max term": "productivity",
            "Max score": 0.6397341476460121
        }
    },
    {
        "ID": "2252",
        "Question": "I've been asked this in a few interviews. And it always catches me off guard.My professional and academic background are already in the resumÃ©, which the interviewer has obviously looked at. What more to tell him/her? Should I start with my hobbies? I like gardening, or looking at NSFW pictures on reddit in my free time? What and how do you answer to this specific question? Do you have a prepared answer for it? Am I wrong if I think this question is a bit silly? UPDATE There have been a lot of great answers to this question. I'm in pickle which to choose as the 'correct' answer, because most of them are very insightful. I found a great writing on this subject matter. It's a bit crazy for my taste, but it's interesting: How To Introduce Yourselfâ€¦ I Mean Practically ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "answer": 0.33526234873548655,
                    "answers": 0.13339578616576706,
                    "asked": 0.12496824423120664,
                    "background": 0.15099624043317073,
                    "bit": 0.2499364884624133,
                    "catches": 0.1890239982839802,
                    "choose": 0.14336756329039146,
                    "correct": 0.13868830243065422,
                    "crazy": 0.1822504512134293,
                    "free": 0.12068578784681748,
                    "great": 0.23386694520452295,
                    "interesting": 0.1322052370993939,
                    "interviewer": 0.1890239982839802,
                    "interviews": 0.16120989222487364,
                    "introduce": 0.1890239982839802,
                    "like": 0.06738095819750524,
                    "looked": 0.16440812227894713,
                    "looking": 0.11175411624516218,
                    "lot": 0.09697072305146814,
                    "matter": 0.13727618223372318,
                    "mean": 0.12590232131831317,
                    "obviously": 0.1489019542223571,
                    "practically": 0.1890239982839802,
                    "prepared": 0.17671606028146367,
                    "professional": 0.14694288030686883,
                    "question": 0.29091216915440443,
                    "silly": 0.17671606028146367,
                    "specific": 0.12318213437406417,
                    "start": 0.10533980543958199,
                    "subject": 0.16440812227894713,
                    "taste": 0.17671606028146367,
                    "tell": 0.13463494230435233,
                    "think": 0.08024588632472444,
                    "time": 0.07450142458819958,
                    "update": 0.14336756329039146,
                    "writing": 0.10533980543958199,
                    "wrong": 0.12232700430183577
                },
                "Max term": "answer",
                "Max score": 0.33526234873548655
            }
        ],
        "Best Answer": "Don't assume the interviewer knows your resumÃ© inside out. Often, they'll be interviewing several people for the position and may have just had a cursory glance over your resumÃ© before starting the interview. With that in mind, and assuming this question comes early on in the interview, use this question as an opportunity to give a brief history of your career and why you are applying for the job, as well as what your stand-out skills or attributes are.  Your answer can effectively steer the course of the interview, giving the interviewer some \"jumping off\" points that could change what questions you get asked next. Focusing on your strengths with this answer means that it will be more natural to talk about what makes you great in answers to subsequent questions and not as something you have to try to shoehorn in to some other answer. ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "answer": 0.29575745581895857,
                "answers": 0.11767739050377037,
                "applying": 0.1558931165051022,
                "asked": 0.11024288922208991,
                "assume": 0.13966184026943051,
                "assuming": 0.13966184026943051,
                "attributes": 0.16077537479542128,
                "career": 0.11767739050377037,
                "change": 0.1031548770309624,
                "comes": 0.12800476965366012,
                "course": 0.11767739050377037,
                "early": 0.12800476965366012,
                "effectively": 0.14503545699239095,
                "focusing": 0.16675077601781343,
                "giving": 0.13733182497047283,
                "great": 0.1031548770309624,
                "history": 0.1351884186723336,
                "inside": 0.14503545699239095,
                "interview": 0.394069271244242,
                "interviewer": 0.33350155203562687,
                "interviewing": 0.14818948448318406,
                "job": 0.09250560987929594,
                "knows": 0.12365279172616252,
                "makes": 0.09379121434925583,
                "means": 0.10791287392313222,
                "mind": 0.11279513221345129,
                "natural": 0.14503545699239095,
                "opportunity": 0.13966184026943051,
                "people": 0.07457940621211945,
                "points": 0.12110054873480115,
                "position": 0.12962819294855468,
                "question": 0.1710887873141681,
                "questions": 0.21435835286315413,
                "skills": 0.11561650594505038,
                "stand": 0.15176522593758426,
                "starting": 0.12365279172616252,
                "strengths": 0.16675077601781343,
                "talk": 0.1332039344029549,
                "try": 0.09560738704473196,
                "use": 0.06280916118546319
            },
            "Max term": "interview",
            "Max score": 0.394069271244242
        }
    },
    {
        "ID": "2259",
        "Question": "Sometimes, one creates a exploratory prototype and forgets about structure in the directories... What are good tips on dividing the programming files over (several levels of) directories? ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "creates": 0.4106491649218999,
                    "files": 0.32137151360889715,
                    "good": 0.19730343220779165,
                    "levels": 0.4106491649218999,
                    "programming": 0.1915456827750319,
                    "prototype": 0.43502899291895675,
                    "structure": 0.40097385733312485,
                    "tips": 0.3657953321779876
                },
                "Max term": "prototype",
                "Max score": 0.43502899291895675
            }
        ],
        "Best Answer": "If your language is OOP and package based (Eg Java), then you should probably keep each package in its own folder (eg my/package/name) to keep with the convention. If your language isn't package based (Eg PHP), then organize by what each file does. Here's an example  Does this do utility functions? Goes in /util Is this a 3rd party plugin? Goes in /plugin Is this part of the admin panel? Goes in /admin, along with ALL supporting files Is this Javascript? Goes in /javascript Is this CSS? Goes in /css Is this a template? Goes in /templates/templateName etc  Language agnostic, Most people have a /src directory for all source files, a /lib directory for libraries, and a /bin or /dist directory for builds.  ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "3rd": 0.11713245631275553,
                "admin": 0.24063672749385884,
                "agnostic": 0.12031836374692942,
                "based": 0.16433952293991091,
                "builds": 0.11713245631275553,
                "convention": 0.10433847046516428,
                "css": 0.23426491262551105,
                "directory": 0.3722594773878542,
                "example": 0.06867651030047167,
                "file": 0.08572147471391173,
                "files": 0.18333428139379013,
                "folder": 0.12031836374692942,
                "functions": 0.101380935395567,
                "goes": 0.5552804462830683,
                "java": 0.07822112952216086,
                "javascript": 0.20867694093032857,
                "language": 0.1817449142634304,
                "libraries": 0.09442689924570448,
                "oop": 0.10779105887303835,
                "organize": 0.12869830928896328,
                "party": 0.10599275222191223,
                "people": 0.05756041270985888,
                "php": 0.09082345258623847,
                "plugin": 0.24817298492523612,
                "probably": 0.07307707327349743,
                "source": 0.07649784106122129,
                "src": 0.12869830928896328,
                "supporting": 0.12869830928896328,
                "template": 0.1143726977639461,
                "templates": 0.12408649246261806,
                "utility": 0.1143726977639461
            },
            "Max term": "goes",
            "Max score": 0.5552804462830683
        }
    },
    {
        "ID": "2329",
        "Question": "Google sometimes come up with irrelevant links, not everything is available on SO, there are cases where the local documentation is also annoying to look through... Are there other efficient ways you use to search? ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "annoying": 0.2905853599062936,
                    "available": 0.244637133442114,
                    "cases": 0.244637133442114,
                    "come": 0.2350104611802946,
                    "documentation": 0.2537223299857777,
                    "efficient": 0.32985986588533805,
                    "google": 0.2537223299857777,
                    "irrelevant": 0.3211255134038656,
                    "links": 0.3401904122299518,
                    "local": 0.2955155232852509,
                    "look": 0.2033019954667323,
                    "search": 0.2860500492402909,
                    "use": 0.13290016871482188,
                    "ways": 0.2368093784618676
                },
                "Max term": "links",
                "Max score": 0.3401904122299518
            }
        ],
        "Best Answer": "Practise your Google-fu. Google is pretty awesome, but it's not magic. Sometimes you'll need to use search operators to get better answers, especially on some code phrases that can be difficult to search. Check out the Google Guide, for example. If I know where the answer is, I might use the site: operator, or if I need something citable I often use inurl:edu. Google Code is handy for finding examples, and I use it to search for APIs sometimes. ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "answer": 0.10755345784929946,
                "answers": 0.1283816520295294,
                "apis": 0.17007358636420203,
                "awesome": 0.18191888867290118,
                "better": 0.0909603096414317,
                "check": 0.12305528999632348,
                "code": 0.1273537838356591,
                "difficult": 0.13211619021886944,
                "especially": 0.13347523107733397,
                "example": 0.0970762902855497,
                "examples": 0.13347523107733397,
                "finding": 0.16166921062670853,
                "google": 0.523270286132506,
                "guide": 0.16557021143222575,
                "handy": 0.18191888867290118,
                "know": 0.07933221361283455,
                "magic": 0.15515027035121529,
                "need": 0.17126789521645158,
                "operator": 0.16166921062670853,
                "operators": 0.16557021143222575,
                "phrases": 0.18191888867290118,
                "pretty": 0.11392954155603625,
                "search": 0.4424565955307565,
                "site": 0.1308175715331265,
                "use": 0.27408982612748894
            },
            "Max term": "google",
            "Max score": 0.523270286132506
        }
    },
    {
        "ID": "2331",
        "Question": "Please, explain why and list which languages have the (mis)feature implemented As far you know. Post what you consider a harmful feature, not what you dislike. ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "consider": 0.26691285685781185,
                    "dislike": 0.38558770217243776,
                    "explain": 0.26691285685781185,
                    "far": 0.27898868674549554,
                    "feature": 0.5165979159641907,
                    "implemented": 0.3294680364227788,
                    "know": 0.179860533367717,
                    "languages": 0.22577023042580502,
                    "list": 0.2768168957109049,
                    "post": 0.30924148222015163
                },
                "Max term": "feature",
                "Max score": 0.5165979159641907
            }
        ],
        "Best Answer": "Register Globals in PHP Information : http://php.net/manual/en/security.globals.php This is by far the worst feature to be ever implemented for readability reasons and security reasons. Basicly all the GET parameter received are transformed into variables. For example with this URL : /index.php?value=foobar You can do the following : <?php echo $value; // return foobar ?>  When you are reading code, it is very confusing to know where the variable comes from. Also if the feature is misused, it can lead to security hole. Here's a code example from php.net that shows how it can be misused : <?php // define $authorized = true only if user is authenticated if (authenticated_user()) {     $authorized = true; }  // Because we didn't first initialize $authorized as false, this might be // defined through register_globals, like from GET auth.php?authorized=1 // So, anyone can be seen as authenticated! if ($authorized) {     include \"/highly/sensitive/data.php\"; } ?>  ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "code": 0.07991903173111375,
                "comes": 0.08763436489993222,
                "confusing": 0.10672722816626026,
                "data": 0.06978822510914226,
                "define": 0.09119380648986156,
                "defined": 0.09736231626451132,
                "en": 0.11006970990117666,
                "example": 0.12183765397471207,
                "false": 0.11006970990117666,
                "far": 0.07722157386849411,
                "feature": 0.14298968389471067,
                "following": 0.08209268178348252,
                "highly": 0.09401983452959492,
                "http": 0.08658648577024305,
                "implemented": 0.09119380648986156,
                "include": 0.08658648577024305,
                "index": 0.11006970990117666,
                "information": 0.0760383960156161,
                "know": 0.049783787384009966,
                "lead": 0.08874578965228144,
                "like": 0.04069456329069551,
                "manual": 0.10672722816626026,
                "net": 0.13957645021828452,
                "parameter": 0.11006970990117666,
                "php": 0.7250765004306947,
                "readability": 0.09561500486179235,
                "reading": 0.07662044152954173,
                "reasons": 0.16112811120682105,
                "received": 0.11006970990117666,
                "return": 0.08992896750515945,
                "security": 0.2512813731915291,
                "seen": 0.07784308741441753,
                "sensitive": 0.11416057692561213,
                "shows": 0.10145318328894679,
                "true": 0.17749157930456289,
                "user": 0.06899101717084216,
                "value": 0.1731729715404861,
                "variable": 0.09736231626451132,
                "variables": 0.09561500486179235,
                "worst": 0.10145318328894679
            },
            "Max term": "php",
            "Max score": 0.7250765004306947
        }
    },
    {
        "ID": "2410",
        "Question": "I am referring to explaining to the non-programmer what programming is. I made sure to search for similar questions before creating this one, but the few ones I did find seemed to dodge the question, and I specifically would like to see some metaphors or analogies. I personally find it easier to explain something technical to someone through the use of metaphors or analogies. The reason I'm interested in this is because many people encounter the work of a programmer on a daily basis, but if you ask the average person what a programmer is or does, they don't really know. This leads to certain situations of misunderstanding (ex. \"[...] but I thought you were good with computers!\") I really would like to find the best one out there. I would like to be able to easily explain to someone what my career choice is about. Of course, at least the general idea. I personally don't have a solid one, but I have long thought about it and I have usually gravitated towards the 'language' metaphor, where we happen to know a language that computers understand, and therefore we are able to tell computers what to do, or \"teach\" them, to solve our problems. For example:  Imagine that in an alternate reality, humanoid robots with artificial intelligence exist, and some people are able to communicate with them through a common language, which is a variation of English. These people who can communicate with the robots are able to teach them how to solve certain problems or do certain tasks, like doing our chores. Well, although robots like that don't exist yet, programmers of our time are like those people, but instead of communicating with the robots, they communicate with computers. Programmers \"teach\" the computers how to perform certain tasks or solve certain problems by means of software which they create by using this \"common language\". Programmers and this \"common language\" are what give us things like email, websites, video games, word processors, smart phones (to put it simply), and many other things which we use on a daily basis.  I don't mean to put programming on the throne or anything, it's just the best metaphor I could come up with. I'm sure someone will find some issue with this one, it's probably a bit contrived, but then again that's why I'm asking this question. ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "able": 0.21066848829164683,
                    "alternate": 0.08057336963727907,
                    "artificial": 0.08356797134189636,
                    "ask": 0.05169657385330199,
                    "asking": 0.058974602889750205,
                    "average": 0.06675580671135724,
                    "basis": 0.15625320377646207,
                    "best": 0.08810679813336329,
                    "bit": 0.05524876601578931,
                    "career": 0.058974602889750205,
                    "certain": 0.29761218422659735,
                    "choice": 0.06265756410959322,
                    "come": 0.055661723777529,
                    "common": 0.1523745217715756,
                    "communicate": 0.24172010891183723,
                    "computers": 0.35635643557911645,
                    "course": 0.058974602889750205,
                    "create": 0.05371337128605187,
                    "creating": 0.06415021973211316,
                    "daily": 0.1355006815219738,
                    "easier": 0.054081067391654115,
                    "easily": 0.06265756410959322,
                    "email": 0.07127128711582328,
                    "encounter": 0.07812660188823103,
                    "english": 0.07268523243456569,
                    "example": 0.044593877544772356,
                    "exist": 0.1283004394642263,
                    "explain": 0.10816213478330823,
                    "explaining": 0.08057336963727907,
                    "games": 0.0649638062989848,
                    "general": 0.058974602889750205,
                    "good": 0.03654331695759831,
                    "happen": 0.0633831499131099,
                    "idea": 0.04839345124338157,
                    "imagine": 0.07605788923281304,
                    "instead": 0.054081067391654115,
                    "intelligence": 0.08356797134189636,
                    "interested": 0.0619692045943675,
                    "issue": 0.05698279628046736,
                    "know": 0.07288558326240605,
                    "language": 0.196688077082665,
                    "leads": 0.07812660188823103,
                    "like": 0.20852500340328994,
                    "long": 0.046359641256073225,
                    "mean": 0.055661723777529,
                    "means": 0.054081067391654115,
                    "misunderstanding": 0.08057336963727907,
                    "non": 0.04940676775699202,
                    "ones": 0.05794178045944458,
                    "people": 0.14950334456888534,
                    "perform": 0.07605788923281304,
                    "person": 0.05698279628046736,
                    "personally": 0.123938409188735,
                    "probably": 0.047451305295375786,
                    "problems": 0.15150867754123268,
                    "processors": 0.07812660188823103,
                    "programmer": 0.12959498545297038,
                    "programmers": 0.134336954610595,
                    "programming": 0.0709538046974851,
                    "question": 0.08574198703376855,
                    "questions": 0.05371337128605187,
                    "reality": 0.07268523243456569,
                    "really": 0.07793983862186149,
                    "reason": 0.052012354736236124,
                    "search": 0.0677503407609869,
                    "similar": 0.05445912248528416,
                    "simply": 0.05608779347809744,
                    "situations": 0.06882451936677524,
                    "smart": 0.07268523243456569,
                    "software": 0.039462454161634616,
                    "solid": 0.07605788923281304,
                    "solve": 0.1785673105359584,
                    "specifically": 0.0649638062989848,
                    "sure": 0.09829235143615067,
                    "tasks": 0.12262887451538383,
                    "teach": 0.2343798056646931,
                    "technical": 0.05335548158813743,
                    "tell": 0.059522436845319465,
                    "things": 0.07943134102032608,
                    "thought": 0.11588356091888916,
                    "time": 0.032937261783890455,
                    "understand": 0.045744874152658814,
                    "use": 0.06295423994182338,
                    "using": 0.03921392727530946,
                    "usually": 0.05445912248528416,
                    "variation": 0.08356797134189636,
                    "video": 0.07426588882044058,
                    "websites": 0.07268523243456569,
                    "word": 0.06882451936677524,
                    "work": 0.0353840295329385
                },
                "Max term": "computers",
                "Max score": 0.35635643557911645
            }
        ],
        "Best Answer": "It's like having to write detailed step by step directions for how to drive somewhere. But  you usually have to add contingency plans for things like 'what if there is a traffic jam', or 'what if a truck breaks down in the turn lane'.  And sometimes you have to dive even deeper and explain the rules of the road like which side to drive on or what to do at a red light.  And sometimes you even need to explain precisely how the steering wheel or the gas pedal works.   And usually, once you've got that all described in exacting detail, the customer says \"that's perfect, except it needs to work for someone driving a hovercraft\" ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "add": 0.13705191141640785,
                "breaks": 0.174153153879116,
                "customer": 0.14982334484007834,
                "deeper": 0.1909042851798421,
                "described": 0.18584933461012382,
                "detailed": 0.174153153879116,
                "drive": 0.348306307758232,
                "driving": 0.19688302272689867,
                "explain": 0.26429685312402784,
                "got": 0.13124995202828432,
                "light": 0.18584933461012382,
                "like": 0.21837257415550534,
                "need": 0.09612243679196844,
                "needs": 0.1468401738116752,
                "perfect": 0.1814705372543223,
                "red": 0.19688302272689867,
                "road": 0.20420040610210496,
                "rules": 0.16817441633205943,
                "says": 0.15675264949586498,
                "step": 0.34205543363634405,
                "things": 0.09704622376930673,
                "turn": 0.16817441633205943,
                "usually": 0.26614442707870445,
                "wheel": 0.19688302272689867,
                "work": 0.08646175184262829,
                "works": 0.13705191141640785,
                "write": 0.10067519884789923
            },
            "Max term": "drive",
            "Max score": 0.348306307758232
        }
    },
    {
        "ID": "2497",
        "Question": "How useful are infix operators in a programming language? Are they worth the extra complexity they provide? Can you provide any examples where infix operators are better suited to the problem that can't be handled by just overloading the normal operators? ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "better": 0.12278956632758142,
                    "complexity": 0.20568244502622715,
                    "examples": 0.18018150778143713,
                    "extra": 0.20944117810429302,
                    "handled": 0.2235073136697929,
                    "language": 0.11559937879700659,
                    "normal": 0.20568244502622715,
                    "operators": 0.6705219410093787,
                    "overloading": 0.245576796462074,
                    "problem": 0.12793062552949824,
                    "programming": 0.10425410462051214,
                    "provide": 0.3566938099876041,
                    "suited": 0.20944117810429302,
                    "useful": 0.15892518468536238,
                    "worth": 0.16482224495585096
                },
                "Max term": "operators",
                "Max score": 0.6705219410093787
            }
        ],
        "Best Answer": "I think infix operators stem from mathematics. This: 2 + 3 * 4  is more readable to most people, than (+ 2 (* 3 4))  because most people are familiar with mathematics. Interesting enough in Haskell you can hop between infix and prefix. This is using the same funtion \"(+)\": (+) 1 2 1 + 2  and this is using the same function \"elem\": elem 42 [1,2,42] 42 `elem` [1,2,42]  ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "familiar": 0.3046597680405015,
                "function": 0.26815359978454795,
                "haskell": 0.3185187351044516,
                "interesting": 0.2704975705576959,
                "operators": 0.3519946509767423,
                "people": 0.3459495005856483,
                "prefix": 0.3867511865243131,
                "readable": 0.32984233570045335,
                "think": 0.1641865161647708,
                "using": 0.36296281119368623
            },
            "Max term": "prefix",
            "Max score": 0.3867511865243131
        }
    },
    {
        "ID": "2654",
        "Question": "In response to This Question, I ask:   What are the best parts of your coding standard? What are the best practices that help with code quality, reliability, maintainability, readability, etc. Please include the language, the item from the standard, and the reason it improves your code. ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "ask": 0.19594286187679563,
                    "best": 0.3339466601024979,
                    "code": 0.2217387543860083,
                    "coding": 0.17985223906229153,
                    "help": 0.17188829211285292,
                    "include": 0.24023788934220566,
                    "language": 0.1490993381108158,
                    "maintainability": 0.30539309399083064,
                    "parts": 0.260862031791291,
                    "practices": 0.24314527457863,
                    "quality": 0.2256048274001388,
                    "question": 0.16249171918117955,
                    "readability": 0.2652878997583233,
                    "reason": 0.19713974989695102,
                    "response": 0.28148617424037636,
                    "standard": 0.41577614037495547
                },
                "Max term": "standard",
                "Max score": 0.41577614037495547
            }
        ],
        "Best Answer": "Just one public class must be put in each file, no more. ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "class": 0.5284280270301372,
                "file": 0.5284280270301372,
                "public": 0.6644754626756907
            },
            "Max term": "public",
            "Max score": 0.6644754626756907
        }
    },
    {
        "ID": "2682",
        "Question": "Weâ€™re working on a .Net framework which ultimately amounts to a single DLL.  We intend to charge for commercial use of the framework, but make it free for open source/non-commercial use.  The rough plan at the moment is to administer this through some form of fairly simple licence which will be issued whether youâ€™re using it for free or paying. Weâ€™re debating whether to make the source code available.  Itâ€™s our perception (and our own preference) that itâ€™s far more appealing to use something where you have access to the source code. Iâ€™m interested in whether people think making the source code available will damage our ability to make money from the framework, or whether it will encourage more usage and enough â€œgoodâ€ people will arrange to pay for the correct licence if using it commercially. My feeling is that, generally, commercial operations donâ€™t mess about on the licencing front and so making the source code available will only encourage usage and therefore ultimately generate more revenue, but Iâ€™d be interested in others views/experience. ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "ability": 0.08882625278495573,
                    "access": 0.0823537926900093,
                    "amounts": 0.11978578385393569,
                    "available": 0.24916010806933114,
                    "charge": 0.10418653704251074,
                    "code": 0.16771400633332403,
                    "commercial": 0.32706264375215527,
                    "correct": 0.0878877135646514,
                    "dll": 0.11978578385393569,
                    "encourage": 0.20837307408502148,
                    "experience": 0.0686797751283413,
                    "fairly": 0.09436017365959783,
                    "far": 0.08102662937924326,
                    "feeling": 0.10032638774268576,
                    "form": 0.08613775876863135,
                    "framework": 0.23585688403852495,
                    "free": 0.15295879706810753,
                    "generally": 0.0823537926900093,
                    "generate": 0.10418653704251074,
                    "good": 0.05238095165048194,
                    "intend": 0.11549334134566486,
                    "interested": 0.17765250556991147,
                    "licence": 0.22397232089644642,
                    "make": 0.16307862245560245,
                    "making": 0.16079175307306445,
                    "mess": 0.11198616044822321,
                    "moment": 0.09865261616786865,
                    "money": 0.08453381027668491,
                    "net": 0.07322700597353081,
                    "non": 0.07081933794046251,
                    "open": 0.07455416928429684,
                    "operations": 0.09865261616786865,
                    "pay": 0.10032638774268576,
                    "paying": 0.11549334134566486,
                    "people": 0.10714855841540992,
                    "plan": 0.09865261616786865,
                    "preference": 0.11978578385393569,
                    "rough": 0.11978578385393569,
                    "simple": 0.07410153103089712,
                    "single": 0.07861896134617499,
                    "source": 0.35600132998165174,
                    "think": 0.050852359921092515,
                    "ultimately": 0.21804176250143684,
                    "usage": 0.21804176250143684,
                    "use": 0.13535729401952243,
                    "using": 0.11241797404526008,
                    "views": 0.11549334134566486,
                    "working": 0.06392057257119198
                },
                "Max term": "source",
                "Max score": 0.35600132998165174
            }
        ],
        "Best Answer": "You should definitely make the source available.  Whether it's freely available or only available to those who buy a license is up to you, but I would never use a third-party library with no source.  Unlike Robert Harvey, I emphatically do not \"know that I will probably never need it.\"  Any library of non-trivial complexity is almost certain to have bugs in there somewhere, have missing or poorly-implemented features that could benefit from customization/extension, or most likely both.  (Yes, even yours.)  I've used a lot of different libraries, from different people and written in different languages, and I can't think of any that I've never needed the source from at one point or another. If you want to do it right, add a provision in the license like what the GPL and MPL have, that if they make changes to the code and end up publishing a product using it, they have to publish the changes they made. That way you get free bugfixes and (potential) features just by letting other people use your code. ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "add": 0.1037034882358238,
                "available": 0.32139424867472177,
                "benefit": 0.12725304904846668,
                "bugs": 0.10451710297356565,
                "buy": 0.12342810416793369,
                "certain": 0.11005396979231526,
                "changes": 0.205831413895887,
                "code": 0.10816803194419747,
                "complexity": 0.1294120646385216,
                "definitely": 0.113367287756154,
                "different": 0.24942334534515195,
                "end": 0.08610739208822281,
                "features": 0.19475768025838783,
                "free": 0.09865158199444672,
                "gpl": 0.13439131189283843,
                "implemented": 0.12342810416793369,
                "know": 0.06738087521098249,
                "languages": 0.08457995446713394,
                "letting": 0.15451294471639787,
                "libraries": 0.113367287756154,
                "library": 0.22442597076474027,
                "license": 0.25053389446756275,
                "like": 0.05507888079516618,
                "likely": 0.10451710297356565,
                "lot": 0.07926629478787432,
                "make": 0.14023788892252548,
                "missing": 0.1317769986414968,
                "need": 0.07273325771260436,
                "needed": 0.10713141622490727,
                "non": 0.091350610197531,
                "party": 0.12725304904846668,
                "people": 0.13821205447108656,
                "point": 0.08859076558266701,
                "poorly": 0.15451294471639787,
                "potential": 0.12526694723378137,
                "probably": 0.087735059187078,
                "product": 0.10141142660931073,
                "publish": 0.14445212830461815,
                "publishing": 0.15451294471639787,
                "right": 0.08859076558266701,
                "robert": 0.15451294471639787,
                "source": 0.27552591993133296,
                "think": 0.06559499486823263,
                "trivial": 0.13439131189283843,
                "unlike": 0.14897607789764827,
                "use": 0.11639919983216224,
                "used": 0.07539867917223257,
                "using": 0.07250456460662051,
                "want": 0.07296407822685896,
                "way": 0.06794270358321952,
                "written": 0.10535830306862413,
                "yes": 0.10069215809303265
            },
            "Max term": "available",
            "Max score": 0.32139424867472177
        }
    },
    {
        "ID": "2699",
        "Question": "This is a \"Share the Knowledge\" question. I am interested in learning from your successes and/or failures. Information that might be helpful... Background:  Context: Language, Application, Environment, etc. How was the bug identified ? Who or what identified the bug ? How complex was reproducing the bug ?   The Hunting.  What was your plan  ? What difficulties did you encounter ? How was the offending code finally found ?  The Killing.  How complex was the fix ? How did you determine the scope of the fix ? How much code was involved in the fix ?  Postmortem.  What was the root cause technically ? buffer overrun, etc. What was the root cause from 30,000 ft ? How long did the process ultimately take ? Were there any features adversely effected by the fix ? What methods, tools, motivations did you find particularly helpful ? ...horribly useless ? If you could do it all again ?............  These examples are general, not applicable in every situation and possibly useless. Please season as needed. ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "000": 0.13450654328529382,
                    "30": 0.1205019938317105,
                    "applicable": 0.13871901719548918,
                    "application": 0.0824912570370302,
                    "background": 0.11493003135873608,
                    "bug": 0.3046006015084913,
                    "cause": 0.22368967324171157,
                    "code": 0.10072062102197563,
                    "complex": 0.21112381211238948,
                    "context": 0.11849162730180413,
                    "determine": 0.13094494734222578,
                    "encounter": 0.13450654328529382,
                    "environment": 0.0944292105830646,
                    "examples": 0.10556190605619474,
                    "failures": 0.13450654328529382,
                    "features": 0.09067426924502006,
                    "finally": 0.12270410121199948,
                    "fix": 0.40990684527325777,
                    "general": 0.10153353383616376,
                    "helpful": 0.21112381211238948,
                    "horribly": 0.13871901719548918,
                    "information": 0.09582992063736608,
                    "interested": 0.10668918522850977,
                    "involved": 0.10448707784822078,
                    "knowledge": 0.09010375532367915,
                    "language": 0.06772554472974203,
                    "learning": 0.08847216186473109,
                    "long": 0.07981500465387638,
                    "methods": 0.09975537669672144,
                    "needed": 0.09975537669672144,
                    "particularly": 0.11664226936681668,
                    "plan": 0.11849162730180413,
                    "possibly": 0.11849162730180413,
                    "process": 0.08795293462342708,
                    "question": 0.07380877967035962,
                    "reproducing": 0.14387466858783518,
                    "root": 0.28774933717567036,
                    "scope": 0.12270410121199948,
                    "share": 0.11184483662085579,
                    "situation": 0.10556190605619474,
                    "technically": 0.13450654328529382,
                    "tools": 0.09511895254567942,
                    "ultimately": 0.13094494734222578,
                    "useless": 0.241003987663421
                },
                "Max term": "fix",
                "Max score": 0.40990684527325777
            }
        ],
        "Best Answer": "It was actually in a 3rd party image viewer sub-component of our application.  We found that there were 2-3 of the users of our application would frequently have the image viewer component throw an exception and die horribly. However, we had dozens of other users who never saw the issue despite using the application for the same task for most of the work day. Also there was one user in particular who got it a lot more frequently than the rest of them. We tried the usual steps:  (1) Had them switch computers with another user who never had the problem to rule out the computer/configuration. - The problem followed them. (2) Had them log into the application and work as a user that never saw the problem. - The problem STILL followed them. (3) Had the user report which image they were viewing and set up a test harness to repeat viewing that image thousands of times in quick succession. The problem did not present itself in the harness.   (4) Had a developer sit with the users and watch them all day. They saw the errors, but didn't notice them doing anything out of the ordinary to cause them. We struggled with this for weeks trying to figure out what the \"Error Users\" had in common that the other users didn't. I have no idea how, but the developer in step (4) had a eureka moment on the drive in to work one day worthy of Encyclopedia Brown. He realized that all the \"Error Users\" were left handed, and confirmed this fact. Only left-handed users got the errors, never Righties. But how could being left handed cause a bug? We had him sit down and watch the left-handers again specifically paying attention to anything they might be doing differently, and that's how we found it. It turned out that the bug only happened if you moved the mouse to rightmost column of pixels in the image viewer while it was loading a new image (overflow error because the vendor had a 1-off calculation for mouseover event).  Apparently, while waiting for the next image to load, the users all naturally moved their hand (and thus the mouse)  towards the keyboard.  The one user who happened to get the error most frequently was one of those ADD types that compulsively moved her mouse around a lot impatiently while waiting for the next page to load, thus she was moving the mouse to the right much more quickly and hitting the timing just right so she did it when the load event happened. Until we got a fix from the vendor, we told her just to let go of the mouse after clicking (next document) and not touch it until it loaded.  It was henceforth known in legend on the dev team as \"The Left Handed Bug\" ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "3rd": 0.05405690352574528,
                "actually": 0.0326558554547633,
                "add": 0.03986348387524534,
                "apparently": 0.05278326847766769,
                "application": 0.13621669301111652,
                "attention": 0.05405690352574528,
                "bug": 0.12574570965762483,
                "calculation": 0.05939457182204081,
                "cause": 0.09234393026658914,
                "common": 0.0360992348778552,
                "component": 0.10811380705149055,
                "computer": 0.03767378114486597,
                "computers": 0.05065490418729121,
                "configuration": 0.05278326847766769,
                "day": 0.11302134343459791,
                "despite": 0.05405690352574528,
                "dev": 0.05278326847766769,
                "developer": 0.06560295609493402,
                "differently": 0.05405690352574528,
                "document": 0.049745826680860174,
                "dozens": 0.05726620753166432,
                "drive": 0.05065490418729121,
                "error": 0.17617440337167237,
                "errors": 0.08808720168583618,
                "event": 0.10811380705149055,
                "exception": 0.05165984274733952,
                "fact": 0.04017623630556745,
                "figure": 0.04504853940296641,
                "fix": 0.04230460059594394,
                "followed": 0.11878914364408162,
                "frequently": 0.1423368005441165,
                "got": 0.11452770615674576,
                "hand": 0.04230460059594394,
                "handed": 0.23757828728816324,
                "happened": 0.14674771182095114,
                "horribly": 0.05726620753166432,
                "idea": 0.034394855701737455,
                "image": 0.40086345272165025,
                "issue": 0.040499592510799085,
                "keyboard": 0.05165984274733952,
                "known": 0.04559372175842783,
                "left": 0.2582992137366976,
                "let": 0.03870593254662256,
                "load": 0.14445734707976918,
                "loading": 0.05939457182204081,
                "log": 0.04891590394031705,
                "lot": 0.06093971799562525,
                "moment": 0.04891590394031705,
                "mouse": 0.28633103765832163,
                "moved": 0.1665816218540705,
                "moving": 0.05165984274733952,
                "new": 0.028136855508857066,
                "notice": 0.04815244902658972,
                "ordinary": 0.05939457182204081,
                "overflow": 0.04678753964994056,
                "page": 0.04678753964994056,
                "particular": 0.03870593254662256,
                "party": 0.04891590394031705,
                "paying": 0.05726620753166432,
                "present": 0.05552720728469017,
                "problem": 0.1547048588408445,
                "quick": 0.05165984274733952,
                "quickly": 0.04271053822222832,
                "realized": 0.05552720728469017,
                "repeat": 0.05278326847766769,
                "report": 0.05065490418729121,
                "rest": 0.05065490418729121,
                "right": 0.06810834650555826,
                "rule": 0.04744560018137216,
                "saw": 0.15497952824201858,
                "set": 0.03743229749854497,
                "sit": 0.11453241506332865,
                "specifically": 0.04617196513329457,
                "step": 0.049745826680860174,
                "steps": 0.04891590394031705,
                "sub": 0.05552720728469017,
                "switch": 0.05065490418729121,
                "task": 0.03926715879913641,
                "team": 0.035496628540703505,
                "test": 0.03356493296119433,
                "throw": 0.05405690352574528,
                "times": 0.03926715879913641,
                "told": 0.05278326847766769,
                "touch": 0.05552720728469017,
                "tried": 0.04453284113450289,
                "trying": 0.03674249619057109,
                "turned": 0.05065490418729121,
                "types": 0.043578235644021523,
                "user": 0.17947053329536525,
                "users": 0.3074978884687463,
                "using": 0.027870658849055648,
                "usual": 0.05552720728469017,
                "vendor": 0.11453241506332865,
                "waiting": 0.11878914364408162,
                "watch": 0.10556653695533538,
                "weeks": 0.04559372175842783,
                "work": 0.07544586459502911
            },
            "Max term": "image",
            "Max score": 0.40086345272165025
        }
    },
    {
        "ID": "2700",
        "Question": "I have had a few that I am proud of and some of them were written by myself few years ago. It doesn't have to be necessarily buggy, just bad code.  ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "ago": 0.47149706056836965,
                    "bad": 0.3838374323835591,
                    "code": 0.22725047789864525,
                    "necessarily": 0.4867818644912451,
                    "written": 0.4426950235220493,
                    "years": 0.3818129125928828
                },
                "Max term": "necessarily",
                "Max score": 0.4867818644912451
            }
        ],
        "Best Answer": "I don't know about being proud of the fix because it was so obvious, but the most horrible code I remember fixing was this. if (userName==\"John O'Reily\") { userName= \"John O''Reily\";} if (userName==\"Stacy O'Neil\") { userName= \"Stacy O''Neil\";} if (userName==\"Finnegan O'Connor\") { userName= \"Finnegan O''Connor\";} ... someSQL = \"SELECT * from Users where UserName='\" + userName + \"'\";  Apparently the previous developer just kept adding new lines every time a new (usually Irish) user started getting errors in the application. I'll leave it as an exercise for the class as to how it was fixed. ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "adding": 0.2006796057172002,
                "apparently": 0.20504370403080618,
                "application": 0.13228801517683464,
                "class": 0.15367871033872096,
                "code": 0.08076086800564901,
                "developer": 0.12742175220512222,
                "errors": 0.17109328990316638,
                "exercise": 0.20504370403080618,
                "fix": 0.16433790960493933,
                "fixed": 0.18705466317880462,
                "fixing": 0.196775786749209,
                "getting": 0.14023233205357885,
                "horrible": 0.23072620087684878,
                "john": 0.46145240175369756,
                "kept": 0.2099913106374674,
                "know": 0.10061638122114654,
                "leave": 0.18175248916938472,
                "lines": 0.19324435293418155,
                "new": 0.21860279742837824,
                "obvious": 0.1793612071847636,
                "previous": 0.16756185608813895,
                "remember": 0.16137216633276202,
                "select": 0.20504370403080618,
                "started": 0.150358399663785,
                "time": 0.09093782171152574,
                "user": 0.13943548390465968,
                "users": 0.14931461202511498,
                "usually": 0.150358399663785
            },
            "Max term": "john",
            "Max score": 0.46145240175369756
        }
    },
    {
        "ID": "2715",
        "Question": "Should curly braces be on their own line or not? What do you think about it? if (you.hasAnswer()) {     you.postAnswer(); } else {     you.doSomething(); }  or should it be if (you.hasAnswer()) {     you.postAnswer(); } else {     you.doSomething(); }  or even if (you.hasAnswer())     you.postAnswer(); else     you.doSomething();  Please be constructive! Explain why, share experiences, back it up with facts and references. ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "braces": 0.3931888662400469,
                    "curly": 0.40780218146292435,
                    "experiences": 0.33061394591178045,
                    "explain": 0.26390944884769657,
                    "facts": 0.3931888662400469,
                    "line": 0.2780695553079903,
                    "references": 0.3711538361953346,
                    "share": 0.3170159751332751,
                    "think": 0.17312324251804737
                },
                "Max term": "curly",
                "Max score": 0.40780218146292435
            }
        ],
        "Best Answer": "You should never do the 3rd method.  Skimping on braces might save you a few keystrokes the first time, but the next coder who comes along, adds something to your else clause without noticing the block is missing braces is going to be in for a lot of pain.  Write your code for other people.  ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "3rd": 0.26630649370937864,
                "block": 0.24506835974696511,
                "braces": 0.5642336849178925,
                "code": 0.1024192073577779,
                "coder": 0.26630649370937864,
                "comes": 0.22461338672247827,
                "going": 0.15125315084083457,
                "keystrokes": 0.29260203851233224,
                "lot": 0.15010703137411663,
                "method": 0.20464873364477607,
                "missing": 0.24954684866249122,
                "pain": 0.2600320447158772,
                "people": 0.13086647516635405,
                "save": 0.25449758847303844,
                "time": 0.11532540261808377,
                "write": 0.14425910786778823
            },
            "Max term": "braces",
            "Max score": 0.5642336849178925
        }
    },
    {
        "ID": "2756",
        "Question": "Coding standards are common in any software development organization, but how important are they to follow?  I can understand the need for some consistency, but when dealing with simple things like the position of braces, line length, etc., I'm not sure excessively strict standards contribute much to software development. Isn't it more important that your code is readable, not that it conforms to a predefined standard?  It seems they're more like... guidelines anyway. ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "braces": 0.21773843186239497,
                    "code": 0.07904738124919719,
                    "coding": 0.12823061578969341,
                    "common": 0.13725705145377953,
                    "consistency": 0.22583093044041327,
                    "contribute": 0.21773843186239497,
                    "dealing": 0.1926008352793762,
                    "development": 0.2282920184012415,
                    "excessively": 0.211126379081091,
                    "follow": 0.164006730587588,
                    "guidelines": 0.22583093044041327,
                    "important": 0.2883716777531622,
                    "length": 0.21773843186239497,
                    "like": 0.16100288452102665,
                    "line": 0.15398815714296177,
                    "need": 0.10630448661339013,
                    "organization": 0.18039837152739585,
                    "position": 0.1755557372743757,
                    "readable": 0.1926008352793762,
                    "simple": 0.13970286925009612,
                    "software": 0.21328369224911886,
                    "standard": 0.14821953507200128,
                    "standards": 0.3557925678401078,
                    "strict": 0.22583093044041327,
                    "sure": 0.13281076962600277,
                    "things": 0.10732612842401773,
                    "understand": 0.12361922070011236
                },
                "Max term": "standards",
                "Max score": 0.3557925678401078
            }
        ],
        "Best Answer": "Asking everyone to 100% adhere to the same standard code formatting guideline is like asking everyone to collaborate separately on writing a 100 page paper with the same writing style.   Hopefully everyone will write the paper in English (or same language), but different styles will be apparent.  Some will write it well, others not.  Some will use contractions, some will spell the words out fully (example: it's verus it is).  Etc. I think you touched on the most important points:   It's a guideline Readability  If you want the code to adhere to the same formatting, like a paper to be in the same writing style, it'll need editing and revising.  The code will need to be cleaned up, reviewed, re-factored, etc. I've never been in a shop where I was completely happy with another developer's coding style or formatting (at minimal because it's not exactly like mine).  But I'll be content if I can read/understand it and if it's consistent.  Everything else is the sugar on the syntactic sugar. So to answer your question: somewhat important, but it's certainly not the end of the world if they don't. ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "100": 0.20750989002005615,
                "answer": 0.07787031571356055,
                "apparent": 0.1317120023706533,
                "asking": 0.18590048103103443,
                "certainly": 0.10238986147278634,
                "code": 0.13830907280305418,
                "coding": 0.07478829909589742,
                "collaborate": 0.1317120023706533,
                "completely": 0.09767005099415177,
                "consistent": 0.12313582593759613,
                "content": 0.12313582593759613,
                "developer": 0.07273978449232062,
                "different": 0.07087226750633636,
                "editing": 0.12313582593759613,
                "end": 0.07340082121709225,
                "english": 0.11455964950453895,
                "exactly": 0.1052142445321401,
                "example": 0.0702846893442417,
                "formatting": 0.36940747781278843,
                "fully": 0.11987531498107358,
                "happy": 0.11031517259441087,
                "hopefully": 0.11705093192171982,
                "important": 0.16818781656605508,
                "language": 0.06200026172468132,
                "like": 0.14085324096012705,
                "minimal": 0.1317120023706533,
                "need": 0.12400052344936265,
                "page": 0.10375494501002808,
                "paper": 0.32542426646598793,
                "points": 0.09565410214547738,
                "question": 0.06756924105081415,
                "read": 0.07915261459079567,
                "readability": 0.11031517259441087,
                "separately": 0.12313582593759613,
                "shop": 0.12699219189201874,
                "somewhat": 0.10678173586882216,
                "standard": 0.08644649214661775,
                "style": 0.29301015298245536,
                "styles": 0.12313582593759613,
                "sugar": 0.2634240047413066,
                "syntactic": 0.1317120023706533,
                "think": 0.055915367708805015,
                "understand": 0.07209878229770499,
                "use": 0.04961128568346049,
                "want": 0.062197020851733745,
                "words": 0.10847475548866264,
                "world": 0.08147929342526805,
                "write": 0.12987370870056078,
                "writing": 0.22020246365127674
            },
            "Max term": "formatting",
            "Max score": 0.36940747781278843
        }
    },
    {
        "ID": "2776",
        "Question": "The Joel Test is a well known test for determining how good your team is. What do you think about the points? Do you disagree with any of them? Is there anything that you would add? ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "add": 0.3008520017981107,
                    "disagree": 0.4079705548974104,
                    "good": 0.19601644809453164,
                    "joel": 0.3399839135956628,
                    "known": 0.3440984361371167,
                    "points": 0.3255387244376815,
                    "team": 0.2678950938401611,
                    "test": 0.5066329527643452,
                    "think": 0.1902962556974766
                },
                "Max term": "test",
                "Max score": 0.5066329527643452
            }
        ],
        "Best Answer": "Jeff Atwood has The Programmer's Bill of Rights. From the post:   Every programmer shall have two monitors Every programmer shall have a fast PC Every programmer shall have their choice of mouse and keyboard Every programmer shall have a comfortable chair Every programmer shall have a fast internet connection Every programmer shall have quiet working conditions   This seems to have some items that I'd like to see on Joel's list.  Specifically in the area of hardware (dual monitor, fast PC, mouse/keyboard, comfortable chair, fast connection).   The only thing not mentioned is having a comfortable and adjustable desk. This could all be added by changing: Current #9: Do you use the best tools money can buy? to  Improved #9: Do you use the best tools and equipment money can buy? ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "added": 0.09761063953343853,
                "area": 0.11256013607057598,
                "best": 0.12693900601003977,
                "buy": 0.19235554869469765,
                "changing": 0.09617777434734882,
                "choice": 0.09027327147949431,
                "comfortable": 0.3287389757537581,
                "conditions": 0.10699785155112851,
                "connection": 0.20944107270557252,
                "current": 0.08833817462955912,
                "desk": 0.11256013607057598,
                "dual": 0.12039973578836571,
                "equipment": 0.12039973578836571,
                "fast": 0.3696952017615776,
                "hardware": 0.0924238004403944,
                "improved": 0.11256013607057598,
                "internet": 0.09617777434734882,
                "items": 0.11256013607057598,
                "jeff": 0.12039973578836571,
                "joel": 0.09131865211554906,
                "keyboard": 0.20944107270557252,
                "like": 0.042918622173881364,
                "list": 0.08080793882248755,
                "mentioned": 0.10699785155112851,
                "money": 0.16993416238620362,
                "monitor": 0.10957965858458603,
                "monitors": 0.11608529272797097,
                "mouse": 0.23217058545594194,
                "pc": 0.21399570310225702,
                "post": 0.09027327147949431,
                "programmer": 0.43566297909912693,
                "quiet": 0.11608529272797097,
                "rights": 0.10699785155112851,
                "specifically": 0.09359596731389129,
                "thing": 0.0686955211022048,
                "tools": 0.159198236456396,
                "use": 0.0907007042775117,
                "working": 0.06424819207592228
            },
            "Max term": "programmer",
            "Max score": 0.43566297909912693
        }
    },
    {
        "ID": "2777",
        "Question": "I have heard a lot of people mention Code Complete as a book worthwhile reading. Unfortunately, I am so busy that I don't have time to read it, so can anyone tell me what the key points of the book are? ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "book": 0.4718674467693479,
                    "code": 0.12848473485653575,
                    "complete": 0.2545068327685474,
                    "heard": 0.2891551435382088,
                    "key": 0.28177714105375284,
                    "lot": 0.1883090352264908,
                    "mention": 0.30743787260352884,
                    "people": 0.16417178766694981,
                    "points": 0.26657886651301993,
                    "read": 0.22059079334689968,
                    "reading": 0.2463632729594552,
                    "tell": 0.26144979943740865,
                    "time": 0.14467553655093243,
                    "unfortunately": 0.3262097919076026
                },
                "Max term": "book",
                "Max score": 0.4718674467693479
            }
        ],
        "Best Answer": "Code Complete is about software craftsmanship; it is an advanced-beginner/intermediate-level book, written for the working programmer, but it would still be very useful to someone who's been programming for at least a year.   Thus the key points of Code Complete (2nd ed.) are nicely summarized in its Chapter 34, Themes in Software Craftsmanship.  As paraphrased from my notes:  Conquer Complexity: reduce the cognitive load on your mind via discipline, conventions, and abstraction. Pick Your Process: be conscious of quality from start (requirements) to finish (deployment) and beyond (maintenance). Write Programs for People First, Computers Second: code readability is hugely important for comprehensibility, review-ability, error-rate, error-correction, modifiability, and the consequent development time and quality. Program into Your Language, Not in it: think of the What? and Why? before the How? Focus Your Attention with the Help of Conventions: conventions manage complexity by providing structure where it's needed, so that the ultimate resource - your attention - can be effectively used. Program in Terms of the Problem Domain: work at the highest level of abstraction possible; top-level code should describe the problem being solved.  Distinguish OS level, programming language level, low-level implementation structures, low-level problem domain terms, and finally, high-level problem-domain terms that would make total sense to the (non-coder) user. Watch for Falling Rocks: as programming merges art and science, good judgement is vital, including heeding warning signs. Iterate, Repeatedly, Again and Again: iterate requirements, design, estimates, code, code tuning.  Thou Shalt Render Software and Religion Asunder: be eclectic and willing to experiment.  Don't be an inflexible zealot, it precludes curiosity and learning.  Go beyond having just a hammer in your toolbox.  But the most important take-aways are in Chapter 33, Personal Character: once you consciously seek to improve as a coder, you can and will.  The fastest way to do so is to take on the the attitudes of master coders (humility, curiosity, intellectual honesty, discipline, creativity), while also practicing their habits (many good habits are listed in the book, e.g. choosing good variable/value names).   Also, the book makes clear that the gap between average and excellent in software is immense; that fact alone should drive the conscientious coder to better himself. That's the short of it; the long version is in the book. :)  I can also send you my not-so-long, not-so-short notes if you want more details.  But the book is certainly money and time well-spent, even if the writing style is tiresome at times.   Beyond Code Complete, I'd highly recommend The Pragmatic Programmer.  It's for intermediate-level programmers, nicely-written and a great mix of high, medium, and low-level advice. ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "ability": 0.05071605031477988,
                "abstraction": 0.11265298013565837,
                "advanced": 0.06077974662969379,
                "advice": 0.05728214316297191,
                "art": 0.06224633287479541,
                "attention": 0.12449266574959082,
                "average": 0.05463344049900291,
                "beginner": 0.06393938244362168,
                "better": 0.034196644815258165,
                "book": 0.2197970797391404,
                "certainly": 0.05316685425390129,
                "chapter": 0.12155949325938759,
                "character": 0.058328942690572386,
                "choosing": 0.0683926390054863,
                "clear": 0.05632649006782919,
                "code": 0.16757586304469052,
                "coder": 0.18673899862438625,
                "coders": 0.06393938244362168,
                "complete": 0.14225993083229993,
                "complexity": 0.11456428632594381,
                "computers": 0.058328942690572386,
                "conscious": 0.06594183506636489,
                "conventions": 0.19181814733086508,
                "deployment": 0.06077974662969379,
                "design": 0.03921325983940031,
                "details": 0.052501009056581435,
                "development": 0.03456898833986262,
                "discipline": 0.1367852780109726,
                "domain": 0.16897947020348755,
                "drive": 0.058328942690572386,
                "ed": 0.06594183506636489,
                "effectively": 0.05948612588175708,
                "error": 0.10143210062955976,
                "estimates": 0.05544737443975522,
                "excellent": 0.06224633287479541,
                "experiment": 0.0683926390054863,
                "fact": 0.046262793752915275,
                "fastest": 0.06393938244362168,
                "finally": 0.058328942690572386,
                "finish": 0.06224633287479541,
                "focus": 0.05544737443975522,
                "good": 0.08972195368434459,
                "great": 0.04230885417696812,
                "habits": 0.1367852780109726,
                "help": 0.03711488449272273,
                "high": 0.09180532087509542,
                "highest": 0.0683926390054863,
                "highly": 0.05632649006782919,
                "implementation": 0.05544737443975522,
                "important": 0.08733303280252984,
                "improve": 0.05632649006782919,
                "including": 0.052501009056581435,
                "intermediate": 0.1367852780109726,
                "key": 0.052501009056581435,
                "language": 0.06438838438502992,
                "learning": 0.04205635841138689,
                "level": 0.4180953719105067,
                "listed": 0.0683926390054863,
                "load": 0.05544737443975522,
                "long": 0.07588213900463256,
                "low": 0.16162705838612335,
                "maintenance": 0.05948612588175708,
                "make": 0.031037009001330267,
                "makes": 0.03846835869711088,
                "manage": 0.06077974662969379,
                "master": 0.05632649006782919,
                "medium": 0.05948612588175708,
                "mind": 0.046262793752915275,
                "mix": 0.0683926390054863,
                "money": 0.048265246375658474,
                "names": 0.05387568612870778,
                "needed": 0.047419976944099974,
                "nicely": 0.1367852780109726,
                "non": 0.04043486011892432,
                "notes": 0.12449266574959082,
                "os": 0.05544737443975522,
                "people": 0.03058865768495206,
                "personal": 0.05018018393713831,
                "pick": 0.051873233505964574,
                "points": 0.0496692507871794,
                "possible": 0.04022158968817021,
                "pragmatic": 0.05728214316297191,
                "problem": 0.1425136774424251,
                "process": 0.04180953719105067,
                "program": 0.08361907438210134,
                "programmer": 0.07070765601288573,
                "programmers": 0.036647448754379565,
                "programming": 0.0871036691357612,
                "programs": 0.047419976944099974,
                "providing": 0.06393938244362168,
                "quality": 0.09742719538407338,
                "rate": 0.05728214316297191,
                "readability": 0.05728214316297191,
                "recommend": 0.05316685425390129,
                "reduce": 0.05728214316297191,
                "repeatedly": 0.0683926390054863,
                "requirements": 0.09110792375621757,
                "resource": 0.06594183506636489,
                "review": 0.05316685425390129,
                "science": 0.05544737443975522,
                "second": 0.05071605031477988,
                "send": 0.0683926390054863,
                "sense": 0.04918103343037985,
                "short": 0.0983620668607597,
                "signs": 0.06393938244362168,
                "software": 0.1291854445385646,
                "solved": 0.06393938244362168,
                "spent": 0.05948612588175708,
                "start": 0.03811403499948119,
                "structure": 0.06077974662969379,
                "structures": 0.06077974662969379,
                "style": 0.05071605031477988,
                "terms": 0.15561970051789373,
                "think": 0.029034556378587068,
                "time": 0.05391219192814023,
                "times": 0.04521599422531479,
                "total": 0.05948612588175708,
                "used": 0.03337399759988988,
                "useful": 0.04426034113017207,
                "user": 0.04133193663747258,
                "value": 0.051873233505964574,
                "variable": 0.058328942690572386,
                "version": 0.04918103343037985,
                "vital": 0.0683926390054863,
                "want": 0.03229636113464115,
                "warning": 0.06393938244362168,
                "watch": 0.06077974662969379,
                "way": 0.03007373141294322,
                "willing": 0.05463344049900291,
                "work": 0.028958548586813317,
                "working": 0.03649595556528042,
                "write": 0.03371904426168007,
                "writing": 0.03811403499948119,
                "written": 0.09327027455503945,
                "year": 0.0496692507871794
            },
            "Max term": "level",
            "Max score": 0.4180953719105067
        }
    },
    {
        "ID": "2806",
        "Question": "There's around a zillion \"PHP frameworks\". And most of them bill themselves as following the MVC pattern. While it's welcome to overcome osCommerce coding style (processing logic heavily intermixed with SQL and HTML), there are certainly simpler and easier to follow approaches to get a maintainable application design. The original MVC concept was targetted at GUI applications. And for Gtk/Python it seems feasible to follow it accordingly. But PHP web apps don't operate on live Views (GUI elements) and a persistent Controller runtime. It's quite certainly a misnomer if it just describes the used code + directory grouping or class naming. \"MVC\" seems to be used like a buzzword for PHP frameworks. And I've actually seen one or two mature PHP frameworks admit it, but redefining the phrase anyway to match interna. So is it generally snake oil? Why isn't better terminology used, and a more sensible concept for maintainable PHP propagated? Some elaborative reasoning Why I suspect that PHP implementations don't follow the real MVC pattern: Models: in theory, Models should be fat and contain business logic, and controllers should be thin handlers (input->output). In reality the PHP frameworks advocate shallow Models. CI and Symfony for example equate Model == ORM. Even HTTP input is handled by the controller, isn't treated as model. Views: workarounds with AJAX discounted, there can't be Views on web pages. PHP frameworks still pump out pages. The interface still effectively follows the ordinary HTTP model, there's no advantage over non-MVC applications. (And lastly, none of the widespread php frameworks can factually output to GUI Views instead of HTML. I've seen a PHP library that can operate Gtk/Console/Web, but the frameworks don't.) Controller: I'm unsure. Controllers probably don't need to be long-running and persistently active in the MVC model. In PHP framework context, they're however mostly request handlers. Not really something to get argumentative about, but it just feels slightly buzzwordish. Would there be better descriptors? I've seen acronyms like PMVC or HMVC thrown around. Though descriptions get more ambigous there, maybe these would describe the current web frameworks less hokey? ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "active": 0.06103307697494487,
                    "actually": 0.03355672544664468,
                    "admit": 0.058845997961150774,
                    "advantage": 0.05111815399717252,
                    "advocate": 0.058845997961150774,
                    "application": 0.034993618334052706,
                    "applications": 0.08537426449160011,
                    "approaches": 0.052052310027330254,
                    "apps": 0.04807825734444346,
                    "better": 0.06103365758783125,
                    "business": 0.039773704701216384,
                    "certainly": 0.09489140221460766,
                    "ci": 0.06103307697494487,
                    "class": 0.04065201317348331,
                    "code": 0.021363348656631594,
                    "coding": 0.034655611739163227,
                    "concept": 0.0937030117160875,
                    "console": 0.058845997961150774,
                    "context": 0.05026533635823756,
                    "controller": 0.17653799388345234,
                    "current": 0.044780418965944216,
                    "describes": 0.05705902429205808,
                    "design": 0.034993618334052706,
                    "directory": 0.058845997961150774,
                    "easier": 0.039497595741530236,
                    "effectively": 0.05308497160917128,
                    "elements": 0.058845997961150774,
                    "example": 0.03256871642445682,
                    "feels": 0.055548159582651524,
                    "follow": 0.132973398190056,
                    "following": 0.04388878456383184,
                    "follows": 0.06103307697494487,
                    "framework": 0.04005781792422323,
                    "frameworks": 0.37033026940280606,
                    "generally": 0.04196078371501048,
                    "grouping": 0.058845997961150774,
                    "gui": 0.16271816712337306,
                    "handled": 0.055548159582651524,
                    "html": 0.09258256735070151,
                    "http": 0.09258256735070151,
                    "implementations": 0.06103307697494487,
                    "input": 0.10223630799434504,
                    "instead": 0.039497595741530236,
                    "interface": 0.04685150585804375,
                    "library": 0.044324466063352,
                    "like": 0.04351264649619267,
                    "live": 0.05026533635823756,
                    "logic": 0.09152271790152006,
                    "long": 0.0338583252396628,
                    "maintainable": 0.11109631916530305,
                    "match": 0.058845997961150774,
                    "maybe": 0.04096318914693246,
                    "model": 0.1830454358030401,
                    "models": 0.16271816712337306,
                    "mvc": 0.3530759877669047,
                    "naming": 0.05423938904112435,
                    "need": 0.02872985512482293,
                    "non": 0.03608376524133643,
                    "ordinary": 0.06103307697494487,
                    "original": 0.04744570110730383,
                    "orm": 0.058845997961150774,
                    "output": 0.09896164035924114,
                    "overcome": 0.058845997961150774,
                    "pages": 0.12206615394988975,
                    "pattern": 0.097508943297662,
                    "php": 0.47378697387687196,
                    "phrase": 0.06103307697494487,
                    "probably": 0.034655611739163227,
                    "processing": 0.058845997961150774,
                    "python": 0.04128456941062294,
                    "quite": 0.0389676710169395,
                    "real": 0.036884309583609574,
                    "reality": 0.05308497160917128,
                    "really": 0.028461311754004504,
                    "reasoning": 0.058845997961150774,
                    "request": 0.05423938904112435,
                    "running": 0.044780418965944216,
                    "runtime": 0.05705902429205808,
                    "seen": 0.12485053791977496,
                    "simpler": 0.05705902429205808,
                    "slightly": 0.06103307697494487,
                    "sql": 0.04525862209350973,
                    "style": 0.04525862209350973,
                    "suspect": 0.055548159582651524,
                    "terminology": 0.06103307697494487,
                    "theory": 0.05308497160917128,
                    "treated": 0.06103307697494487,
                    "used": 0.0893481138070564,
                    "views": 0.2353839918446031,
                    "web": 0.1443350609653457,
                    "welcome": 0.06103307697494487
                },
                "Max term": "php",
                "Max score": 0.47378697387687196
            }
        ],
        "Best Answer": "I think you are looking at this in completely the wrong way. A GUI app and a web page are worlds apart so the exact same definition of MVC will never work for both. MVC is more about the ideal: separating certain parts of the app like display and logic. In PHP (or the web in general), a View is the web page itself: the HTML output. It's not \"live\" as per your definition, but you simply click links to go back to the controller (i.e. another page request). The Controller and Model is where things do differ, like you explained. In PHP the model tends to be the data layer, interacting with the database and so on. But it is still modelling the situation, and the controller still controls the application flow, if only once per page load. So the name \"Model-View-Controller\" is perfectly logical, albeit a different implementation in GUI apps vs web apps. ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "apart": 0.10093754338200378,
                "app": 0.14803485491689877,
                "application": 0.06512185942965976,
                "apps": 0.1789437997819787,
                "certain": 0.08089916712372784,
                "click": 0.10093754338200378,
                "completely": 0.08422466056005293,
                "controller": 0.4380411045970612,
                "controls": 0.10337311807500642,
                "data": 0.06943352363271342,
                "database": 0.08422466056005293,
                "definition": 0.18146062056080045,
                "different": 0.06111589594849161,
                "display": 0.1061847827129402,
                "exact": 0.09878921424927044,
                "explained": 0.1095102761492653,
                "flow": 0.11358035117660996,
                "general": 0.08015458553270827,
                "gui": 0.20187508676400756,
                "html": 0.08614640645466425,
                "ideal": 0.10337311807500642,
                "implementation": 0.09208201865383782,
                "layer": 0.09354197491833402,
                "like": 0.08097546305407642,
                "links": 0.1095102761492653,
                "live": 0.09354197491833402,
                "load": 0.09208201865383782,
                "logic": 0.08516023568793571,
                "logical": 0.09073031028040023,
                "looking": 0.06715058343802345,
                "model": 0.2554807070638071,
                "mvc": 0.2190205522985306,
                "output": 0.09208201865383782,
                "page": 0.3578875995639574,
                "parts": 0.09354197491833402,
                "perfectly": 0.1061847827129402,
                "php": 0.16030917106541653,
                "request": 0.10093754338200378,
                "separating": 0.11358035117660996,
                "simply": 0.07623101503685395,
                "situation": 0.08333474181673048,
                "tends": 0.10337311807500642,
                "things": 0.053979051200173434,
                "think": 0.0482179830708457,
                "view": 0.18708394983666804,
                "vs": 0.08829473558739759,
                "way": 0.049943751619222224,
                "web": 0.2686023337520938,
                "work": 0.04809175615801772,
                "wrong": 0.07350359866005807
            },
            "Max term": "controller",
            "Max score": 0.4380411045970612
        }
    },
    {
        "ID": "2829",
        "Question": "I originally thought of creative commons when while reading a book about wordpress (professional wordpress), I learned that I should also specify that the product is provided   ... WITHOUT ANY WARRANTY; without even the   implied warranty of MERCHANTABILITY or   FITNESS FOR A PARTICULAR PURPOSE  and they recommend GNU GPL.  How do I write a license or select 1? btw, what does MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE mean actually? Isn't without warranty enough?  ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "actually": 0.1234613436582577,
                    "book": 0.14433087411431314,
                    "creative": 0.22455187717602543,
                    "gnu": 0.22455187717602543,
                    "gpl": 0.1953093406968311,
                    "implied": 0.21650521260623215,
                    "learned": 0.16651476630729264,
                    "license": 0.1820490069688674,
                    "mean": 0.14956620772761617,
                    "originally": 0.18807305819679435,
                    "particular": 0.29266949973928014,
                    "product": 0.1473800544932773,
                    "professional": 0.17456143087708592,
                    "provided": 0.1953093406968311,
                    "purpose": 0.3406282350947227,
                    "reading": 0.15071108117056528,
                    "recommend": 0.17456143087708592,
                    "select": 0.19955665402655567,
                    "specify": 0.22455187717602543,
                    "thought": 0.15569284930776423,
                    "wordpress": 0.4330104252124643,
                    "write": 0.1107089124742557
                },
                "Max term": "wordpress",
                "Max score": 0.4330104252124643
            }
        ],
        "Best Answer": "For small bits of code, I generally release them under the X11 licence. The problem with the GPL is that it's far too complicated for code that you don't really care enough about to protect. If you really don't want people using your code in commercial products, you would need to monitor for infringement and fight it out in court, which isn't really worth the time or the effort for small, free, open-source projects.  Copyright (c)   Permission is hereby granted, free of charge, to any person obtaining a copy    of this software and associated documentation files (the \"Software\"), to deal    in the Software without restriction, including without limitation the rights    to use, copy, modify, merge, publish, distribute, sublicense, and/or sell    copies of the Software, and to permit persons to whom the Software is    furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in    all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN    THE SOFTWARE.   EDIT: If the body of code is more substantial, and you feel that you've invested enough time in it that you would be willing to protect it, by all means use the GPL to protect it. ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "action": 0.10565477573250834,
                "associated": 0.10186870833815835,
                "authors": 0.09877526603431723,
                "bits": 0.10186870833815835,
                "body": 0.10186870833815835,
                "care": 0.09189575633612612,
                "charge": 0.09189575633612612,
                "claim": 0.09615979783336052,
                "code": 0.1479289541399585,
                "commercial": 0.09615979783336052,
                "complicated": 0.08322859913194772,
                "conditions": 0.0938941762244888,
                "connection": 0.09189575633612612,
                "contract": 0.08213357671646927,
                "copies": 0.2037374166763167,
                "copy": 0.17402933305259538,
                "deal": 0.08322859913194772,
                "distribute": 0.10565477573250834,
                "documentation": 0.07597617423364743,
                "edit": 0.07037297720844973,
                "effort": 0.08322859913194772,
                "event": 0.09615979783336052,
                "express": 0.09877526603431723,
                "far": 0.07146799962392818,
                "feel": 0.06349346751025862,
                "fight": 0.10565477573250834,
                "files": 0.07525406701827818,
                "following": 0.07597617423364743,
                "free": 0.1349144020316412,
                "generally": 0.07263859881732146,
                "gpl": 0.18379151267225224,
                "granted": 0.10186870833815835,
                "implied": 0.10186870833815835,
                "included": 0.09189575633612612,
                "including": 0.1622099225373811,
                "kind": 0.07091165605797933,
                "licence": 0.09877526603431723,
                "limited": 0.09010810883013882,
                "means": 0.06837455732008704,
                "merge": 0.09877526603431723,
                "modify": 0.09010810883013882,
                "monitor": 0.09615979783336052,
                "need": 0.04973444811387642,
                "notice": 0.17131317043984265,
                "open": 0.06575908911913037,
                "particular": 0.06885253142297149,
                "people": 0.047254175517380266,
                "person": 0.07204320584728183,
                "problem": 0.05503973398287276,
                "products": 0.09010810883013882,
                "projects": 0.061495047621895955,
                "protect": 0.2963257981029517,
                "provided": 0.09189575633612612,
                "publish": 0.09877526603431723,
                "purpose": 0.08013515682810658,
                "really": 0.14780871256041073,
                "release": 0.08322859913194772,
                "rights": 0.0938941762244888,
                "sell": 0.08849098495637439,
                "small": 0.12628724183634732,
                "software": 0.44903053282453337,
                "source": 0.06280084241974977,
                "subject": 0.09189575633612612,
                "substantial": 0.21130955146501668,
                "time": 0.08328499426610333,
                "use": 0.11938933054719042,
                "using": 0.04957806950839037,
                "want": 0.04989228142494815,
                "willing": 0.084399198325341,
                "worth": 0.07091165605797933
            },
            "Max term": "software",
            "Max score": 0.44903053282453337
        }
    },
    {
        "ID": "2932",
        "Question": "When I say Free Software I mean it in the FSF terms. Free as in Free Speech, not as in Free Beer. Why is it a good idea for programmers to use and write Free Software? ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "free": 0.8362780516387104,
                    "fsf": 0.261963937623753,
                    "good": 0.11455383025728579,
                    "idea": 0.15170093086325315,
                    "mean": 0.17448508204215418,
                    "programmers": 0.1403705152946629,
                    "say": 0.136467332782203,
                    "software": 0.2474091380819697,
                    "terms": 0.1986897523490621,
                    "use": 0.09867261536001025,
                    "write": 0.129153864160597
                },
                "Max term": "free",
                "Max score": 0.8362780516387104
            }
        ],
        "Best Answer": "There are literally scores of different reasons why someone might choose to distribute Free software: that's why there are scores of different F/OSS licenses. My favorite reason for going Free is from Linus Torvalds on why he chose and sticks with GPLv2:  Me, I just don't care about proprietary software. It's not \"evil\" or \"immoral,\" it just doesn't matter. I think that Open Source can do better, and I'm willing to put my money where my mouth is by working on Open Source, but it's not a crusade -- it's just a superior way of working together and generating code. It's superior because it's a lot more fun and because it makes cooperation much easier (no silly NDA's or artificial barriers to innovation like in a proprietary setting), and I think Open Source is the right thing to do the same way I believe science is better than alchemy. Like science, Open Source allows people to build on a solid base of previous knowledge, without some silly hiding. But I don't think you need to think that alchemy is \"evil.\" It's just pointless because you can obviously never do as well in a closed environment as you can with open scientific methods.  This goes to Eric S. Raymond's Linus's Law:  Given a large enough beta-tester and co-developer base, almost every problem will be characterized quickly and the fix obvious to someone. Or, less formally, \"Given enough eyeballs, all bugs are shallow.\"  ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "allows": 0.08995427441609433,
                "artificial": 0.1157151443973,
                "base": 0.17990854883218865,
                "believe": 0.08241970295361503,
                "beta": 0.10531606180939382,
                "better": 0.11571624520537516,
                "bugs": 0.07827312905576972,
                "build": 0.07650202385712987,
                "care": 0.10064600147234136,
                "choose": 0.08776556648173853,
                "chose": 0.1157151443973,
                "closed": 0.10531606180939382,
                "code": 0.04050365960783551,
                "developer": 0.06390529727329369,
                "different": 0.12452919279415715,
                "distribute": 0.1157151443973,
                "easier": 0.0748851314911357,
                "environment": 0.07594727998467309,
                "eric": 0.1115685704994547,
                "evil": 0.20129200294468272,
                "favorite": 0.10064600147234136,
                "fix": 0.08241970295361503,
                "free": 0.14776085041239917,
                "fun": 0.08882771497527592,
                "generating": 0.10818057293482068,
                "given": 0.16046199003851844,
                "goes": 0.08321056867754913,
                "going": 0.05981598856617708,
                "knowledge": 0.07246841407424855,
                "large": 0.07827312905576972,
                "law": 0.1115685704994547,
                "licenses": 0.09868813550885187,
                "like": 0.0824974328999108,
                "literally": 0.10818057293482068,
                "lot": 0.059362733420511946,
                "makes": 0.06508553765568598,
                "matter": 0.08403659531960919,
                "methods": 0.08023099501925922,
                "money": 0.08166112662040374,
                "need": 0.054470125038053555,
                "obvious": 0.08995427441609433,
                "obviously": 0.09115356404637255,
                "open": 0.36010310182854416,
                "oss": 0.1157151443973,
                "people": 0.05175368274135279,
                "previous": 0.08403659531960919,
                "problem": 0.0602805762565968,
                "proprietary": 0.2231371409989094,
                "quickly": 0.08321056867754913,
                "reason": 0.07202062036570883,
                "reasons": 0.08166112662040374,
                "right": 0.06634585374372028,
                "science": 0.1876254823046893,
                "scientific": 0.1157151443973,
                "setting": 0.09530013794421785,
                "silly": 0.21636114586964136,
                "software": 0.109285974237741,
                "solid": 0.10531606180939382,
                "source": 0.27512276651920364,
                "superior": 0.21636114586964136,
                "tester": 0.10531606180939382,
                "thing": 0.06602267099457808,
                "think": 0.19649704603972015,
                "way": 0.10176493329158377,
                "willing": 0.09243562681879097,
                "working": 0.12349676308922948
            },
            "Max term": "open",
            "Max score": 0.36010310182854416
        }
    },
    {
        "ID": "2948",
        "Question": "How valuable (or not) do you think daily stand-up meetings are? If you're not familiar with it, this refers to a daily meeting that is part of Scrum adherents (and some other agile methodologies).  The idea is that you hold a daily meeting, timeboxed to 15 minutes, and in which everyone must stand (to encourage people to be to-the-point). In the meeting, you go around the room and each say: - What you did yesterday - What you plan to do today - Any blockers or impediments to your progress. Do you think this practice has value?  Has anyone worked at a place that's done it, and what did you think? ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "15": 0.15211934317309955,
                    "agile": 0.13060591117756434,
                    "daily": 0.4417407091308385,
                    "encourage": 0.15797227368571323,
                    "familiar": 0.14307310331567383,
                    "hold": 0.16140763290283192,
                    "idea": 0.10517712151911855,
                    "meeting": 0.45635802951929866,
                    "meetings": 0.14724690304361282,
                    "methodologies": 0.14958149606914514,
                    "minutes": 0.14508540751260116,
                    "people": 0.0812317112916534,
                    "place": 0.12592922240177165,
                    "plan": 0.14958149606914514,
                    "point": 0.1041353378394821,
                    "practice": 0.13190242872284472,
                    "progress": 0.15797227368571323,
                    "room": 0.165302321962856,
                    "say": 0.0946153801545365,
                    "scrum": 0.1751161545996154,
                    "stand": 0.330604643925712,
                    "think": 0.23131384765408164,
                    "today": 0.14307310331567383,
                    "valuable": 0.165302321962856,
                    "value": 0.1377553592354584,
                    "worked": 0.11920557522318789
                },
                "Max term": "meeting",
                "Max score": 0.45635802951929866
            }
        ],
        "Best Answer": "We had daily standups at my first job. Well, with all the co-ops/interns/temps, it was actually on the long side - usually around 30 minutes. But the idea of a short, timeboxed, daily meeting helped a lot just to know what other people were stuck on - and if it was something I was working on, I could reprioritize my tasks to finish what they needed to continue sooner. It also gave everyone a chance to know what everyone was working on so if someone had an emergency, everyone was at least aware of what was going on - reducing a truck factor is always a good thing. Honestly, every day might be a little extreme in some cases. But the idea of short, regular meetings for everyone to stay on the same page is a valuable addition to any process. ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "30": 0.1571176902937351,
                "actually": 0.10314056325839636,
                "addition": 0.1667111752422859,
                "aware": 0.15998892930288372,
                "cases": 0.13006701285672725,
                "chance": 0.14582997212220963,
                "continue": 0.15998892930288372,
                "daily": 0.3041703024288256,
                "day": 0.11898922729915032,
                "extreme": 0.18087013242295996,
                "factor": 0.1667111752422859,
                "finish": 0.170733836244884,
                "going": 0.09697108894146479,
                "good": 0.08203199899730802,
                "helped": 0.170733836244884,
                "honestly": 0.16316293677198973,
                "idea": 0.21726607622836075,
                "job": 0.10406756588205714,
                "know": 0.16361268190398143,
                "little": 0.11898922729915032,
                "long": 0.10406756588205714,
                "lot": 0.09623629133806409,
                "meeting": 0.1571176902937351,
                "meetings": 0.1520851512144128,
                "minutes": 0.14985263312480773,
                "needed": 0.13006701285672725,
                "ops": 0.18759237836236217,
                "page": 0.14777420850769749,
                "people": 0.08390082806385053,
                "process": 0.11467828459243502,
                "regular": 0.1520851512144128,
                "short": 0.26979473714367747,
                "sooner": 0.18087013242295996,
                "stay": 0.14777420850769749,
                "stuck": 0.17537765756717594,
                "tasks": 0.13763791232962155,
                "thing": 0.1070330935697094,
                "usually": 0.12224918406532928,
                "valuable": 0.170733836244884,
                "working": 0.20020760142180924
            },
            "Max term": "daily",
            "Max score": 0.3041703024288256
        }
    },
    {
        "ID": "2959",
        "Question": "One of the criteria of the Joel Test is daily builds. The idea is that if the build is broken, whoever broke it is around to fix it up. If the build cannot be fixed, everyone will have to check out an old version and work on that. I can understand how this can be pretty bad on centralised version control where it is important to avoid merging and branching as much as possible, but this only sounds like a minor nuisance for distributed version control. Do you agree with this? Are there other reasons why daily builds are important? ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "agree": 0.15437258626762995,
                    "avoid": 0.1376862442651465,
                    "bad": 0.11740461269570344,
                    "broken": 0.18565115372521207,
                    "build": 0.26257374325327426,
                    "builds": 0.36147060142655946,
                    "check": 0.1343263057373653,
                    "control": 0.2665612817515564,
                    "daily": 0.32198837844112654,
                    "distributed": 0.17647699514267592,
                    "fix": 0.14144233597512018,
                    "fixed": 0.16099418922056327,
                    "idea": 0.11499668280634615,
                    "important": 0.25357577252810704,
                    "joel": 0.1506164945576563,
                    "like": 0.07078786505625421,
                    "minor": 0.16632153079419293,
                    "old": 0.14014052579212025,
                    "possible": 0.11678537147047136,
                    "pretty": 0.12436470168841356,
                    "reasons": 0.14014052579212025,
                    "sounds": 0.15243927186325923,
                    "test": 0.11222189686231934,
                    "understand": 0.10870290602943865,
                    "version": 0.42839867615858074,
                    "work": 0.08408257555646452
                },
                "Max term": "version",
                "Max score": 0.42839867615858074
            }
        ],
        "Best Answer": "I think what's important to note here is that regular builds help catch errors sooner rather than later. It doesn't have to be daily, but often enough. Ideally, it can also run your unit tests. The goal is to find out when a build breaks before the final testing phase, to find them as soon as possible. Just set it up to build your main development branch(es). We use it at work (although we build hourly), and often when we forget to set-it up we find about problems just hours before releasing. ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "branch": 0.19121846327728556,
                "breaks": 0.17443976403298436,
                "build": 0.40567171284190967,
                "builds": 0.186155193592304,
                "catch": 0.2045364661073893,
                "daily": 0.1658220853552817,
                "development": 0.10338274432393021,
                "errors": 0.1516724878166714,
                "final": 0.186155193592304,
                "forget": 0.18176918989107635,
                "goal": 0.16338791737599104,
                "help": 0.11099655495844357,
                "hourly": 0.17790046044718183,
                "hours": 0.14568391084465968,
                "ideally": 0.18176918989107635,
                "important": 0.13059000327825668,
                "later": 0.15335727949456965,
                "main": 0.15513318423086886,
                "note": 0.15335727949456965,
                "phase": 0.18176918989107635,
                "possible": 0.12028753292265579,
                "problems": 0.12360815988581783,
                "regular": 0.1658220853552817,
                "releasing": 0.2045364661073893,
                "run": 0.1265297500468689,
                "set": 0.2578104232007169,
                "soon": 0.16338791737599104,
                "sooner": 0.1972070402492973,
                "testing": 0.12028753292265579,
                "tests": 0.129736806308865,
                "think": 0.08683135558193002,
                "unit": 0.13236590801455592,
                "use": 0.07704170364203682,
                "work": 0.086604045079629
            },
            "Max term": "build",
            "Max score": 0.40567171284190967
        }
    },
    {
        "ID": "3033",
        "Question": "When writing software for yourself, your company or third parties, do you always consider certain principles, values, standards, or rules of behavior that guide the decisions, procedures and systems in a way that contributes to the welfare of its key stakeholders, and respects the rights of all constituents affected by its operations?  And can this code of conduct sometimes be overruled by business requirements, lack of technical skills or other friction during the development process?  Some random examples in order of severity. (yes that is controversial) :  Do you accept known bugs as a risk for the end-user? When writing applications, do you always give the end user the chance for a complete de-install? Do you always secure and encrypt private data delivered end-users in your web application? Do you alwask ask the end-user before submitting his entered data to the server? Did you ever wrote an application that sends unwanted e-mails? Did you ever work on harvesting or scraping projects only for the benefit of the business? Did you ever write software that is legal but moraly controversial, like  for weapons industry. Did you ever wrote software that ( can intentionally) or is be used for criminal activities  It would be nice if you can get a good case with explanation on your moral and ethical decisions.  note: Since ethics and law are quite local and cultural dependent, it would be interesting if you add the location of the \"crime scene\" with it. ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "accept": 0.10648871603143534,
                    "add": 0.08533401689448616,
                    "affected": 0.12714336286222572,
                    "application": 0.14579655931603036,
                    "applications": 0.08892531416863692,
                    "ask": 0.07865305502359309,
                    "behavior": 0.1084347384998919,
                    "benefit": 0.10471213670926015,
                    "bugs": 0.08600351234692633,
                    "business": 0.16571219475884322,
                    "case": 0.08285609737942161,
                    "certain": 0.09055960872026396,
                    "chance": 0.09883830688423331,
                    "code": 0.04450386781773108,
                    "company": 0.07516926042247518,
                    "complete": 0.0881547403813214,
                    "consider": 0.08228091055629456,
                    "cultural": 0.1225872664888881,
                    "data": 0.15544962836591392,
                    "decisions": 0.22117193306857394,
                    "delivered": 0.11571724973075163,
                    "dependent": 0.11886466469825635,
                    "development": 0.06426448068369797,
                    "encrypt": 0.12714336286222572,
                    "end": 0.2834191896992819,
                    "ethical": 0.12714336286222572,
                    "examples": 0.09328602357778608,
                    "explanation": 0.11571724973075163,
                    "good": 0.05559833670151426,
                    "guide": 0.11571724973075163,
                    "industry": 0.09328602357778608,
                    "install": 0.12714336286222572,
                    "intentionally": 0.1225872664888881,
                    "interesting": 0.08892531416863692,
                    "key": 0.09760048657544076,
                    "known": 0.09760048657544076,
                    "lack": 0.1030778421576331,
                    "law": 0.1225872664888881,
                    "legal": 0.11299083487322951,
                    "like": 0.045322507702112914,
                    "local": 0.10648871603143534,
                    "location": 0.1084347384998919,
                    "nice": 0.09233618804243915,
                    "note": 0.09532950581098075,
                    "operations": 0.10471213670926015,
                    "order": 0.09883830688423331,
                    "principles": 0.1084347384998919,
                    "private": 0.1030778421576331,
                    "procedures": 0.12714336286222572,
                    "process": 0.07772481418295696,
                    "projects": 0.0740022123923252,
                    "quite": 0.08117697782198455,
                    "random": 0.11571724973075163,
                    "requirements": 0.08468577889523711,
                    "rights": 0.11299083487322951,
                    "risk": 0.10015604033592253,
                    "rules": 0.10471213670926015,
                    "secure": 0.11571724973075163,
                    "server": 0.09055960872026396,
                    "skills": 0.0881547403813214,
                    "software": 0.18011885588484608,
                    "stakeholders": 0.1225872664888881,
                    "standards": 0.10015604033592253,
                    "submitting": 0.12714336286222572,
                    "systems": 0.0881547403813214,
                    "technical": 0.08117697782198455,
                    "used": 0.06204296761622934,
                    "user": 0.2305108339484523,
                    "users": 0.08228091055629456,
                    "values": 0.1084347384998919,
                    "way": 0.05590770295250969,
                    "web": 0.07516926042247518,
                    "work": 0.05383455448533353,
                    "write": 0.0626844166604879,
                    "writing": 0.14170959484964096,
                    "wrote": 0.19767661376846662,
                    "yes": 0.08285609737942161
                },
                "Max term": "end",
                "Max score": 0.2834191896992819
            }
        ],
        "Best Answer": "Overall, I always keep the Software Engineering Code of Ethics in mind. However, to address some of your particular points:  Do you accept known bugs as a risk for the end-user?  It depends. If it's a mission critical system and the bug is a showstopper, that's unacceptable. However, if it's a minor flaw that has workarounds in a non-critical system, that's acceptable. I always consider the impact of the problem on the system and to the users (and people affected by) the system.  Do you always secure and encrypt private data delivered end-users in your web application?  If I was on a project where this applied, I would consult any applicable laws and guidelines and follow them. If there were no applicable guidelines, I would err on the side of caution and use some form of security. Of course, you have to weigh a number of factors, ranging from how the system is deployed (physical locations, connections between nodes) and performance of any algorithms or techniques used.  Did you ever write software that is legal but morally controversial, like for weapons industry.  All of my jobs (as you can see in my profile) have been in the defense industry (and I'm also planning on working in the defense or intelligence industries after graduation), including work on ISR systems and Command and Control systems. I don't understand anyone, especially really good software engineers with skills that these projects need, who says that they won't build such systems. The way I see it, by bringing the best software engineering practices to these systems, you are only making them safer and more reliable. And these systems that involve life and death need to be as safe and reliable as possible. ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "accept": 0.09323474772863431,
                "acceptable": 0.10407034134695688,
                "address": 0.10407034134695688,
                "affected": 0.1113186429849571,
                "algorithms": 0.08892361146439369,
                "applicable": 0.21465922948043445,
                "application": 0.06382509778557303,
                "applied": 0.1113186429849571,
                "best": 0.058682345930290626,
                "bringing": 0.10407034134695688,
                "bug": 0.07855847950891214,
                "bugs": 0.07529920611565177,
                "build": 0.07359539259735148,
                "code": 0.03896475648846939,
                "command": 0.10407034134695688,
                "consider": 0.07203993272239143,
                "control": 0.0747130384732952,
                "course": 0.07855847950891214,
                "critical": 0.19785517898334895,
                "data": 0.06805090447765158,
                "death": 0.1113186429849571,
                "delivered": 0.10131466495767631,
                "depends": 0.08545277925378443,
                "deployed": 0.10732961474021722,
                "encrypt": 0.1113186429849571,
                "end": 0.1240719093902213,
                "engineering": 0.17784722292878738,
                "engineers": 0.09892758949167448,
                "especially": 0.08167530982639348,
                "factors": 0.08892361146439369,
                "follow": 0.0808436942353517,
                "form": 0.08004905179384174,
                "good": 0.04867836790300985,
                "guidelines": 0.2226372859699142,
                "including": 0.08545277925378443,
                "industry": 0.16335061965278697,
                "intelligence": 0.1113186429849571,
                "involve": 0.10407034134695688,
                "jobs": 0.0876902596089344,
                "known": 0.08545277925378443,
                "legal": 0.09892758949167448,
                "life": 0.08653653599839187,
                "like": 0.03968150551076399,
                "locations": 0.10407034134695688,
                "making": 0.0747130384732952,
                "mind": 0.07529920611565177,
                "minor": 0.09323474772863431,
                "need": 0.10480115518221722,
                "non": 0.0658134241225016,
                "number": 0.06971503648925614,
                "overall": 0.09682203970895666,
                "particular": 0.07254352972637121,
                "people": 0.04978734427760704,
                "performance": 0.08545277925378443,
                "physical": 0.10131466495767631,
                "planning": 0.08346445291685586,
                "points": 0.0808436942353517,
                "possible": 0.06546629648880319,
                "practices": 0.08545277925378443,
                "private": 0.0902484034753684,
                "problem": 0.05799026551093475,
                "profile": 0.1113186429849571,
                "project": 0.05256687191982698,
                "projects": 0.06479163108439122,
                "really": 0.05191077951597003,
                "reliable": 0.20814068269391375,
                "risk": 0.0876902596089344,
                "safe": 0.1113186429849571,
                "safer": 0.1113186429849571,
                "says": 0.08545277925378443,
                "secure": 0.10131466495767631,
                "security": 0.08167530982639348,
                "skills": 0.07718268457767384,
                "software": 0.21026748767930792,
                "systems": 0.38591342288836916,
                "techniques": 0.09167928785367425,
                "understand": 0.060935514317536646,
                "use": 0.04192982339969612,
                "used": 0.05432087689297874,
                "user": 0.06727354237719348,
                "users": 0.14407986544478285,
                "way": 0.04894922931858742,
                "web": 0.0658134241225016,
                "work": 0.04713411236024119,
                "working": 0.05940230274840557,
                "write": 0.05488248888391086
            },
            "Max term": "systems",
            "Max score": 0.38591342288836916
        }
    },
    {
        "ID": "3049",
        "Question": "I would like to do some web programming using functional programming. What decent web-frameworks exists for functional programming languages? ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "decent": 0.3464588185796234,
                    "frameworks": 0.28872285910450096,
                    "functional": 0.514991072648968,
                    "languages": 0.2083770035543695,
                    "like": 0.13569612577274245,
                    "programming": 0.48481304695373856,
                    "using": 0.17862724107533717,
                    "web": 0.45011531504717234
                },
                "Max term": "functional",
                "Max score": 0.514991072648968
            }
        ],
        "Best Answer": "Compojure is an open source web framework for the Clojure programming language. http://en.wikibooks.org/wiki/Compojure ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "clojure": 0.39980760077865585,
                "en": 0.38548076594486025,
                "framework": 0.26240558186647756,
                "http": 0.3032389645176145,
                "language": 0.18819982569270094,
                "open": 0.24883857324794828,
                "org": 0.3638777120728619,
                "programming": 0.16972932312882863,
                "source": 0.23764428972227872,
                "web": 0.23637287063408788,
                "wiki": 0.39980760077865585
            },
            "Max term": "clojure",
            "Max score": 0.39980760077865585
        }
    },
    {
        "ID": "3069",
        "Question": "If you browse the code golf questions on StackExchange, you notice a ton of non-standard but real world (Eg not brain-f*ck) languages like F#, Scala, R, J and Clojure. Visiting their websites, some of the languages look interesting solving problems in whatever language your already using. However there is coding in spare time, and coding for money. The closest thing we have to the truth on who uses a language is the TIOBE Index, which lists none of the above languages in the top 10-15. Which makes me wonder if I'll ever use them. Should I even bother learning some of the small niche languages? It doesn't seem I would be making money, and some will probably fail anyway. ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "10": 0.13465928210633749,
                    "15": 0.1552987442651192,
                    "bother": 0.16127400513543197,
                    "brain": 0.17334731653337263,
                    "clojure": 0.18542062793131325,
                    "closest": 0.18542062793131325,
                    "code": 0.06490260230947148,
                    "coding": 0.2105699272759053,
                    "fail": 0.14063454297665026,
                    "golf": 0.17877620519903684,
                    "index": 0.17877620519903684,
                    "interesting": 0.129685004556669,
                    "language": 0.17456461452229238,
                    "languages": 0.4059949358025146,
                    "learning": 0.11401981994755575,
                    "like": 0.06609647289771588,
                    "lists": 0.16127400513543197,
                    "look": 0.106838870092454,
                    "makes": 0.10429232339657364,
                    "making": 0.12444760497347077,
                    "money": 0.26170571629839395,
                    "niche": 0.17334731653337263,
                    "non": 0.10962374405474153,
                    "notice": 0.15032446671545072,
                    "probably": 0.10528496363795264,
                    "problems": 0.11205582583708527,
                    "questions": 0.11917923664103992,
                    "real": 0.11205582583708527,
                    "scala": 0.17334731653337263,
                    "small": 0.11081496088872163,
                    "solving": 0.1527078543745909,
                    "stackexchange": 0.17877620519903684,
                    "standard": 0.12169705545268217,
                    "thing": 0.10579397517307867,
                    "time": 0.07308120161635631,
                    "use": 0.06984143873251622,
                    "uses": 0.14606343164231447,
                    "using": 0.08700786799398369,
                    "websites": 0.16127400513543197,
                    "wonder": 0.14811779441001743,
                    "world": 0.11470436618067176
                },
                "Max term": "languages",
                "Max score": 0.4059949358025146
            }
        ],
        "Best Answer": "The Sapir-Whorf Hypothesis.  It states, more or less, that what you can think of is limited by what you have the language to describe.  The consequence of this is that multi-lingual people are able to think in ways that single language speakers may not be able to. Many people (myself included) think this holds true to programming as well.  Learning Lisp, for example, teaches you a whole new way of thinking about problems that you can apply to C# or Java or Python.  The more language paradigms you've learnt, the more tools will be in your mental toolbox, regardless of what language you're actually using. ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "able": 0.2768914941871396,
                "actually": 0.12077977061360098,
                "apply": 0.18398812255343483,
                "example": 0.1172236577487222,
                "holds": 0.21967462375305072,
                "included": 0.19106723342775744,
                "java": 0.13351532970598942,
                "language": 0.41362621239732,
                "learning": 0.1350834657762476,
                "limited": 0.18735040387075702,
                "lisp": 0.18091860020181047,
                "mental": 0.2053709285904041,
                "multi": 0.17809491336005717,
                "new": 0.10406596020292262,
                "paradigms": 0.19106723342775744,
                "people": 0.19649927143515195,
                "problems": 0.1327566498653953,
                "programming": 0.09325791987338304,
                "python": 0.14859438031951677,
                "regardless": 0.19522229536445712,
                "single": 0.14417896847121717,
                "speakers": 0.21180273225935062,
                "think": 0.2797737596201491,
                "thinking": 0.1384457470935698,
                "tools": 0.14523209900219458,
                "true": 0.1707699669758635,
                "using": 0.10308141482626086,
                "way": 0.0965957116007565,
                "ways": 0.14743764544709925
            },
            "Max term": "language",
            "Max score": 0.41362621239732
        }
    },
    {
        "ID": "3139",
        "Question": " Possible Duplicate: At which point do you â€œknowâ€ a technology enough to list it on a resume   I'm having trouble selecting exactly what to put in the computer skills section of my resume. I feel the need to list a lot of languages and the IDEs I work with, and perhaps mention that I use Mercurial too. But this seems, well, kinda fake; after all, where do I draw the line in the list of languages? Sure, I learned a little C in a class, I can conquer some simple printf and getchar projects, but I don't really think that counts as being able to list it on my resume. I seem to recall Joel or Jeff addressing this but I can't find it now. But I'm pretty sure they said something along the lines of don't put it on your resume if you don't want to be drilled on it. Well, I sure wouldn't want to be drilled on C... But is there no justification in my listing languages like C# that I don't work with daily but could pick back up after a short refresher? I mean, I wouldn't want to be drilled on the internals of .NET either, but I think I am justified in listing it in a list of languages I have used... How do you decide? What do you have in your 'Computer Skills' section of your resume? (and can you please find the Joel/Jeff posts I'm thinking of, if they exist?) ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "able": 0.06946945810031735,
                    "class": 0.07341942440677418,
                    "computer": 0.13983524045380993,
                    "daily": 0.08936466002949378,
                    "decide": 0.0868315663887536,
                    "draw": 0.1030512487255521,
                    "duplicate": 0.09587392495330498,
                    "exactly": 0.0880528408381121,
                    "exist": 0.08461599621176735,
                    "fake": 0.11022857249779924,
                    "feel": 0.06624210063452705,
                    "ides": 0.11022857249779924,
                    "internals": 0.11022857249779924,
                    "jeff": 0.2204571449955985,
                    "joel": 0.16720841784592658,
                    "justified": 0.10627860619134241,
                    "kinda": 0.11022857249779924,
                    "know": 0.04806909674649878,
                    "languages": 0.24135525110736186,
                    "learned": 0.08173917413065904,
                    "like": 0.03929293054359411,
                    "line": 0.07516195726747057,
                    "lines": 0.09232176097141769,
                    "list": 0.36990711335734566,
                    "listing": 0.2204571449955985,
                    "little": 0.06991762022690497,
                    "lot": 0.0565480810536249,
                    "mean": 0.07341942440677418,
                    "mention": 0.09232176097141769,
                    "mercurial": 0.09795885646745756,
                    "need": 0.0518874530900328,
                    "net": 0.06738452658616478,
                    "pick": 0.08360420892296329,
                    "point": 0.06320010044846554,
                    "possible": 0.06482522796881042,
                    "posts": 0.1030512487255521,
                    "pretty": 0.06903236284403089,
                    "projects": 0.06415716912037449,
                    "really": 0.05140245128631883,
                    "resume": 0.501612784342269,
                    "said": 0.06991762022690497,
                    "section": 0.1959177129349151,
                    "short": 0.0792651839120061,
                    "simple": 0.06818927691283619,
                    "skills": 0.15285377030143235,
                    "sure": 0.19447568390643125,
                    "technology": 0.08173917413065904,
                    "think": 0.0935901216638765,
                    "thinking": 0.06946945810031735,
                    "trouble": 0.09795885646745756,
                    "use": 0.041519232129499574,
                    "used": 0.05378894815984126,
                    "want": 0.15615635702225164,
                    "work": 0.09334511780066079
                },
                "Max term": "resume",
                "Max score": 0.501612784342269
            }
        ],
        "Best Answer": "As little as possible, and only those relevant to the position I'm applying for. As someone who reads resumes on occasion, nothing is more annoying than going through a list of every single computer related piece of equipment, software, and skill the applicant has ever touched, read about, or has actual experience with. You applying for a job writing code?  Why the $*@( are you telling me you have experience with Outlook?  Seriously? Only include the skills relevant to the position you are applying for on your resume.   You are retooling your resume for each position you are applying for, aren't you? Aren't you? ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "actual": 0.13002132352033188,
                "annoying": 0.13405058735057404,
                "applying": 0.6086735929101218,
                "code": 0.05697304828095999,
                "computer": 0.10324234212962868,
                "equipment": 0.16276663818570783,
                "experience": 0.1866461235937926,
                "going": 0.0841380565990855,
                "include": 0.12345234739239665,
                "job": 0.09029539467788222,
                "list": 0.10924306814071603,
                "little": 0.10324234212962868,
                "outlook": 0.15693400584655973,
                "piece": 0.14464882730875142,
                "position": 0.37959304929538507,
                "possible": 0.09572277121084967,
                "read": 0.09781496559666124,
                "related": 0.12203911263203009,
                "relevant": 0.24407822526406017,
                "resume": 0.2962782687945765,
                "seriously": 0.13002132352033188,
                "single": 0.10682857033830372,
                "skill": 0.1363249321313869,
                "skills": 0.11285410743421928,
                "software": 0.07686163604675944,
                "telling": 0.14813913439728826,
                "writing": 0.09070703272702071
            },
            "Max term": "applying",
            "Max score": 0.6086735929101218
        }
    },
    {
        "ID": "3199",
        "Question": "Are different version naming conventions suited to different projects? What do you use and why? Personally, I prefer a build number in hexadecimal (e.g 11BCF), this should be incremented very regularly. And then for customers a simple 3 digit version number, i.e. 1.1.3. 1.2.3 (11BCF) <- Build number, should correspond with a revision in source control ^ ^ ^ | | | | | +--- Minor bugs, spelling mistakes, etc. | +----- Minor features, major bug fixes, etc. +------- Major version, UX changes, file format changes, etc.  ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "bug": 0.12890119583099519,
                    "bugs": 0.12355327870533668,
                    "build": 0.24151521701419817,
                    "changes": 0.2433204262638628,
                    "control": 0.12259147661179404,
                    "conventions": 0.1707618519862105,
                    "customers": 0.14388490455749897,
                    "different": 0.1965679697471218,
                    "features": 0.11511489155538215,
                    "file": 0.1216602131319314,
                    "fixes": 0.1707618519862105,
                    "format": 0.15886861328400273,
                    "major": 0.28398367796818735,
                    "minor": 0.3059649461229383,
                    "mistakes": 0.16624025248324142,
                    "naming": 0.16232346483625598,
                    "number": 0.34317179865403774,
                    "personally": 0.13544651740754443,
                    "prefer": 0.13265084720930687,
                    "projects": 0.10631212287747042,
                    "regularly": 0.1707618519862105,
                    "simple": 0.11299355762536463,
                    "source": 0.10856956997883291,
                    "suited": 0.15577814325970674,
                    "use": 0.06879975797635088,
                    "ux": 0.18265509068841826,
                    "version": 0.39404091954934883
                },
                "Max term": "version",
                "Max score": 0.39404091954934883
            }
        ],
        "Best Answer": "I tend to follow Jeff Atwood's opinion of the .NET convention of version numbering.  (Major version).(Minor version).(Revision number).(Build number)  More often than not, for personal projects, I find this to be overkill. The few times where I have worked on substantial projects like search engines in C# I've stuck to this convention and have been able to use it as an internal tracker effectively. ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "able": 0.13439772752739124,
                "build": 0.140985653078502,
                "convention": 0.3457751811415667,
                "effectively": 0.18548061256284615,
                "follow": 0.15487112204711528,
                "internal": 0.18548061256284615,
                "jeff": 0.21325155050007275,
                "like": 0.07601729907443378,
                "major": 0.16577681852496343,
                "minor": 0.17860848803466994,
                "net": 0.13036415557771933,
                "number": 0.267104219488411,
                "opinion": 0.15334883675687813,
                "personal": 0.15646423627716982,
                "projects": 0.24824082323824717,
                "search": 0.17288759057078334,
                "stuck": 0.19936608153145946,
                "substantial": 0.21325155050007275,
                "tend": 0.16174324657529152,
                "times": 0.140985653078502,
                "tracker": 0.20560982549005521,
                "use": 0.08032436986666952,
                "version": 0.46004651027063437,
                "worked": 0.1399633150643381
            },
            "Max term": "version",
            "Max score": 0.46004651027063437
        }
    },
    {
        "ID": "3233",
        "Question": "As an entrepreneur/programmer who makes a good living from writing and selling software, I'm dumbfounded as to why developers write applications and then put them up on the Internet for free.  You've found yourself in one of the most lucrative fields in the world.  A business with 99% profit margin, where you have no physical product but can name your price; a business where you can ship a buggy product and the customer will still buy it. Occasionally some of our software will get a free competitor, and I think, this guy is crazy.  He could be making a good living off of this but instead chose to make it free.    Do you not like giant piles of money? Are you not confident that people would pay for it?   Are you afraid of having to support it?  It's bad for the business of programming because now customers expect to be able to find a free solution to every problem. (I see tweets like \"is there any good FREE software for XYZ? or do I need to pay $20 for that\".) It's also bad for customers because the free solutions eventually break (because of a new OS or what have you) and since it's free, the developer has no reason to fix it. Customers end up with free but stale software that no longer works and never gets updated. Customer cries. Developer still working day job cries in their cubicle. What gives? PS: I'm not looking to start an open-source/software should be free kind of debate. I'm talking about when developers make a closed source application and make it free. ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "20": 0.07875002461789245,
                    "able": 0.061217952754322465,
                    "afraid": 0.09713574465489974,
                    "application": 0.05569326246558016,
                    "applications": 0.06793769187780191,
                    "bad": 0.11485651978872617,
                    "break": 0.07759402185817249,
                    "business": 0.189902686313329,
                    "buy": 0.07759402185817249,
                    "chose": 0.09713574465489974,
                    "closed": 0.08840635459826304,
                    "confident": 0.08448612625835453,
                    "crazy": 0.09365495097459413,
                    "customer": 0.1425384253197998,
                    "customers": 0.22955342710869292,
                    "day": 0.061612882679529295,
                    "debate": 0.09081093545662713,
                    "developer": 0.10728913091481149,
                    "developers": 0.11084394086126952,
                    "end": 0.05413207072153674,
                    "eventually": 0.07999860271653658,
                    "expect": 0.07875002461789245,
                    "fields": 0.08284261823450358,
                    "fix": 0.06918626997644604,
                    "free": 0.6201807166385276,
                    "gets": 0.07759402185817249,
                    "gives": 0.07875002461789245,
                    "good": 0.12742904660137655,
                    "guy": 0.07999860271653658,
                    "instead": 0.06286146077817342,
                    "internet": 0.07759402185817249,
                    "job": 0.053886413694537526,
                    "kind": 0.06519399116744902,
                    "like": 0.06925151948423303,
                    "living": 0.18162187091325427,
                    "longer": 0.07283040440394331,
                    "looking": 0.057428259894363086,
                    "make": 0.13224243244787795,
                    "makes": 0.05463530464727217,
                    "making": 0.06519399116744902,
                    "money": 0.06854949181410741,
                    "need": 0.04572431883981027,
                    "new": 0.04601589553148225,
                    "occasionally": 0.08284261823450358,
                    "open": 0.06045687991980934,
                    "os": 0.07875002461789245,
                    "pay": 0.16271176876556867,
                    "people": 0.0434440326536207,
                    "physical": 0.08840635459826304,
                    "price": 0.08448612625835453,
                    "problem": 0.050601835165213035,
                    "product": 0.12750613818527137,
                    "programmer": 0.05021184238162823,
                    "programming": 0.041236795297992325,
                    "reason": 0.06045687991980934,
                    "selling": 0.08840635459826304,
                    "software": 0.22934712960888062,
                    "solution": 0.0662343031707253,
                    "solutions": 0.07651780903623097,
                    "source": 0.11547431814803372,
                    "stale": 0.09365495097459413,
                    "start": 0.05413207072153674,
                    "support": 0.06421874244442118,
                    "talking": 0.07203028549441302,
                    "think": 0.041236795297992325,
                    "updated": 0.08448612625835453,
                    "working": 0.05183396740168587,
                    "works": 0.06519399116744902,
                    "world": 0.06008983007141592,
                    "write": 0.04789001449625418,
                    "writing": 0.05413207072153674,
                    "xyz": 0.09713574465489974
                },
                "Max term": "free",
                "Max score": 0.6201807166385276
            }
        ],
        "Best Answer": "Because I don't want to feel obligated to provide technical support or offer refunds. ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "feel": 0.3702423443757319,
                "offer": 0.5073988772870809,
                "provide": 0.44742930111136914,
                "support": 0.407313586870336,
                "technical": 0.39335561953813797,
                "want": 0.29093127159958665
            },
            "Max term": "offer",
            "Max score": 0.5073988772870809
        }
    },
    {
        "ID": "3241",
        "Question": "This question is a little abstract but I'm hoping someone can point me in the right direction. My question is what amount of time can one expect to devote to a software project's bugs in relation to the original development time. I realize there are a huge number of determining factors that go into but I was hoping for a typical or average breakdown.  For example, if Project A takes 40 hours to complete and an additional 10 fixing bugs then this project would have a 4:1 ratio. If another Project (B) takes 10 hours to complete but another 8 on bugs then it would have a 5:4 ratio.  Is this a documented/researched concept? UPDATE Thanks for all the informative answers. I understand that it's impossible to put a standard to this kind of metric due to all the variables and environmental factors involved. Before I assign an answer I'd like to know if this metric has an agreed-upon name so I can do further research. I would like to get to a point where I can understand the measurements necessary to generate the metrics myself and eventually come up with a baseline standard for my project. ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "10": 0.1898269138649159,
                    "40": 0.12218239103008771,
                    "abstract": 0.12600889732434176,
                    "additional": 0.10946100740261176,
                    "agreed": 0.12218239103008771,
                    "answer": 0.07726736952227391,
                    "answers": 0.09223053117589976,
                    "assign": 0.13069216253247612,
                    "average": 0.10439957558636222,
                    "baseline": 0.12600889732434176,
                    "breakdown": 0.13069216253247612,
                    "bugs": 0.2652120746449371,
                    "come": 0.08704951112201467,
                    "complete": 0.18123059511031417,
                    "concept": 0.10032469149481613,
                    "development": 0.06605821779057512,
                    "direction": 0.13069216253247612,
                    "documented": 0.11894712605651603,
                    "eventually": 0.1076348405599339,
                    "example": 0.06974047830107913,
                    "expect": 0.10595492991136445,
                    "factors": 0.20879915117272443,
                    "fixing": 0.11146134685418793,
                    "generate": 0.1136726195276993,
                    "hoping": 0.26138432506495224,
                    "hours": 0.1861745801795602,
                    "huge": 0.09588980408397382,
                    "impossible": 0.1076348405599339,
                    "involved": 0.09491345693245795,
                    "kind": 0.08771584260838088,
                    "know": 0.056992974347991,
                    "like": 0.09317508062772427,
                    "little": 0.08289760793882223,
                    "metric": 0.26138432506495224,
                    "metrics": 0.13069216253247612,
                    "necessary": 0.09061529755515708,
                    "number": 0.08184800528912843,
                    "original": 0.10159706159216848,
                    "point": 0.14986600320973195,
                    "project": 0.3085771612261866,
                    "question": 0.13409211119208736,
                    "realize": 0.10595492991136445,
                    "research": 0.10946100740261176,
                    "right": 0.07493300160486598,
                    "software": 0.06171543224523733,
                    "standard": 0.17155428204932463,
                    "takes": 0.17155428204932463,
                    "thanks": 0.12218239103008771,
                    "time": 0.10302133464084262,
                    "typical": 0.1136726195276993,
                    "understand": 0.14308104963628962,
                    "update": 0.09912506905754548,
                    "variables": 0.10946100740261176
                },
                "Max term": "project",
                "Max score": 0.3085771612261866
            }
        ],
        "Best Answer": "The equilibrium percentage of total capacity allocated to defect-fixing is equal to the defect injection rate. Many factors can affect this rate, among them, of course: what kind of product the team is developing, what technologies and technical practices they use, the team's skill level, the company culture, etc. Considering Team B, if they create on average 8 units of rework for every 10 units of work they complete, then working those 8 units will create new 6.4 units of rework.  We can estimate the total effort they will eventually have to expend as the sum of a geometric progression: 10 + 8 + 6.4 + 5.12 + ... The number of bugs will decrease exponentially with time, but Team B has such a coefficient in their exponent that it will go to zero very slowly.  Actually, the sum of the first three terms in the above series is only 24.4; of the first five, 33.6; of the first 10, 45; of the entire series, 50.  So, Team B summary: defect injection rate, 0.8; feature development, 10/50 = 20%; defect-fixing, 80%.  20/80 is their sustainable capacity allocation. By contrast, Team A is in much better shape.  Their progression looks like this: 40 + 10 + 2.5 + 0.625 + ... The sum of this series is 53 1/3, so Team A's feature development allocation is 40/(53 1/3) = 75% and defect-fixing allocation is 25%, which matches their defect injection rate of 10/40 = 0.25. Actually, all terms in Team A's series after the first three are negligibly small.  What this means in practical terms is that Team A can probably squash all their bugs with a couple of maintenance releases, the second release being pretty small in scope.  This also creates an illusion that any team can do that.  But not Team B. I thought about this equivalence while reading David Anderson's new book, \"Kanban\".  (The book is on a different subject, but addresses quality concerns, too.)  When discussing software quality, Anderson quotes this book, by Capers Jones, \"Software Assessments, Benchmarks, and Best Practices\": \"...in 2000... measured software quality for North American teams... ranged from 6 defects per function point down to less than 3 per 100 function points, a range of 200 to 1.  The midpoint is approximately 1 defect per 0.6 to 1.0 function points.  This implies that it is common for teams to spend more than 90 percent of their effort fixing defects.\"  He cites an example provided by one of his colleagues of a company that spends 90% of the time fixing their bugs. The fluency with which Anderson goes from the defect injection rate to the defext-fixing capacity allocation (failure demand is the term for it) suggests that the equivalence of the two things is well known to software quality researchers and has probably been known for some time. The key words in the line of reasoning that I'm trying to present here are \"equlibrium\" and \"sustainable\".  If we take away sustainability, then there's an obvious way to cheat these numbers: you do the initial coding, then move on to code somewhere else, and leave maintenance to others.  Or you run up the technical debt and unload it on a new owner. Obviously, no particular allocation will suit all teams.  If we decreed that 20% must be spent on bugs, then, if a team has an ultra-low defect injection rate, they will simply not have enough bugs to fill the time, and if a team had a very high rate, their bugs will continue to accumulate. The math I used here is way simplified.  I neglected things like transaction costs (planning and estimation meetings, post-mortems, etc.), which would affect the percentages somewhat.  I also omitted equations simulating sustaining one product and developing another one concurrently.  But the conclusion still stands.  Do what you can, in terms of technical practices, like unit-testing, continuous integration, code reviews, etc., to reduce your defect injection rate and, consequently, your failure demand.  If you can create only one bug for every 10 features, you will have a lot of free time to develop new features and satisfy your customers. ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "10": 0.2190383953557028,
                "100": 0.03394121729898955,
                "12": 0.04154278699550555,
                "20": 0.10479410211253176,
                "25": 0.08056251824979639,
                "40": 0.12084377737469461,
                "50": 0.07097040525903821,
                "75": 0.0430867723260351,
                "80": 0.07097040525903821,
                "90": 0.0734934610002529,
                "actually": 0.04737925928002596,
                "affect": 0.0749514918475226,
                "average": 0.03441859601264535,
                "away": 0.02987417622724531,
                "best": 0.02271347198328443,
                "better": 0.021543591107094473,
                "book": 0.08308215799558226,
                "bug": 0.030406688674217808,
                "bugs": 0.17487096482166276,
                "capacity": 0.12926031697810528,
                "code": 0.03016324214058109,
                "coding": 0.02446539690990475,
                "colleagues": 0.04154278699550555,
                "common": 0.0261875701198172,
                "company": 0.050947225821755836,
                "complete": 0.02987417622724531,
                "concerns": 0.039214652508024445,
                "considering": 0.03608725583190807,
                "continue": 0.03674673050012645,
                "continuous": 0.040281259124898196,
                "contrast": 0.0430867723260351,
                "costs": 0.03674673050012645,
                "couple": 0.03230558497404262,
                "course": 0.030406688674217808,
                "create": 0.08308215799558226,
                "creates": 0.039214652508024445,
                "culture": 0.03608725583190807,
                "customers": 0.03394121729898955,
                "david": 0.04154278699550555,
                "defect": 0.430867723260351,
                "defects": 0.0861735446520702,
                "demand": 0.0830855739910111,
                "develop": 0.03195067400474736,
                "developing": 0.06196725323039259,
                "development": 0.04355632862833502,
                "different": 0.023184350699353987,
                "discussing": 0.04154278699550555,
                "effort": 0.0678824345979791,
                "entire": 0.034931367370843916,
                "equal": 0.040281259124898196,
                "estimate": 0.03441859601264535,
                "estimation": 0.039214652508024445,
                "eventually": 0.035485202629519104,
                "example": 0.02299213703591975,
                "factors": 0.03441859601264535,
                "failure": 0.0749514918475226,
                "feature": 0.053967526451426884,
                "features": 0.05430923501873653,
                "fixing": 0.2204803830007587,
                "free": 0.027509528478663524,
                "function": 0.08962252868173594,
                "goes": 0.030983626615196293,
                "high": 0.028918279922979174,
                "initial": 0.04154278699550555,
                "injection": 0.24168755474938922,
                "integration": 0.039214652508024445,
                "jones": 0.0430867723260351,
                "key": 0.033075182607393915,
                "kind": 0.028918279922979174,
                "known": 0.06615036521478783,
                "leave": 0.03394121729898955,
                "level": 0.026339647602473565,
                "like": 0.04607713355958642,
                "line": 0.0293797340106835,
                "looks": 0.0326796894283822,
                "lot": 0.022103836043784023,
                "low": 0.03394121729898955,
                "maintenance": 0.0749514918475226,
                "matches": 0.0430867723260351,
                "math": 0.040281259124898196,
                "means": 0.02788363293300311,
                "meetings": 0.034931367370843916,
                "new": 0.08164559488116636,
                "number": 0.026983763225713442,
                "numbers": 0.03608725583190807,
                "obvious": 0.03349465933527691,
                "obviously": 0.03394121729898955,
                "owner": 0.039214652508024445,
                "particular": 0.028078554186736708,
                "percent": 0.0430867723260351,
                "percentage": 0.04154278699550555,
                "planning": 0.03230558497404262,
                "point": 0.024704015277526626,
                "points": 0.06258239867305794,
                "post": 0.03230558497404262,
                "practical": 0.039214652508024445,
                "practices": 0.09922554782218174,
                "present": 0.040281259124898196,
                "pretty": 0.026983763225713442,
                "probably": 0.0489307938198095,
                "product": 0.05655825222402964,
                "provided": 0.0374757459237613,
                "quality": 0.12275658453656006,
                "range": 0.038290715830656005,
                "rate": 0.28869804665526455,
                "reading": 0.028918279922979174,
                "reasoning": 0.04154278699550555,
                "reduce": 0.03608725583190807,
                "release": 0.03394121729898955,
                "releases": 0.040281259124898196,
                "reviews": 0.03608725583190807,
                "run": 0.02665421299435765,
                "scope": 0.03674673050012645,
                "second": 0.03195067400474736,
                "series": 0.15685861003209778,
                "simply": 0.028918279922979174,
                "skill": 0.03608725583190807,
                "slowly": 0.038290715830656005,
                "small": 0.05150083939851121,
                "software": 0.08138571515312137,
                "somewhat": 0.034931367370843916,
                "spend": 0.03013531087546483,
                "spent": 0.0374757459237613,
                "subject": 0.0374757459237613,
                "suggests": 0.0430867723260351,
                "sum": 0.12926031697810528,
                "summary": 0.040281259124898196,
                "team": 0.33475545609032287,
                "teams": 0.11024019150037935,
                "technical": 0.08252858543599056,
                "technologies": 0.0374757459237613,
                "term": 0.03394121729898955,
                "terms": 0.1307187577135288,
                "testing": 0.025339254380085732,
                "things": 0.04095396898044143,
                "thought": 0.02987417622724531,
                "time": 0.08491053909394208,
                "total": 0.0749514918475226,
                "transaction": 0.0430867723260351,
                "trying": 0.02665421299435765,
                "unit": 0.02788363293300311,
                "units": 0.1661711479820222,
                "use": 0.016229273965706725,
                "used": 0.02102533046108582,
                "way": 0.03789238249104176,
                "words": 0.035485202629519104,
                "work": 0.018243635689395767,
                "working": 0.02299213703591975,
                "zero": 0.04154278699550555
            },
            "Max term": "defect",
            "Max score": 0.430867723260351
        }
    },
    {
        "ID": "3272",
        "Question": "How would you, as someone involved in the hiring process (manager,interviewer, etc) feel about a candidate that has changed jobs every 1-2 years? updateThanks for all the input everybody, some really great responses, and good info in every post.  I asked it because I'm currently at my 3 job in the last 5 years and I'm feeling like my position is going nowhere (like the position should have been contract in the first place, not full-time).   My only options here seem like transition to a different team doing something I'm not really interested in or look for new work, but I'm a little afraid my recent job history is all short stints. ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "afraid": 0.1910916360779151,
                    "asked": 0.12633520856991426,
                    "candidate": 0.16620649947094324,
                    "changed": 0.1526479118415422,
                    "contract": 0.14855021406147328,
                    "currently": 0.1417025745896971,
                    "different": 0.10282356434173388,
                    "everybody": 0.1739186228497631,
                    "feel": 0.11483693474976647,
                    "feeling": 0.1600484878816211,
                    "going": 0.0987799408475296,
                    "good": 0.08356218432743417,
                    "great": 0.11821254864299391,
                    "hiring": 0.162973285597918,
                    "history": 0.1549220742464353,
                    "info": 0.1739186228497631,
                    "input": 0.1600484878816211,
                    "interested": 0.1417025745896971,
                    "interviewer": 0.1910916360779151,
                    "involved": 0.13877777687340018,
                    "job": 0.212017584090063,
                    "jobs": 0.15053071729443207,
                    "like": 0.2043540131308838,
                    "little": 0.1212087949347285,
                    "look": 0.11010648982510039,
                    "manager": 0.14493578846272234,
                    "new": 0.09052540641904488,
                    "options": 0.1600484878816211,
                    "place": 0.13249322015923642,
                    "position": 0.29710042812294657,
                    "post": 0.143276619572028,
                    "process": 0.11681743798272526,
                    "really": 0.17822200346310588,
                    "recent": 0.1842439966061389,
                    "responses": 0.1910916360779151,
                    "short": 0.13741367899928572,
                    "team": 0.11420418760516927,
                    "time": 0.0753163579436412,
                    "transition": 0.1842439966061389,
                    "work": 0.08091128677535092,
                    "years": 0.22476130445998704
                },
                "Max term": "position",
                "Max score": 0.29710042812294657
            }
        ],
        "Best Answer": "It depends on the context:  In a startup culture (like Silicon Valley), one to two years is the lifetime of many companies, and it's expected you'd be switching your place of employment that often. If you're a contract worker, a contract may only be a short, set timespan. Everywhere else, one to two years is an unusually short stay at a company.  In any context, employers are generally looking for a person who's going to be in it for the long haul, whatever the long haul is for the company:  Startups are looking for someone who will last until the exit: acquisition, IPO, shuttering, etc. Contract hires should be able to successfully complete their contracts to term. Other companies are looking for an employee who will last long enough to make a return on the investment of hiring them: this can take several years.  It's a red-flag to potential employers if you're constantly leaving your job for personal reasons, even if you have perfectly valid reasons. I'd also note that having experience in one context isn't necessarily going to translate to another.  For example, if you're a life-long contract worker, it can look just as unappealing to a company looking to hire full-time employees as someone who went from regular job to regular job. Similarly, a person who stayed at a job for 10 years might be unappealing to a startup that wants people who are constantly looking for the next big thing. ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "10": 0.07307011479346186,
                "able": 0.06341051351987546,
                "big": 0.06262218236714678,
                "companies": 0.1447037634538484,
                "company": 0.17845527104125397,
                "complete": 0.06976113196583748,
                "constantly": 0.17502410356148432,
                "context": 0.24859141400003346,
                "contract": 0.31286223021045395,
                "contracts": 0.089415141017098,
                "culture": 0.08426969825794636,
                "depends": 0.07723601016198935,
                "employee": 0.09700926391332901,
                "employees": 0.09406338813116234,
                "employers": 0.18314537129307198,
                "employment": 0.10061472448158251,
                "example": 0.05369043463285875,
                "exit": 0.10061472448158251,
                "expected": 0.09406338813116234,
                "experience": 0.057687952857755256,
                "flag": 0.09700926391332901,
                "generally": 0.06917351871756695,
                "going": 0.1040204243018656,
                "hire": 0.08751205178074216,
                "hiring": 0.08580968044884449,
                "job": 0.22326556249457782,
                "leaving": 0.09700926391332901,
                "life": 0.07821555755261349,
                "like": 0.0358659038317548,
                "long": 0.22326556249457782,
                "look": 0.05797393525308245,
                "looking": 0.2974254517354233,
                "make": 0.045659593704970775,
                "necessarily": 0.07543887267265995,
                "note": 0.07543887267265995,
                "people": 0.045000008918883935,
                "perfectly": 0.09406338813116234,
                "person": 0.1372130555734815,
                "personal": 0.0738217658316313,
                "place": 0.06976113196583748,
                "potential": 0.08157050793193682,
                "reasons": 0.14200927283221296,
                "red": 0.09700926391332901,
                "regular": 0.16314101586387364,
                "return": 0.07925834409842432,
                "set": 0.06341051351987546,
                "short": 0.1447037634538484,
                "similarly": 0.09406338813116234,
                "startup": 0.18812677626232469,
                "startups": 0.10061472448158251,
                "stay": 0.07925834409842432,
                "stayed": 0.10061472448158251,
                "successfully": 0.09157268564653599,
                "switching": 0.09406338813116234,
                "term": 0.07925834409842432,
                "thing": 0.057406944322256244,
                "time": 0.03965602450735156,
                "translate": 0.09157268564653599,
                "unusually": 0.10061472448158251,
                "valid": 0.09157268564653599,
                "wants": 0.07821555755261349,
                "went": 0.07723601016198935,
                "worker": 0.20122944896316503,
                "years": 0.2366853640118712
            },
            "Max term": "contract",
            "Max score": 0.31286223021045395
        }
    },
    {
        "ID": "3277",
        "Question": "Today I found a GPLed project on SourceForge whose executables are spreading a virus. This fact has been pointed out several times in reviews of the project and the infected executable is still available for download. Apparently, older executables are not infected, so the project itself does not seem to be made with malicious purpose in mind.\r \r There is no preferred way to contact developers and forums for the project are dead.\r \r What should I do?",
        "TF-IDF scores": [
            {
                "Scores": {
                    "apparently": 0.23166829463565924,
                    "available": 0.18074614981917153,
                    "contact": 0.21833681704026947,
                    "developers": 0.14873732502237216,
                    "download": 0.26068562181686583,
                    "fact": 0.176335426324121,
                    "malicious": 0.25134412895869673,
                    "mind": 0.176335426324121,
                    "older": 0.23166829463565924,
                    "preferred": 0.2372583398921628,
                    "project": 0.49240369181429694,
                    "purpose": 0.1977201980913341,
                    "reviews": 0.21833681704026947,
                    "sourceforge": 0.25134412895869673,
                    "times": 0.17234544158690032,
                    "today": 0.20535275350532756,
                    "virus": 0.25134412895869673,
                    "way": 0.11462913973984283
                },
                "Max term": "project",
                "Max score": 0.49240369181429694
            }
        ],
        "Best Answer": "If you can't get in touch with the developers, then contact SourceForge.  Report the problem, give them detailed information they can use to verify the issue, and they'll (probably) take it down.  They're a reputable site and I imagine they wouldn't want to be associated with malware. ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "associated": 0.314013969133576,
                "contact": 0.27277665410705887,
                "detailed": 0.277761496797866,
                "developers": 0.18582330919001075,
                "imagine": 0.29641604651057535,
                "information": 0.21692724148043796,
                "issue": 0.2220757815257207,
                "probably": 0.1849292487511411,
                "problem": 0.1696619659753163,
                "report": 0.277761496797866,
                "site": 0.2341992984881609,
                "sourceforge": 0.314013969133576,
                "touch": 0.30447832161274646,
                "use": 0.12267397309379202,
                "verify": 0.3256846584875679,
                "want": 0.15379475773237816
            },
            "Max term": "verify",
            "Max score": 0.3256846584875679
        }
    },
    {
        "ID": "3317",
        "Question": "What's the difference in this terminology? Is one considered more professional than the other? ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "considered": 0.4486563145614461,
                    "difference": 0.48717293559709096,
                    "professional": 0.459844958067596,
                    "terminology": 0.5915341551978756
                },
                "Max term": "terminology",
                "Max score": 0.5915341551978756
            }
        ],
        "Best Answer": "While the terms can be and often are interchangeable, I view a developer as someone who's involved in the whole process from requirements gathering, through specification and coding to testing and, yes, support. They might not be fully involved in all stages all of the time. A programmer is someone who just concentrates on the coding and has little involvement in the rest of the process. This may be their choice of course. As @sunpech points out in his comment most people writing software these days are (or should be) developers. You have to know much more than just how to code to write good software. ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "choice": 0.17886290308293729,
                "code": 0.08350081046346707,
                "coding": 0.27090993213080294,
                "comment": 0.19646715463910774,
                "course": 0.16834948550783335,
                "days": 0.16400797010809404,
                "developer": 0.13174474027518562,
                "developers": 0.13610983773781318,
                "fully": 0.2171156038997465,
                "gathering": 0.23855395867000817,
                "good": 0.10431691452102317,
                "involved": 0.34649332360181573,
                "know": 0.10402995392866798,
                "little": 0.15131398972119883,
                "people": 0.10669343203091972,
                "points": 0.17324666180090786,
                "process": 0.2916638618458923,
                "programmer": 0.12331437633805896,
                "requirements": 0.1588925079825295,
                "rest": 0.20345172208892076,
                "software": 0.22529982499101434,
                "specification": 0.22302097153493397,
                "support": 0.15771367466583366,
                "terms": 0.18093416750403354,
                "testing": 0.1402931599604468,
                "time": 0.09402303370691277,
                "view": 0.19646715463910774,
                "write": 0.11761224026678876,
                "writing": 0.13294199583794566,
                "yes": 0.15545955042283285
            },
            "Max term": "involved",
            "Max score": 0.34649332360181573
        }
    },
    {
        "ID": "3383",
        "Question": "Years ago, in my first real programming job, my boss encouraged me to keep a journal of my daily activities.  I still do so, although no longer a paper and hand-written one. Do you keep a journal, if so, what do you write in it, and how does it help you in your job?  Or, does it just take time that is not ever recovered? ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "ago": 0.27927002132274786,
                    "boss": 0.2851557498521802,
                    "daily": 0.31175806352363483,
                    "hand": 0.2738967721589706,
                    "help": 0.20868191928414248,
                    "job": 0.4266544439866892,
                    "longer": 0.28832328564704685,
                    "paper": 0.31670097359991783,
                    "programming": 0.1632495165608073,
                    "real": 0.23239269051017866,
                    "time": 0.15156317792913093,
                    "write": 0.18958848906923137,
                    "written": 0.2622104335272942,
                    "years": 0.22614966064174025
                },
                "Max term": "job",
                "Max score": 0.4266544439866892
            }
        ],
        "Best Answer": "I find an activity log helpful for several reasons:  I fully agree with Jon Sagara in that it helps answering the question \"what have you done past week (apart from sleeping)?\".  Additionally, it helps to keep track of the million interruptions, which are often forgotten but combined they take a lot of time. I also find it a great help for learning to estimate, as it gives you hard figures on how long things take (often longer than you'd think).  ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "activity": 0.22585795575901887,
                "additionally": 0.21776448874699572,
                "agree": 0.1755767461314159,
                "answering": 0.21115164469749523,
                "apart": 0.2007173509452174,
                "combined": 0.22585795575901887,
                "estimate": 0.1804199599052897,
                "figures": 0.22585795575901887,
                "fully": 0.20556056471909118,
                "gives": 0.1831078727955417,
                "great": 0.13971958757359698,
                "hard": 0.14932004630676682,
                "help": 0.12256716602332053,
                "helpful": 0.16571364884376605,
                "helps": 0.3511534922628318,
                "interruptions": 0.21776448874699572,
                "jon": 0.21776448874699572,
                "learning": 0.138885752554489,
                "log": 0.18601103988369375,
                "long": 0.12529553650381298,
                "longer": 0.1693436984934623,
                "lot": 0.1158668183707271,
                "past": 0.16748327911939276,
                "question": 0.1158668183707271,
                "reasons": 0.1593898121073696,
                "things": 0.10733897220413992,
                "think": 0.09588291438076567,
                "time": 0.0890190643060349,
                "track": 0.18916696218209197,
                "week": 0.1733778774036489
            },
            "Max term": "helps",
            "Max score": 0.3511534922628318
        }
    },
    {
        "ID": "3425",
        "Question": "And what do you think about operator precedence? Would be harder programming in a language where the operations are executed in sequential order? Ex.: 2 + 3 * 4 == 20 2 + (3 * 4) == 14 OK, the Lisp family doesn't have precedence by definition. Let's gonna talk about procedural and object-oriented languages using this \"feature\". ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "20": 0.218546450953872,
                    "definition": 0.21533832115765253,
                    "executed": 0.25991048573089576,
                    "family": 0.2695703570645819,
                    "feature": 0.16882264080167345,
                    "gonna": 0.2520177961612698,
                    "harder": 0.23446523525795773,
                    "language": 0.1268937711856075,
                    "languages": 0.14756206069375152,
                    "let": 0.17567214876762033,
                    "lisp": 0.22201149510492374,
                    "object": 0.1938475972767936,
                    "ok": 0.20693331860608868,
                    "operations": 0.22201149510492374,
                    "operator": 0.23956405600823583,
                    "order": 0.20955775495188975,
                    "oriented": 0.20211836734335026,
                    "procedural": 0.25991048573089576,
                    "programming": 0.1144400310325735,
                    "sequential": 0.2695703570645819,
                    "talk": 0.21533832115765253,
                    "think": 0.1144400310325735,
                    "using": 0.12649478272317524
                },
                "Max term": "family",
                "Max score": 0.2695703570645819
            }
        ],
        "Best Answer": "Smalltalk. Everything's done with message sending, so 1 + 2 * 3 means \"send * with parameter 3 to the object returned by sending the message + with parameter 2 to the object 1\". That throws people (it threw me) because of how we usually write maths, but since I can never remember C's operator precedence I cope in the same manner in both languages - I use ()s to group terms: 1 + (2 * 3). ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "cope": 0.23227764706536425,
                "group": 0.18831245376838615,
                "languages": 0.12714813537843705,
                "manner": 0.20642245630033054,
                "means": 0.1503186314422235,
                "message": 0.44790826951885526,
                "object": 0.33406094256825714,
                "operator": 0.20642245630033054,
                "parameter": 0.44790826951885526,
                "people": 0.1038863470874195,
                "remember": 0.16245726300335248,
                "send": 0.23227764706536425,
                "smalltalk": 0.23227764706536425,
                "terms": 0.1761738222072572,
                "throws": 0.23227764706536425,
                "use": 0.08749083226305394,
                "usually": 0.15136943770447192,
                "write": 0.11451788344894309
            },
            "Max term": "message",
            "Max score": 0.44790826951885526
        }
    },
    {
        "ID": "3438",
        "Question": "It seems like in language holy wars, people constantly denigrate any feature they don't find particularly useful as being \"just syntactic sugar\".  The line between \"real features\" and \"syntactic sugar\" tends to get blurred in these debates.  What do you believe is a reasonable and unambiguous definition of syntactic sugar that avoids it being defined as any feature the speaker/writer doesn't find useful? ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "avoids": 0.17694643575348998,
                    "believe": 0.12603253229698996,
                    "constantly": 0.15390337475815177,
                    "defined": 0.15090949348421007,
                    "definition": 0.141348436174154,
                    "feature": 0.22163093071239395,
                    "features": 0.11151712052537913,
                    "holy": 0.17694643575348998,
                    "language": 0.08329328482223629,
                    "like": 0.06307569673132829,
                    "line": 0.12065510911883193,
                    "particularly": 0.14345425796797834,
                    "people": 0.07913942246623477,
                    "real": 0.10693459087319594,
                    "reasonable": 0.16542490525582088,
                    "speaker": 0.17060567996362552,
                    "sugar": 0.5308393072604699,
                    "syntactic": 0.5308393072604699,
                    "tends": 0.16104462265356947,
                    "useful": 0.22902200359864167,
                    "writer": 0.17694643575348998
                },
                "Max term": "sugar",
                "Max score": 0.5308393072604699
            }
        ],
        "Best Answer": "How about this: \"syntactic sugar is a convenience shorthand for some functionality that does not introduce any meaningful layer of abstraction.\" Take a->b, which, as you point out, is equivalent to (*a).b.  Does this notation allow you to consider the code it's in any useful, otherwise hidden manner?  No, so it's syntactic sugar. Now consider a[i] == *(a + i).  Think about any C program that uses arrays in any substantive way.  Can you imagine trying to comprehend it without the [] notation?  With multidimensional arrays?  It is meaningful to consider arrays as whole units, not as a reference to the start of a contiguous block of memory.  While it does help to know how arrays work in C if you're planning on doing complicated things with them, it is unproductive to always have to think \"I need to store the two bits of memory 2*i bytes to the right of the memory location referenced by a.\"  The whole point of an array is the ability to abstract away the process of storing a sequence as a coherent unit.  The [] notation facilitates this abstraction.  It's not syntactic sugar. This is not to imply that syntactic sugar is always bad thing.  Like many alliterations, it has become an epithet and pitted against \"real features.\"  But LISP and Scheme, for example, would be unreadable if not for the let shorthand (and others). The ternary operator, <pred> ? <cnsq> : <alt>, is another example.  Syntactic sugar can help to organize programs and remove redundant code, which may save in maintenance down the line.  Syntactic sugar may sometimes be preferable to piling on \"real features\" if it helps to remove syntactic barriers to programming. To quote R^5RS, \"Programming languages should be designed not by piling feature on top of feature, but by removing the weaknesses and restrictions that make additional features appear necessary.\"  IMHO, syntax can qualify as a weakness and restriction and so letting programmers get away from syntax can increase a language's expressivity. ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "ability": 0.05705882664144204,
                "abstract": 0.07418881620546418,
                "abstraction": 0.12674186621999456,
                "additional": 0.06444610446002678,
                "allow": 0.059067020315406046,
                "alt": 0.07694612865835719,
                "appear": 0.07193592789200835,
                "array": 0.07694612865835719,
                "away": 0.10670106315459918,
                "bad": 0.04549182476704613,
                "bits": 0.07418881620546418,
                "block": 0.06444610446002678,
                "code": 0.05386675736441524,
                "complicated": 0.06061362065710426,
                "consider": 0.1493872126849121,
                "designed": 0.06238187134535437,
                "equivalent": 0.07193592789200835,
                "example": 0.08212060634801606,
                "feature": 0.09637742651694503,
                "features": 0.1454814955782929,
                "functionality": 0.05645594241534296,
                "help": 0.08351327624857466,
                "helps": 0.059816139094335065,
                "imagine": 0.07003113796370286,
                "imho": 0.07193592789200835,
                "increase": 0.0669257271256595,
                "introduce": 0.07694612865835719,
                "know": 0.03355510117688371,
                "language": 0.03622054201327746,
                "languages": 0.04212009595889478,
                "layer": 0.06337093310999728,
                "let": 0.05014383594678771,
                "letting": 0.07694612865835719,
                "like": 0.027428812879089493,
                "line": 0.05246753634800274,
                "lisp": 0.06337093310999728,
                "location": 0.0656238214234531,
                "maintenance": 0.0669257271256595,
                "make": 0.03491863631107106,
                "manner": 0.06838113387634613,
                "meaningful": 0.15389225731671438,
                "memory": 0.19333831338008034,
                "necessary": 0.05335053157729959,
                "need": 0.03622054201327746,
                "notation": 0.22256644861639255,
                "operator": 0.06838113387634613,
                "organize": 0.07694612865835719,
                "planning": 0.05769264123537378,
                "point": 0.08823489137402772,
                "process": 0.047038425108744356,
                "program": 0.047038425108744356,
                "programmers": 0.0412307427796263,
                "programming": 0.06533149599523048,
                "programs": 0.05335053157729959,
                "qualify": 0.07418881620546418,
                "quote": 0.0614661431816918,
                "real": 0.09300218738308705,
                "redundant": 0.07418881620546418,
                "reference": 0.06444610446002678,
                "remove": 0.1312476428469062,
                "removing": 0.07418881620546418,
                "restrictions": 0.07694612865835719,
                "right": 0.04411744568701386,
                "save": 0.0669257271256595,
                "scheme": 0.07193592789200835,
                "sequence": 0.07418881620546418,
                "start": 0.04288074686698304,
                "store": 0.06838113387634613,
                "sugar": 0.4616767719501431,
                "syntactic": 0.5386229006085004,
                "syntax": 0.12122724131420852,
                "thing": 0.04390254156599168,
                "things": 0.0365686403984278,
                "think": 0.06533149599523048,
                "trying": 0.047600188912545305,
                "unit": 0.04979573756163736,
                "units": 0.07418881620546418,
                "unreadable": 0.07418881620546418,
                "useful": 0.04979573756163736,
                "uses": 0.06061362065710426,
                "way": 0.03383488691453446,
                "work": 0.0325802343310876
            },
            "Max term": "syntactic",
            "Max score": 0.5386229006085004
        }
    },
    {
        "ID": "3450",
        "Question": "Long winding if conditions should be avoided if at all possible, yet sometimes we all end up writing them. Even if it's a very simple condition, the involved statements are sometimes simply very wordy, so the whole condition ends up being very lengthy. What's the most readable way to format those? if (FoobarBaz::quxQuux(corge, grault) || !garply(waldo) || fred(plugh) !== xyzzy) {     thud(); }  or if (     FoobarBaz::quxQuux(corge, grault)  || !garply(waldo)  || fred(plugh) !== xyzzy ) {     thud(); }  or if (FoobarBaz::quxQuux(corge, grault)     || !garply(waldo)     || fred(plugh) !== xyzzy) {     thud(); }  or thudable = FoobarBaz::quxQuux(corge, grault); thudable ||= !garply(waldo); thudable ||= fred(plugh) !== xyzzy;  if (thudable) {     thud(); }  or any other preferences? ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "avoided": 0.2615138505733136,
                    "condition": 0.5594555872655137,
                    "conditions": 0.24859085231260616,
                    "end": 0.15588746204092666,
                    "ends": 0.26970393743294113,
                    "format": 0.24329990751387037,
                    "involved": 0.20314861564232417,
                    "lengthy": 0.27972779363275685,
                    "long": 0.15518002835215422,
                    "possible": 0.16450741927024282,
                    "preferences": 0.2615138505733136,
                    "readable": 0.23856699611279047,
                    "simple": 0.17304438901829725,
                    "simply": 0.18774315646803513,
                    "way": 0.12300239699438867,
                    "writing": 0.15588746204092666
                },
                "Max term": "condition",
                "Max score": 0.5594555872655137
            }
        ],
        "Best Answer": "Often, a long if condition is the sign of code that needs refactoring, but sometimes you can't avoid it. In those cases, I prefer the first:  if (bar || baz || quux) { ... }  Because you're able to tell what's going on with one line. However, I'd much rather do something like this, when possible: function foo() {   return bar || baz || quux; }  if (foo()) { ... }  ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "able": 0.16595773607615358,
                "avoid": 0.18257854864290518,
                "bar": 0.45807236644941834,
                "cases": 0.18257854864290518,
                "code": 0.09217259968107956,
                "condition": 0.26332844451189635,
                "foo": 0.47932731506894266,
                "function": 0.18257854864290518,
                "going": 0.1361209140611012,
                "like": 0.09386809650070721,
                "line": 0.17955672331788397,
                "long": 0.14608242875905467,
                "needs": 0.18935904829861325,
                "possible": 0.15486299114049348,
                "prefer": 0.19123880493644999,
                "refactoring": 0.21687080993009236,
                "return": 0.20743461330898086,
                "sign": 0.22903618322470917,
                "tell": 0.18755930599188195
            },
            "Max term": "foo",
            "Max score": 0.47932731506894266
        }
    },
    {
        "ID": "3482",
        "Question": "You've shipped, asserts are turned off, you receive a rare crash report indicating that a null pointer violation occurred in your code.  In a development environment, the problem would have been caught by an assert. All you have is a crash report, so reproducing the issue is near impossible.  Following the backtrace doesn't give any clues as to why the crash happened in the first place. Options: - Add pointer checking to prevent the crash.  This will prevent the crash, but you probably won't even find out why it happened in the first place. - let it fly, hope that it happens again with a repro scenario Let's say the application isn't intended for a guided missle or automatic braking system... Which would you choose? ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "add": 0.09024106111744534,
                    "application": 0.07709021969643892,
                    "assert": 0.13445461020444474,
                    "asserts": 0.13445461020444474,
                    "caught": 0.12569985408050194,
                    "checking": 0.1194882557575362,
                    "choose": 0.10197874350965057,
                    "code": 0.04706301662405484,
                    "crash": 0.6284992704025096,
                    "development": 0.06795994305798575,
                    "environment": 0.08824654698063285,
                    "following": 0.09668608750136166,
                    "guided": 0.13445461020444474,
                    "happened": 0.22146699926718677,
                    "happens": 0.10591540965909112,
                    "hope": 0.11261223930889351,
                    "impossible": 0.11073349963359339,
                    "intended": 0.13445461020444474,
                    "issue": 0.0916810536288371,
                    "let": 0.17524130281631015,
                    "null": 0.1296365202299425,
                    "options": 0.11261223930889351,
                    "place": 0.18644797477141553,
                    "pointer": 0.259273040459885,
                    "prevent": 0.22522447861778702,
                    "probably": 0.07634559813686961,
                    "problem": 0.070042702065445,
                    "rare": 0.12569985408050194,
                    "report": 0.22934033156606787,
                    "reproducing": 0.13445461020444474,
                    "say": 0.070042702065445,
                    "scenario": 0.1194882557575362,
                    "turned": 0.11467016578303393,
                    "violation": 0.13445461020444474
                },
                "Max term": "crash",
                "Max score": 0.6284992704025096
            }
        ],
        "Best Answer": "I chose the second approach. There is no point in hiding the crash if the NULL pointer was unexpected at the point where crash has occured. This NULL pointer in most cases would just be one of the symptom of something else is wrong. If we hide it with a NULL pointer check it is almost certain that something else will break. I feel you have a better chance catching the scenario if you know the point where it crashes everytime instead at some random place. ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "approach": 0.1210711242889986,
                "better": 0.08655317369504878,
                "break": 0.1382795794913312,
                "cases": 0.12002199406494342,
                "certain": 0.12329620362253507,
                "chance": 0.13456758684711684,
                "check": 0.11709311381120252,
                "chose": 0.17310470063026076,
                "crash": 0.32366663481135793,
                "feel": 0.1040276467309631,
                "hide": 0.16690161081892826,
                "instead": 0.11202482039795324,
                "know": 0.07548847284614746,
                "null": 0.5007048324567848,
                "place": 0.12002199406494342,
                "point": 0.2977513239995682,
                "pointer": 0.5007048324567848,
                "random": 0.1575481363829032,
                "scenario": 0.1538361437386888,
                "second": 0.12836449703578434,
                "unexpected": 0.1538361437386888,
                "wrong": 0.11202482039795324
            },
            "Max term": "null",
            "Max score": 0.5007048324567848
        }
    },
    {
        "ID": "3519",
        "Question": "I am C++ developer with some good experience on it. When I try to learn a new language ( have tried Java, C#, python, perl till now) I usually pickup a book and try to read it. But the problem with this is that these books typically start with some very basic programming concepts such as loops, operators etc and it starts to get very boring soon. Also, I feel I would get only theoeritcal knowledge without any practical knowledge on writing the code. So my question is how do you tacke these situations? do you just skip the chapters if its explaining something basic? also, do you have some standard set of programs that you will try to write in every new programming language you try to learn? ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "basic": 0.2603898138638389,
                    "book": 0.11637193586448007,
                    "books": 0.13283991656602046,
                    "boring": 0.16926407124640686,
                    "code": 0.06337380307397282,
                    "concepts": 0.15164063822532844,
                    "developer": 0.09998903220088148,
                    "experience": 0.10380763394317451,
                    "explaining": 0.17456508089726516,
                    "feel": 0.1088041899538289,
                    "good": 0.07917240038085832,
                    "java": 0.11004161316772682,
                    "knowledge": 0.22677452097370981,
                    "language": 0.17045269543537694,
                    "learn": 0.19650538409931317,
                    "loops": 0.17456508089726516,
                    "new": 0.17153964509985933,
                    "operators": 0.1647821314482833,
                    "perl": 0.1608996986002844,
                    "practical": 0.1647821314482833,
                    "problem": 0.09431763464978708,
                    "programming": 0.1537239501431321,
                    "programs": 0.12553293524607378,
                    "python": 0.12246957225080964,
                    "question": 0.09288153747461612,
                    "read": 0.1088041899538289,
                    "set": 0.11410519960468721,
                    "situations": 0.14911077748221419,
                    "skip": 0.18105299236447706,
                    "soon": 0.14462883768409066,
                    "standard": 0.11883044673873008,
                    "start": 0.10089770168375757,
                    "starts": 0.1647821314482833,
                    "till": 0.17456508089726516,
                    "tried": 0.13574984882543736,
                    "try": 0.41523053577269803,
                    "typically": 0.1647821314482833,
                    "usually": 0.1179876324526861,
                    "write": 0.08926302526150078,
                    "writing": 0.10089770168375757
                },
                "Max term": "try",
                "Max score": 0.41523053577269803
            }
        ],
        "Best Answer": "Basically by writing code in that language. You need to have a good example application to study/modify otherwise you're starting off on the wrong foot and you might never recover. Years ago the company I worked for at the time decided to use Ada for their next product, but as all the developers used FORTRAN in the previous product we ended up creating FORTRAN constructs in Ada. We never really recovered from that. Having access to the documentation and Stack Overflow is essential otherwise you'll potentially miss the important features of the language. On that score find out who are the Gurus in the language and read their blogs, these will often discuss the new features of a language/framework and also the obscurer areas you'll never find by yourself. If you can't find out who they are ask here! In an ideal world I'd like to learn by myself for a while and then be evaluated, but I've never managed that yet. ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "access": 0.11592552161067182,
                "ago": 0.12245569299675599,
                "application": 0.09667725669691572,
                "areas": 0.141224689847178,
                "ask": 0.10430920491107212,
                "basically": 0.1328263337177121,
                "blogs": 0.15346351531151586,
                "code": 0.0590207597930239,
                "company": 0.09968901762391474,
                "creating": 0.12943717380798714,
                "decided": 0.15346351531151586,
                "developers": 0.09620632415425036,
                "discuss": 0.14984776045036574,
                "documentation": 0.12125203089570885,
                "ended": 0.1625744899017845,
                "essential": 0.16861675730078773,
                "evaluated": 0.16861675730078773,
                "example": 0.0899779533513479,
                "features": 0.21253499870103687,
                "fortran": 0.325148979803569,
                "framework": 0.11066817695756512,
                "good": 0.07373417719087219,
                "gurus": 0.16861675730078773,
                "ideal": 0.15346351531151586,
                "important": 0.10765641603056608,
                "language": 0.31748915499428243,
                "learn": 0.09150387471163647,
                "like": 0.06010643504648668,
                "managed": 0.1328263337177121,
                "miss": 0.1625744899017845,
                "modify": 0.14380549305136248,
                "need": 0.07937228874857061,
                "new": 0.07987843318004524,
                "overflow": 0.1328263337177121,
                "previous": 0.12245569299675599,
                "product": 0.22133635391513024,
                "read": 0.10133060741587134,
                "really": 0.07863038100564927,
                "recover": 0.1625744899017845,
                "score": 0.16861675730078773,
                "stack": 0.127889441783065,
                "starting": 0.12503649620094046,
                "study": 0.14984776045036574,
                "time": 0.06645816797017798,
                "use": 0.06351201080313976,
                "used": 0.08228100765356178,
                "worked": 0.11066817695756512,
                "world": 0.10430920491107212,
                "writing": 0.0939672029433711,
                "wrong": 0.10912044493264297,
                "years": 0.09916321588582105
            },
            "Max term": "fortran",
            "Max score": 0.325148979803569
        }
    },
    {
        "ID": "3558",
        "Question": "At some point in time, I just stopped coding for fun.  I used to go to work, finish my assignments and then upon arriving home I'd go and write stuff on the side for fun.  However, I now just go home and try to avoid the computer.  I'd rather read the paper, watch TV, go out to the bar, etc. Is this a bad sign?  I mean I still try to keep up on the latest trends, hit up the developer forums/blogs/etc but I haven't said, \"I want to learn language X - I wonder if I could write app Y in it\" Has this happened to anyone else? ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "app": 0.13830663231983711,
                    "assignments": 0.20462745084085313,
                    "avoid": 0.1471513340694496,
                    "bad": 0.12547546398905632,
                    "bar": 0.18459441244441346,
                    "blogs": 0.19315975067332525,
                    "coding": 0.12050929091553529,
                    "computer": 0.1346184797543563,
                    "developer": 0.11720843977583208,
                    "finish": 0.19315975067332525,
                    "fun": 0.3258370847280404,
                    "happened": 0.1747895863952319,
                    "hit": 0.18459441244441346,
                    "home": 0.3441231162586404,
                    "language": 0.09990342964530412,
                    "latest": 0.19315975067332525,
                    "learn": 0.11517307934113623,
                    "mean": 0.14136080813397758,
                    "paper": 0.1747895863952319,
                    "point": 0.12168465424143715,
                    "read": 0.12754168197108642,
                    "said": 0.1346184797543563,
                    "sign": 0.18459441244441346,
                    "stopped": 0.20462745084085313,
                    "stuff": 0.13375559420463493,
                    "time": 0.08364882773125333,
                    "try": 0.2433693084828743,
                    "used": 0.10356454360666742,
                    "want": 0.10022047526833458,
                    "watch": 0.18860871255812306,
                    "wonder": 0.16953579846125252,
                    "work": 0.08986273996480183,
                    "write": 0.2092705507850481
                },
                "Max term": "home",
                "Max score": 0.3441231162586404
            }
        ],
        "Best Answer": "This is a very common issue called burn-out. It happens to everyone that takes their work seriously. My advice is to take a few weeks off from coding and plan a long term project for fun. Then set aside at least 15 minutes each night to complete a part of the project. As long as you take it slow you'll be back in the game in no time. ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "15": 0.22040901289893983,
                "advice": 0.22040901289893983,
                "aside": 0.2395101165555043,
                "called": 0.2073017199286212,
                "coding": 0.14942654570938493,
                "common": 0.15994500959607863,
                "complete": 0.1824615793477463,
                "fun": 0.20201226671001274,
                "game": 0.20201226671001274,
                "happens": 0.2073017199286212,
                "issue": 0.17944168996087875,
                "long": 0.2919776815453124,
                "minutes": 0.2102173910881558,
                "night": 0.2631597426420503,
                "plan": 0.21673187123238324,
                "project": 0.24853850379381032,
                "seriously": 0.2102173910881558,
                "set": 0.16585141493624267,
                "slow": 0.22040901289893983,
                "takes": 0.17271954124266423,
                "term": 0.2073017199286212,
                "time": 0.10372109308386325,
                "weeks": 0.20201226671001274,
                "work": 0.11142608772241971
            },
            "Max term": "long",
            "Max score": 0.2919776815453124
        }
    },
    {
        "ID": "3622",
        "Question": "I often develop an application entirely myself. But did I really? I feel strange about that claim and never know when that is true. I mean I designed it, coded it, but I used XYZ plug-in. Can I still claim that I did it all myself even though I didn't create the plugin I used? Consider this conversation?  ME: I designed and developed this app entirely myself. Other: Cool, how did you program XYZ part? ME: I didn't program that part I used XYZ plugin. Other: So you didn't really program it ALL yourself than did you?  I mean if I must give them credit for the plug-in I used, then do I have to give the language authors credit for the language I used and the IDE authors credit as well? Where do I draw the line? This is just something that always crosses my mine as soon as I am about to take full credit for a project, and was wondering others opinions on the matter. ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "app": 0.08202106218316324,
                    "application": 0.07216360072446155,
                    "authors": 0.23533346037169076,
                    "claim": 0.2291020706024198,
                    "coded": 0.11185209762928594,
                    "consider": 0.0814516721723038,
                    "conversation": 0.1145510353012099,
                    "cool": 0.11766673018584538,
                    "create": 0.08089788386713495,
                    "credit": 0.4706669207433815,
                    "designed": 0.20407801884758595,
                    "develop": 0.09333202136793961,
                    "developed": 0.10541550803947052,
                    "draw": 0.11766673018584538,
                    "entirely": 0.2146838364492799,
                    "feel": 0.07563703961574438,
                    "ide": 0.09234587414436869,
                    "know": 0.054886607460828386,
                    "language": 0.11849302203092518,
                    "line": 0.0858219755258392,
                    "matter": 0.09140561118277019,
                    "mean": 0.16766460783177053,
                    "opinions": 0.11766673018584538,
                    "plugin": 0.24270363016268057,
                    "program": 0.2308244783029735,
                    "project": 0.05943453105705644,
                    "really": 0.11738544542058743,
                    "soon": 0.10054113844450957,
                    "true": 0.0978422007725856,
                    "used": 0.30708845008566665,
                    "wondering": 0.0978422007725856,
                    "xyz": 0.3775859834579588
                },
                "Max term": "credit",
                "Max score": 0.4706669207433815
            }
        ],
        "Best Answer": "That depends on what \"XYZ part\" does.  Most code libraries are pretty modular things that take care of one simple task.  Even if someone else designed that, you're the one who integrated it into the overall vision of what your program is supposed to do. Unless the third-party code takes care of a major part of the application logic itself--for example, building a video game on top of an existing engine--it's just a component.  Saying that you didn't really build the program yourself because you used third-party controls is like saying that you didn't really build the house yourself because you bought premade nails, boards, drywall, wiring, etc... ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "application": 0.10581579264157182,
                "build": 0.24402797873085924,
                "building": 0.15457412640067217,
                "care": 0.32104301387511003,
                "code": 0.12919953861301237,
                "component": 0.16796984181252744,
                "controls": 0.16796984181252744,
                "depends": 0.14167238098941645,
                "designed": 0.14962305863542444,
                "engine": 0.15199532550100064,
                "example": 0.09848322945269299,
                "existing": 0.1327135274313086,
                "game": 0.14167238098941645,
                "house": 0.1779420424204627,
                "integrated": 0.1779420424204627,
                "libraries": 0.13540970477728492,
                "like": 0.06578806934129781,
                "logic": 0.13837592967681436,
                "major": 0.14346914406444627,
                "modular": 0.1845554625362432,
                "overall": 0.16052150693755501,
                "party": 0.3039906510020013,
                "pretty": 0.11558073706256382,
                "program": 0.22564353669995524,
                "really": 0.1721260279013898,
                "saying": 0.2907638107704403,
                "simple": 0.11416916009605144,
                "supposed": 0.14742668257662897,
                "takes": 0.121129221753518,
                "task": 0.12201398936542962,
                "things": 0.08770996618970747,
                "unless": 0.13685572394866577,
                "used": 0.09005872054793877,
                "video": 0.16401230330034475,
                "xyz": 0.1845554625362432
            },
            "Max term": "care",
            "Max score": 0.32104301387511003
        }
    },
    {
        "ID": "3645",
        "Question": "I am a computer science student and learning Java now a days.  I want to be a good developer/programmer.  I like reading books. I search on the internet for the related topics and study them. I refer to StackOverflow and other good programming websites daily but I code rarely. Is this a bad sign? If yes then what should I do to overcome this problem? ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "bad": 0.15210247781262878,
                    "books": 0.18876114054763443,
                    "code": 0.09005208418012677,
                    "computer": 0.16318572316092533,
                    "daily": 0.20857455709471487,
                    "days": 0.17687564286394067,
                    "developer": 0.1420811172454499,
                    "good": 0.22500273987084884,
                    "internet": 0.20551280867268232,
                    "java": 0.15636550327791254,
                    "learning": 0.15820201438397147,
                    "like": 0.09170857453470649,
                    "overcome": 0.24805122301910953,
                    "problem": 0.1340222483608734,
                    "programmer": 0.13298932713321637,
                    "programming": 0.10921833176582889,
                    "rarely": 0.19512982919205377,
                    "reading": 0.1726705216787695,
                    "related": 0.192896058322375,
                    "science": 0.20857455709471487,
                    "search": 0.20857455709471487,
                    "sign": 0.22376699500079542,
                    "stackoverflow": 0.21188149731710168,
                    "student": 0.24051866312584333,
                    "study": 0.2286331654421496,
                    "topics": 0.24805122301910953,
                    "want": 0.12148815498464706,
                    "websites": 0.22376699500079542,
                    "yes": 0.16765653463215896
                },
                "Max term": "overcome",
                "Max score": 0.24805122301910953
            }
        ],
        "Best Answer": "Experience trumps all, if you aren't getting experience then yes you definitely have a problem if you want to be a great programmer. Start on a new project or join another person's open source project.   Get some experience.  Write some code. ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "code": 0.11501539525976393,
                "definitely": 0.24108755935446982,
                "experience": 0.5651929726397575,
                "getting": 0.19971153725357016,
                "great": 0.20327024718337666,
                "join": 0.2990586182455938,
                "new": 0.15566132318783624,
                "open": 0.20451189345401644,
                "person": 0.22405560411022804,
                "problem": 0.17117451538373046,
                "programmer": 0.16985525837426982,
                "project": 0.3103316995304432,
                "source": 0.19531169555136005,
                "start": 0.1831165004633457,
                "want": 0.1551658497652216,
                "write": 0.1620010419849686,
                "yes": 0.21413255200211753
            },
            "Max term": "experience",
            "Max score": 0.5651929726397575
        }
    },
    {
        "ID": "3678",
        "Question": "I work with C# professionally and I write code like this all the time. private IEnumerable<Something> GetAlotOfSomething() {     if (somethingA.IsReady)         yield return somethingA;      if (somethingB.IsReady)         yield return somethingB;      if (somethingC.IsReady)         yield return somethingC;       // ... More complex logic }  var specialSomethings =      GetAlotOfSomething()     .Where(s => s.IsSpecial);   Then one day I have to write a bit of VB6 or JScript and I end up writing so much boilerplate just to get things done. Anyone thoughts? ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "bit": 0.18301786596141262,
                    "code": 0.09689800310247151,
                    "complex": 0.2031110967495766,
                    "day": 0.17559139083885822,
                    "end": 0.15427172327614727,
                    "like": 0.09868042278746424,
                    "logic": 0.20756035829652586,
                    "private": 0.2244307643122875,
                    "return": 0.6542074284609627,
                    "things": 0.13156270784254914,
                    "thoughts": 0.21520004972007717,
                    "time": 0.10910845249606614,
                    "var": 0.2669085162937502,
                    "vb6": 0.2669085162937502,
                    "work": 0.1172136509326431,
                    "write": 0.27296480498823483,
                    "writing": 0.15427172327614727
                },
                "Max term": "return",
                "Max score": 0.6542074284609627
            }
        ],
        "Best Answer": "Iterators (generators etc) are certainly great features that I use a lot.  I don't qualify them as necessary, but I will certainly choose languages that have them when I get a choice. ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "certainly": 0.5696323268799763,
                "choice": 0.2747050709753182,
                "choose": 0.27788620484935617,
                "features": 0.23090469143995718,
                "generators": 0.3663810718620678,
                "great": 0.22664958638852992,
                "languages": 0.2005559756342197,
                "lot": 0.1879562265816681,
                "necessary": 0.25402999844852026,
                "qualify": 0.3532520540730767,
                "use": 0.13800288278975736
            },
            "Max term": "certainly",
            "Max score": 0.5696323268799763
        }
    },
    {
        "ID": "3713",
        "Question": "With parallel algorithms knocking at the door, it might be a good time to think about error handling. So at first there were error codes. Those sucked. It was free to ignore them, so you could fail late and produce hard-to-debug code. Then came exceptions. Those were made impossible to ignore once they occur, and most people (except Joel) like them better. And now we got libraries that help parallel code. Problem is, you can't handle exceptions in parallel code as easily as you could with non-parallel code. If you asynchronously launch a task and it throws an exception, there's no stack trace past it to unwind; best you can do is capture it and register it on the task object, if there's such an object. However, it defeats the primary strength of exceptions: you have to check for them and you can ignore them without any additional effort, whereas in single-threaded code an exception will necessarily trigger the appropriate actions (even if it means terminating your program). How should language implementations or libraries support errors in parallel code? ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "additional": 0.11162186613412943,
                    "algorithms": 0.10646051710175289,
                    "appropriate": 0.11843741116082222,
                    "best": 0.07025527629390328,
                    "better": 0.06663670559506141,
                    "came": 0.11843741116082222,
                    "capture": 0.13327214336081344,
                    "check": 0.09014919984028812,
                    "code": 0.27989471341932637,
                    "debug": 0.10498393204027932,
                    "easily": 0.09992474069388571,
                    "effort": 0.10498393204027932,
                    "error": 0.19765392377104726,
                    "errors": 0.09882696188552363,
                    "exception": 0.23183323854068477,
                    "exceptions": 0.37378314394673373,
                    "fail": 0.10108188707035118,
                    "free": 0.08509000849389449,
                    "good": 0.05827838223483396,
                    "got": 0.0856607621733475,
                    "handle": 0.10360267896083102,
                    "handling": 0.13327214336081344,
                    "hard": 0.0881093718889027,
                    "help": 0.07232328330739494,
                    "ignore": 0.3477498578110272,
                    "implementations": 0.13327214336081344,
                    "impossible": 0.1097596491155867,
                    "joel": 0.10108188707035118,
                    "language": 0.06273466062513326,
                    "late": 0.1212952493017441,
                    "launch": 0.12849642628550606,
                    "libraries": 0.19556551011303477,
                    "like": 0.047507220258857216,
                    "means": 0.08624715487035997,
                    "necessarily": 0.09992474069388571,
                    "non": 0.07879269688820516,
                    "object": 0.19167155510524334,
                    "occur": 0.12459438131557792,
                    "past": 0.09882696188552363,
                    "people": 0.059606063334926455,
                    "primary": 0.10646051710175289,
                    "problem": 0.06942670851412831,
                    "produce": 0.1023051911334319,
                    "program": 0.08147143779505261,
                    "single": 0.08747045893344067,
                    "stack": 0.10108188707035118,
                    "strength": 0.13327214336081344,
                    "support": 0.0881093718889027,
                    "task": 0.1762187437778054,
                    "think": 0.05657769047037757,
                    "threaded": 0.12459438131557792,
                    "throws": 0.13327214336081344,
                    "time": 0.05252753422021359,
                    "trace": 0.13327214336081344
                },
                "Max term": "exceptions",
                "Max score": 0.37378314394673373
            }
        ],
        "Best Answer": "I'm rather fond of callbacks for errors that can be handled. And they can be made to work just fine asynchronously... But for errors that can't be handled, truly exceptional errors, I'd rather see the relevant information saved and the program terminated. Since this is usually accomplished via some sort of global error-handler anyway, I see no need to twist exceptions into something that works for this - but better platform support for detecting critical errors and producing memory dumps, etc. would be nice. ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "accomplished": 0.1851065730920526,
                "better": 0.09900038897904624,
                "critical": 0.17595932556818392,
                "error": 0.14682460035973513,
                "errors": 0.5872984014389405,
                "exceptions": 0.1851065730920526,
                "fine": 0.16583365079597853,
                "global": 0.190903737978686,
                "handled": 0.36041028003860426,
                "information": 0.13188018794923306,
                "memory": 0.16583365079597853,
                "need": 0.09320322409241284,
                "nice": 0.14379408198650312,
                "platform": 0.1581655712098267,
                "producing": 0.19799889437765936,
                "program": 0.12103995778852167,
                "relevant": 0.14845554126640648,
                "saved": 0.190903737978686,
                "sort": 0.14527324992421997,
                "support": 0.13090176070089637,
                "truly": 0.19799889437765936,
                "usually": 0.1290308460013779,
                "work": 0.08383593156144797,
                "works": 0.1328896815181894
            },
            "Max term": "errors",
            "Max score": 0.5872984014389405
        }
    },
    {
        "ID": "3730",
        "Question": "What tools do they use? What processes? What rules do they have regarding code? How do they test their code? ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "code": 0.36278514509318377,
                    "processes": 0.4419673420402305,
                    "regarding": 0.49965139481684934,
                    "rules": 0.4267944514920474,
                    "test": 0.29285622872305095,
                    "tools": 0.34260852097870736,
                    "use": 0.19519584409942078
                },
                "Max term": "regarding",
                "Max score": 0.49965139481684934
            }
        ],
        "Best Answer": "I was searching a couple of weeks ago for some info about google development methodologies and found the following which I posted on my blog  Steve Y - Good Agile vs Bad Agile A summary of google methodologies from Steve Y's post Google Product Development/Management Process  I can't post more than one link at the moment, though, (stackexchange spam prevention apparently), so follow the link to my blog or google the above strings. Chris. ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "agile": 0.23032934525574436,
                "ago": 0.1163079058652676,
                "apparently": 0.1423247771505732,
                "bad": 0.09468421266384434,
                "blog": 0.25967647607359917,
                "chris": 0.16015149198466605,
                "couple": 0.12007832923479587,
                "development": 0.16189681052036653,
                "follow": 0.1163079058652676,
                "following": 0.11516467262787218,
                "good": 0.07003241360118806,
                "google": 0.4606586905114887,
                "info": 0.14575900601924388,
                "link": 0.26379363492315866,
                "management": 0.10511217235283822,
                "methodologies": 0.26379363492315866,
                "moment": 0.13189681746157933,
                "post": 0.24015665846959175,
                "posted": 0.15441257164002625,
                "prevention": 0.16015149198466605,
                "process": 0.09790322259385285,
                "product": 0.10511217235283822,
                "searching": 0.14972353229567217,
                "stackexchange": 0.15441257164002625,
                "steve": 0.29151801203848776,
                "strings": 0.16015149198466605,
                "summary": 0.14972353229567217,
                "vs": 0.12449806231648038,
                "weeks": 0.12293888718693105
            },
            "Max term": "google",
            "Max score": 0.4606586905114887
        }
    },
    {
        "ID": "3747",
        "Question": "We have a legacy classic ASP application that's been around since 2001.  It badly needs to be re-written, but it's working fine from an end user perspective. The reason I feel like a rewrite is necessary is that when we need to update it (which is admittedly not that often) then it takes forever to go through all the spaghetti code and fix problems.  Also, adding new features is also a pain since it was architect-ed and coded badly. I've run cost analysis for them on maintenance but they are willing to spend more for the small maintenance jobs than a rewrite.  Any suggestions on convincing them otherwise? ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "adding": 0.1543204248383903,
                    "admittedly": 0.1658731765826765,
                    "analysis": 0.14860279666109957,
                    "application": 0.10172803873197367,
                    "architect": 0.17106799024518882,
                    "asp": 0.14860279666109957,
                    "badly": 0.3548518566539253,
                    "code": 0.06210422537162038,
                    "coded": 0.15767636877392524,
                    "convincing": 0.17106799024518882,
                    "cost": 0.12885323710806215,
                    "ed": 0.17106799024518882,
                    "end": 0.09887640161870095,
                    "features": 0.11181931158607655,
                    "feel": 0.10662449792356424,
                    "fine": 0.14860279666109957,
                    "fix": 0.1263740574766017,
                    "forever": 0.17742592832696266,
                    "jobs": 0.13976567894786524,
                    "legacy": 0.1543204248383903,
                    "like": 0.06324662036717604,
                    "maintenance": 0.3086408496767806,
                    "necessary": 0.12301811354106675,
                    "need": 0.0835189944349919,
                    "needs": 0.1275866911900351,
                    "new": 0.08405158174754301,
                    "pain": 0.15767636877392524,
                    "perspective": 0.1543204248383903,
                    "problems": 0.10722436411419227,
                    "reason": 0.11042915336298713,
                    "rewrite": 0.3026368613843028,
                    "run": 0.10975870850950044,
                    "small": 0.10603700099365876,
                    "spaghetti": 0.17742592832696266,
                    "spend": 0.1240934332941476,
                    "suggestions": 0.1513184306921514,
                    "takes": 0.11644989707589898,
                    "update": 0.1345708652853529,
                    "user": 0.10722436411419227,
                    "willing": 0.1417314646603107,
                    "working": 0.09467873868458303,
                    "written": 0.12098206246224152
                },
                "Max term": "badly",
                "Max score": 0.3548518566539253
            }
        ],
        "Best Answer": "I believe there's two factors you should consider that you at least didn't cover in your Q. Let me define these as I use them, then I'll get onto the business of answering your Q.  Risk Opportunity cost  Risk is probably obvious: The chance that they pile a mountain of money into something that goes nowhere. Risk is compounded by what Brooks called \"Second System Effect\" and the rest of us call \"Gold Plating\". Every rebuild I've seen carries risk from people who add every feature they didn't add the first time around. Opportunity Cost in this context is the cost associated with you rewriting functionality that from the business perspective was working fine. It is Opportunity Cost because it means you don't have the opportunity to add features.  To sell something that is purely a refactor is hard because Risk and Opportunity Cost both have money attached to them from a decision making perspective. What I generally recommend is that instead of selling a rewrite of the system, you sell an \"improve as you go\" at a component level. It costs more because you have to build adapters/facades/proxies, but it's less risky and easier to sell. I've been there on the \"we need to rebuild it all\" and it just doesn't go well.  And here's the rub: Over time, all systems turn into garbage unless you are disciplined enough to keep them from doing so.  Which leaves me with this question back to you: If you can't sell them, or even your team, on doing the right thing day to day, what makes you think you can actually see a rewrite through? It really does take some serious introspection to answer that question honestly. Sometimes you've been handed a system from someone who had no clue. Sometimes you've been handed a system by someone who started with the best of intentions and on the right foot but got compromised by a poor corporate culture along the way. If you can't tell which it is, you need to find out soon! ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "actually": 0.05085917891657528,
                "add": 0.1862536470487766,
                "answer": 0.05468920605232442,
                "answering": 0.08647968735474944,
                "associated": 0.08918805690946359,
                "believe": 0.0658864151846781,
                "best": 0.04876346962652851,
                "build": 0.06115581500161094,
                "business": 0.12056348983100551,
                "called": 0.07286827483110976,
                "chance": 0.07190956117799625,
                "component": 0.0841897935241781,
                "consider": 0.05986326919135992,
                "context": 0.07618305126971375,
                "corporate": 0.08220619726303192,
                "cost": 0.3358948049746456,
                "costs": 0.07889142082442792,
                "cover": 0.07747559707996478,
                "culture": 0.07747559707996478,
                "day": 0.11734848461494861,
                "decision": 0.08647968735474944,
                "define": 0.07389315743914243,
                "easier": 0.05986326919135992,
                "effect": 0.08045654136143127,
                "factors": 0.07389315743914243,
                "feature": 0.05793134221993318,
                "features": 0.05829814865435657,
                "fine": 0.07747559707996478,
                "functionality": 0.06787001144582429,
                "generally": 0.06359652135410676,
                "goes": 0.06651863424850775,
                "got": 0.059456260010293374,
                "handed": 0.1850056666961352,
                "hard": 0.06115581500161094,
                "honestly": 0.08045654136143127,
                "improve": 0.07618305126971375,
                "instead": 0.05986326919135992,
                "leaves": 0.08647968735474944,
                "let": 0.060281744915502755,
                "level": 0.056548492752755926,
                "makes": 0.05202946143732054,
                "making": 0.06208454901625886,
                "means": 0.05986326919135992,
                "money": 0.13056001660157648,
                "need": 0.08708697422601218,
                "obvious": 0.07190956117799625,
                "opportunity": 0.38737798539982393,
                "people": 0.041371959692112895,
                "perspective": 0.16091308272286253,
                "pile": 0.08918805690946359,
                "poor": 0.07889142082442792,
                "probably": 0.05252467082069552,
                "purely": 0.08918805690946359,
                "question": 0.09490928893161381,
                "really": 0.04313647793193953,
                "recommend": 0.07190956117799625,
                "refactor": 0.08220619726303192,
                "rest": 0.07889142082442792,
                "rewrite": 0.15778284164885584,
                "rewriting": 0.08918805690946359,
                "right": 0.10607391943649205,
                "risk": 0.36434137415554874,
                "risky": 0.0925028333480676,
                "second": 0.06859478473939225,
                "seen": 0.06307524310329087,
                "sell": 0.3099023883198591,
                "selling": 0.0841897935241781,
                "soon": 0.07389315743914243,
                "started": 0.060281744915502755,
                "systems": 0.06413675928307744,
                "team": 0.055283481530217275,
                "tell": 0.0658864151846781,
                "thing": 0.05277860701825521,
                "think": 0.03926999702128858,
                "time": 0.07291764987980275,
                "turn": 0.07618305126971375,
                "unless": 0.06859478473939225,
                "use": 0.034842568704148945,
                "way": 0.040675508439188525,
                "working": 0.04936173460513494
            },
            "Max term": "opportunity",
            "Max score": 0.38737798539982393
        }
    },
    {
        "ID": "3766",
        "Question": "I mean seriously, how do you tackle a guy who even changes our variable names (even though they are reasonable) and sends back the code (after review) like 4 times? I know for sure I'm not that bad a developer! So many times, he enforces his ideals, which are not even best practices in the industry! I point out to him whatever link I can find on the internet trying to prove my point, but in the end he uses his authority to shut us out. Sick and tired. Frustrated. Do I have any way out other than quitting the job? ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "authority": 0.2253756164389236,
                    "bad": 0.1332457945392806,
                    "best": 0.11880822055932383,
                    "changes": 0.15011487184593678,
                    "code": 0.07888800813146853,
                    "developer": 0.12446681756046177,
                    "end": 0.12559793360647648,
                    "guy": 0.18561379712017803,
                    "industry": 0.16535975292522204,
                    "internet": 0.1800346573796386,
                    "job": 0.12502795698160785,
                    "know": 0.09828306822281234,
                    "like": 0.0803391375056693,
                    "link": 0.18561379712017803,
                    "mean": 0.15011487184593678,
                    "names": 0.17753761441130317,
                    "point": 0.25844046193847237,
                    "practices": 0.17300761385802613,
                    "prove": 0.20512157224396754,
                    "quitting": 0.2253756164389236,
                    "reasonable": 0.210700711984507,
                    "review": 0.1752017867102657,
                    "seriously": 0.1800346573796386,
                    "sick": 0.21729943373004873,
                    "sure": 0.13254300026933663,
                    "tackle": 0.21729943373004873,
                    "times": 0.2980023207062288,
                    "tired": 0.21729943373004873,
                    "trying": 0.13942120423506119,
                    "uses": 0.17753761441130317,
                    "variable": 0.19221251886571977,
                    "way": 0.09910256212319855
                },
                "Max term": "times",
                "Max score": 0.2980023207062288
            }
        ],
        "Best Answer": "Quit and find another job. Doing something about your boss is a lost cause so you might as well just find a new job and hope that your new boss isn't a douche like your previous one. Also, judging by his character, I'm pretty sure that even his boss won't be able to do anything about his attitude problems. ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "able": 0.1705081122748252,
                "attitude": 0.24623496796998495,
                "boss": 0.6018699149687867,
                "cause": 0.21031823160742738,
                "character": 0.23073849770436594,
                "hope": 0.22659755258767666,
                "job": 0.3001756923557733,
                "like": 0.09644185511076336,
                "lost": 0.21611977525521459,
                "new": 0.2563327628153853,
                "pretty": 0.16943529136803095,
                "previous": 0.19648235987290627,
                "problems": 0.16350148874692175,
                "quit": 0.2608536904191363,
                "sure": 0.15910916179575857
            },
            "Max term": "boss",
            "Max score": 0.6018699149687867
        }
    },
    {
        "ID": "3824",
        "Question": "I've been involved with many projects in several companies because I've been a developer for a long time and I'm a contractor. I estimate that less than 20% of projects are methodically tested. With methodically tested I mean any testing beyond ad-hoc no plan testing. I also estimate that less than 10% of projects are thoroughly methodically tested where they have dedicated testers as part of the team, test plan document, where developers write automated tests and then they also track test coverage and measure results.  Two questions  What are your percentage estimates about this issue? What's your professional experience regarding software testing?  Additional note Since methodical testing question may get quite biased answers (people like to brag about being superior to others) I encourage other developers (those that're not exposed to methodical testing) to provide their answer as well, because otherwise it will look like testing is being done everywhere... except at your company. ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "10": 0.09679647633290148,
                    "20": 0.10805700473872758,
                    "ad": 0.12460640781483043,
                    "additional": 0.11163264045858493,
                    "answer": 0.07880030237009145,
                    "answers": 0.09406032312669782,
                    "automated": 0.11367266530479878,
                    "biased": 0.12850882943048222,
                    "companies": 0.09584502812150712,
                    "company": 0.07880030237009145,
                    "contractor": 0.13328500748289973,
                    "coverage": 0.11844884335721627,
                    "dedicated": 0.12130695735157473,
                    "developer": 0.07360849843494319,
                    "developers": 0.15209473649083902,
                    "document": 0.11163264045858493,
                    "encourage": 0.11592780814676112,
                    "estimate": 0.21294158645178257,
                    "estimates": 0.10805700473872758,
                    "experience": 0.07641962215705847,
                    "exposed": 0.12850882943048222,
                    "hoc": 0.13328500748289973,
                    "involved": 0.09679647633290148,
                    "issue": 0.09088353237110294,
                    "like": 0.09502361180686726,
                    "long": 0.07394035098016594,
                    "look": 0.0767984649745244,
                    "mean": 0.08877651510584937,
                    "measure": 0.12850882943048222,
                    "note": 0.09993438595081121,
                    "people": 0.05961181682291342,
                    "percentage": 0.12850882943048222,
                    "plan": 0.21954048737829396,
                    "professional": 0.10361267923153282,
                    "projects": 0.23273064068197483,
                    "provide": 0.09679647633290148,
                    "question": 0.06837620442309997,
                    "questions": 0.08566903059670151,
                    "quite": 0.08509822182512776,
                    "regarding": 0.12850882943048222,
                    "results": 0.10647079322589129,
                    "software": 0.06293982507614262,
                    "superior": 0.12460640781483043,
                    "team": 0.07965657896888287,
                    "test": 0.15064347477072518,
                    "tested": 0.3241710142161827,
                    "testers": 0.11367266530479878,
                    "testing": 0.4703080589241641,
                    "tests": 0.08454224094497484,
                    "thoroughly": 0.12850882943048222,
                    "time": 0.05253260445166677,
                    "track": 0.11163264045858493,
                    "write": 0.0657123797544022
                },
                "Max term": "testing",
                "Max score": 0.4703080589241641
            }
        ],
        "Best Answer": "The pattern I have seen with testing over my career shows a strong correspondence with the risk of failure in a project. Big projects are more likely to be tested than small ones, mission critical applications are more likely to be tested than one off marketing web sites, in house systems are less likely to be tested than public facing ones. That said there are still projects that have been excessively tested and those that have not been tested enough, but these are the minority. ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "applications": 0.11627918037732594,
                "big": 0.10347534999997256,
                "career": 0.11732631037515487,
                "critical": 0.1477473742099268,
                "excessively": 0.15542802312430423,
                "facing": 0.16625328976628756,
                "failure": 0.1446027564823209,
                "house": 0.16029571562708195,
                "likely": 0.33737585361713146,
                "ones": 0.23054314856795374,
                "pattern": 0.1328065321983166,
                "project": 0.07850810210267574,
                "projects": 0.19353131745523228,
                "public": 0.13924517147150287,
                "risk": 0.13096453342873787,
                "said": 0.1054539137353426,
                "seen": 0.11336373480877289,
                "shows": 0.1477473742099268,
                "sites": 0.12609684092596016,
                "small": 0.09935977463034565,
                "strong": 0.13692210756794349,
                "systems": 0.11527157428397687,
                "tested": 0.6739254796684332,
                "testing": 0.0977732648209652,
                "web": 0.09829169650072386
            },
            "Max term": "tested",
            "Max score": 0.6739254796684332
        }
    },
    {
        "ID": "3851",
        "Question": "How would you consider that a programmer is bad at what he or she is doing? If possible... How should he/she improve? ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "bad": 0.41195131474519997,
                    "consider": 0.45092540609809056,
                    "improve": 0.5738556179044343,
                    "possible": 0.40977851053400627,
                    "programmer": 0.3601856389683303
                },
                "Max term": "improve",
                "Max score": 0.5738556179044343
            }
        ],
        "Best Answer": "When they fail to learn from their mistakes and from peer reviews. We are all green at some point; however, if you're not getting better or attempting to get better then you're a bad programmer. ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "bad": 0.2511195924450505,
                "better": 0.4247546539663523,
                "fail": 0.3221572974040821,
                "getting": 0.2581578026886974,
                "green": 0.3865791472195999,
                "learn": 0.2305009746551734,
                "mistakes": 0.3865791472195999,
                "point": 0.24353287733282844,
                "programmer": 0.2195639815307595,
                "reviews": 0.35574918283771256
            },
            "Max term": "better",
            "Max score": 0.4247546539663523
        }
    },
    {
        "ID": "3853",
        "Question": "I'm doing my first big project and I don't have a lot of experience in a professional programming environment. While researching anything programming-related I often see references to Unit Testing, but I am still unclear as to how to set those up or even if it would be beneficial to me.  Can someone explain unit testing to me, and how to set it up in a Visual Studio 2010 solution that has multiple projects? Is it something that occurs within your project's solution, or is it a separate solution? And is it something you'd recommend for a small development team or is it just a waste of time to setup?   Right now I just run the entire program to test whatever I am currently working on, but occasionally I have run into problems that are not easy to debug and it would be useful to run subsets of the code elsewhere... Sometimes I do setup another project with some of the libraries referenced to test a small part of the program, but I feel more time is wasted setting that up then just running the entire program because of all the dependencies involved ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "2010": 0.12779863104279632,
                    "beneficial": 0.14693317994315366,
                    "big": 0.09145059470762903,
                    "code": 0.05143087827018433,
                    "currently": 0.10895720146593284,
                    "debug": 0.11574529071579288,
                    "development": 0.07426722316982626,
                    "easy": 0.09381214418942142,
                    "entire": 0.23824373980592956,
                    "environment": 0.09643660226414946,
                    "experience": 0.08424486973924276,
                    "explain": 0.09508790364271888,
                    "feel": 0.08829981439285885,
                    "involved": 0.10670828132496575,
                    "libraries": 0.10780595840766777,
                    "lot": 0.07537781884146413,
                    "multiple": 0.10369195038878945,
                    "occasionally": 0.12531256516597156,
                    "occurs": 0.14693317994315366,
                    "problems": 0.08879658646986292,
                    "professional": 0.11422245254307622,
                    "program": 0.26946795769672655,
                    "programming": 0.12475435248528291,
                    "project": 0.20815428872650915,
                    "projects": 0.08552062919254022,
                    "recommend": 0.11422245254307622,
                    "references": 0.13372859655788513,
                    "related": 0.11016750788946016,
                    "right": 0.08424486973924276,
                    "run": 0.27268612124213076,
                    "running": 0.10780595840766777,
                    "separate": 0.12101054179293627,
                    "set": 0.18520367553178824,
                    "setting": 0.12101054179293627,
                    "setup": 0.2611556324862299,
                    "small": 0.17562657154507835,
                    "solution": 0.3005695839601309,
                    "studio": 0.12101054179293627,
                    "team": 0.08781328577253918,
                    "test": 0.16606912663143092,
                    "testing": 0.17282228500577468,
                    "time": 0.11582371893957508,
                    "unclear": 0.1416679288660103,
                    "unit": 0.19017580728543776,
                    "useful": 0.09508790364271888,
                    "visual": 0.11912186990296478,
                    "waste": 0.13057781624311496,
                    "working": 0.0784070754433167
                },
                "Max term": "solution",
                "Max score": 0.3005695839601309
            }
        ],
        "Best Answer": "Setting up unit testing in VS2010 is fairly easy.   Add a new project to your solution and select the Test Project template from the New Project dialog box.  Usually you create one test project for project you want to test in your solution (ie. BusinessLogic.proj would have a mate called BusinessLogicTest.proj, just as an example). Once you have the project added, the easiest way (not necessarily the best way to do this, especially if you're goal is to get to TDD) to get started is to right-click on a function that you want to test and select \"Create Unit Tests\".  Make sure the Output Project is the Test Project you just created and click OK.  VS creates a new Test Class for you with a Test Method stubbed out. That's the basics of getting setup.  There's a lot to learn to test effectively, but you're at least on the right path by wanting to unit test.  I'll see if I can find a demo or article to get you a bit further. EDIT Found one.  This article is by Deborah Kurata (an MS MVP) and she has both C# and VB code samples.  She is using VS2008, but the basics are the same for VS2010 ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "add": 0.07080438512662228,
                "added": 0.08552700903760944,
                "article": 0.16620539172486531,
                "basics": 0.20342921484245627,
                "best": 0.055612347005095895,
                "bit": 0.06974520950409978,
                "box": 0.10549494747823826,
                "called": 0.08310269586243266,
                "class": 0.07026652115838446,
                "click": 0.18750427740990733,
                "code": 0.036926294006376814,
                "create": 0.13561390067776571,
                "created": 0.08310269586243266,
                "creates": 0.09601433301634572,
                "demo": 0.10549494747823826,
                "dialog": 0.10549494747823826,
                "easiest": 0.10171460742122813,
                "easy": 0.0673551557783805,
                "edit": 0.07026652115838446,
                "effectively": 0.09175674190721647,
                "especially": 0.07740242145755025,
                "example": 0.056294638889698725,
                "fairly": 0.08310269586243266,
                "function": 0.073144830348421,
                "getting": 0.06411843322744014,
                "goal": 0.08427152424306113,
                "learn": 0.057249330441929244,
                "lot": 0.05411969606035154,
                "make": 0.04787426954257887,
                "method": 0.07378420026432486,
                "ms": 0.10171460742122813,
                "necessarily": 0.0790979645516651,
                "new": 0.1499276450550055,
                "ok": 0.08098227051209818,
                "output": 0.08552700903760944,
                "path": 0.08835712106289527,
                "project": 0.3985344588167008,
                "right": 0.12097210598573922,
                "select": 0.18750427740990733,
                "setting": 0.08688303591944277,
                "setup": 0.09375213870495366,
                "solution": 0.14386844634954712,
                "started": 0.06874837541276642,
                "sure": 0.062041391491040265,
                "tdd": 0.08200932993166907,
                "template": 0.09375213870495366,
                "test": 0.5365537048427712,
                "testing": 0.062041391491040265,
                "tests": 0.06691509747881397,
                "unit": 0.20481337308194184,
                "using": 0.04950307075660968,
                "usually": 0.06874837541276642,
                "vb": 0.09375213870495366,
                "vs": 0.08200932993166907,
                "want": 0.0996336147041752,
                "wanting": 0.09862584469272737,
                "way": 0.0927768473922636
            },
            "Max term": "test",
            "Max score": 0.5365537048427712
        }
    },
    {
        "ID": "3884",
        "Question": "I learned about them in a Structured Programming course, but never saw them used thereafter either at the analysis phase or for documentation purposes. Not even for highly structured languages like Pascal (Delphi). Does any of you actually use Nassi-Shneiderman diagrams? If yes, what tools do you use to create/maintain them? edit: Or have you never heard of them? ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "actually": 0.13745118514322163,
                    "analysis": 0.2093842815627776,
                    "course": 0.1764246827857931,
                    "create": 0.16068551590271452,
                    "delphi": 0.2499966445320267,
                    "diagrams": 0.2221691242490485,
                    "documentation": 0.17977217301449808,
                    "edit": 0.16651408368309212,
                    "heard": 0.19693260780531027,
                    "highly": 0.20589106839544888,
                    "languages": 0.13684746511216467,
                    "learned": 0.1853831433759317,
                    "like": 0.08911573984072627,
                    "maintain": 0.20589106839544888,
                    "pascal": 0.2499966445320267,
                    "phase": 0.2221691242490485,
                    "programming": 0.10613045169291473,
                    "purposes": 0.22752995906290643,
                    "saw": 0.21744053282482745,
                    "structured": 0.444338248498097,
                    "tools": 0.1652787054261998,
                    "use": 0.18832991266630875,
                    "used": 0.12199247661613256,
                    "yes": 0.16291645790681147
                },
                "Max term": "structured",
                "Max score": 0.444338248498097
            }
        ],
        "Best Answer": "Heard of Nassi-Shneiderman diagrams, although I don't use them myself.  I can't help posting a link to the rejection letter that Nassi and Shneiderman received from Communications of the ACM when they first proposed the diagram:  http://www.cs.umd.edu/hcil/members/bshneiderman/nsd/rejection_letter.html ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "cs": 0.33988454177643074,
                "diagram": 0.3093398154253981,
                "diagrams": 0.3020514580650103,
                "heard": 0.26774099024425335,
                "help": 0.18444639207272429,
                "html": 0.2577895875493597,
                "http": 0.2577895875493597,
                "link": 0.27992052280718505,
                "members": 0.2715067317139777,
                "posting": 0.3093398154253981,
                "received": 0.3277050092134991,
                "use": 0.12802257044130705,
                "www": 0.2956226712607801
            },
            "Max term": "cs",
            "Max score": 0.33988454177643074
        }
    },
    {
        "ID": "3918",
        "Question": "What should you do, if a co-worker is editing your code?   Without the purpose of adding functionality or fixing bugs, just to change how it looks... ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "adding": 0.3548028734291011,
                    "bugs": 0.2759327811836209,
                    "change": 0.25234964978757696,
                    "code": 0.1427857500847017,
                    "editing": 0.38136416315583915,
                    "fixing": 0.3479008956110752,
                    "functionality": 0.29929791503799313,
                    "looks": 0.30939604872838494,
                    "purpose": 0.30939604872838494,
                    "worker": 0.40792545288257726
                },
                "Max term": "worker",
                "Max score": 0.40792545288257726
            }
        ],
        "Best Answer": "Talk to them about it.  Go into the conversation with the attitude of \"They're not doing this to annoy me or because they have some form of obsessive-compulsive disorder; they're trying to make my code better.\" Because you could be wrong.  That could be a subtle bug fix and you just didn't spot it. Or, it could be that there's a coding standard you don't know about that you're violating, and they're just correcting it. Or, it could be that they're trying to annoy you, or they have some form of obsessive-compulsive disorder.  If that's the case, ask them nicely to stop, and if that doesn't work, take it up with your boss. But you'll never know unless you ask. ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "ask": 0.3178510537818457,
                "attitude": 0.23381704472015408,
                "better": 0.12845348570383108,
                "boss": 0.1905056323290988,
                "bug": 0.18129963242888764,
                "case": 0.1674181495963543,
                "code": 0.08992404223199356,
                "coding": 0.14587472889652547,
                "conversation": 0.23381704472015408,
                "fix": 0.18298378272257332,
                "form": 0.3694792403627942,
                "know": 0.2240647466425911,
                "make": 0.1165848875987735,
                "nicely": 0.2569045274528986,
                "spot": 0.23381704472015408,
                "standard": 0.1686140580597217,
                "stop": 0.2115802303343676,
                "talk": 0.20522059710835977,
                "trying": 0.3178510537818457,
                "unless": 0.1905056323290988,
                "work": 0.1087775285264295,
                "wrong": 0.16625593321583654
            },
            "Max term": "form",
            "Max score": 0.3694792403627942
        }
    },
    {
        "ID": "3921",
        "Question": "For which issues is it right to edit the code written by a co-worker? For which issues is it wrong? ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "code": 0.1568801742571716,
                    "edit": 0.29852505864436196,
                    "issues": 0.664706702566992,
                    "right": 0.25697305372727713,
                    "worker": 0.44819189655964786,
                    "written": 0.3056102371054059,
                    "wrong": 0.29004767942815485
                },
                "Max term": "issues",
                "Max score": 0.664706702566992
            }
        ],
        "Best Answer": "When it's right When the edit improves the functionality of the program or makes the code itself more readable / maintainable. When it's wrong When the edit harms the functionality of the program or serves no purpose apart from providing the editor with busywork. ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "apart": 0.2663653626481362,
                "code": 0.10491372069083851,
                "edit": 0.39927766233213563,
                "editor": 0.25562479006890426,
                "functionality": 0.4398262129521932,
                "maintainable": 0.2727926315772306,
                "makes": 0.16858639403785458,
                "program": 0.3664580112153408,
                "providing": 0.28021236902907054,
                "purpose": 0.2273328439279365,
                "readable": 0.25562479006890426,
                "right": 0.17185090029043582,
                "wrong": 0.1939695781869023
            },
            "Max term": "functionality",
            "Max score": 0.4398262129521932
        }
    },
    {
        "ID": "3956",
        "Question": "In Windows the default way is registry. This allow you to differentiate system-wide and per-user settings. In Unix you should use text files in the /etc folder for system-wide settings (what's the convention for per-user settings?). Many new programs (and especially those designed for being portable) use XML files.  What's the best way (and location) to store non-BLOB settings? Should we follow each system default or have a unified solution? And what's the best portable way?  ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "allow": 0.11956129964746694,
                    "best": 0.16421086843648955,
                    "blob": 0.15575153607054176,
                    "convention": 0.1262710997213839,
                    "default": 0.28350893022946344,
                    "designed": 0.1262710997213839,
                    "especially": 0.11427605137278976,
                    "files": 0.22187234703572362,
                    "folder": 0.14561007113933777,
                    "follow": 0.11311249599471644,
                    "location": 0.13283333635800315,
                    "new": 0.07378382116853846,
                    "non": 0.09208288590552496,
                    "portable": 0.3115030721410835,
                    "programs": 0.10799019246619185,
                    "settings": 0.5670178604589269,
                    "solution": 0.106202865855953,
                    "store": 0.13841458725980377,
                    "text": 0.12269187142679919,
                    "unix": 0.14561007113933777,
                    "use": 0.11733226756189843,
                    "user": 0.1882516222115732,
                    "way": 0.2054620174502874,
                    "wide": 0.2709372124162676,
                    "windows": 0.11200067161765549,
                    "xml": 0.14175446511473172
                },
                "Max term": "settings",
                "Max score": 0.5670178604589269
            }
        ],
        "Best Answer": " What's the best way (and location) to store non-BLOB settings?  On Windows, it seems acceptable to use the registry. In my opinion, the registry was a poorly-devised system, and instead a simple text file in the Users\\Username\\AppData directory should be preferred. This is easier to back up, less dangerous for users to modify, and easier to clean up. On Linux and most Unixes, The preferred location is /home/user/.config/appname for user-specific settings and /etc/ for global (system-wide) settings. The less-preferred (but acceptable) location for user settings is ~/.appname, but this is generally falling out of favor. These files should be user-editable, so a human-readable format is always preferred. I disagree with most people that XML is an acceptable format for storing non-blob data. It is, in my opinion, an overwrought and excessively complex format for what usually ends up being very small pieces of structured data. I prefer to see files in YAML, JSON, ASN.1, name=value pairs, or similar formats. Having too much syntax makes it too easy for a user to mess up and leave the file in an invalid format.  Should we follow each system default or have a unified solution?  That is entirely up to you, but keep some things in mind:  Platforms like *nix have strict limitations on which locations are writable. More strict than Windows. So:  The only place you should write to anything is in the user's home directory. Unless your application is a system service; in which case, all mutable data files should be written in /var/. Nonmutable data files should be kept in your app directory in /usr/share/ or /usr/local/share/ or /opt/ Configuration files in /etc/ should never be written to by the application when it is running, even if it has write access to them. /etc/ should be the repository for default behaviors and nothing else. Plan for your application to be installed in one of three places: /usr/local/, /opt/appname, or /home/username/appname. Blobs should be stored alongside other configuration files if they are to be changed. It is generally preferable to use a user-editable format, so something like SQLite or Berkeley DB is preferred (since there are command-line tools for each), but not required.  On Windows, your applications should only ever write in the User directory. The standardized location for data files is Users\\User\\AppData. Nowhere else seems acceptable. On Mac OS X, your application settings should be stored in ~/Library/Preferences along with all of the other applications' plist files. plist seems to be the preferred format, but you'll want to double-check with the Apple guidelines.   And what's the best portable way?  There is no \"best,\" to be honest. There are only platform-specific limitations and expectations. My recommendation is to stick with platform-specific means, even if it means writing more code. ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "acceptable": 0.21159413972022106,
                "access": 0.038901190663190616,
                "app": 0.03687358368880916,
                "apple": 0.052898534930055266,
                "application": 0.1297681595323432,
                "applications": 0.07914915420250679,
                "best": 0.08948399954667302,
                "blob": 0.11316563485987438,
                "case": 0.03687358368880916,
                "changed": 0.045199513197267324,
                "check": 0.03827428288752038,
                "clean": 0.05028449489586048,
                "code": 0.019805628630300123,
                "command": 0.052898534930055266,
                "complex": 0.041515230697385413,
                "config": 0.05149783573134404,
                "configuration": 0.10056898979172096,
                "dangerous": 0.05455521045555573,
                "data": 0.17295000193819235,
                "db": 0.05028449489586048,
                "default": 0.10299567146268808,
                "directory": 0.21822084182222293,
                "disagree": 0.05149783573134404,
                "double": 0.052898534930055266,
                "easier": 0.07323521472403985,
                "easy": 0.036126322382967715,
                "ends": 0.05455521045555573,
                "entirely": 0.04825688792147902,
                "excessively": 0.052898534930055266,
                "expectations": 0.05028449489586048,
                "favor": 0.05455521045555573,
                "file": 0.07537569965541412,
                "files": 0.32241511889521485,
                "follow": 0.041092523845253144,
                "format": 0.2952855145810401,
                "generally": 0.07780238132638123,
                "global": 0.05455521045555573,
                "guidelines": 0.05658281742993719,
                "home": 0.1376186989059903,
                "honest": 0.05455521045555573,
                "human": 0.04825688792147902,
                "installed": 0.05455521045555573,
                "instead": 0.036617607362019924,
                "kept": 0.05149783573134404,
                "leave": 0.0445726054215971,
                "library": 0.041092523845253144,
                "like": 0.040339898537283106,
                "line": 0.03858233132636222,
                "linux": 0.04825688792147902,
                "local": 0.0947816927586597,
                "location": 0.1930275516859161,
                "locations": 0.052898534930055266,
                "mac": 0.05149783573134404,
                "makes": 0.03182576588122817,
                "means": 0.07323521472403985,
                "mess": 0.052898534930055266,
                "mind": 0.03827428288752038,
                "modify": 0.04825688792147902,
                "mutable": 0.052898534930055266,
                "nix": 0.05658281742993719,
                "non": 0.0669053962877675,
                "opinion": 0.08137722059192921,
                "os": 0.045872899635330096,
                "pairs": 0.052898534930055266,
                "people": 0.02530670637048597,
                "pieces": 0.05658281742993719,
                "place": 0.039231647396214715,
                "places": 0.04921425243017334,
                "plan": 0.04660021239597856,
                "platform": 0.09039902639453465,
                "platforms": 0.04739084637932985,
                "poorly": 0.05658281742993719,
                "portable": 0.05658281742993719,
                "prefer": 0.041092523845253144,
                "preferences": 0.052898534930055266,
                "preferred": 0.3089870143880642,
                "readable": 0.04825688792147902,
                "recommendation": 0.05455521045555573,
                "repository": 0.052898534930055266,
                "required": 0.041515230697385413,
                "running": 0.041515230697385413,
                "service": 0.04921425243017334,
                "settings": 0.25748917865672016,
                "share": 0.08797234472356753,
                "similar": 0.03687358368880916,
                "simple": 0.035003096917684155,
                "small": 0.033816208964597465,
                "solution": 0.03858233132636222,
                "specific": 0.11062075106642746,
                "stick": 0.04921425243017334,
                "store": 0.05028449489586048,
                "stored": 0.10579706986011053,
                "strict": 0.11316563485987438,
                "structured": 0.05028449489586048,
                "syntax": 0.0445726054215971,
                "text": 0.0445726054215971,
                "things": 0.026890978654850527,
                "tools": 0.03740824134537122,
                "unless": 0.04195856538740231,
                "use": 0.0426255203742489,
                "user": 0.30775383329434264,
                "users": 0.10985282208605976,
                "usually": 0.03687358368880916,
                "value": 0.04291592989609663,
                "var": 0.05455521045555573,
                "want": 0.02671952906490606,
                "way": 0.04976139183162768,
                "wide": 0.04921425243017334,
                "windows": 0.12206583088789383,
                "write": 0.08368964349588408,
                "writing": 0.031532625663426773,
                "written": 0.07716466265272444,
                "xml": 0.05149783573134404
            },
            "Max term": "files",
            "Max score": 0.32241511889521485
        }
    },
    {
        "ID": "3967",
        "Question": "The jRails project is a drop in replacement for the Prototype/scriptalicious helpers already a part of the Rails framework. Are your experiences with this project positive? Does it do what it says on the tin?  Is it still being maintained or is this a bad choice if I want to do jQuery with RoR? ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "bad": 0.19872739127251812,
                    "choice": 0.25202568037306694,
                    "drop": 0.32408789890503936,
                    "experiences": 0.2725102063643837,
                    "framework": 0.22061405185706623,
                    "jquery": 0.28667240550577755,
                    "maintained": 0.32408789890503936,
                    "positive": 0.3142463368297863,
                    "project": 0.31745734136364906,
                    "prototype": 0.32408789890503936,
                    "rails": 0.2923596762452382,
                    "says": 0.25802954525632804,
                    "want": 0.15872867068182453
                },
                "Max term": "drop",
                "Max score": 0.32408789890503936
            }
        ],
        "Best Answer": " Is it still being maintained or is this a bad choice if I want to do jQuery with RoR?  Their website doesn't exist anymore, their Google Group has some spam and their code isn't updated. I guess this isn't maintained anymore and might be a bad choice for continuous development... ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "anymore": 0.45576593178120195,
                "bad": 0.2882234859680363,
                "choice": 0.36552444877102735,
                "code": 0.08532117949142372,
                "continuous": 0.22788296589060097,
                "development": 0.12320550011054007,
                "exist": 0.18711606522963162,
                "google": 0.17528351597017605,
                "group": 0.19761705001325958,
                "guess": 0.19761705001325958,
                "jquery": 0.2078870947699698,
                "maintained": 0.4700396024138045,
                "updated": 0.21201135008191993,
                "want": 0.11510574987685292,
                "website": 0.18711606522963162
            },
            "Max term": "maintained",
            "Max score": 0.4700396024138045
        }
    },
    {
        "ID": "4028",
        "Question": "As programmers, we often take incredible pride in our skills and hold very strong opinions about what is 'good' code and 'bad' code. At any given point in our careers, we've probably had some legacy system dropped in our laps, and thought 'My god, this code sucks!' because it didn't fit into our notion of what good code should be, despite the fact that it may have well been perfectly functional, maintainable code. How do you prepare yourself mentally when trying to get your head around another programmer's work?  ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "bad": 0.1286309425847308,
                    "code": 0.38077895364987524,
                    "despite": 0.19801736537677564,
                    "dropped": 0.2175699284048114,
                    "fact": 0.14717070244680733,
                    "fit": 0.18555540581053132,
                    "functional": 0.14717070244680733,
                    "given": 0.1508519211820152,
                    "god": 0.2175699284048114,
                    "good": 0.1902816767349943,
                    "head": 0.17379931394258777,
                    "hold": 0.19335187697062356,
                    "legacy": 0.18923662454573917,
                    "maintainable": 0.19801736537677564,
                    "mentally": 0.2175699284048114,
                    "notion": 0.2175699284048114,
                    "opinions": 0.20340327647527529,
                    "perfectly": 0.20340327647527529,
                    "point": 0.12474480090018468,
                    "prepare": 0.19801736537677564,
                    "probably": 0.12353987933477435,
                    "programmer": 0.11246721781829126,
                    "programmers": 0.1165824702431756,
                    "skills": 0.1508519211820152,
                    "strong": 0.17918522504108744,
                    "sucks": 0.2175699284048114,
                    "thought": 0.1508519211820152,
                    "trying": 0.13459247234829097,
                    "work": 0.09212262363841252
                },
                "Max term": "code",
                "Max score": 0.38077895364987524
            }
        ],
        "Best Answer": "For any legacy code base, the correct way to prepare yourself mentally for dealing with it is to start by writing unit tests for it. Whether it sucks or not, you need to first have the confidence to be able to change it without breaking stuff! ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "able": 0.19541310063275463,
                "base": 0.24103801989058374,
                "breaking": 0.27555193894131447,
                "change": 0.19181203360188523,
                "code": 0.1085320511289471,
                "confidence": 0.31006585799204517,
                "correct": 0.22749760811860634,
                "dealing": 0.2644409387342161,
                "legacy": 0.26968716119683916,
                "mentally": 0.31006585799204517,
                "need": 0.14595605564704403,
                "prepare": 0.28220087556694,
                "start": 0.17279434067027258,
                "stuff": 0.19541310063275463,
                "sucks": 0.31006585799204517,
                "tests": 0.19667375176114243,
                "unit": 0.20065932309537773,
                "way": 0.13634270396889558,
                "writing": 0.17279434067027258
            },
            "Max term": "confidence",
            "Max score": 0.31006585799204517
        }
    },
    {
        "ID": "4107",
        "Question": "I was browsing some old code that I wrote (first year in the university) and noticed that I used to write comment titles preceeding various parts of the code. Stuff like (this is from a Monopoly game):  /*Board initialization*/ ...code...  /*Player initialization*/ ...code...  /*Game logic starts here*/ /*Displaying current situation*/ ...code...  /*Executing move*/ ...code...  /*Handle special event*/ ...code...  /*Commit changes, switch to next player*/ ...code...  This might be redundant, and arguably unnecessary if the code is really super clear, but as I scanned through the file it surprised me how strongly I felt like I know what's going on even though I hardly looked at the actual code. I can definitely see this as being fitting in certain circumstances, so I wonder- do you do this? Do you think it's a good idea? Or is it too much?  ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "actual": 0.12070833684544144,
                    "arguably": 0.15110821561701915,
                    "certain": 0.10762890466821322,
                    "changes": 0.10064793512551179,
                    "circumstances": 0.13428812211985003,
                    "clear": 0.12444899816538232,
                    "code": 0.5289226195220447,
                    "comment": 0.12444899816538232,
                    "commit": 0.12656043933881495,
                    "current": 0.11086921289097376,
                    "definitely": 0.11086921289097376,
                    "event": 0.13752843034261056,
                    "felt": 0.14569335496164817,
                    "file": 0.10064793512551179,
                    "game": 0.2319937909106443,
                    "going": 0.0781115328048101,
                    "good": 0.06607789239729234,
                    "handle": 0.11746802862268091,
                    "hardly": 0.14126909166255144,
                    "idea": 0.08750539168910575,
                    "initialization": 0.29138670992329635,
                    "know": 0.06589612176852161,
                    "like": 0.10773040938953501,
                    "logic": 0.11329786466603917,
                    "looked": 0.13142996770808374,
                    "noticed": 0.13142996770808374,
                    "old": 0.10663830731193898,
                    "parts": 0.12444899816538232,
                    "really": 0.0704656924806993,
                    "redundant": 0.14569335496164817,
                    "situation": 0.11086921289097376,
                    "special": 0.12444899816538232,
                    "starts": 0.13752843034261056,
                    "strongly": 0.13142996770808374,
                    "stuff": 0.09523307447014083,
                    "surprised": 0.14126909166255144,
                    "switch": 0.12887326146447906,
                    "think": 0.06414959371940727,
                    "university": 0.12250666057158607,
                    "unnecessary": 0.14126909166255144,
                    "used": 0.07373725153260274,
                    "various": 0.11903413751001135,
                    "wonder": 0.12070833684544144,
                    "write": 0.07449960529063716,
                    "wrote": 0.11746802862268091,
                    "year": 0.10974034584164583
                },
                "Max term": "code",
                "Max score": 0.5289226195220447
            }
        ],
        "Best Answer": "This is a code smell. This says what and not why. If this is necessary, split the code in small functions. ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "code": 0.3790020387069358,
                "functions": 0.42647240944982645,
                "necessary": 0.37536991686922566,
                "says": 0.41559065767473835,
                "small": 0.32355479288636907,
                "smell": 0.506135224418706
            },
            "Max term": "smell",
            "Max score": 0.506135224418706
        }
    },
    {
        "ID": "4112",
        "Question": "If you were to run across code like this in your travels would the short names bother you? let setPropertyAssignment =      parser {         let! a = setIdentifierName         let! b = propertyName         let! c = openParenthesis          let! d = propertySetParameterList         let! e = closeParenthesis          let! f = openCurlyBracket          let! g = functionBody         let! h = closeCurlyBracket         return Node(NodeType.PropertyAssignment, [a;b;c;d;e;f;g;h])     }  Here is the largest parser in the project: let iterationStatement =      parser {         let! a = doKeyWord         let! b = statement         let! c = whileKeyWord         let! d = openParenthesis         let! e = expression         let! f = closeParenthesis         let! g = statementTerminator         let symbols = [a; b; c; d; e; f; g]         return Node(NodeType.IterationStatement, symbols)     } +++ parser {         let! a = whileKeyWord         let! b = openParenthesis         let! c = expression         let! d = closeParenthesis         let! e = statement         let symbols = [a; b; c; d; e]         return Node(NodeType.IterationStatement, symbols)     } +++ parser {         let! a = forKeyWord         let! b = openParenthesis         let! c = maybeOne expressionNoIn         let! d = semiColon         let! e = maybeOne expression         let! f = semiColon         let! g = maybeOne expression         let! h = closeParenthesis         let! i = statement         let symbols = [a;b] @ c @ [d] @ e @ [f] @ g @ [h;i]                       return Node(NodeType.IterationStatement, symbols)     } +++ parser {         let! a = forKeyWord         let! b = openParenthesis         let! c = varKeyWord         let! d = variableDeclarationListNoIn         let! e = semiColon         let! f = maybeOne expression         let! g = semiColon         let! h = maybeOne expression         let! i = closeParenthesis         let! j = statement         let symbols = [a;b;c;d;e] @ f @ [g] @ h @ [i;j]         return Node(NodeType.IterationStatement, symbols)     } +++ parser {         let! a = forKeyWord         let! b = openParenthesis         let! c = leftHandSideExpression         let! d = inKeyWord         let! e = expression         let! f = closeParenthesis         let! g = statement         let symbols = [a;b;c;d;e;f;g]                        return Node(NodeType.IterationStatement, symbols)     }  +++ parser {         let! a = forKeyWord         let! b = openParenthesis         let! a = varKeyWord         let! c = variableDeclarationNoIn         let! a = inKeyWord         let! c = expression         let! d = closeParenthesis         let! e = statement         let symbols = [a; b; c; d; e]         return Node(NodeType.IterationStatement, symbols)     }  ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "bother": 0.02074387746236986,
                    "code": 0.008348100663625235,
                    "expression": 0.19079790479924247,
                    "let": 0.9636206171964194,
                    "like": 0.008501662331345165,
                    "names": 0.018787416640251423,
                    "project": 0.01126231953967098,
                    "return": 0.13151191648175994,
                    "run": 0.014753855182380525,
                    "short": 0.017150307165412278,
                    "statement": 0.12716991711173922
                },
                "Max term": "let",
                "Max score": 0.9636206171964194
            }
        ],
        "Best Answer": "Depends on the complexity.  With something this size, it's pretty obvious what you're doing and why.  Make it much bigger--a page or so--and it'll get very confusing very quickly. ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "bigger": 0.35541725890557435,
                "complexity": 0.3422489194823121,
                "confusing": 0.38202454282195014,
                "depends": 0.31368263527125057,
                "make": 0.18543968867307598,
                "obvious": 0.31766092216384917,
                "page": 0.3218960455347911,
                "pretty": 0.25591205523034855,
                "quickly": 0.29384646979220475,
                "size": 0.3485033294511669
            },
            "Max term": "confusing",
            "Max score": 0.38202454282195014
        }
    },
    {
        "ID": "4142",
        "Question": "Often when stating a new project I'll require a \"quick 'n' dirty\" content management solution. Ideally something that can read my database schema and generated HTML forms. Previously I've used; phpMyEdit and phpMyAdmin but they are lacking is key areas. My wish list woulds be:  Database independent Foreign key aware Handles views as-well-as tables Generates modern HTML and CSS AJAX interface.  What's your swiss army knife when it comes to CMS on a project? ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "areas": 0.1628851860206296,
                    "army": 0.19447854273112417,
                    "aware": 0.16586182282862058,
                    "cms": 0.19447854273112417,
                    "comes": 0.14928974640704332,
                    "content": 0.18181544244499875,
                    "css": 0.17700115515173492,
                    "database": 0.2884282198119467,
                    "dirty": 0.19447854273112417,
                    "foreign": 0.18181544244499875,
                    "forms": 0.1875095357512678,
                    "generates": 0.1875095357512678,
                    "html": 0.29500925847245224,
                    "ideally": 0.17283082980847694,
                    "interface": 0.14928974640704332,
                    "key": 0.29857949281408663,
                    "list": 0.13052694908672546,
                    "management": 0.1276420334843961,
                    "modern": 0.1553534422290877,
                    "new": 0.09212987800962828,
                    "previously": 0.19447854273112417,
                    "project": 0.18367325315460578,
                    "quick": 0.16915234215887334,
                    "read": 0.1168723036770571,
                    "require": 0.13602019894789144,
                    "solution": 0.13260979061022085,
                    "tables": 0.18181544244499875,
                    "used": 0.09490095005425898,
                    "views": 0.1875095357512678,
                    "wish": 0.19447854273112417
                },
                "Max term": "key",
                "Max score": 0.29857949281408663
            }
        ],
        "Best Answer": "I think you're looking for \"scaffolding\", where the software generates views that allow users to maintain the data without you having to do much or any work.  If you must stick with PHP, then look at CakePHP. http://book.cakephp.org/view/105/Scaffolding But two quick suggestions for you. Look at this site: http://www.phpscaffold.com/ Second suggestion: Consider switching to Python/Django or Ruby on Rails.  Both of those are better than what PHP has to offer in terms of scaffolding.  There may be something in PHP somewhere that's as good, but I have not seen it.  CakePHP is the closest I know of. ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "allow": 0.14546317094445968,
                "better": 0.09474774827904558,
                "book": 0.12179720259749796,
                "closest": 0.18949369388835843,
                "com": 0.1473080107961262,
                "consider": 0.12263096811986383,
                "data": 0.1158405898251617,
                "django": 0.18270331559365627,
                "generates": 0.18270331559365627,
                "good": 0.08286342250546791,
                "http": 0.2874476193319599,
                "know": 0.082635477335541,
                "look": 0.21837151961514426,
                "looking": 0.11203180806021239,
                "maintain": 0.15606233100411113,
                "offer": 0.15606233100411113,
                "org": 0.17246428444592046,
                "php": 0.4011817626201656,
                "python": 0.12817911116329284,
                "quick": 0.16481665121209604,
                "rails": 0.16481665121209604,
                "ruby": 0.15137144289980434,
                "second": 0.14051763250142404,
                "seen": 0.12921075361632128,
                "site": 0.13626460141744104,
                "software": 0.08948268204805837,
                "stick": 0.16481665121209604,
                "suggestion": 0.17715517255022725,
                "suggestions": 0.16161047404754014,
                "switching": 0.17715517255022725,
                "terms": 0.14372380966597995,
                "think": 0.08044528502763162,
                "users": 0.12263096811986383,
                "view": 0.15606233100411113,
                "views": 0.18270331559365627,
                "work": 0.08023469222938694,
                "www": 0.16481665121209604
            },
            "Max term": "php",
            "Max score": 0.4011817626201656
        }
    },
    {
        "ID": "4180",
        "Question": " Possible Duplicate: Will high reputation in Stack Overflow help to get a good job?   Just curious, what Web2.0 websites do employers use (if any) to pre-screen potential employees? Does any employer actually refer to a user's online \"reputation\" to get a job? ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "actually": 0.1444772518135129,
                    "curious": 0.2335257020583088,
                    "duplicate": 0.2285554001055934,
                    "employees": 0.2456655383131643,
                    "employer": 0.23916056566843602,
                    "employers": 0.23916056566843602,
                    "good": 0.11490879438197264,
                    "help": 0.14260144108171943,
                    "high": 0.1763655098849248,
                    "job": 0.2915515573420592,
                    "online": 0.2335257020583088,
                    "overflow": 0.20699917529654496,
                    "possible": 0.1545379092653599,
                    "potential": 0.2130378581902127,
                    "reputation": 0.4571108002111868,
                    "screen": 0.2130378581902127,
                    "stack": 0.19930542564316697,
                    "use": 0.09897836889494804,
                    "user": 0.1588040433847387,
                    "websites": 0.2285554001055934
                },
                "Max term": "reputation",
                "Max score": 0.4571108002111868
            }
        ],
        "Best Answer": "I can tell you that there are certain employers who do care about your stack overflow reputation score, and will factor it into their hiring. How do I know? Because those employers made me implement -- and I really didn't want to -- a reputation sort on http://careers.stackoverflow.com. It is not the default sort, though, because I insisted that it not be. Anyway, we always tell employers the same thing, that they should look at the content and evaluate someone's merit based on more than a number; the number is just shorthand for a bunch of other factors. ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "based": 0.11592585226953703,
                "bunch": 0.16525154246000098,
                "care": 0.15792374591291863,
                "certain": 0.1293248418919243,
                "com": 0.14114734583442126,
                "content": 0.1697462498554156,
                "default": 0.16525154246000098,
                "employers": 0.495754627380003,
                "evaluate": 0.1697462498554156,
                "factor": 0.16135804981616692,
                "factors": 0.14504083847825533,
                "hiring": 0.1548516563869911,
                "http": 0.13771304193117298,
                "implement": 0.13186190939028858,
                "know": 0.07917952482444905,
                "look": 0.10461943051476405,
                "merit": 0.18156875379791257,
                "number": 0.22742052825851952,
                "overflow": 0.14302915244449413,
                "really": 0.08467023395772595,
                "reputation": 0.31584749182583727,
                "score": 0.18156875379791257,
                "sort": 0.2664366690715168,
                "stack": 0.13771304193117298,
                "stackoverflow": 0.14953554587366993,
                "tell": 0.2586496837838486,
                "thing": 0.10359624193818869,
                "want": 0.08574036809653934
            },
            "Max term": "employers",
            "Max score": 0.495754627380003
        }
    },
    {
        "ID": "4200",
        "Question": "Why would you hire in-house over outsourcing in developing a product for your company? I can only think of a few but I'm not entirely sure if they're good enough reason. This is actually for a debate that I'm going to have in class. I'm more inclined on the outsourcing part but unfortunately, I was asked to switch to the in-house side of the debate. Any ideas? ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "actually": 0.1395124492637976,
                    "asked": 0.16775728038381318,
                    "class": 0.16901118478781452,
                    "company": 0.1500186445630109,
                    "debate": 0.47444702220690055,
                    "developing": 0.18246809687813478,
                    "entirely": 0.21640804235496383,
                    "going": 0.1311673477301859,
                    "good": 0.11096007949314908,
                    "hire": 0.2207013440590392,
                    "house": 0.4893057469499589,
                    "ideas": 0.19478564272743756,
                    "inclined": 0.23722351110345027,
                    "product": 0.16654081160742196,
                    "reason": 0.1579302454359887,
                    "sure": 0.14922738323916807,
                    "switch": 0.21640804235496383,
                    "think": 0.10772201957897681,
                    "unfortunately": 0.22550084702784573
                },
                "Max term": "house",
                "Max score": 0.4893057469499589
            }
        ],
        "Best Answer": " An in-house team will be more responsive to your needs, since they're actually part of your company, so they have a better idea of what you want. An in-house team is easier to communicate with- nothing beats regular face-to-face contact. Your in-house team will have more domain-specific knowledge that an external team would have to learn. You're investing not just in the software, but in the expertise solving the types of software problems your company has.  Using your own developers builds up a stock of programmers who've dealt with those specific problems before.  (For counter-arguments, see Joel's take on it.) ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "actually": 0.09119540263606284,
                "arguments": 0.13892120204626632,
                "better": 0.08293403042146955,
                "builds": 0.15096040246497586,
                "communicate": 0.15992276976252667,
                "company": 0.1961260198073276,
                "contact": 0.13892120204626632,
                "counter": 0.15992276976252667,
                "developers": 0.09463712195384417,
                "domain": 0.1366035430100332,
                "easier": 0.10734060307917954,
                "external": 0.15506640248938305,
                "face": 0.294807246923074,
                "house": 0.47976830928758,
                "idea": 0.09605176990920644,
                "joel": 0.1258034625585294,
                "knowledge": 0.10387647208501377,
                "learn": 0.09001137322791933,
                "needs": 0.11927431315877297,
                "problems": 0.20047721693099815,
                "programmers": 0.08887774359982971,
                "regular": 0.13447150337174257,
                "responsive": 0.16586648294088685,
                "software": 0.15665088848997213,
                "solving": 0.1366035430100332,
                "specific": 0.21618194065583193,
                "stock": 0.16586648294088685,
                "team": 0.3965144121214606,
                "types": 0.12169746253412222,
                "using": 0.0778321657808918,
                "want": 0.07832544424498607
            },
            "Max term": "house",
            "Max score": 0.47976830928758
        }
    },
    {
        "ID": "4250",
        "Question": "I'm sure many of us have seen method names like this at one point or another:  UploadTheFileToTheServerPlease CreateATemporaryFile WriteTheRecordToTheDatabase ResetTheSystemClock  That is, method names that are also grammatically-correct English sentences, and include extra words purely to make them read like prose. Personally, I'm not a huge fan of such \"literal\" method names, and prefer to be succint, while still being as clear as possible. To me, words like \"a\", \"an\", and \"the\" just look plain awkward in method names, and it makes method names needlessly long without really adding anything useful. I would prefer the following method names for the previous examples:  UploadFileToServer CreateTemporaryFile WriteOutRecord ResetSystemClock  In my experience, this is far more common than the other approach of writing out the lengthier names, but I have seen both styles and was curious to see what other people's thoughts were on these two approaches. So, are you in the \"method names that read like prose\" camp or the \"method names that say what I mean but read out loud like a bad foreign-language-to-English translation\" camp? ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "adding": 0.08020983968918785,
                    "approach": 0.06449900848463948,
                    "approaches": 0.0786495182380911,
                    "awkward": 0.08621451707618048,
                    "bad": 0.05452151404918245,
                    "clear": 0.07594945328219382,
                    "common": 0.05604960620218348,
                    "correct": 0.06766190350288341,
                    "curious": 0.08195413066918647,
                    "english": 0.1604196793783757,
                    "examples": 0.06766190350288341,
                    "experience": 0.05287433395243763,
                    "extra": 0.0786495182380911,
                    "fan": 0.09221919446317313,
                    "far": 0.062379777057111806,
                    "following": 0.06631466999617014,
                    "foreign": 0.08621451707618048,
                    "huge": 0.06766190350288341,
                    "include": 0.06994477589520119,
                    "language": 0.04340997092023525,
                    "like": 0.16436584093929033,
                    "long": 0.05115893928722649,
                    "look": 0.053136453301902725,
                    "make": 0.041849649469138495,
                    "makes": 0.05186992493568483,
                    "mean": 0.06142400308121315,
                    "method": 0.5159920678771158,
                    "names": 0.6538035676598861,
                    "people": 0.0412451019939404,
                    "personally": 0.06838445444410444,
                    "plain": 0.09221919446317313,
                    "point": 0.05287433395243763,
                    "possible": 0.054233944690652805,
                    "prefer": 0.1339459440018268,
                    "previous": 0.0669729720009134,
                    "purely": 0.08891458203207776,
                    "read": 0.16625797708266155,
                    "really": 0.043004209740187475,
                    "say": 0.04804061052780354,
                    "seen": 0.12576367445237424,
                    "styles": 0.08621451707618048,
                    "sure": 0.054233944690652805,
                    "thoughts": 0.07168906687519981,
                    "useful": 0.05967971210121453,
                    "words": 0.15189890656438765,
                    "writing": 0.051392162321904106
                },
                "Max term": "names",
                "Max score": 0.6538035676598861
            }
        ],
        "Best Answer": "I'll agree that prose methods suck with one exception: Unit Test Cases These are generally never called in your code and show up in test reports.  As such, it's handy to have readouts with a bit more prose:  AddingACustomerOrderFailWhenCustomersIdIsInvalid : Failed OutOfBoundsPriceReturnsAnError : Passed CanDeleteAnEventFromASeason : Passed  Even this should be done sparingly, but I can see it as at least one case where grammatical additions can make it a little easier to express what passed and what failed.  This is, of course, unless your language/framework provides a good mechanism for test-descriptions in the test readout other than method names, in which case ignore this one too. ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "agree": 0.13578409340903172,
                "bit": 0.1154782029072534,
                "called": 0.13759439599041795,
                "case": 0.22765545911774207,
                "cases": 0.12110700678438818,
                "code": 0.06113942595054674,
                "course": 0.12326576048650545,
                "easier": 0.11303753774173879,
                "exception": 0.15192303149433045,
                "express": 0.1632963093279769,
                "failed": 0.3104536805706551,
                "framework": 0.1146408286492239,
                "generally": 0.12008689602013417,
                "good": 0.07638101037998946,
                "handy": 0.17466958716162337,
                "ignore": 0.15192303149433045,
                "language": 0.08222151303179652,
                "little": 0.110792343433464,
                "make": 0.07926615536153048,
                "mechanism": 0.17466958716162337,
                "method": 0.12216562126711047,
                "methods": 0.12110700678438818,
                "names": 0.13759439599041795,
                "passed": 0.5240087614848701,
                "provides": 0.15192303149433045,
                "suck": 0.17466958716162337,
                "test": 0.3948356089513052,
                "unit": 0.11303753774173879,
                "unless": 0.12952492694776857
            },
            "Max term": "passed",
            "Max score": 0.5240087614848701
        }
    },
    {
        "ID": "4267",
        "Question": " Basically I am looking for what is it that you goof up and you are out from the remaining process ? Are elimination rounds a fair way to judge a person ? Anyone can have a bad hour :-(  Should you code the best possible or should you get the Algorithm right ? I generally first code a workable solution and then work on it till a level I think it looks beautiful to me. Is this a wrong approach ?  Recently I had a telephonic interview in which I was asked to write a variation of Level Order traversal in 20 minutes. I could get the Algorithm and working code in 20 minutes but couldn't get the Exception handling and the coding convention right, after which I didn't hear back from them :-( All the other questions in the interview went very well this was the only thing which was 'not upto the mark'. Needless to say I like the company and will apply again but want to get it right the next time :-) Please share your experiences and valuable suggestions. ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "20": 0.25347957377644836,
                    "algorithm": 0.24629454676265183,
                    "apply": 0.1309336409583086,
                    "approach": 0.10933848760110887,
                    "asked": 0.10335323412440502,
                    "bad": 0.09242467485806252,
                    "basically": 0.12314727338132592,
                    "beautiful": 0.15632964734329535,
                    "best": 0.08241018933189193,
                    "code": 0.16415974388448876,
                    "coding": 0.08876661361631188,
                    "company": 0.09242467485806252,
                    "convention": 0.12673978688822418,
                    "exception": 0.13597143224971883,
                    "experiences": 0.12673978688822418,
                    "fair": 0.1507276802152295,
                    "generally": 0.10747802413941467,
                    "handling": 0.15632964734329535,
                    "hear": 0.1422806227136453,
                    "hour": 0.14615053979650708,
                    "interview": 0.24629454676265183,
                    "judge": 0.15632964734329535,
                    "level": 0.19113373309484472,
                    "like": 0.05572647668178145,
                    "looking": 0.09242467485806252,
                    "looks": 0.1185701329626035,
                    "mark": 0.15632964734329535,
                    "minutes": 0.24975864685305998,
                    "needless": 0.15632964734329535,
                    "order": 0.1215270487690647,
                    "person": 0.10659706469019278,
                    "possible": 0.09193718831399354,
                    "process": 0.09556686654742236,
                    "questions": 0.10048098877994645,
                    "recently": 0.12314727338132592,
                    "right": 0.26889714321665703,
                    "say": 0.08143827047814049,
                    "share": 0.1215270487690647,
                    "solution": 0.10659706469019278,
                    "suggestions": 0.13332638092811416,
                    "thing": 0.08919576540307747,
                    "think": 0.06636623510125757,
                    "till": 0.1507276802152295,
                    "time": 0.061615358569173904,
                    "valuable": 0.1422806227136453,
                    "variation": 0.15632964734329535,
                    "want": 0.07382196125295225,
                    "way": 0.06874154725489186,
                    "went": 0.1200050816919661,
                    "work": 0.06619249898789631,
                    "working": 0.08342125623371824,
                    "write": 0.07707388360549389,
                    "wrong": 0.10116883367548819
                },
                "Max term": "right",
                "Max score": 0.26889714321665703
            }
        ],
        "Best Answer": "When doing technical interviews, I'm honestly looking for people to hit a home run. If the candidate doesn't look like they know their stuff, they're not going to be effective in their role (I'm talking senior developers positions here). Look at it this way: Would you rather have a tough interview where you don't get the job (because you're not a good fit), or an easy interview where you do get the job, but then get let go after 90 days because you're in over your head? I've seen far too many developers in the latter camp. If you didn't get the job because you flubbed the technical part, consider it a blessing in disguise. If you don't like rejection, bone up on your technical skills. ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "90": 0.16253448860526068,
                "candidate": 0.16575899722012724,
                "consider": 0.12333211574310998,
                "days": 0.1310234746356939,
                "developers": 0.21747216139258418,
                "easy": 0.12167741407731618,
                "effective": 0.15961756575285532,
                "far": 0.128911980523454,
                "fit": 0.16253448860526068,
                "going": 0.0985139810565139,
                "good": 0.08333719754479535,
                "head": 0.1522369153742025,
                "hit": 0.16575899722012724,
                "home": 0.15450495471653097,
                "honestly": 0.16575899722012724,
                "interview": 0.30025084252392525,
                "interviews": 0.16253448860526068,
                "job": 0.3171701068580666,
                "know": 0.08310794908894828,
                "let": 0.12419427207273984,
                "like": 0.13586920047173362,
                "look": 0.21962006779437054,
                "looking": 0.11267235454821377,
                "people": 0.08523576126382675,
                "positions": 0.1837479293437693,
                "role": 0.16575899722012724,
                "run": 0.11789426757840962,
                "seen": 0.1299495214348007,
                "senior": 0.15961756575285532,
                "skills": 0.13213648913832057,
                "stuff": 0.12010760712824345,
                "talking": 0.14132104786675206,
                "technical": 0.3650322422319485,
                "tough": 0.16936369116821473,
                "way": 0.08380091135176247
            },
            "Max term": "technical",
            "Max score": 0.3650322422319485
        }
    },
    {
        "ID": "4272",
        "Question": "From time to time I have tried some monitors. My main work is coding (work, phd, etc). At work I have an LG Flatron L246WH which I highly recommend. However at home I have an LG W2363V with which I feel pretty uncomfortable when coding. Fonts, subpixels or whatever mess with my minds when using smooth fonts. Currently, what are the best monitors out there, to best fit our needs? ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "best": 0.24140754150980442,
                    "coding": 0.2600276754002287,
                    "currently": 0.16979204383071905,
                    "feel": 0.13760087221333706,
                    "fit": 0.19527921303901227,
                    "fonts": 0.4579428361492064,
                    "highly": 0.1885752106299235,
                    "home": 0.1856320232498387,
                    "main": 0.17366617239353702,
                    "mess": 0.21406237983821672,
                    "monitors": 0.441532764494611,
                    "needs": 0.16465296749296668,
                    "pretty": 0.14339692200725795,
                    "recommend": 0.17799707965801673,
                    "time": 0.18049239240945517,
                    "tried": 0.17167810917148868,
                    "using": 0.10744389737268227,
                    "work": 0.2908505958414491
                },
                "Max term": "fonts",
                "Max score": 0.4579428361492064
            }
        ],
        "Best Answer": "The main thing you want to know is the type of panel -- is it TN, VA, or IPS? http://www.codinghorror.com/blog/2007/11/not-all-lcd-panels-are-created-equal.html They all have strengths and weaknesses, but the TN has a lot of weaknesses and only one primary strength -- it's cheap. Apple, for example, has NEVER to my knowledge ever shipped a TN LCD. I strongly advise avoiding TN panels if you want to invest in an LCD you won't mind keeping for a few years. ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "11": 0.23045732089345586,
                "apple": 0.22345903420354143,
                "avoiding": 0.22345903420354143,
                "blog": 0.19378067581986513,
                "cheap": 0.22345903420354143,
                "com": 0.18581058260443659,
                "created": 0.18828784904185655,
                "equal": 0.22345903420354143,
                "example": 0.12754816626738422,
                "html": 0.18128956235194216,
                "http": 0.18128956235194216,
                "invest": 0.2390225315715727,
                "keeping": 0.19685305971997338,
                "know": 0.10423429183877331,
                "knowledge": 0.14969158860945123,
                "lot": 0.12262034409655236,
                "main": 0.18128956235194216,
                "mind": 0.1616818745582885,
                "primary": 0.19093609263255695,
                "strength": 0.2390225315715727,
                "strengths": 0.2390225315715727,
                "strongly": 0.20789553683551018,
                "thing": 0.13637718765711804,
                "type": 0.1671747013362971,
                "want": 0.225742363833407,
                "www": 0.20789553683551018,
                "years": 0.14056872685272906
            },
            "Max term": "invest",
            "Max score": 0.2390225315715727
        }
    },
    {
        "ID": "4274",
        "Question": "I'm an ASP.Net/C# programmer using SQL Server as a back end. I am the Technical Director of the company, I'm extremely happy in everything I do and consider the languages and system we use to be perfect for what we do. In the back of my mind though I know that over time programmers can become stale. I remember as a wee youngster that all those \"old\" developers were past it and couldn't keep up with the youngsters. So considering I'm happy in everything I'm doing. What options are there for keeping up with everything and avoiding becoming stale. One particular idea that I use is to let all the new developers use and showcase the things that they think are cool. If anything catches my eye then absolutely it will be something we all use going forward. Thoughts? ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "absolutely": 0.15622187442402552,
                    "asp": 0.15887238429322803,
                    "avoiding": 0.17733627930355034,
                    "catches": 0.18968741438311618,
                    "company": 0.11214633882290265,
                    "consider": 0.1227563344649349,
                    "considering": 0.15887238429322803,
                    "cool": 0.17733627930355034,
                    "developers": 0.21645688326896118,
                    "end": 0.10570951575913347,
                    "extremely": 0.15622187442402552,
                    "forward": 0.18968741438311618,
                    "going": 0.09805406430580331,
                    "happy": 0.31774476858645606,
                    "idea": 0.10984625439663256,
                    "keeping": 0.15622187442402552,
                    "know": 0.08271995606000669,
                    "languages": 0.10383436093953151,
                    "let": 0.12361446578071925,
                    "mind": 0.12831014940695487,
                    "net": 0.11595901432738909,
                    "new": 0.08986018766728181,
                    "old": 0.13386396434897485,
                    "options": 0.15887238429322803,
                    "particular": 0.12361446578071925,
                    "past": 0.1406612844865207,
                    "perfect": 0.16857300950359136,
                    "programmer": 0.09805406430580331,
                    "programmers": 0.1016419295854101,
                    "remember": 0.1326692368215353,
                    "server": 0.13510746954450076,
                    "sql": 0.1406612844865207,
                    "stale": 0.36578018849114063,
                    "technical": 0.12110935784492004,
                    "things": 0.09014892582162863,
                    "think": 0.08052752470588531,
                    "thoughts": 0.14745860462406654,
                    "time": 0.07476290167538997,
                    "use": 0.2857943493725066,
                    "using": 0.08901004000957254
                },
                "Max term": "stale",
                "Max score": 0.36578018849114063
            }
        ],
        "Best Answer": "Learning many languages gives you different insights - different tools - into problems. I think it's very important to learn several very different languages. Maybe a functional language (Scheme, Haskell), a object-oriented one (Smalltalk, Ruby), a concurrency-oriented one (Erlang), a logic programming one (Prolog) and and and. The important thing here is that the languages shouldn't be more of the same. If you know C#, learning Java isn't going to teach you that much. If you know C, learning Pascal isn't going to expand your intellectual horizons. ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "concurrency": 0.1588723504805293,
                "different": 0.3062038554935907,
                "erlang": 0.16857297362631535,
                "expand": 0.18289005532119915,
                "functional": 0.1283101220987953,
                "gives": 0.15378360897139493,
                "going": 0.1961080868740504,
                "haskell": 0.156221841175433,
                "important": 0.24221866413859983,
                "java": 0.11528947608785402,
                "know": 0.1654398769095523,
                "language": 0.0892907755021468,
                "languages": 0.3115030165216107,
                "learn": 0.10293834363697166,
                "learning": 0.34993064912702343,
                "logic": 0.14222373245506068,
                "maybe": 0.12731129029643048,
                "object": 0.13640387647361477,
                "oriented": 0.28444746491012135,
                "pascal": 0.1896873740120761,
                "problems": 0.11463436179099294,
                "programming": 0.08052750756726841,
                "prolog": 0.17733624156119374,
                "ruby": 0.15152615854857643,
                "scheme": 0.17733624156119374,
                "smalltalk": 0.1896873740120761,
                "teach": 0.17733624156119374,
                "thing": 0.10822841860029686,
                "think": 0.08052750756726841,
                "tools": 0.1254068176438862
            },
            "Max term": "learning",
            "Max score": 0.34993064912702343
        }
    },
    {
        "ID": "4296",
        "Question": "Has anybody's organization started the migration from Java to Scala? If yes, how do you do that? What can I do to encourage my colleagues to do the same? ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "anybody": 0.3973900586676734,
                    "colleagues": 0.4209827068589848,
                    "encourage": 0.37976847731115027,
                    "java": 0.26537733629409216,
                    "organization": 0.34878819558391483,
                    "scala": 0.40819874468033296,
                    "started": 0.2845400273096254,
                    "yes": 0.2845400273096254
                },
                "Max term": "colleagues",
                "Max score": 0.4209827068589848
            }
        ],
        "Best Answer": "Probably the easiest way is to first use Scala only for testing. In this case, you might even not have to tell your boss :-) If he asks, tell him \"that's just my private test case, it's so much easier and faster to use Scala for it\". Once you (and your organization) has enough experience with Scala you can start using it for the 'real' code. ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "asks": 0.22677135045310812,
                "boss": 0.16816060012844122,
                "case": 0.29556224836315065,
                "code": 0.07937655555288044,
                "easier": 0.1467552279829299,
                "easiest": 0.21864515256029432,
                "experience": 0.1300204820102951,
                "faster": 0.17002854324538422,
                "organization": 0.18114959829031568,
                "private": 0.18384838139925838,
                "probably": 0.12876460215326918,
                "real": 0.13704543682500803,
                "scala": 0.6360166963018367,
                "start": 0.12637575203606402,
                "tell": 0.32304202600418497,
                "test": 0.12815253889335212,
                "testing": 0.13336382896740528,
                "use": 0.17083360741101272,
                "using": 0.10641152467863774,
                "way": 0.09971629673670174
            },
            "Max term": "scala",
            "Max score": 0.6360166963018367
        }
    },
    {
        "ID": "4325",
        "Question": "I have never had the opportunity to work from home on certain days, but I would definitely like to try it if I can.  What are the pros and cons? I'll list a few that I can think of. Pros:  You don't need to do any work.  (That's a JOKE) You can be a lot more productive.  No commute, relaxed, no meetings, no interruptions  Cons:  Less of a team effort. Other team members can get held up due to having to wait for information for an off-site member  Apologies if this has been asked before - I did a search but couldn't find a pros and cons discussion. Edit: It appears The Oatmeal has already covered this! :-) ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "asked": 0.11211776992468127,
                    "certain": 0.12079044222766354,
                    "cons": 0.475633086881898,
                    "covered": 0.1507097160078202,
                    "days": 0.11659234937841965,
                    "definitely": 0.12442699566456546,
                    "discussion": 0.13966740226081475,
                    "edit": 0.11295579594151775,
                    "effort": 0.1335903784800775,
                    "held": 0.15854436229396598,
                    "home": 0.1374875434428391,
                    "information": 0.11295579594151775,
                    "interruptions": 0.1635096522602342,
                    "joke": 0.16958667604097147,
                    "like": 0.06045217979149578,
                    "list": 0.11382043035971558,
                    "lot": 0.08699923155197485,
                    "meetings": 0.1374875434428391,
                    "member": 0.1507097160078202,
                    "members": 0.1354693094115709,
                    "need": 0.07982885470050136,
                    "opportunity": 0.142037043704838,
                    "productive": 0.13966740226081475,
                    "pros": 0.49052895678070263,
                    "relaxed": 0.16958667604097147,
                    "search": 0.1374875434428391,
                    "site": 0.12194949785530228,
                    "team": 0.20270388556434069,
                    "think": 0.0719942084143556,
                    "try": 0.09723336443211916,
                    "wait": 0.1507097160078202,
                    "work": 0.14361147834680554
                },
                "Max term": "pros",
                "Max score": 0.49052895678070263
            }
        ],
        "Best Answer": "Pro:  No commute. Unless you have annoying neighbours, your environment's as quiet as you like. If you have kids, you have the option of seeing them during the day. You decide when best to work: maybe you're a night owl. Maybe you want to time-shift your work day into the evening so you can spend more time with your children.  Con:  If you're the only person not colocated, you're left out. (\"Why's Foo not answering my mail?\" \"Dude, he resigned a WEEK ago. Didn't you hear? Oh. Noone thought to mail you!\") You have to bring your own discipline to the party. It's tough to explain to your children just why you aren't available to play Lego. Cabin fever, if you're prone to it. (I'm not.) Some people just need to get out their domestic environments. Unless you're disciplined with your time, you can easily start working outside your required hours.  ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "ago": 0.1306838949108682,
                "annoying": 0.1481996404629131,
                "answering": 0.16822978811842426,
                "available": 0.12476586993814948,
                "best": 0.09486005805662268,
                "bring": 0.1599165257252949,
                "day": 0.22827916365850248,
                "decide": 0.14175137318786182,
                "discipline": 0.17994667338080608,
                "easily": 0.13492035336764502,
                "environment": 0.11810433678965776,
                "environments": 0.1599165257252949,
                "explain": 0.11645260754502011,
                "foo": 0.16377523508158856,
                "hear": 0.16377523508158856,
                "hours": 0.12816949280740195,
                "left": 0.15651290285604244,
                "like": 0.06414518466928343,
                "maybe": 0.24154737016078137,
                "need": 0.08470557462712715,
                "night": 0.17994667338080608,
                "oh": 0.17349840610575482,
                "option": 0.15651290285604244,
                "outside": 0.13813448444516893,
                "party": 0.1481996404629131,
                "people": 0.0804812809336076,
                "person": 0.12270089205175608,
                "play": 0.15071404256637935,
                "prone": 0.16822978811842426,
                "quiet": 0.17349840610575482,
                "required": 0.1320282021636956,
                "seeing": 0.1481996404629131,
                "shift": 0.17349840610575482,
                "spend": 0.12585646709163306,
                "start": 0.1002811692458026,
                "thought": 0.12476586993814948,
                "time": 0.21277113443505585,
                "tough": 0.1599165257252949,
                "unless": 0.26687622158946495,
                "want": 0.08497438953945957,
                "week": 0.13813448444516893,
                "work": 0.152384658931365,
                "working": 0.09602386881575241
            },
            "Max term": "unless",
            "Max score": 0.26687622158946495
        }
    },
    {
        "ID": "4391",
        "Question": "I've programmed a bit of Haskell and Prolog as part of a couple of uni courses, but that's about it. And I've never seen it been used in industry (not that I've had much of working experience to begin with but I've never seen an ad where you are required to know them). So should we be using functional and/or logic programming languages more often? Are there any advantages or disadvantages for using or not using them? ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "ad": 0.23908341296252444,
                    "advantages": 0.20732992741299358,
                    "begin": 0.23908341296252444,
                    "bit": 0.1690725466329626,
                    "couple": 0.19174498715137858,
                    "courses": 0.25573511863933707,
                    "disadvantages": 0.23908341296252444,
                    "experience": 0.1466270025997937,
                    "functional": 0.1729867602862921,
                    "haskell": 0.21061713408775218,
                    "industry": 0.18763474372554043,
                    "know": 0.11152241093929681,
                    "languages": 0.1399886898140691,
                    "logic": 0.19174498715137858,
                    "programmed": 0.25573511863933707,
                    "programming": 0.10856659178662276,
                    "prolog": 0.23908341296252444,
                    "required": 0.18763474372554043,
                    "seen": 0.34875806922647284,
                    "used": 0.12479271687399196,
                    "using": 0.36000796177175803,
                    "working": 0.13646640430988877
                },
                "Max term": "using",
                "Max score": 0.36000796177175803
            }
        ],
        "Best Answer": "I believe in using the right tool for the job. Both imperative and functional languages have their place and there's no need to push for using one kind more than the other. For the advantages/disadvantages, I don't think I could beat Eric Lippert's answer to the \"Why hasn't functional programming taken over yet?\" SO question. ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "advantages": 0.23044531643675858,
                "answer": 0.16805167475162996,
                "beat": 0.2842472433873077,
                "believe": 0.20245900817380355,
                "disadvantages": 0.2657390249560097,
                "eric": 0.27406143576373976,
                "functional": 0.38454640110047106,
                "imperative": 0.25260723499620463,
                "job": 0.15768720982289536,
                "kind": 0.19077644733770122,
                "languages": 0.1555961472822502,
                "need": 0.13380256292010434,
                "place": 0.19708257970231055,
                "programming": 0.1206707729602993,
                "push": 0.23409901656490661,
                "question": 0.14582095906808412,
                "right": 0.16297457117696004,
                "taken": 0.23409901656490661,
                "think": 0.1206707729602993,
                "tool": 0.19880530804565552,
                "using": 0.26676370268207905
            },
            "Max term": "functional",
            "Max score": 0.38454640110047106
        }
    },
    {
        "ID": "4399",
        "Question": "How much should programmers help testers in designing tests?   I don't think they should help at all.  My worry is that if they help testers in designing tests for their own code, they'll 'infect' the testers with their own prejudices and blind spots about that code.   I feel that the requirements should be sufficient for giving the information needed for testers to create their tests.  If there is some part of the implementation that the programmers find worrisome, then I think it's their duty to implement unit tests to test that part or even run their own informal system tests to test that part. Not everyone I know agrees with this though (and I understand some of their points to a certain extent).  What do others think about this?  Is this discussed in the literature anywhere? ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "certain": 0.11026529380956283,
                    "code": 0.1083757346112739,
                    "create": 0.09950400185647604,
                    "designing": 0.2692987362342502,
                    "extent": 0.13203003489985535,
                    "feel": 0.09303318913389921,
                    "giving": 0.12749739848522643,
                    "help": 0.2520333441087887,
                    "implement": 0.11242845510966026,
                    "implementation": 0.12550748298699171,
                    "information": 0.10311332417766411,
                    "know": 0.06751025897843871,
                    "literature": 0.15480963820465496,
                    "needed": 0.1073371283976966,
                    "points": 0.11242845510966026,
                    "programmers": 0.16590610818026857,
                    "requirements": 0.10311332417766411,
                    "run": 0.0957678853050915,
                    "sufficient": 0.15480963820465496,
                    "test": 0.17497138100952644,
                    "testers": 0.5281201395994214,
                    "tests": 0.490976216337816,
                    "think": 0.19716284824341207,
                    "understand": 0.08474236365410232,
                    "unit": 0.1001851587657979,
                    "worry": 0.1346493681171251
                },
                "Max term": "testers",
                "Max score": 0.5281201395994214
            }
        ],
        "Best Answer": "I agree. Programmers can help the testers to understand the functional specs, to find resources for research but should not pollute the testers' minds with their own ideas about how to approach testing. ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "agree": 0.2813254136246367,
                "approach": 0.2531098678116192,
                "functional": 0.2447934859154308,
                "help": 0.1963885277410346,
                "ideas": 0.2778021813744939,
                "programmers": 0.19391515303648021,
                "research": 0.30310092339996286,
                "resources": 0.2933924861187294,
                "testers": 0.6172798507261283,
                "testing": 0.21282724950450885,
                "understand": 0.19809793137697973
            },
            "Max term": "testers",
            "Max score": 0.6172798507261283
        }
    },
    {
        "ID": "4418",
        "Question": "While hacking on some static analysis tool, I realized I could make the task at hand (irrelevant for this question) much easier by saving the source files on-the-fly, while they were being edited. This seemed weird at first, but being a lazy cat I actually did it, and it turns out I find this pretty useful :     no need to check if all files were saved before running a compiler/interpreter forces you to make granular commits much more regularly  My editor has been behaving this way for a couple of days, I never had such a clean commit history, and didn't get burned yet.  In the days of DVCS when by saving we actually mean commit, do you think that manually saving files is still a relevant practice ? ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "actually": 0.17297510947690145,
                    "analysis": 0.13174956981391261,
                    "check": 0.10640494295046425,
                    "clean": 0.13979409689819483,
                    "commit": 0.26349913962782523,
                    "compiler": 0.12955155700880208,
                    "couple": 0.11794321360266953,
                    "days": 0.21629557295097346,
                    "easier": 0.10179927952637476,
                    "edited": 0.15166695802592617,
                    "editor": 0.13415722043289158,
                    "files": 0.33612545824730256,
                    "forces": 0.14706129460183667,
                    "granular": 0.15730383449122942,
                    "hacking": 0.15166695802592617,
                    "hand": 0.11204181941576753,
                    "history": 0.1275295812338052,
                    "irrelevant": 0.14316726166155588,
                    "make": 0.14277093552879022,
                    "mean": 0.10477462171212568,
                    "need": 0.07404700204394744,
                    "practice": 0.11423983222087805,
                    "pretty": 0.09851397993539955,
                    "question": 0.08069804208916553,
                    "realized": 0.14706129460183667,
                    "regularly": 0.14706129460183667,
                    "relevant": 0.11794321360266953,
                    "running": 0.11541498417912857,
                    "saved": 0.15166695802592617,
                    "saving": 0.4719115034736882,
                    "source": 0.09350086878151917,
                    "static": 0.13415722043289158,
                    "task": 0.1039972923314853,
                    "think": 0.06677980434030562,
                    "tool": 0.11001984364077065,
                    "turns": 0.13681875471244392,
                    "useful": 0.10179927952637476,
                    "way": 0.06916991853956418,
                    "weird": 0.14706129460183667
                },
                "Max term": "saving",
                "Max score": 0.4719115034736882
            }
        ],
        "Best Answer": "I often use the opportunity to keep editing the file while the build is in progress.  If they were auto-saved, the build would break while I'm editing (a broken code would be complied), and I'd just have to wait while the code is compiling.  This is unproductive and boring. ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "auto": 0.2683801274431334,
                "boring": 0.2509050660770364,
                "break": 0.21438754136396246,
                "broken": 0.2509050660770364,
                "build": 0.3548649231588949,
                "code": 0.1878816707023498,
                "compiling": 0.2683801274431334,
                "editing": 0.5018101321540728,
                "file": 0.17875868327592612,
                "opportunity": 0.22478133766794692,
                "progress": 0.23343000471093936,
                "saved": 0.25876290718253236,
                "use": 0.10108936873403318,
                "wait": 0.23850631272073097
            },
            "Max term": "editing",
            "Max score": 0.5018101321540728
        }
    },
    {
        "ID": "4442",
        "Question": "I have had the question posed at my work that, since we are planning to eventually move to Sharepoint 2010 for most of our Development, and since Sharepoint 2010 supports asp.net web parts, should we start moving all of our new development to be exclusively asp.net web parts? It was also asked how prism factors into all of this.  (not sure what that is) We are now a mostly client/server based location but are moving to an SOA framework (slowly though). Is this a good idea?  Is it better to have some apps in WPF and Winforms hitting the services or should we just go to web parts solely?  What are we going to miss out on if we make this move? ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "2010": 0.3037932793650982,
                    "apps": 0.13757049332493382,
                    "asked": 0.11545814222938253,
                    "asp": 0.2925376272633854,
                    "based": 0.11150158141377925,
                    "better": 0.08732045260739296,
                    "client": 0.12108596828023897,
                    "development": 0.17654244878840492,
                    "eventually": 0.14382857245439787,
                    "factors": 0.13950540404313028,
                    "framework": 0.1146209134385912,
                    "going": 0.0902752968779288,
                    "good": 0.0763677416002015,
                    "idea": 0.10113199587176722,
                    "location": 0.14894179541201327,
                    "make": 0.07925238537924172,
                    "miss": 0.168381164727244,
                    "moving": 0.3037932793650982,
                    "net": 0.21351964384524733,
                    "new": 0.0827314520474206,
                    "parts": 0.4314857173631936,
                    "planning": 0.13094095072900996,
                    "question": 0.08959123658205825,
                    "server": 0.1243892031391672,
                    "services": 0.14382857245439787,
                    "slowly": 0.15519987454147735,
                    "start": 0.09732343055374065,
                    "supports": 0.158944773358361,
                    "sure": 0.10270502954701516,
                    "web": 0.3097488340545352,
                    "work": 0.07394507803658716,
                    "wpf": 0.16326794176962858
                },
                "Max term": "parts",
                "Max score": 0.4314857173631936
            }
        ],
        "Best Answer": "If you write the web parts and your service-architecture well, you'll end up with a very good solution that will have many of the upsides of a desktop application with all the benefits of integrating with your SharePoint.  Instead of using the traditional MVC I'd recommend a service-oriented approach with most of the work being done in Services and front end jQuery (or extjs if that's your thing). The problem is going to be integrating with your existing client/server architecture as a stopgap during SOA coding and deployment.  You lose very little, especially because your Winforms applications are going to require access to the service layer anyway to be functional (I'm making an assumption here, but from your description it sounds like it), so you can guarantee access to SharePoint (again, making some assumptions about your network configuration). All in all, having a one-stop shop in Sharepoint with all your functionality seamlessly integrated and in one place seems like a best-case scenario to the end users.  It is, admittedly, a little more difficult to code your front end in JS, especially if you're new to this kind of development.  The effort to learn and do it right pays off in spades, at least IME. Disclaimer:  That's all based on a lot of assumptions about your app and your environment based on your post and my knowledge of people in similar situations.  Your situation may be radically different in ways I just don't know about.  Good luck! ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "access": 0.1652879286588189,
                "admittedly": 0.11238074103408287,
                "app": 0.07833639750155391,
                "application": 0.06892176669049847,
                "applications": 0.08407454585708045,
                "approach": 0.08407454585708045,
                "architecture": 0.19800043265206752,
                "assumptions": 0.240415692456529,
                "based": 0.1534977437693602,
                "benefits": 0.09900021632603376,
                "best": 0.06336834717663099,
                "case": 0.07833639750155391,
                "client": 0.08334600593767051,
                "code": 0.04207623566629939,
                "coding": 0.06825604497374324,
                "configuration": 0.10682732152021539,
                "deployment": 0.10682732152021539,
                "description": 0.10940501374550766,
                "desktop": 0.10251975469235985,
                "development": 0.06075893100559451,
                "different": 0.06468205236357649,
                "difficult": 0.08729936068733093,
                "disclaimer": 0.1202078462282645,
                "effort": 0.09469264949817822,
                "end": 0.2679590157641848,
                "environment": 0.07889597339573083,
                "especially": 0.17639476768655388,
                "existing": 0.0864412631229509,
                "functional": 0.08131212479012911,
                "functionality": 0.08819738384327694,
                "going": 0.12427675207087957,
                "good": 0.10513102938774832,
                "instead": 0.07779258642380302,
                "integrated": 0.11590027940040896,
                "integrating": 0.240415692456529,
                "jquery": 0.10251975469235985,
                "js": 0.11590027940040896,
                "kind": 0.08067914950470541,
                "know": 0.05242091464216377,
                "knowledge": 0.07528203867191241,
                "layer": 0.09900021632603376,
                "learn": 0.06523363322072016,
                "like": 0.08570043947065614,
                "little": 0.15249488132579764,
                "lose": 0.10251975469235985,
                "lot": 0.06166752301843785,
                "making": 0.16135829900941082,
                "mvc": 0.11590027940040896,
                "network": 0.11238074103408287,
                "new": 0.05694578976829084,
                "oriented": 0.09012939659272921,
                "parts": 0.09900021632603376,
                "people": 0.05376304691250147,
                "place": 0.08334600593767051,
                "post": 0.09012939659272921,
                "problem": 0.0626210015892547,
                "radically": 0.1202078462282645,
                "recommend": 0.09344679681216628,
                "require": 0.08407454585708045,
                "right": 0.06892176669049847,
                "scenario": 0.10682732152021539,
                "server": 0.08561969161798466,
                "service": 0.3136609075197037,
                "services": 0.09900021632603376,
                "shop": 0.11590027940040896,
                "similar": 0.07833639750155391,
                "situation": 0.08819738384327694,
                "situations": 0.09900021632603376,
                "solution": 0.08196656090782524,
                "sounds": 0.09227649810377994,
                "stop": 0.09900021632603376,
                "thing": 0.06858603619977613,
                "traditional": 0.11590027940040896,
                "users": 0.07779258642380302,
                "using": 0.05640703805805438,
                "ways": 0.08067914950470541,
                "web": 0.0710688682015492,
                "work": 0.0508979446638715,
                "write": 0.059265057563386854
            },
            "Max term": "service",
            "Max score": 0.3136609075197037
        }
    },
    {
        "ID": "4475",
        "Question": "I have several projects coming up soon for public release, both commercial and open source. The projects are all downloadable, not web apps. I've worked on them alone and would like to get feedback during a beta period, but I don't currently have a large audience (though the markets are large). What are the best ways to get participation in the betas? Are there any existing sites or communities that specialize in software testing that I can reach out to? At this point, I'm specifically looking for technical testers who aren't intimidated diving into the code and can help spot security bugs, logical errors, etc. Edit: I'm looking for websites or communities similar to Invite Share. Invite Share itself would be perfect, but there doesn't seem to be any public information about how to submit a beta. Bounty Explanation: While Joel's article on running a beta is helpful, I wonder if there isn't an existing community available for beta testing of any sort, technical or user. As a self-taught and sole developer, I don't have a lot of technical contacts that would be appropriate approaching for testing. I did propose a Beta Testing site in Area 51 a few months ago, but it seems as if it either got buried, there wasn't a whole lot of interest, or it's a poor fit for StackExchange. If you know of existing testing communities, sites like InviteShare, or other ways to get testers, please share. ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "ago": 0.07241959456835295,
                    "appropriate": 0.08861910616992417,
                    "apps": 0.07855273201624267,
                    "area": 0.0932259714034817,
                    "article": 0.07855273201624267,
                    "audience": 0.0997189832691315,
                    "available": 0.06914007057297474,
                    "best": 0.0525675099435663,
                    "beta": 0.45378721429425994,
                    "bugs": 0.06745285491703534,
                    "code": 0.03490453886402953,
                    "coming": 0.08351947166756028,
                    "commercial": 0.090757442858852,
                    "communities": 0.2796779142104451,
                    "community": 0.08861910616992417,
                    "currently": 0.07394586678268517,
                    "developer": 0.05507119489670828,
                    "edit": 0.0664193519715095,
                    "errors": 0.07394586678268517,
                    "existing": 0.21512326711399024,
                    "explanation": 0.090757442858852,
                    "feedback": 0.08861910616992417,
                    "fit": 0.0850457438818925,
                    "got": 0.06409444535501284,
                    "help": 0.05411486673980626,
                    "helpful": 0.07316455389399486,
                    "information": 0.0664193519715095,
                    "intimidated": 0.0997189832691315,
                    "joel": 0.07563308243862454,
                    "know": 0.04348601588142746,
                    "large": 0.1349057098340707,
                    "like": 0.07109320196539853,
                    "logical": 0.07965756575964465,
                    "looking": 0.11791102663446688,
                    "lot": 0.10231316655398941,
                    "months": 0.08212609430427435,
                    "open": 0.062064676794787506,
                    "perfect": 0.08861910616992417,
                    "period": 0.090757442858852,
                    "point": 0.05717437517712382,
                    "poor": 0.0850457438818925,
                    "projects": 0.1160803869475348,
                    "propose": 0.0932259714034817,
                    "public": 0.16703894333512057,
                    "reach": 0.090757442858852,
                    "release": 0.07855273201624267,
                    "running": 0.07316455389399486,
                    "security": 0.07316455389399486,
                    "self": 0.08351947166756028,
                    "share": 0.23255768721215053,
                    "similar": 0.06498432637240564,
                    "site": 0.07170775570466341,
                    "sites": 0.1512661648772491,
                    "software": 0.04708928245012981,
                    "soon": 0.07965756575964465,
                    "sort": 0.07316455389399486,
                    "source": 0.05927262739544615,
                    "specifically": 0.07751922907071684,
                    "spot": 0.090757442858852,
                    "stackexchange": 0.09614562098109984,
                    "submit": 0.09614562098109984,
                    "taught": 0.0932259714034817,
                    "technical": 0.19100216112832089,
                    "testers": 0.170091487763785,
                    "testing": 0.2932227859236998,
                    "user": 0.06026348387729721,
                    "ways": 0.1338555345938109,
                    "web": 0.05895551331723344,
                    "websites": 0.08673295953783187,
                    "wonder": 0.07965756575964465,
                    "worked": 0.06544852518288326
                },
                "Max term": "beta",
                "Max score": 0.45378721429425994
            }
        ],
        "Best Answer": " What are the best ways to get participation in the betas?  Joel (on Software) has an excellent article on this: Top Twelve Tips for Running a Beta.   Are there any existing sites or communities that specialize in software testing that I can reach out to?  I don't think there will be much \"We Test Your Code\" sites so you will have to start a webpage yourself and advertise it to the right audience...  At this point, I'm specifically looking for technical testers who aren't intimidated diving into the code and can help spot security bugs, logical errors, etc.  This seems more like a job description that you need technical testers in your company and is less like beta testing, perhaps it can still be alpha testing... But those aren't always technical either. Test-Driven Development helps you prevent bugs and errors, thinking about the security can help too... ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "alpha": 0.1474547902295936,
                "article": 0.12047326236203217,
                "audience": 0.15293511664716003,
                "best": 0.08062074041983035,
                "beta": 0.27838230305168205,
                "bugs": 0.20689962726714045,
                "code": 0.10706346069090197,
                "communities": 0.14297703750806054,
                "company": 0.09041777212900398,
                "description": 0.13919115152584102,
                "development": 0.07730089584212577,
                "driven": 0.1173992999965654,
                "errors": 0.22681578554533943,
                "excellent": 0.13919115152584102,
                "existing": 0.10997538907512636,
                "help": 0.16598772241512988,
                "helps": 0.11888821919023615,
                "intimidated": 0.15293511664716003,
                "job": 0.08484132173331228,
                "joel": 0.11599550964049912,
                "like": 0.10903287196635518,
                "logical": 0.12216770279737908,
                "looking": 0.09041777212900398,
                "need": 0.07199053304447578,
                "point": 0.08768611000919281,
                "prevent": 0.1280905573145918,
                "reach": 0.13919115152584102,
                "right": 0.08768611000919281,
                "running": 0.11220962365827962,
                "security": 0.22441924731655924,
                "sites": 0.23199101928099825,
                "software": 0.14443799301293037,
                "specifically": 0.11888821919023615,
                "spot": 0.13919115152584102,
                "start": 0.08522809579071819,
                "technical": 0.29293256744487683,
                "test": 0.1728527298102166,
                "testers": 0.2608626830022633,
                "testing": 0.269822612497863,
                "think": 0.06492516345511333,
                "thinking": 0.09638444404420778,
                "tips": 0.12398776828954487,
                "ways": 0.10264450722347764
            },
            "Max term": "technical",
            "Max score": 0.29293256744487683
        }
    },
    {
        "ID": "4507",
        "Question": "Considering the fact that you don't have to get involved in setting up/buying a server or even buying a domain, do you think that fact alone is enough to choose one over the other? I don't necessarily want to work on Google App Engine, I just find it convenient when it comes to hosting/environment/etc. and wondering if that's a good enough reason to learn python. In any case, I'm not looking for a debate between python and ruby but more on Google App Engine and whether its value is enough to dictate the language you should learn. ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "app": 0.2507832283658987,
                    "buying": 0.3710388422695551,
                    "case": 0.12539161418294936,
                    "choose": 0.14593910288863604,
                    "comes": 0.14770527388821159,
                    "considering": 0.16115641959704147,
                    "convenient": 0.1798857615460315,
                    "debate": 0.1798857615460315,
                    "domain": 0.15846780456474663,
                    "engine": 0.31693560912949326,
                    "environment": 0.12628731690692668,
                    "fact": 0.2603096109921944,
                    "good": 0.08414064149033249,
                    "google": 0.27672984361541164,
                    "hosting": 0.19241446322214206,
                    "involved": 0.13973846261575656,
                    "language": 0.09057448724995573,
                    "learn": 0.20883652630062072,
                    "looking": 0.11375861523081611,
                    "necessarily": 0.14426844844216066,
                    "python": 0.2603096109921944,
                    "reason": 0.11975795459420335,
                    "ruby": 0.1537046132515988,
                    "server": 0.13704984758346175,
                    "setting": 0.15846780456474663,
                    "think": 0.08168523194478139,
                    "value": 0.14593910288863604,
                    "want": 0.0908619272792198,
                    "wondering": 0.14957854925957229,
                    "work": 0.08147139316523565
                },
                "Max term": "buying",
                "Max score": 0.3710388422695551
            }
        ],
        "Best Answer": "If you want to develop for Google App Engine, you'd definitely want to learn Python (Java is also an option, but the people behind GAE seem to be Pythonistas). One thing to keep in mind is that writing something in Python doesn't mean you get Google App Engine for free. There are several people, including people at Google, who have had to \"port\" their projects to GAE (RSSmeme is another example) even though they're written in Python. This is because GAE has its own restrictions and specialized environment: for example, you don't access to things like MySQL, threading, or local file storage. The General FAQ for GAE touches upon several of these \"quirks\". ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "access": 0.12851116061614767,
                "app": 0.24362580965468364,
                "definitely": 0.1371467142576797,
                "develop": 0.13861128268307193,
                "engine": 0.3078901842268196,
                "environment": 0.12268304396208689,
                "example": 0.1994931065116352,
                "file": 0.12450285556602741,
                "free": 0.11934430641017078,
                "general": 0.13191302689426607,
                "google": 0.4032478526118983,
                "including": 0.14348972686793726,
                "java": 0.11360926796478239,
                "learn": 0.10143813870046402,
                "like": 0.06663198595961299,
                "local": 0.15655697337182037,
                "mean": 0.12450285556602741,
                "mind": 0.12644015341875356,
                "mysql": 0.18022464849477268,
                "option": 0.1625806457549418,
                "people": 0.2508042158812784,
                "projects": 0.1087961506789227,
                "python": 0.3793204602562607,
                "restrictions": 0.18692290428357855,
                "thing": 0.10665111706116208,
                "things": 0.08883509265717308,
                "threading": 0.18022464849477268,
                "want": 0.17653740837794385,
                "writing": 0.10416890208751095,
                "written": 0.12745779996701245
            },
            "Max term": "google",
            "Max score": 0.4032478526118983
        }
    },
    {
        "ID": "4522",
        "Question": "I see a few developers that like to use virtual machines for web development.  Are there others that do this? If there are, why do you do it?  Are there any pros / cons to developing on a VM rather than in a non virtualised environment? I would think things are slower in a VM. ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "cons": 0.27857685360620427,
                    "developers": 0.17001562714433643,
                    "developing": 0.21427635092061303,
                    "development": 0.1506132783274817,
                    "environment": 0.19557258502251573,
                    "like": 0.1062199739952052,
                    "machines": 0.2541327849583758,
                    "non": 0.176170236205661,
                    "pros": 0.2873013193395285,
                    "slower": 0.297979202423059,
                    "things": 0.1416145878891552,
                    "think": 0.12650036726473876,
                    "use": 0.11223830078551675,
                    "virtual": 0.2712004229329985,
                    "vm": 0.595958404846118,
                    "web": 0.176170236205661
                },
                "Max term": "vm",
                "Max score": 0.595958404846118
            }
        ],
        "Best Answer": "I use VMs for IE testing. I do have a dedicated Windows machine, but I lean towards using VMs for a few reasons:  It's a hassle to switch computers, even if it's right next to you It's extremely easy to rollback a VM to have a clean testing environment I'd rather use an environment users are actually going to use rather than kludges like IETester, and you generally can't run multiple versions of IE at the same time. It's cheaper to run multiple VM instances than it is to buy multiple testing computers VMs, at least the ones for Mac OS X, have gotten so good in the past couple of years that the \"slow\" stigma given to VMs is unwarranted.  ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "actually": 0.07894800751625389,
                "buy": 0.11470333719846802,
                "clean": 0.1276075551681658,
                "computers": 0.24492414611849117,
                "couple": 0.10766152126919862,
                "dedicated": 0.13068666450241315,
                "easy": 0.0916781939652535,
                "environment": 0.1884859066832768,
                "extremely": 0.11825790805860532,
                "generally": 0.0987200098945229,
                "given": 0.0995586138394844,
                "going": 0.07422563942597882,
                "good": 0.0627906486916106,
                "like": 0.051185517909003914,
                "mac": 0.13068666450241315,
                "machine": 0.11022628064558353,
                "multiple": 0.30399979093914076,
                "ones": 0.0995586138394844,
                "os": 0.11641219789643366,
                "past": 0.10647874575530047,
                "reasons": 0.10133326364638026,
                "right": 0.08232854685569302,
                "run": 0.17765554293547214,
                "slow": 0.1202643092337046,
                "switch": 0.12246207305924559,
                "testing": 0.25333662986563027,
                "time": 0.05659453508108147,
                "use": 0.16225692792560553,
                "users": 0.09292493364509974,
                "using": 0.06737943176366076,
                "versions": 0.1202643092337046,
                "vm": 0.2871817649442218,
                "vms": 0.5743635298884436,
                "windows": 0.10325596575666772,
                "years": 0.08444554328854344
            },
            "Max term": "vms",
            "Max score": 0.5743635298884436
        }
    },
    {
        "ID": "4596",
        "Question": "We have an offshore development crew who has a bad habit of installing nonsense software on corporate desktops (which has nothing to do with their job function) and so are considering removing their local administrator rights. Is Local Administrator, or local Power User a requirement with VS2010?  How do you run without elevated rights?  What issues will you run into? ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "administrator": 0.391623006145274,
                    "bad": 0.12382995321232138,
                    "considering": 0.1754240051012944,
                    "corporate": 0.18613525950815019,
                    "development": 0.10586598287053378,
                    "function": 0.14522156152010623,
                    "habit": 0.209449402401985,
                    "issues": 0.1553156390085714,
                    "job": 0.11619283082664576,
                    "local": 0.5262720153038832,
                    "nonsense": 0.20194392479624101,
                    "power": 0.16980510783089137,
                    "removing": 0.20194392479624101,
                    "requirement": 0.182173603743289,
                    "rights": 0.37227051901630037,
                    "run": 0.25913795263750083,
                    "software": 0.09890616355462835,
                    "user": 0.12657720998514035
                },
                "Max term": "local",
                "Max score": 0.5262720153038832
            }
        ],
        "Best Answer": "A programmer should work as a limited user with admin access. That is, the programmer should be the admin of the machine, but while working, he should always use a limited user account. If you need elevated rights to work, for anything but installing software, you're doing something very wrong. Worse, if you work as a power user or disable UAC prompts or the like, you're ignoring issues that will affect end-users of your software, forcing them to run with the same privileges you did. This is wrong. This is true, irrespective of the operating system you're on. Though Windows seems to be the only one where where it comes up. To clarify: When I say the developer should be a limited user, I mean that they should have full admin rights to the machine, but when they test their code, it should be done in a limited-user environment. For example, the developer could be operating the machine as an Admin-capable user, but runs all tests in a virtual machine or in a limited user account. On Linux, this means simply that the dev has sudo access; on Windows, this may mean an Administrator-level account with UAC and other security features fully enabled. ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "access": 0.13330106977967837,
                "account": 0.2435883225846847,
                "admin": 0.36253035836387965,
                "administrator": 0.09063258959096991,
                "affect": 0.08432020184354913,
                "capable": 0.09347101967578457,
                "code": 0.03393355626227887,
                "comes": 0.07441896097655548,
                "dev": 0.0861538792087863,
                "developer": 0.10707842310927684,
                "disable": 0.09694497733839069,
                "end": 0.05402575939499764,
                "environment": 0.06362786284695109,
                "example": 0.051732169377689985,
                "features": 0.06109772528697138,
                "fully": 0.08823273114904798,
                "issues": 0.07188882341657578,
                "level": 0.05926404792173423,
                "like": 0.034557757347204544,
                "limited": 0.4133996077309009,
                "linux": 0.08267992154618017,
                "machine": 0.2976758439062219,
                "mean": 0.129143365899155,
                "means": 0.06273800558434034,
                "need": 0.04563451970731518,
                "operating": 0.18694203935156914,
                "power": 0.07859536547645332,
                "privileges": 0.09694497733839069,
                "programmer": 0.1002264601789976,
                "rights": 0.1723077584175726,
                "run": 0.05997181815239543,
                "runs": 0.08432020184354913,
                "say": 0.050502456956509366,
                "security": 0.07112924527202281,
                "simply": 0.06506595505889068,
                "software": 0.0915586836197126,
                "test": 0.054785337539550616,
                "tests": 0.06149187959942816,
                "true": 0.0753627810791819,
                "uac": 0.19388995467678138,
                "use": 0.03651576834111756,
                "user": 0.41010942160677655,
                "users": 0.06273800558434034,
                "virtual": 0.08823273114904798,
                "windows": 0.1394259452688861,
                "work": 0.12314421013682923,
                "working": 0.051732169377689985,
                "worse": 0.08267992154618017,
                "wrong": 0.12547601116868068
            },
            "Max term": "limited",
            "Max score": 0.4133996077309009
        }
    },
    {
        "ID": "4614",
        "Question": "You know who they are.  They are the rock stars of programming:   They code 10X faster. Their code just works. They not only know their primary language inside and out, but they also know how it works under the hood. They know the answer to most any question before you ask it. A few of them invented the programming principles we all use. And they tend to be  uncharacteristically humble, as well.  What is it about these folks?  Is there something about their thought process that is fundamentally different from the above-average programmer?  Or are they simply very talented people that work hard? To put it another way: How can I be like them?  I know what I think I need to learn to be that good, but it seems like it will take me the next ten years to learn it, and then my knowledge will be obsolete. ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "10x": 0.19112408961896696,
                    "answer": 0.11719534073205617,
                    "ask": 0.1226268760833929,
                    "average": 0.15834813464950093,
                    "code": 0.1387707135464628,
                    "different": 0.10666323184576623,
                    "faster": 0.14862689685311845,
                    "folks": 0.18532023332437436,
                    "fundamentally": 0.19112408961896696,
                    "good": 0.08668258776590732,
                    "hard": 0.13105285474437353,
                    "hood": 0.19112408961896696,
                    "humble": 0.1982274356394067,
                    "inside": 0.17241303100934205,
                    "invented": 0.18532023332437436,
                    "know": 0.43222068315142353,
                    "knowledge": 0.12414302347038478,
                    "language": 0.09331080440239363,
                    "learn": 0.21514562046523844,
                    "like": 0.14132337349409999,
                    "need": 0.09331080440239363,
                    "obsolete": 0.1982274356394067,
                    "people": 0.08865736518886595,
                    "primary": 0.15834813464950093,
                    "principles": 0.16905908152166157,
                    "process": 0.12117966879429158,
                    "programmer": 0.1024686101846667,
                    "programming": 0.16830599724024115,
                    "question": 0.10169215516070648,
                    "simply": 0.13304307012969063,
                    "tend": 0.15034802291203667,
                    "think": 0.08415299862012057,
                    "thought": 0.13744082059700438,
                    "use": 0.07466531343234337,
                    "way": 0.08716491635331973,
                    "work": 0.08393269962492146,
                    "works": 0.26608614025938127,
                    "years": 0.11657720329503307
                },
                "Max term": "know",
                "Max score": 0.43222068315142353
            }
        ],
        "Best Answer": " Humble: An exceptional programmer will never claim their code is the best, in fact they will always be looking for a better way (Every chance they get.). Patient: An exceptional programmer will have boundless patience (This does not mean they will waste days on a problem. See: Troubleshooter). Troubleshooter: An exceptional programmer will be able to solve a problem in minutes that may take days for your average programmer. Curious: An exceptional programmer will be unable to resist trying to figure out why something occurs. Engineer: An exceptional programmer will engineer systems rather than hobble together a mishmash of frameworks (This does not mean they won't use frameworks.).  ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "able": 0.11250252431029369,
                "average": 0.14259743976518618,
                "best": 0.09410270400932924,
                "better": 0.08925584687100639,
                "chance": 0.13876953799227576,
                "claim": 0.16246766854961958,
                "code": 0.062483680372726134,
                "curious": 0.15863976677670916,
                "days": 0.24545442196150555,
                "engineer": 0.3337733136829978,
                "fact": 0.12074941437508342,
                "figure": 0.13539308933742183,
                "frameworks": 0.27078617867484367,
                "humble": 0.17850999556114255,
                "looking": 0.10553806382241789,
                "mean": 0.23779861841568473,
                "minutes": 0.14259743976518618,
                "occurs": 0.17850999556114255,
                "problem": 0.1859857749136472,
                "programmer": 0.5536570986822068,
                "solve": 0.12714619927263213,
                "systems": 0.12376975061777819,
                "trying": 0.11042933100917131,
                "unable": 0.15863976677670916,
                "use": 0.06723844621399767,
                "waste": 0.15863976677670916,
                "way": 0.07849472895176397
            },
            "Max term": "programmer",
            "Max score": 0.5536570986822068
        }
    },
    {
        "ID": "4647",
        "Question": "There is a school of thought in linguistics that problem solving is very much tied to the syntax, semantics, grammar, and flexibility of one's own native spoken language. Working with various international development teams, I can clearly see a mental culture (if you will) in the codebase.  Programming language aside, the German coding is quite different from my colleagues in India.  As well, code is distinctly different in Middle America as it is in Coastal America (actually, IBM noticed this years ago). Do you notice with your international colleagues (from ANY country) that coding style and problem solving are in-line with native tongues? ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "actually": 0.09077639193611783,
                    "ago": 0.11990487898241317,
                    "america": 0.33020876994413784,
                    "aside": 0.15026679267684587,
                    "clearly": 0.1300594940124328,
                    "code": 0.057791327518109614,
                    "codebase": 0.14360346918753525,
                    "coding": 0.18749811563242175,
                    "colleagues": 0.3183759621174563,
                    "country": 0.15918798105872814,
                    "culture": 0.13828290813644167,
                    "development": 0.08345183987565968,
                    "different": 0.17768042285593216,
                    "flexibility": 0.15918798105872814,
                    "german": 0.16510438497206892,
                    "grammar": 0.15918798105872814,
                    "ibm": 0.15918798105872814,
                    "language": 0.15543784766636587,
                    "line": 0.112580326921955,
                    "mental": 0.15435392707980208,
                    "middle": 0.16510438497206892,
                    "native": 0.30870785415960417,
                    "notice": 0.13385365425740392,
                    "noticed": 0.14360346918753525,
                    "problem": 0.17201875381904708,
                    "programming": 0.07009135257142127,
                    "quite": 0.10541387843983141,
                    "school": 0.1283483266640119,
                    "semantics": 0.15918798105872814,
                    "solving": 0.27195179585154716,
                    "style": 0.12243192275067112,
                    "syntax": 0.1300594940124328,
                    "teams": 0.1408099519046996,
                    "thought": 0.11447498214123994,
                    "various": 0.1300594940124328,
                    "working": 0.08810366707870736,
                    "years": 0.09709759594934692
                },
                "Max term": "america",
                "Max score": 0.33020876994413784
            }
        ],
        "Best Answer": "Till now with my experience I have noticed that my native internationl fellow did the same job compared to the non-native. The issue arises when they tried to explain the concept or the requirement. Else I suppose the syntax name doesn't play much role until you read what excatly they do. Once a programmer acquires the knowledge of the syntax then it doesn't count what is the actual meaning of the word used for syntax. ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "actual": 0.166822730818682,
                "compared": 0.2013528143292913,
                "concept": 0.16031137013447133,
                "count": 0.1952383428296033,
                "experience": 0.11973734458167067,
                "explain": 0.1351485629838101,
                "fellow": 0.18559042261704448,
                "issue": 0.14239998216626945,
                "job": 0.11585272255869243,
                "knowledge": 0.13078700442703697,
                "meaning": 0.2013528143292913,
                "native": 0.3904766856592066,
                "non": 0.12346749030812879,
                "noticed": 0.18164036302271147,
                "play": 0.17491052114442748,
                "programmer": 0.10795260337002642,
                "read": 0.12550064277125125,
                "requirement": 0.18164036302271147,
                "role": 0.18164036302271147,
                "suppose": 0.19006863083813272,
                "syntax": 0.4935268035088463,
                "till": 0.2013528143292913,
                "tried": 0.1565812244080132,
                "used": 0.10190720860882596,
                "word": 0.17199244281015263
            },
            "Max term": "syntax",
            "Max score": 0.4935268035088463
        }
    },
    {
        "ID": "4654",
        "Question": "I'm tired of how luggish my developments PC is. It's Core2 Duo, 2GB RAM, Seagate ST3500320AS HDD - not the top model, but quite a decent one. Typically I open several copies of Visual Studio 2008, lots of tabs in Firefox, Outlook, MSDN, plus the programs I debug are quite huge, plus whatever Windows thinks it can't live without so I end up with Task Manager showing something like 2,5 GB pagefile usage. All the software above becomes luggish to such extent that it's really annoying. Something like I click on a menubar in Visual Studio - and instead of just opening the menu it works the harddisk for say 10 seconds. I'd like to have some magic \"don't make me think\" solution - so that it is installed once and then the lugs disappear or at least decrease significantly. It should not be very expensive - something like the current price of a hybrid drive. Will a hybrid drive magically help overcome my problem once and for all? Do you have experience using hybrid drives for similar purposes? ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "10": 0.10526173820814562,
                    "2008": 0.13550376599818267,
                    "annoying": 0.11937011647524079,
                    "click": 0.12880769644593956,
                    "copies": 0.1397474709143804,
                    "current": 0.10634453512214134,
                    "debug": 0.1141762414207397,
                    "decent": 0.131915764615782,
                    "drive": 0.24722764278287696,
                    "end": 0.08077330562850066,
                    "expensive": 0.1397474709143804,
                    "experience": 0.08310284182036372,
                    "extent": 0.12361382139143848,
                    "firefox": 0.14494134596888147,
                    "help": 0.07865585232678725,
                    "huge": 0.10634453512214134,
                    "installed": 0.1397474709143804,
                    "instead": 0.0937988869816001,
                    "like": 0.20666765833927533,
                    "live": 0.11937011647524079,
                    "lots": 0.1086740713140044,
                    "magic": 0.12361382139143848,
                    "make": 0.06577529285191401,
                    "manager": 0.109932536504542,
                    "menu": 0.1397474709143804,
                    "model": 0.1086740713140044,
                    "msdn": 0.14494134596888147,
                    "open": 0.09021088559919944,
                    "opening": 0.14494134596888147,
                    "outlook": 0.1397474709143804,
                    "overcome": 0.1397474709143804,
                    "pc": 0.12880769644593956,
                    "plus": 0.2521323720549678,
                    "price": 0.1260661860274839,
                    "problem": 0.07550565575420744,
                    "programs": 0.10049495653384323,
                    "purposes": 0.131915764615782,
                    "quite": 0.185080843582125,
                    "ram": 0.1397474709143804,
                    "really": 0.06758992071395702,
                    "say": 0.07550565575420744,
                    "showing": 0.1397474709143804,
                    "similar": 0.09445459051539713,
                    "software": 0.06844417938568585,
                    "solution": 0.0988316822502645,
                    "studio": 0.23874023295048158,
                    "tabs": 0.14494134596888147,
                    "task": 0.09582415823744683,
                    "think": 0.06153158793571632,
                    "thinks": 0.1397474709143804,
                    "tired": 0.1397474709143804,
                    "typically": 0.131915764615782,
                    "usage": 0.131915764615782,
                    "using": 0.06801313121214518,
                    "visual": 0.23501409504300597,
                    "windows": 0.10422708182042793,
                    "works": 0.09727937807513155
                },
                "Max term": "plus",
                "Max score": 0.2521323720549678
            }
        ],
        "Best Answer": "It sounds more to me like getting more RAM in your machine would be the best thing you can do.  ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "best": 0.29431853001810704,
                "getting": 0.3393354898838402,
                "like": 0.19902071373743443,
                "machine": 0.4285843719644742,
                "ram": 0.5383066054529501,
                "sounds": 0.4285843719644742,
                "thing": 0.318552435931784
            },
            "Max term": "ram",
            "Max score": 0.5383066054529501
        }
    },
    {
        "ID": "4662",
        "Question": "I want to know about Which language is best for long term career and How? Which language should I choose among Java and .NET Platform or Should I choose Oracle like DBMS Language (SQL/PLSQL)? I am confused? Detailed answer would be appreciated. ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "answer": 0.17583191063505005,
                    "appreciated": 0.28674957243326143,
                    "best": 0.15678000564541597,
                    "career": 0.20988252370710123,
                    "choose": 0.4511438759202262,
                    "detailed": 0.25364473645861896,
                    "java": 0.18076000860837893,
                    "know": 0.1296948975271229,
                    "language": 0.41999153511941295,
                    "like": 0.10601598418349688,
                    "long": 0.16498760531156684,
                    "net": 0.18180972520859542,
                    "oracle": 0.2706795969420995,
                    "platform": 0.237574760967457,
                    "sql": 0.22053990048397648,
                    "term": 0.2342796488209284,
                    "want": 0.1404414623461444
                },
                "Max term": "choose",
                "Max score": 0.4511438759202262
            }
        ],
        "Best Answer": "All of them. Both are solid technologies and they will stay in mainstream for long long time. Anyway the most characteristic of our career is change (evolution, new technologies introduction). You need learn new things forever. Technologies knowledge are not important to stay relevant on career, fundamentals, hard work, motivation and evolution is the key. ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "career": 0.3026782560018555,
                "change": 0.1326624347470434,
                "forever": 0.21445000545967535,
                "fundamentals": 0.21445000545967535,
                "hard": 0.14177798004995198,
                "important": 0.13691948164048887,
                "introduction": 0.20676533462714586,
                "key": 0.16462066448290136,
                "knowledge": 0.13430266085585277,
                "learn": 0.11637637175341536,
                "long": 0.23793386774459632,
                "mainstream": 0.18289456673030155,
                "need": 0.10094718951992544,
                "new": 0.20318182730810924,
                "relevant": 0.16079024953733317,
                "solid": 0.19517782350486346,
                "stay": 0.3378621252944584,
                "technologies": 0.559568991880592,
                "things": 0.10191734489872874,
                "time": 0.08452276459463205,
                "work": 0.0908015978451749
            },
            "Max term": "technologies",
            "Max score": 0.559568991880592
        }
    },
    {
        "ID": "4714",
        "Question": "It seems to me that rapid-development web platforms are going to radically change the world of web applications. It has been five years since Rails 1.0 was released for Ruby, and since that time we have seen Grails for Groovy, Django for Python, and Roo for Java. But to my knowledge (which is probably limited, being a Java/Groovy progammer) there is no similar framework for C#. Does such a thing exist?  If not, why not? Edit:  It's quite possible I'm not using the right words when I say \"rapid-development,\" but I'm talking about frameworks that can conceivably allow you to build a working blog engine in 30 minutes.  You couldn't reasonably do this with, say, Java, Spring, and Hibernate, given the various configuration needed to allow your controllers to be found, and both configuration and code necessary for your entities to persist and be retrieved.   So I'm talking about frameworks that handle all of the CRUD with a convention-over-configuration mentality.  If someone has the right words for what I'm talking about, let me know. ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "30": 0.11481068173196923,
                    "allow": 0.21045569556478438,
                    "applications": 0.09587472103539019,
                    "blog": 0.11113325214743562,
                    "build": 0.0906264821032901,
                    "change": 0.08479969713312255,
                    "code": 0.04798179182059841,
                    "configuration": 0.36546280013641147,
                    "convention": 0.11113325214743562,
                    "crud": 0.1370794644908493,
                    "development": 0.13857334586076298,
                    "django": 0.13216731463916895,
                    "edit": 0.09130387115471293,
                    "engine": 0.11289526486217015,
                    "exist": 0.10522784778239219,
                    "framework": 0.08996931667034673,
                    "frameworks": 0.20793919269107297,
                    "given": 0.09504392782890282,
                    "going": 0.07085972820022371,
                    "handle": 0.10656240226675838,
                    "java": 0.24994525427740089,
                    "know": 0.05977838496185221,
                    "knowledge": 0.08584815276807369,
                    "let": 0.08933120221839906,
                    "limited": 0.1169087835271235,
                    "minutes": 0.10950188318212485,
                    "necessary": 0.09504392782890282,
                    "needed": 0.09504392782890282,
                    "platforms": 0.11481068173196923,
                    "possible": 0.08061618992334472,
                    "probably": 0.07783603472519461,
                    "python": 0.09272458389844436,
                    "quite": 0.08752086147730191,
                    "radically": 0.1370794644908493,
                    "rails": 0.11922812745758193,
                    "rapid": 0.2741589289816986,
                    "reasonably": 0.1247604142941703,
                    "released": 0.11922812745758193,
                    "right": 0.1571903859213365,
                    "ruby": 0.10950188318212485,
                    "say": 0.14282018409073344,
                    "seen": 0.0934708725590606,
                    "similar": 0.08933120221839906,
                    "talking": 0.3049507572452341,
                    "thing": 0.07821234144701515,
                    "time": 0.05402814181833604,
                    "using": 0.06432397562327312,
                    "various": 0.10798311501048982,
                    "web": 0.16208729630742613,
                    "words": 0.2257905297243403,
                    "working": 0.07314889610516644,
                    "world": 0.08479969713312255,
                    "years": 0.08061618992334472
                },
                "Max term": "configuration",
                "Max score": 0.36546280013641147
            }
        ],
        "Best Answer": "I don't know what you mean by \"rapid development web platforms\". The definition of \"rapid development\" that I'm familiar with has nothing to do with languages, paradigms, or frameworks, but rather the use of rapid prototyping and iterative development to produce a system. Any language or framework can be used equally well. I've never used Grails or Roo before, but Django and Rails are both MVC frameworks, so their counterpart in .NET would be ASP.NET MVC. ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "asp": 0.15960718259519271,
                "definition": 0.15222701232946587,
                "development": 0.28896224177894136,
                "django": 0.18373597650066237,
                "familiar": 0.15011565557038115,
                "framework": 0.12507328531758252,
                "frameworks": 0.2890723075229299,
                "know": 0.08310254289863121,
                "language": 0.08970377203164813,
                "languages": 0.10431460369816685,
                "mean": 0.12692855242388484,
                "mvc": 0.36747195300132474,
                "net": 0.23299066928019987,
                "paradigms": 0.1657482145610006,
                "platforms": 0.15960718259519271,
                "produce": 0.14628534611711816,
                "rails": 0.1657482145610006,
                "rapid": 0.5716942044674752,
                "use": 0.07177904314191799,
                "used": 0.18598220788290726,
                "web": 0.11266502518683694
            },
            "Max term": "rapid",
            "Max score": 0.5716942044674752
        }
    },
    {
        "ID": "4765",
        "Question": "Have you ever reached a point at your job when you just know it's time to move on?  When do you move to the point that you're willing to let go of the demons you know for the ones you don't know?  What was your deciding factor final straw so to speak when you finally faced the decision to find a new job?  ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "deciding": 0.2862535844740215,
                    "decision": 0.2676147269602188,
                    "factor": 0.25439024709628494,
                    "final": 0.26052856220892384,
                    "finally": 0.24413254359751693,
                    "job": 0.31760046992615065,
                    "know": 0.37449322623828385,
                    "let": 0.18654418395468275,
                    "new": 0.13560625993517275,
                    "ones": 0.198473674554877,
                    "point": 0.32824983364186583,
                    "reached": 0.27599588097525346,
                    "speak": 0.2676147269602188,
                    "time": 0.1128232395378367,
                    "willing": 0.2286652248311873
                },
                "Max term": "know",
                "Max score": 0.37449322623828385
            }
        ],
        "Best Answer": "I had one job where I work up every morning wishing I was sick enough to go to the hospital so I wouldn't have to go to work.  At another job, I was working so many hours I was having trouble actually driving home at 2 or 3 am when I went home. Only job I ever quit without having another job, just physically couldn't take one more day and the final straw was when they asked me to do something unethical and illegal. Thanks to my exhaustion, I had a car accident in the parking lot the day I quit. Other signs it's time to move on:  You aren't sure if your paycheck will bounce or not You are part of a Death March The work is boring beyond belief You think someone is sabotaging you in terms of office politics  - you start getting fewer responsibilities and less interesting assignments and Joe is getting the credit for the things you did and you are starting to see emails blaming you for things that someone else did. You simply can't live with the corporate culture  ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "accident": 0.15124509253431243,
                "actually": 0.08624698741071432,
                "asked": 0.10370802122440329,
                "assignments": 0.15124509253431243,
                "boring": 0.14665223987988496,
                "bounce": 0.15686628988471712,
                "corporate": 0.13940525607102813,
                "credit": 0.14665223987988496,
                "culture": 0.13138310504292444,
                "day": 0.19899954129918923,
                "death": 0.15686628988471712,
                "driving": 0.15124509253431243,
                "emails": 0.14276903829102108,
                "fewer": 0.14276903829102108,
                "final": 0.14276903829102108,
                "getting": 0.1906825108507551,
                "home": 0.2543497089362315,
                "hours": 0.11173017225250702,
                "interesting": 0.1097138206544268,
                "job": 0.34808861851984485,
                "joe": 0.15686628988471712,
                "live": 0.12919120606619597,
                "lot": 0.08047357843774587,
                "morning": 0.15686628988471712,
                "office": 0.13940525607102813,
                "quit": 0.30249018506862485,
                "responsibilities": 0.14665223987988496,
                "sick": 0.15124509253431243,
                "signs": 0.14665223987988496,
                "simply": 0.10528296821677668,
                "start": 0.08741887065397877,
                "starting": 0.11632302490693446,
                "sure": 0.0922527868407378,
                "terms": 0.11897715606136379,
                "thanks": 0.14665223987988496,
                "things": 0.1491013789894345,
                "think": 0.06659405462029688,
                "time": 0.06182686945770399,
                "trouble": 0.13940525607102813,
                "went": 0.12041703062882568,
                "work": 0.1992591663363944,
                "working": 0.08370762158868864
            },
            "Max term": "job",
            "Max score": 0.34808861851984485
        }
    },
    {
        "ID": "4879",
        "Question": "Code needs to be written to file, on way or another. While all programmers should strive to write no more code than necessary, this \"small\" portion needs to be written nevertheless. What tips do you have for improving the code writing effort? Usage of IDEs? Different keyboards or character layouts? Minimal usage of mouse? Code generation tools? What else can you think of? ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "character": 0.19418785567775249,
                    "code": 0.3187949094708225,
                    "different": 0.122517548808133,
                    "effort": 0.17936213961567923,
                    "file": 0.15165757798256466,
                    "generation": 0.21953258468823733,
                    "ides": 0.22769176501401917,
                    "improving": 0.22769176501401917,
                    "minimal": 0.22769176501401917,
                    "mouse": 0.21953258468823733,
                    "necessary": 0.15786988781731462,
                    "needs": 0.3274655421931703,
                    "programmers": 0.12200614585841818,
                    "small": 0.13607792356338733,
                    "think": 0.09666141684793336,
                    "tips": 0.18459458115906796,
                    "tools": 0.15053242105776554,
                    "usage": 0.4144591465983762,
                    "way": 0.10012102304491131,
                    "write": 0.11225694481407414,
                    "writing": 0.12688868315407192,
                    "written": 0.3105140223507901
                },
                "Max term": "usage",
                "Max score": 0.4144591465983762
            }
        ],
        "Best Answer": "For me, an IDE with autocomplete is important. A programming language that requires less keystrokes would be nice (type less, read less) but keeping it understandable (unlike J). Keyboard layout: I don't think it's a problem. I switched the layout a few times (US/CH, PC/Mac), and after some time the brain adjusted. Code generation: I avoid them, except to generate getters, setter, and implement an interface. ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "avoid": 0.16073351417851042,
                "brain": 0.21672725920305963,
                "code": 0.08114439493483547,
                "generate": 0.2016326171797031,
                "generation": 0.2235147202642261,
                "ide": 0.1700894396437241,
                "implement": 0.1683575939956336,
                "important": 0.14801088244692073,
                "interface": 0.1779560477966888,
                "keeping": 0.19092279822522348,
                "keyboard": 0.2016326171797031,
                "keystrokes": 0.2318219012264162,
                "language": 0.10912459222283807,
                "layout": 0.4636438024528324,
                "mac": 0.2109885426449168,
                "nice": 0.1683575939956336,
                "pc": 0.20601744024858,
                "problem": 0.1207651588529176,
                "programming": 0.09841477326835846,
                "read": 0.13931387626955116,
                "requires": 0.19416205497346978,
                "switched": 0.21672725920305963,
                "think": 0.09841477326835846,
                "time": 0.09136967818322052,
                "times": 0.15326295197227707,
                "type": 0.1621385098966455,
                "unlike": 0.2235147202642261
            },
            "Max term": "layout",
            "Max score": 0.4636438024528324
        }
    },
    {
        "ID": "4889",
        "Question": "why not combine the best features of the all existent programming languages and fit it in a universal programming language? ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "best": 0.32416217809422204,
                    "features": 0.3875453283245449,
                    "fit": 0.5244420670485217,
                    "language": 0.289461593534574,
                    "languages": 0.33660871479011956,
                    "programming": 0.5221059069697195
                },
                "Max term": "fit",
                "Max score": 0.5244420670485217
            }
        ],
        "Best Answer": "For the same reason you don't use a Swiss army knife to carve a chicken...   The Swiss Army knife generally has a blade, as well as various tools, such as screwdrivers and can openers and many others. These attachments are stowed inside the handle of the knife through a pivot point mechanism... The design of the knife and its flexibility have both led to worldwide recognition...  ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "army": 0.632220060141631,
                "design": 0.1812432584450087,
                "flexibility": 0.3047824410472191,
                "generally": 0.21732845957270255,
                "handle": 0.24573661934032429,
                "inside": 0.2749442237456303,
                "mechanism": 0.3161100300708155,
                "point": 0.1812432584450087,
                "reason": 0.19674555641010996,
                "tools": 0.20898783117726322,
                "use": 0.11906754682172192,
                "various": 0.24901283251938083
            },
            "Max term": "army",
            "Max score": 0.632220060141631
        }
    },
    {
        "ID": "4951",
        "Question": "What are the key differences between software engineers and programmers? ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "differences": 0.5429620282036272,
                    "engineers": 0.5429620282036272,
                    "key": 0.46900581099447836,
                    "programmers": 0.32738163956815863,
                    "software": 0.28851218897142505
                },
                "Max term": "differences",
                "Max score": 0.5429620282036272
            }
        ],
        "Best Answer": "When hiring, we look for a distinction between someone who is going to be able to help us architect our system, define processes, create technical specifications, implement advanced refactoring, etc. and someone who is going to help us complete programming tasks off a checklist.  I believe you could call the former a Software Engineer and the latter a Programmer. ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "able": 0.16912923076616446,
                "advanced": 0.2384890640308381,
                "architect": 0.2587441935430867,
                "believe": 0.1911436121958568,
                "checklist": 0.2683607182898122,
                "complete": 0.18606767130281635,
                "create": 0.17248903699144352,
                "define": 0.21437203693485238,
                "engineer": 0.2508869207138049,
                "going": 0.27744443893567006,
                "help": 0.29126459240479086,
                "hiring": 0.2288725392841126,
                "implement": 0.19489342730428985,
                "look": 0.15462872841690425,
                "processes": 0.2288725392841126,
                "programmer": 0.13872221946783503,
                "programming": 0.11392650610190137,
                "refactoring": 0.22101526645483083,
                "software": 0.12672525579169738,
                "specifications": 0.2683607182898122,
                "tasks": 0.19689823935884518,
                "technical": 0.17133975055001602
            },
            "Max term": "help",
            "Max score": 0.29126459240479086
        }
    },
    {
        "ID": "5015",
        "Question": "I'm currently using Planning Poker to do our detailed estimates. This works great but relies upon a fairly detailed work breakdown. Often it takes 6-8 weeks to get a sufficiently detailed design and work breakdown. I've found the 6-8 weeks of analysis are often wasted as the estimate comes out so high it doesn't make economic sense to continue the project. I think providing a high-level estimate up front with a wide range might be better to weed out these shaky business cases. What tools and techniques exist for high-level initial estimates? Right now I just pick a previous project that \"feels\" the same and provide a -50%/+100% range. ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "100": 0.11585148574962052,
                    "50": 0.12112156763683653,
                    "analysis": 0.12317655456858558,
                    "better": 0.07353469429670424,
                    "breakdown": 0.294135979046067,
                    "business": 0.095840470056786,
                    "cases": 0.10196946299788125,
                    "comes": 0.1128954513549715,
                    "continue": 0.12542753806909818,
                    "currently": 0.10905716850237884,
                    "design": 0.08432216348256863,
                    "detailed": 0.3762826142072945,
                    "estimate": 0.23496184302144266,
                    "estimates": 0.23846232582227156,
                    "exist": 0.1128954513549715,
                    "fairly": 0.11585148574962052,
                    "feels": 0.13385129107744065,
                    "great": 0.09097876925513525,
                    "high": 0.2961201124480851,
                    "initial": 0.14179790763581748,
                    "level": 0.17981012772684715,
                    "make": 0.06674037704946256,
                    "pick": 0.11154551531735887,
                    "planning": 0.1102685853687656,
                    "poker": 0.14179790763581748,
                    "previous": 0.10680618500186626,
                    "project": 0.1388968453344956,
                    "provide": 0.10680618500186626,
                    "providing": 0.13749193720355585,
                    "range": 0.26139523991262836,
                    "right": 0.08432216348256863,
                    "sense": 0.1057563476778671,
                    "sufficiently": 0.14179790763581748,
                    "takes": 0.09652508178825218,
                    "techniques": 0.12112156763683653,
                    "think": 0.06243440661720093,
                    "tools": 0.0972301326823886,
                    "using": 0.06901104996419719,
                    "weeks": 0.225790902709943,
                    "wide": 0.1279158848840782,
                    "work": 0.12454192679496051,
                    "works": 0.0987067041493617
                },
                "Max term": "detailed",
                "Max score": 0.3762826142072945
            }
        ],
        "Best Answer": "If you are doing detailed planning poker sessions for all of the requirements up front, you are wasting a lot of time, as in my experience, detailed project requirements simply aren't that fixed, so you spend a lot of time estimating items that you never build, or are so greatly changed by the time you build them that the initial estimate is not valid. All estimates are guesses, but you can get better at estimating if you do it often and keep data about how accurate your estimates are. Estimation is best done at two levels, once initially on the project and another as an ongoing process within the project. First, when asked for a project estimate - estimate at the feature level, using your experience on previous projects. Keep the data on your previous initial estimates and see how you track against them. You can do this initial estimate similarly to planning poker, but don't break the work down into tasks. Simply give yourself some big buckets (increments of a half week or week for the features could work, but not much more granular than that) to estimate. If more than one team member is estimating, don't waste time on too much discussion at this point, just go with the most pessimistic estimate rather than getting down into the weeds. Second, as you work through your short project iterations (assuming that you do have short iterations), you pick the highest priority items and estimate them at the task level (and of course develop and deliver them). Once you've cycled through that first iteration you can see how accurate your detailed estimates are, as well as how they compare to your initial ballpark estimates. Now you can revise those initial estimates as you see how accurate they are, and once you have a few cycles under your belt you can give a confidence interval for the project completion date. The units for the ballpark estimate are a good communication tool for the precision of the estimate. Your initial units are in days or weeks, but your detailed estimates are in hours. ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "accurate": 0.1872079210673273,
                "asked": 0.044129256776276896,
                "assuming": 0.05590540355560749,
                "best": 0.035187098273395126,
                "better": 0.033374750368638156,
                "big": 0.04154421398367904,
                "break": 0.05332036076300963,
                "build": 0.08825851355255379,
                "changed": 0.05332036076300963,
                "communication": 0.05692704392729934,
                "compare": 0.0643569653128037,
                "confidence": 0.066748865749602,
                "course": 0.04710522210499669,
                "data": 0.08160934350828504,
                "date": 0.05411473232302448,
                "days": 0.04589043937750527,
                "deliver": 0.062402640355775765,
                "detailed": 0.22770817570919735,
                "develop": 0.049497122541794975,
                "discussion": 0.0549727189702714,
                "estimate": 0.4798832468670867,
                "estimates": 0.37880312626117135,
                "estimating": 0.20024659724880597,
                "estimation": 0.060750282148513995,
                "experience": 0.07654158853014652,
                "feature": 0.041802518307547054,
                "features": 0.04206720115629061,
                "fixed": 0.05411473232302448,
                "getting": 0.040569077419144416,
                "good": 0.02918851467230713,
                "granular": 0.066748865749602,
                "greatly": 0.062402640355775765,
                "half": 0.05692704392729934,
                "highest": 0.066748865749602,
                "hours": 0.047542797584767045,
                "initial": 0.38614179187682224,
                "initially": 0.05931894436409763,
                "items": 0.12480528071155153,
                "iteration": 0.0643569653128037,
                "iterations": 0.1287139306256074,
                "level": 0.08160934350828504,
                "levels": 0.060750282148513995,
                "lot": 0.06848533343242526,
                "member": 0.05931894436409763,
                "ongoing": 0.066748865749602,
                "pick": 0.050626493576445164,
                "planning": 0.10009388208880772,
                "point": 0.03827079426507326,
                "poker": 0.1287139306256074,
                "precision": 0.0643569653128037,
                "previous": 0.09695096434020625,
                "priority": 0.0643569653128037,
                "process": 0.04080467175414252,
                "project": 0.18912083273206315,
                "projects": 0.038850346797114584,
                "requirements": 0.08891820318617781,
                "second": 0.049497122541794975,
                "short": 0.09599799760929756,
                "similarly": 0.062402640355775765,
                "simply": 0.08959883881216094,
                "spend": 0.046684810937520124,
                "task": 0.044129256776276896,
                "tasks": 0.04897413536918341,
                "team": 0.03989185577641727,
                "time": 0.10523289387881461,
                "tool": 0.046684810937520124,
                "track": 0.05590540355560749,
                "units": 0.1287139306256074,
                "using": 0.03132163106491523,
                "valid": 0.060750282148513995,
                "waste": 0.05931894436409763,
                "wasting": 0.066748865749602,
                "week": 0.1024783618879008,
                "weeks": 0.0512391809439504,
                "work": 0.08478764528019478
            },
            "Max term": "estimate",
            "Max score": 0.4798832468670867
        }
    },
    {
        "ID": "5034",
        "Question": "I'd like to know at what point can be considerated an AI implementation?  I means, what is the minimal requeriment for that? Can you give a simple code example? ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "code": 0.18677817600928376,
                    "example": 0.28474587699224424,
                    "implementation": 0.4326071483050956,
                    "know": 0.23269864013628458,
                    "like": 0.19021392377483798,
                    "means": 0.34532455599206907,
                    "minimal": 0.5336076743790701,
                    "point": 0.3059466148988062,
                    "simple": 0.33009881781582
                },
                "Max term": "minimal",
                "Max score": 0.5336076743790701
            }
        ],
        "Best Answer": "Any program in which the decisions made at time t are impacted by the outcome of decisions made at time t-1.  It learns. A very simple construct within the field of Neural Networks is a Perceptron.  It learns by adjusting weights given to different input values based on the accuracy of the result.  It is trained with a known set of good inputs.  Here is an article that covers the theory behind a single layer Perceptron network including an introduction to the the proof that networks of this type can solve specific types of problems:  If the exemplars used to train the perceptron are drawn from two linearly separable classes, then the perceptron algorithm converges and positions the decision surface in the form of a hyperplane between the two classes.  Here is a book chapter in PDF form that covers the topic.  Here is an Excel Spreadsheet that explains a bit more with a concrete example. And finally, here is a beautiful Javascript Example that you can watch learn.   ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "accuracy": 0.15290030200829363,
                "algorithm": 0.12044583744345139,
                "article": 0.12044583744345139,
                "based": 0.09762196111291933,
                "beautiful": 0.15290030200829363,
                "bit": 0.10108601266433519,
                "book": 0.09827677469781415,
                "chapter": 0.1358807285521219,
                "classes": 0.2518498326039845,
                "construct": 0.15290030200829363,
                "covers": 0.2948424462995055,
                "decision": 0.142944489758164,
                "decisions": 0.26597735501606873,
                "different": 0.08227337608334666,
                "drawn": 0.15290030200829363,
                "example": 0.16318255031992573,
                "field": 0.12806139837063654,
                "finally": 0.13040164969358103,
                "form": 0.21990070785196178,
                "given": 0.10601329180173304,
                "good": 0.06686155125558642,
                "including": 0.11737257484460455,
                "input": 0.12806139837063654,
                "inputs": 0.14742122314975276,
                "introduction": 0.14742122314975276,
                "javascript": 0.12395954331759937,
                "known": 0.11737257484460455,
                "layer": 0.12592491630199226,
                "learn": 0.08297496821967953,
                "network": 0.142944489758164,
                "pdf": 0.14742122314975276,
                "positions": 0.14742122314975276,
                "problems": 0.09240271594067696,
                "program": 0.09347045173715005,
                "proof": 0.14742122314975276,
                "result": 0.12592491630199226,
                "set": 0.09636250278123755,
                "simple": 0.09458673733534907,
                "single": 0.10035300138843281,
                "solve": 0.10890534284582057,
                "specific": 0.09964123983624809,
                "theory": 0.13298867750803436,
                "time": 0.1205274507258081,
                "topic": 0.142944489758164,
                "train": 0.15290030200829363,
                "trained": 0.14742122314975276,
                "type": 0.10693996986142765,
                "types": 0.1121840799008311,
                "used": 0.07461174749870214,
                "values": 0.13040164969358103,
                "watch": 0.1358807285521219
            },
            "Max term": "covers",
            "Max score": 0.2948424462995055
        }
    },
    {
        "ID": "5074",
        "Question": "What are the preferred use cases for the following sets of terms:  Log in / Log out Log on / Log off Sign in / Sign out Sign on / Sign off  From what I can guess, \"Logging in\" should be used for a long-lived session (like a website), whereas \"Sign in\" should be for something that you will be attending to (like IM or a financial transaction). I'm a little fuzzy here... ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "cases": 0.11004294821578217,
                    "following": 0.11412966145803471,
                    "guess": 0.1286713521891375,
                    "im": 0.15302483065345504,
                    "like": 0.11315154117633262,
                    "little": 0.10067060886790478,
                    "log": 0.5228457227651264,
                    "logging": 0.14444903659987343,
                    "long": 0.08804616567858238,
                    "preferred": 0.14444903659987343,
                    "session": 0.15871217401251433,
                    "sets": 0.15302483065345504,
                    "sign": 0.6902184576850744,
                    "terms": 0.12037718945353189,
                    "transaction": 0.15871217401251433,
                    "use": 0.0597813021186923,
                    "used": 0.07744780420217529,
                    "website": 0.1218340073783719
                },
                "Max term": "sign",
                "Max score": 0.6902184576850744
            }
        ],
        "Best Answer": "I've always used Login/Logout without the space.   I notice that Microsoft is preferential to Sign in/Sign out. ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "login": 0.4039432968690935,
                "microsoft": 0.29954113287963113,
                "notice": 0.3274854656819595,
                "sign": 0.7026785968799746,
                "space": 0.3274854656819595,
                "used": 0.19711481844002693
            },
            "Max term": "sign",
            "Max score": 0.7026785968799746
        }
    },
    {
        "ID": "5119",
        "Question": "I'm freelancing on a project where I'm the only programmer, and find myself at the end of a line of four middlemen, who stand between me and the actual customer, each passing my work as internal to their own company. Communication is terrible and the requirements, made by an advertising company, are flimsy. I've managed to communicate with people upper the ladder by keeping asking questions that made people face their ignorance, but they won't let me contact the end client since, from his end, it's pretty much a done deal.  The project will soon be over though, and I've decided it's the last time I'll be working under these conditions. The middlemen, are pretty much useless from the perspective of shipping a product, but still necessary to me since they are the ones bringing the contracts in. Hence I'm not thinking about crossing them altogether, which would probably end badly. Rather I'm looking for a way to make them understand I need to be part of the requirements and design process, meet the clients, and shouldn't have to go through a whole channel of clueless people each time I require some information. Sorry for the venting :) Any ideas ? ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "actual": 0.12344330251648829,
                    "advertising": 0.15453197070408378,
                    "asking": 0.1090544793621772,
                    "badly": 0.15453197070408378,
                    "bringing": 0.1444699154513156,
                    "client": 0.10714460787696989,
                    "clients": 0.12173116978036232,
                    "communicate": 0.1489944221019399,
                    "communication": 0.13179322503313048,
                    "company": 0.1827237173526847,
                    "conditions": 0.13733077363527438,
                    "contact": 0.12942799982345216,
                    "contracts": 0.13733077363527438,
                    "customer": 0.11338124726372013,
                    "deal": 0.12173116978036232,
                    "decided": 0.14064449958529768,
                    "design": 0.08860167422736442,
                    "end": 0.34447197976857025,
                    "face": 0.13733077363527438,
                    "ideas": 0.11862511099791992,
                    "information": 0.10292837949765558,
                    "internal": 0.13440786019854745,
                    "keeping": 0.12726871838250622,
                    "let": 0.100704556845535,
                    "line": 0.10537127638798242,
                    "looking": 0.09136185867634235,
                    "make": 0.07012757857393413,
                    "managed": 0.12173116978036232,
                    "meet": 0.13179322503313048,
                    "necessary": 0.10714460787696989,
                    "need": 0.0727422137393511,
                    "ones": 0.10714460787696989,
                    "passing": 0.15453197070408378,
                    "people": 0.20734360986724354,
                    "perspective": 0.13440786019854745,
                    "pretty": 0.19355611400774417,
                    "probably": 0.0877458624641677,
                    "process": 0.09446791745878477,
                    "product": 0.10142391392911052,
                    "programmer": 0.07988135555539233,
                    "project": 0.1459461253514877,
                    "questions": 0.09932553087874665,
                    "require": 0.10808117493989877,
                    "requirements": 0.20585675899531117,
                    "soon": 0.12344330251648829,
                    "sorry": 0.1489944221019399,
                    "stand": 0.14064449958529768,
                    "terrible": 0.1444699154513156,
                    "thinking": 0.0973908308955117,
                    "time": 0.12181365399519094,
                    "understand": 0.08459036923966398,
                    "upper": 0.1444699154513156,
                    "useless": 0.12942799982345216,
                    "way": 0.06795106972396,
                    "work": 0.06543133364821975,
                    "working": 0.0824619727830512
                },
                "Max term": "end",
                "Max score": 0.34447197976857025
            }
        ],
        "Best Answer": "Sell the middlemen on giving some progress demos to the client then lead the client into some of the issues that you are facing during the demo. ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "client": 0.48594742319927925,
                "demo": 0.35043486766867493,
                "demos": 0.3378772713165444,
                "facing": 0.35043486766867493,
                "giving": 0.28860951090916753,
                "issues": 0.25986235710705746,
                "lead": 0.272419953459188,
                "progress": 0.304799068359147,
                "sell": 0.2935061514073743
            },
            "Max term": "client",
            "Max score": 0.48594742319927925
        }
    },
    {
        "ID": "5120",
        "Question": "Let me explain this a little. In a previous job, I had a coworker that has a good reputation with the management. He always finished on time. And the bosses were happy with his progress so het got certain privileges. The problem was that the other programmers knew his secret. He has optimized the 80/20 rule, so he worked his 20 percent time to finish 80 percent of the code. The other (hard) 20% was left to the maintenance programmers. Who (not surprisingly) got penalized because of their lack of progress. But because this programmer had a good reputation with the management, it was almost imposible to shift the blame to him. (Fortunately he left the company). My question is, what to do as programming team if you have such a programmer within your team. Do you try to warn management with risk of ruining your own chances? Do you accept the fact? Or are there other options. ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "20": 0.34432054940656304,
                    "80": 0.23318649082137832,
                    "accept": 0.11857140339133526,
                    "blame": 0.1364965675912953,
                    "certain": 0.1008349081170452,
                    "chances": 0.1364965675912953,
                    "code": 0.0495534762756753,
                    "company": 0.08369830187031792,
                    "coworker": 0.1364965675912953,
                    "explain": 0.09161687172654773,
                    "fact": 0.0957618566135099,
                    "finish": 0.1288470479173632,
                    "finished": 0.13235158270433314,
                    "good": 0.12381354672313764,
                    "got": 0.18198794086205747,
                    "happy": 0.11857140339133526,
                    "hard": 0.09359502970719384,
                    "job": 0.07853626992025467,
                    "knew": 0.1415696190948306,
                    "lack": 0.11477351646885435,
                    "left": 0.2462670926276714,
                    "let": 0.09225732182653996,
                    "little": 0.08979714278471293,
                    "maintenance": 0.1231335463138357,
                    "management": 0.27874901478244607,
                    "options": 0.11857140339133526,
                    "percent": 0.2831392381896612,
                    "previous": 0.10281306609769128,
                    "privileges": 0.1415696190948306,
                    "problem": 0.07374919042716435,
                    "programmer": 0.14636159789110573,
                    "programmers": 0.15171706886580752,
                    "programming": 0.060100197139259785,
                    "progress": 0.2462670926276714,
                    "question": 0.07262627206267339,
                    "reputation": 0.2462670926276714,
                    "risk": 0.11152019390715388,
                    "rule": 0.11308871062371924,
                    "shift": 0.1364965675912953,
                    "team": 0.16921560430521576,
                    "time": 0.11159575923400125,
                    "try": 0.08116964544218273,
                    "worked": 0.09291633826081536
                },
                "Max term": "20",
                "Max score": 0.34432054940656304
            }
        ],
        "Best Answer": "Try to implement a code review team. It sounds like this programmer was working solo on a project with no team interaction. I'd try to encourage a more team-based workflow so that he can't just stomp over everything and then leave it on your door. ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "based": 0.19413355629553014,
                "code": 0.10643034959134073,
                "encourage": 0.2644647230740521,
                "implement": 0.22082064447830274,
                "leave": 0.23952170697374037,
                "like": 0.10838811491279579,
                "programmer": 0.15717682391885168,
                "project": 0.14358387064490005,
                "review": 0.23637036667887257,
                "solo": 0.2644647230740521,
                "sounds": 0.23341013749754363,
                "team": 0.5451588044698282,
                "try": 0.34867034121104984,
                "workflow": 0.30406149445406255,
                "working": 0.1622545196686744
            },
            "Max term": "team",
            "Max score": 0.5451588044698282
        }
    },
    {
        "ID": "5225",
        "Question": "Suppose I develop a useful library and decide to publish it as open source. Some time later I have a business need to do something that wouldn't comply with the open source licence. Am I allowed to do that? How should I publish the software in a way that I keep ownership and don't block myself from using the library in the future in any way? Keep in mind that at least in theory, other developers may decide to contribute to my open-source project. Can I specify in a licence that I as the original developer get ownership of their contributions as well? Don't get me wrong here, I'm not trying to be evil and get ownership of other's work - I just want to keep ownership of mine, and if someone posts an important bugfix I could be rendered unable to use the original code unless I use his work as well. ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "allowed": 0.1208013114386411,
                    "block": 0.11632557867119589,
                    "business": 0.09050990408460712,
                    "code": 0.04861489902343976,
                    "contribute": 0.1339112278133813,
                    "decide": 0.21881584798247636,
                    "develop": 0.10299150092899868,
                    "developer": 0.0767029350948591,
                    "developers": 0.07924433285130313,
                    "evil": 0.1208013114386411,
                    "future": 0.11259962636440517,
                    "important": 0.08867567637057092,
                    "later": 0.10413553981276223,
                    "library": 0.20173143045800915,
                    "licence": 0.25968950363718585,
                    "mind": 0.09394806054904686,
                    "need": 0.06537828073211537,
                    "open": 0.2593302842694562,
                    "original": 0.21593693062832423,
                    "ownership": 0.5356449112535252,
                    "posts": 0.12984475181859292,
                    "project": 0.06558576007312464,
                    "publish": 0.25968950363718585,
                    "software": 0.06558576007312464,
                    "source": 0.24766401930493182,
                    "specify": 0.13888819219854473,
                    "suppose": 0.12640659535415316,
                    "theory": 0.1208013114386411,
                    "time": 0.054741029029160004,
                    "trying": 0.08591860697405719,
                    "unable": 0.12342832875635343,
                    "unless": 0.10299150092899868,
                    "use": 0.10462860874031663,
                    "useful": 0.08988158455425847,
                    "using": 0.06517271367029627,
                    "want": 0.06558576007312464,
                    "way": 0.12214431989598208,
                    "work": 0.11761501004789678,
                    "wrong": 0.08988158455425847
                },
                "Max term": "ownership",
                "Max score": 0.5356449112535252
            }
        ],
        "Best Answer": "You always keep ownership under open-source licenses.  The work you created is your property, and you can do whatever you want to with it, (within legal limits, of course,) including allowing other people to use it under the terms of an open-source license.  If you want to use it for a proprietary project, you're welcome to do so, unless you have completely turned over the rights to someone else by contract.  But this is not what open-source licenses do.  They're about sharing usefulness, not about giving up ownership. Things get a bit sticker once other people start contributing.  It's their work, then, not yours, and you need to get their permission.  One thing you can do is publish your library under a dual license.  That's what Sam Lantinga, the primary creator and maintainer of SDL, does.  Because Apple doesn't like dynamic link libraries for iOS, and complying with the LGPL in a statically linked app is more trouble than it's worth, he publishes SDL under both the LGPL and a commercial license for static iPhone apps.  When anyone submits a patch, he explicitly asks them for permission to deploy their patch in the library under both licenses, and if they don't like that, he doesn't add it to the codebase. EDIT: My example is no longer accurate.  A while back Sam changed the model (not sure why; maybe he just got tired of the administration hassles) and now licenses SDL under a highly permissive zlib-style license.  But he used to do it this way. ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "accurate": 0.09930315237405404,
                "add": 0.07129063043146386,
                "allowing": 0.10241312701438511,
                "app": 0.06922050118153289,
                "apple": 0.09930315237405404,
                "apps": 0.08367339915447485,
                "asks": 0.10621942835331495,
                "bit": 0.0702241809773484,
                "changed": 0.0848502544011121,
                "codebase": 0.09238687639479314,
                "commercial": 0.09667370628176146,
                "completely": 0.0787662232530864,
                "contract": 0.08257252459201624,
                "course": 0.07495992191415654,
                "created": 0.08367339915447485,
                "creator": 0.10621942835331495,
                "deploy": 0.10621942835331495,
                "dual": 0.10621942835331495,
                "dynamic": 0.10241312701438511,
                "edit": 0.07074907271136688,
                "example": 0.05668123929303415,
                "explicitly": 0.10241312701438511,
                "giving": 0.08747970049340469,
                "got": 0.06827261092161295,
                "highly": 0.08747970049340469,
                "including": 0.08153841189714799,
                "ios": 0.10621942835331495,
                "iphone": 0.09667370628176146,
                "legal": 0.0943959764726656,
                "lgpl": 0.2124388567066299,
                "libraries": 0.07793397842185121,
                "library": 0.15428091391321863,
                "license": 0.3444574446797152,
                "licenses": 0.362358700534943,
                "like": 0.07572759995146276,
                "limits": 0.10241312701438511,
                "link": 0.08747970049340469,
                "linked": 0.09667370628176146,
                "longer": 0.07964116556692696,
                "maybe": 0.07129063043146386,
                "model": 0.07964116556692696,
                "need": 0.05000024477358416,
                "open": 0.1983315796236055,
                "ownership": 0.20482625402877022,
                "patch": 0.2124388567066299,
                "people": 0.09501343362785594,
                "primary": 0.0848502544011121,
                "project": 0.050158921595913473,
                "proprietary": 0.10241312701438511,
                "publish": 0.09930315237405404,
                "rights": 0.0943959764726656,
                "sam": 0.2124388567066299,
                "sharing": 0.0943959764726656,
                "source": 0.18940941010052154,
                "start": 0.05919425056194093,
                "static": 0.09058967513373575,
                "statically": 0.09930315237405404,
                "style": 0.0787662232530864,
                "sure": 0.06246745740863008,
                "terms": 0.08056342451414378,
                "thing": 0.06060477570096438,
                "things": 0.05048077332162263,
                "tired": 0.10241312701438511,
                "trouble": 0.0943959764726656,
                "turned": 0.09058967513373575,
                "unless": 0.0787662232530864,
                "use": 0.08001825665577014,
                "used": 0.05183258020853443,
                "want": 0.10031784319182695,
                "way": 0.04670699369968325,
                "welcome": 0.10621942835331495,
                "work": 0.08995004496277036,
                "worth": 0.07129063043146386
            },
            "Max term": "licenses",
            "Max score": 0.362358700534943
        }
    },
    {
        "ID": "5232",
        "Question": "I tend to understand things rather quickly, but after 2 years of programming in Python I still stumble across things (like Flask today) that amaze me. I look at the code, have no idea what's going on, and then feel very humbled. I feel like an absolute expert each time this happens, up until the moment it happens. Then, for about a 2 week period I feel like an absolute beginner.  Does this often happen, or does it indicated that I have so much more to learn before I can even be considered a \"good\" programmer? ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "absolute": 0.4301524204675655,
                    "beginner": 0.2010719320182904,
                    "code": 0.07528291698053369,
                    "considered": 0.16312718206618665,
                    "expert": 0.18706765380279802,
                    "feel": 0.3877515504253687,
                    "going": 0.11117815389859055,
                    "good": 0.09405036396607853,
                    "happen": 0.16312718206618665,
                    "happens": 0.3388486996496139,
                    "idea": 0.1245486748861847,
                    "learn": 0.11671619659710833,
                    "like": 0.2300031942388857,
                    "look": 0.12392633733101444,
                    "moment": 0.177131460281679,
                    "period": 0.1957477525408486,
                    "programmer": 0.11117815389859055,
                    "programming": 0.09130576685635247,
                    "python": 0.14548387808819557,
                    "quickly": 0.15466094654921209,
                    "tend": 0.16312718206618665,
                    "things": 0.20442989731730002,
                    "time": 0.08476957530744347,
                    "today": 0.16942434982480695,
                    "understand": 0.11773211689108737,
                    "week": 0.1651013650816025,
                    "years": 0.1264859377485917
                },
                "Max term": "absolute",
                "Max score": 0.4301524204675655
            }
        ],
        "Best Answer": "You will never, ever, ever, ever, ever, in the entirety of your career, be in a position where you immediately understand every programming technology simply by looking at it.  There's just too much there.  Its the accumulation of research and knowlege of millions of individuals over many decades.  If you ever find yourself thinking you are at that point, seek a therapist to discuss your delusions. The trait you need most is the ability and willingness to learn.  If you have that, nothing will be beyond you. ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "ability": 0.2647394913016634,
                "career": 0.25194621217018437,
                "decades": 0.33376573051734465,
                "discuss": 0.3172723251183438,
                "immediately": 0.3105195812311441,
                "learn": 0.19374094747792187,
                "looking": 0.21107133209894957,
                "need": 0.16805476788933946,
                "point": 0.20469453748328317,
                "position": 0.27753277043314245,
                "programming": 0.15156136249033864,
                "research": 0.29901471718539635,
                "simply": 0.23961343397610585,
                "technology": 0.2647394913016634,
                "thinking": 0.22499993661646203,
                "understand": 0.19542730606444236
            },
            "Max term": "decades",
            "Max score": 0.33376573051734465
        }
    },
    {
        "ID": "5297",
        "Question": "I've only been a year in the industry and I've had some problems making estimates for specific tasks. Before you close this, yes, I've already read this: How to respond when you are asked for an estimate? and that's about the same problem I'm having. But I'm looking for a more specific gauge of experiences, something quantifiable or probably other programmer's average performances which I should aim for and base my estimates.  The answers range from weeks, and I was looking more for an answer on the level of a task assigned for a day or so. (Note that this doesn't include submitting for QA or documentations, just the actual development time from writing tests if I used TDD, to making the page, before having it submitted to testing) My current rate right now is as follows (on ASP.NET webforms):  Right now, I'm able to develop a simple data entry page with a grid listing (no complex logic, just Creating and Reading) on an already built architecture, given one full day's (8 hours) time.   Adding complex functionality, and Update and Delete pages add another full day to the task. If I have to start the page from scratch (no solution, no existing website) it takes me another full day. (Not always) but if I encounter something new or haven't done yet it takes me another full day.  Whenever I make an estimate that's longer than the expected I feel that others think that I'm lagging a lot behind everyone else. I'm just concerned as there have been expectations that when it's just one page it should take me no more than a full day. Yes, there definitely is more room for improvement.  There always is. I have a lot to learn. But I would like to know if my current rate is way too slow, just average, or average for someone no longer than a year in the industry.  ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "able": 0.06240467887359882,
                    "actual": 0.07909820238522045,
                    "add": 0.06645779383737448,
                    "adding": 0.08612391204236525,
                    "answer": 0.058541521820562006,
                    "answers": 0.06987834174682879,
                    "architecture": 0.08154939667611771,
                    "asked": 0.06546363966128367,
                    "asp": 0.08293298960453745,
                    "assigned": 0.09901874661937149,
                    "average": 0.23729460715566134,
                    "base": 0.07697488130987017,
                    "built": 0.07909820238522045,
                    "close": 0.08444854418310015,
                    "complex": 0.14530157019343468,
                    "concerned": 0.09901874661937149,
                    "creating": 0.07601087176381578,
                    "current": 0.14530157019343468,
                    "data": 0.06053177695134326,
                    "day": 0.37684358771582044,
                    "definitely": 0.07265078509671734,
                    "delete": 0.09901874661937149,
                    "develop": 0.07342661152834948,
                    "development": 0.050048922619264344,
                    "encounter": 0.09257132933086837,
                    "entry": 0.09901874661937149,
                    "estimate": 0.1581964047704409,
                    "estimates": 0.16055322912511436,
                    "existing": 0.07120421668962025,
                    "expectations": 0.08799681396462083,
                    "expected": 0.09257132933086837,
                    "experiences": 0.08027661456255718,
                    "feel": 0.0595055313666164,
                    "follows": 0.09901874661937149,
                    "functionality": 0.07265078509671734,
                    "given": 0.06865456209911149,
                    "grid": 0.09901874661937149,
                    "hours": 0.07052746402136706,
                    "improvement": 0.09901874661937149,
                    "include": 0.07510197938761459,
                    "industry": 0.14530157019343468,
                    "know": 0.043180652739185636,
                    "learn": 0.053734866746366475,
                    "level": 0.06053177695134326,
                    "like": 0.035296989204014126,
                    "listing": 0.09901874661937149,
                    "logic": 0.07424224095343519,
                    "longer": 0.14848448190687039,
                    "looking": 0.11708304364112401,
                    "lot": 0.10159471329037413,
                    "make": 0.04493532893034505,
                    "making": 0.13291558767474895,
                    "net": 0.06053177695134326,
                    "new": 0.046907925772157785,
                    "note": 0.07424224095343519,
                    "page": 0.3120045075783881,
                    "pages": 0.09901874661937149,
                    "probably": 0.05622451640686953,
                    "problem": 0.05158276505215106,
                    "problems": 0.05984030768085309,
                    "programmer": 0.05118521215585771,
                    "qa": 0.09012013503997111,
                    "range": 0.08799681396462083,
                    "rate": 0.1658659792090749,
                    "read": 0.0595055313666164,
                    "reading": 0.06645779383737448,
                    "right": 0.11354578202036282,
                    "room": 0.09012013503997111,
                    "scratch": 0.08799681396462083,
                    "simple": 0.061254687235699184,
                    "slow": 0.08293298960453745,
                    "solution": 0.0675182725625181,
                    "specific": 0.1290559998978982,
                    "start": 0.055181435153463555,
                    "submitting": 0.09901874661937149,
                    "takes": 0.12997787821813025,
                    "task": 0.13092727932256734,
                    "tasks": 0.07265078509671734,
                    "tdd": 0.07697488130987017,
                    "testing": 0.05823274925305586,
                    "tests": 0.0628072646193034,
                    "think": 0.04203618142336262,
                    "time": 0.07805397992902736,
                    "update": 0.07510197938761459,
                    "used": 0.048318817055062274,
                    "way": 0.043540697273552795,
                    "website": 0.07601087176381578,
                    "weeks": 0.07601087176381578,
                    "writing": 0.055181435153463555,
                    "year": 0.14382211389957358,
                    "yes": 0.1290559998978982
                },
                "Max term": "day",
                "Max score": 0.37684358771582044
            }
        ],
        "Best Answer": "If you're programming for a job, and your superiors are happy with the rate you're turning stuff out at, then I'd say you're doing fine.  As you've lasted a year, they're clearly not outraged with your output.  Also, you've only been there a year, and assuming they've been managing people for more than a day, they know that there's a learning curve when you're still green. As for estimates... I've been in the industry for 5 years now (certainly not veteran territory, I know!), and my personal estimates still suck.  I overestimate almost as often as I underestimate, and I do both far more than I get it right.  Something will come up, somewhere, and bite you.  Sometimes you'll find a library that does everything you thought you had to do yourself, and a week's work disappears in half a day.  Other times a stupid bug will stretch a day's work out to 2, 3, 4... If you're repeating a lot of the same work over and over, and you feel like you've maxed out your throughput on it, maybe you should ask to be moved to another task. 'Cross-pollination' and other PHB-friendly terms are definitely of benefit to devs.  If you spend a month or more on something else, maybe you'll find something you're better suited to.  If not, or you're not able to stay away from webforms, the change won't do you any harm, and you might come back with a bit more knowledge and experience that will help you. ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "able": 0.09301012820068437,
                "ask": 0.0912961402177094,
                "assuming": 0.12360624450624973,
                "away": 0.10232517397187842,
                "benefit": 0.1215440889439955,
                "better": 0.07379121322856728,
                "bit": 0.09756931094401233,
                "bite": 0.14229255642922092,
                "bug": 0.10414913819985125,
                "certainly": 0.11472607035387519,
                "change": 0.0912961402177094,
                "clearly": 0.11625562286698352,
                "come": 0.1965971885553927,
                "cross": 0.13431821883914638,
                "curve": 0.1475810225062329,
                "day": 0.2808304684657452,
                "definitely": 0.10828128527690899,
                "devs": 0.1475810225062329,
                "estimates": 0.23929417943497158,
                "experience": 0.0846163134959168,
                "far": 0.09982814679080466,
                "feel": 0.08868913679163781,
                "fine": 0.12360624450624973,
                "friendly": 0.14229255642922092,
                "green": 0.13431821883914638,
                "half": 0.12586508035304206,
                "happy": 0.12360624450624973,
                "help": 0.08008833528411383,
                "industry": 0.10828128527690899,
                "job": 0.0818711182015175,
                "know": 0.12871592706039914,
                "knowledge": 0.092424917275843,
                "learning": 0.09075129235389202,
                "library": 0.10717876843007088,
                "like": 0.05260787412452235,
                "lot": 0.07571016691544218,
                "managing": 0.13115354643005406,
                "maybe": 0.19810206658603338,
                "month": 0.11625562286698352,
                "moved": 0.13797156502017435,
                "output": 0.11964708971748579,
                "people": 0.06600571997048156,
                "personal": 0.10828128527690899,
                "programming": 0.06265220322940042,
                "rate": 0.12360624450624973,
                "repeating": 0.13797156502017435,
                "right": 0.0846163134959168,
                "say": 0.07688076722843444,
                "spend": 0.10321961364130697,
                "stay": 0.11625562286698352,
                "stuff": 0.09301012820068437,
                "stupid": 0.13797156502017435,
                "suck": 0.1475810225062329,
                "suited": 0.12586508035304206,
                "task": 0.09756931094401233,
                "terms": 0.11193463145793695,
                "thought": 0.10232517397187842,
                "times": 0.09756931094401233,
                "underestimate": 0.1475810225062329,
                "week": 0.11328927662168063,
                "work": 0.18746456955969368,
                "year": 0.21435753686014175,
                "years": 0.0867921375651281
            },
            "Max term": "day",
            "Max score": 0.2808304684657452
        }
    },
    {
        "ID": "5331",
        "Question": "So you take a contract where you have solid experience with 75% of the technology necessary.  How do you handle your time to learn the other 25%? Work it into the billing time?  Expose the 25% in the contract as 'research'?  Do the learning on my own time (not billed)?  Not take the contract (too large of an unknown for me and the customer)? On the extreme end of this, I keep hearing a story about Mark Cuban (Dallas billionaire who started broadcast.com and sold it to Yahoo!) when he was at Indiana University.  Someone asked him if he could build a business app for them and he immediately said \"Yes\"... he had no idea how.  So he bought a book, stayed up nights, studied and coded... He finished it (I'm sure it was ugly), it worked and he kept going. I'm not suggesting doing contracts this way (the stress!), but there's a middle ground.  What is it, and how would you (or would you?) bill for the unknown? ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "25": 0.2868275464003182,
                    "75": 0.1534022701508218,
                    "app": 0.09996835971386019,
                    "asked": 0.1014178756976073,
                    "book": 0.09859941506804733,
                    "build": 0.1014178756976073,
                    "business": 0.09996835971386019,
                    "coded": 0.13632682183003436,
                    "com": 0.1192513735092469,
                    "contract": 0.3577541205277407,
                    "contracts": 0.13632682183003436,
                    "customer": 0.11255237763124368,
                    "end": 0.0854884323597935,
                    "experience": 0.08795395479468947,
                    "extreme": 0.1479052036035631,
                    "finished": 0.1434137732001591,
                    "going": 0.07929738570659613,
                    "ground": 0.1479052036035631,
                    "handle": 0.1192513735092469,
                    "hearing": 0.1479052036035631,
                    "idea": 0.08883385778022383,
                    "immediately": 0.1334252762494964,
                    "kept": 0.1396163229026938,
                    "large": 0.10376581001132548,
                    "learn": 0.08324737311441484,
                    "learning": 0.09433092432748255,
                    "mark": 0.1534022701508218,
                    "middle": 0.1534022701508218,
                    "necessary": 0.10636133097804627,
                    "research": 0.12848182096905744,
                    "said": 0.09730255434963905,
                    "sold": 0.1396163229026938,
                    "solid": 0.1396163229026938,
                    "started": 0.09996835971386019,
                    "stayed": 0.1534022701508218,
                    "story": 0.1396163229026938,
                    "stress": 0.1534022701508218,
                    "studied": 0.1479052036035631,
                    "suggesting": 0.1434137732001591,
                    "sure": 0.0902156029795143,
                    "technology": 0.11375430696198818,
                    "time": 0.18138470932347195,
                    "ugly": 0.1534022701508218,
                    "university": 0.1243664996210892,
                    "unknown": 0.3068045403016436,
                    "way": 0.0674543158114062,
                    "work": 0.06495300017789464,
                    "worked": 0.10068245796270003,
                    "yes": 0.09996835971386019
                },
                "Max term": "contract",
                "Max score": 0.3577541205277407
            }
        ],
        "Best Answer": "If I'm learning something that I'll take away with me (like say a mainstream new API, or a new feature of .NET or a language that's somewhat useful) then I don't bill, I consider that time time spent sharpening my saw, and it's not the client's fault I didn't know that stuff yet. Now, if it's something obscure, I bill for it at my normal rate.  Some examples:  APIs and protocols which are not mainstream (industry specific, small 3rd party or just niche products); internal tools, configuration formats and services inside the client organization; a non-standard database schema, database query language or security model; etc. I've never had any objections about the way I do this, and I'm very transparent about it in my proposals. ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "3rd": 0.16084926430261612,
                "api": 0.1703987233838168,
                "apis": 0.16522423331679617,
                "away": 0.12253683152785358,
                "client": 0.24507366305570716,
                "configuration": 0.15705949376247155,
                "consider": 0.11437209197352892,
                "database": 0.2621082722375111,
                "examples": 0.1296694165918795,
                "fault": 0.17673178739500217,
                "feature": 0.11068103847366341,
                "industry": 0.1296694165918795,
                "inside": 0.15371667923859017,
                "internal": 0.15371667923859017,
                "know": 0.0770701932717275,
                "language": 0.16638448852558463,
                "learning": 0.10867683279150855,
                "like": 0.06299918151526192,
                "mainstream": 0.30145285950257233,
                "model": 0.13250989728589554,
                "net": 0.10803902796234358,
                "new": 0.16744549588317448,
                "niche": 0.16522423331679617,
                "non": 0.1044867577241922,
                "normal": 0.14802142005656982,
                "obscure": 0.1703987233838168,
                "organization": 0.14117697067008547,
                "party": 0.14555193968426555,
                "products": 0.15072642975128617,
                "query": 0.15072642975128617,
                "rate": 0.14802142005656982,
                "saw": 0.15371667923859017,
                "say": 0.09206654878682986,
                "security": 0.1296694165918795,
                "services": 0.14555193968426555,
                "small": 0.10562215394516879,
                "somewhat": 0.143280237955313,
                "specific": 0.11517161302636948,
                "spent": 0.15371667923859017,
                "standard": 0.1159943118023982,
                "stuff": 0.11138184248622492,
                "time": 0.1393132094387865,
                "tools": 0.11684157234583319,
                "useful": 0.11437209197352892,
                "way": 0.0777128121320238
            },
            "Max term": "mainstream",
            "Max score": 0.30145285950257233
        }
    },
    {
        "ID": "5341",
        "Question": "I've had a couple of times in the time I've working, moments when I get an error ocurring in just 1 computer and it often takes me hours or days to figure out because it is (or at least seems) an isolated incident as it is not being presented in any other instance of whatever I'm checking. How do you guys deal with this? I've often had to just change the computer per se (like formatting, or stuff like that) because I simply cannot replicat the issue. ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "change": 0.16192452759695378,
                    "checking": 0.23261636250677056,
                    "computer": 0.33205741836554453,
                    "couple": 0.1962566513133383,
                    "days": 0.1799571316763626,
                    "deal": 0.20619312895743172,
                    "error": 0.1941005647294171,
                    "figure": 0.19852933845115311,
                    "formatting": 0.24470892673478517,
                    "guys": 0.24470892673478517,
                    "hours": 0.18643677422313856,
                    "instance": 0.23261636250677056,
                    "isolated": 0.2617524387625939,
                    "issue": 0.17848208655086312,
                    "like": 0.186612602573989,
                    "presented": 0.2523727172410638,
                    "se": 0.2523727172410638,
                    "simply": 0.17567874978849,
                    "stuff": 0.1649644884735938,
                    "takes": 0.17179588598290307,
                    "time": 0.10316642201140776,
                    "times": 0.1730507395481859,
                    "working": 0.13967739091654438
                },
                "Max term": "computer",
                "Max score": 0.33205741836554453
            }
        ],
        "Best Answer": "You have to try to isolate what's different about that machine/environment to every other machine/environment where your application works. That will involve checking the state of your application by adding diagnostics, checking the state of the machine - which may involve remote logging or even physical access, and checking what the user is doing at every step of the way. I've had many problems that only repeated for one user or on one machine and it was only by understanding what they were doing and how they were doing it were we able to resolve things. ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "able": 0.10707854946989788,
                "access": 0.11681028326137496,
                "adding": 0.14777775869736984,
                "application": 0.19483022517898746,
                "checking": 0.45297426574646166,
                "different": 0.09142263345936527,
                "environment": 0.2230256274687852,
                "involve": 0.31768142537283944,
                "logging": 0.1546347727813397,
                "machine": 0.5217002339774999,
                "physical": 0.1546347727813397,
                "problems": 0.10267841229143747,
                "remote": 0.1546347727813397,
                "state": 0.28460507738668755,
                "step": 0.14230253869334378,
                "things": 0.08074670158671812,
                "try": 0.09741511258949373,
                "understanding": 0.13572252802135734,
                "user": 0.20535682458287494,
                "way": 0.07471033888986826,
                "works": 0.11403318298439619
            },
            "Max term": "machine",
            "Max score": 0.5217002339774999
        }
    },
    {
        "ID": "5356",
        "Question": "When you are setting up your system landscape for large and/or multiple application deployments, do you consider mainframe?  If not, why not?  If so, what factors are you considering. If you take a real TCO look at large ERP and/or consolidated application landscapes, mainframe is actually quite cost-effective. My own consultations have included recommendations for scale-up/mainframe/mid-size systems on some specific needs.  Honestly, I've never had a customer take said recommendation, rather defaulting to countless scale-out VMs on Intel boxen (in non-trivial cost) and yet still to this day have system management and performance issues. Curious your take on this.  We need to remember that the virtual machines we manage (and apparently love in IT departments) today have been done for decades on mainframe.  Most mid-size and mainframe shops have small fractions of support persons managing larger and more complex applications. Your thoughts appreciated. ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "actually": 0.06721215572851698,
                    "apparently": 0.10863831957167869,
                    "application": 0.14018033605289174,
                    "applications": 0.08549982580005853,
                    "appreciated": 0.11786508743988108,
                    "complex": 0.08969255650146354,
                    "consider": 0.07911137098590718,
                    "considering": 0.102386668582283,
                    "cost": 0.1775586190833923,
                    "curious": 0.10863831957167869,
                    "customer": 0.08969255650146354,
                    "day": 0.0775400310274662,
                    "decades": 0.11428588383967321,
                    "effective": 0.102386668582283,
                    "factors": 0.09765235127405585,
                    "honestly": 0.1063260890670809,
                    "included": 0.1063260890670809,
                    "issues": 0.09065036935870738,
                    "large": 0.1653811491722301,
                    "larger": 0.10863831957167869,
                    "look": 0.07043763319288214,
                    "love": 0.10425772839929423,
                    "machines": 0.10425772839929423,
                    "mainframe": 0.6112283930613277,
                    "manage": 0.10863831957167869,
                    "management": 0.08023346320690175,
                    "managing": 0.10863831957167869,
                    "mid": 0.23573017487976217,
                    "multiple": 0.08626977818632292,
                    "need": 0.057544217172728014,
                    "needs": 0.0879066650150321,
                    "non": 0.07227366843430943,
                    "performance": 0.09384082224748862,
                    "quite": 0.07804996279903818,
                    "real": 0.07387711186582059,
                    "recommendation": 0.11786508743988108,
                    "recommendations": 0.12224567861226554,
                    "remember": 0.08549982580005853,
                    "said": 0.0775400310274662,
                    "scale": 0.2225194206292854,
                    "setting": 0.10067852479908636,
                    "size": 0.20851545679858846,
                    "small": 0.07305902393584615,
                    "specific": 0.07966440106108454,
                    "support": 0.08081951476910383,
                    "systems": 0.08475893525390173,
                    "thoughts": 0.09503096053109182,
                    "today": 0.0962979336267019,
                    "trivial": 0.1063260890670809,
                    "virtual": 0.1112597103146427,
                    "vms": 0.12224567861226554
                },
                "Max term": "mainframe",
                "Max score": 0.6112283930613277
            }
        ],
        "Best Answer": "It seems to me that you're doing more to express your opinion (\"If you take a real TCO look at large ERP and/or consolidated application landscapes, mainframe is actually quite cost-effective.\") than really ask a question. On that basis, I'm tempted to vote to close, but won't. As for the question (to the extent there is one), I'm going to assume that by \"mainframe\", you mean something like an IBM z series machine, rather than (for example) one of the big Fujitsu SPARC boxes. I think for many people, it's hard to recommend mainframes for a couple of reasons.   Every vendor has TCO numbers to \"prove\" their product is the best. Why should somebody trust numbers from IBM more than from Microsoft, Oracle, etc? Even if a mainframe really would make sense, such a recommendation is unlikely to be taken seriously, and whoever made such a recommendation will often be treated as a pariah. Even if the TCO would theoretically work out better in some respects, introducing machines with which existing staff are thoroughly unfamiliar would often be a mistake anyway. Using a mainframe would often lose versatility in other ways. Just for example, an Intel box can easily run Windows Terminal Server to make Word and Excel available, which is a bit tougher to do with a mainframe.  ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "actually": 0.06361477523422511,
                "application": 0.06633874835292099,
                "ask": 0.07157569765536845,
                "assume": 0.09690665086166171,
                "available": 0.080222402582179,
                "basis": 0.108168987203321,
                "best": 0.06099345734662639,
                "better": 0.05785192621589312,
                "big": 0.0720129072287993,
                "bit": 0.07649383077880216,
                "box": 0.11570275174160347,
                "close": 0.0986775663816122,
                "cost": 0.08402759531708465,
                "couple": 0.08675156843578054,
                "easily": 0.08675156843578054,
                "effective": 0.09690665086166171,
                "example": 0.12348353705150925,
                "existing": 0.08320165713936366,
                "express": 0.108168987203321,
                "extent": 0.0986775663816122,
                "going": 0.059809582499319454,
                "hard": 0.07649383077880216,
                "ibm": 0.22311324385237852,
                "large": 0.07826474629875264,
                "like": 0.041244298867939226,
                "look": 0.06666761622250471,
                "lose": 0.0986775663816122,
                "machine": 0.08881820186189969,
                "machines": 0.0986775663816122,
                "mainframe": 0.5785137587080174,
                "make": 0.10501327041919704,
                "mean": 0.07706558510787227,
                "microsoft": 0.08579851083703512,
                "mistake": 0.09690665086166171,
                "numbers": 0.19381330172332342,
                "opinion": 0.08320165713936366,
                "oracle": 0.1053047828562359,
                "people": 0.05174814011705256,
                "product": 0.07593914631732263,
                "prove": 0.1053047828562359,
                "question": 0.11871275179114313,
                "quite": 0.07387251289120346,
                "real": 0.06992300448271277,
                "really": 0.10791040699015776,
                "reasons": 0.08165238102162091,
                "recommend": 0.08994464065244934,
                "recommendation": 0.22311324385237852,
                "run": 0.07157569765536845,
                "sense": 0.08320165713936366,
                "series": 0.1053047828562359,
                "seriously": 0.09242572731165884,
                "server": 0.08241087611416688,
                "somebody": 0.10063522266503852,
                "staff": 0.11570275174160347,
                "taken": 0.09528993165874393,
                "terminal": 0.11570275174160347,
                "think": 0.04911900048673026,
                "thoroughly": 0.11155662192618926,
                "treated": 0.11570275174160347,
                "trust": 0.0986775663816122,
                "unfamiliar": 0.11155662192618926,
                "unlikely": 0.11155662192618926,
                "using": 0.054293040976019745,
                "vendor": 0.11155662192618926,
                "vote": 0.11155662192618926,
                "ways": 0.07765549337054628,
                "windows": 0.08320165713936366,
                "word": 0.09528993165874393,
                "work": 0.04899041485544149
            },
            "Max term": "mainframe",
            "Max score": 0.5785137587080174
        }
    },
    {
        "ID": "5372",
        "Question": "Being a programmer is not a very healthy profession - long hours of sitting in front of a computer, with impending deadlines just over the cubicle. This takes a toll on the body and mind. So what tips do you have for programmers in order to stay healthy? ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "body": 0.3340429639719426,
                    "computer": 0.21975720167435306,
                    "deadlines": 0.3340429639719426,
                    "hours": 0.24676951350243567,
                    "long": 0.19219888709593763,
                    "mind": 0.23435442358092676,
                    "order": 0.26932847049469455,
                    "profession": 0.3340429639719426,
                    "programmer": 0.17909264252565893,
                    "programmers": 0.18564576481079825,
                    "sitting": 0.34645805389345147,
                    "stay": 0.2729192152803052,
                    "takes": 0.22739069254106095,
                    "tips": 0.2808809503659904
                },
                "Max term": "sitting",
                "Max score": 0.34645805389345147
            }
        ],
        "Best Answer": " Join a gym that is close to work Walk/Bike to work Drink a lot of water at work (increase your water intake, and force you to take break to use the washroom, win-win situation)  ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "break": 0.2019327752576682,
                "close": 0.21559186402635083,
                "drink": 0.2527886817200493,
                "force": 0.23007108159789916,
                "increase": 0.21986897363437036,
                "join": 0.23007108159789916,
                "lot": 0.12968248195021972,
                "situation": 0.18547292121482878,
                "use": 0.09521661868799455,
                "walk": 0.2527886817200493,
                "water": 0.5055773634400986,
                "win": 0.4601421631957983,
                "work": 0.3211044387919865
            },
            "Max term": "water",
            "Max score": 0.5055773634400986
        }
    },
    {
        "ID": "5405",
        "Question": "When I get a new laptop, it usually takes me about two weeks to reinstall all my developer programs, utilities and tweak the O/S settings to how I like them.  I know there are utilities out there to backup/restore systems, but this is usually if it is on the same hardware.  What would you recommend? ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "backup": 0.267097875126484,
                    "developer": 0.15778220292202716,
                    "hardware": 0.21931566157014165,
                    "know": 0.12458998565298968,
                    "laptop": 0.26002539608407155,
                    "like": 0.10184309637661093,
                    "new": 0.13534435975908923,
                    "programs": 0.19809035677634146,
                    "recommend": 0.22209713725180188,
                    "settings": 0.26002539608407155,
                    "systems": 0.19809035677634146,
                    "takes": 0.18751386275024032,
                    "usually": 0.3723678118723737,
                    "utilities": 0.5714014697832092,
                    "weeks": 0.21931566157014165
                },
                "Max term": "utilities",
                "Max score": 0.5714014697832092
            }
        ],
        "Best Answer": "Over the years I've come to this set of habits, which works well for me:  I stopped customizing so much. Before I used to tweak my desktop and Windows settings greatly. After a while I realized I grew dependent on these tweaks, and would get uncomfortable when working at a co-workers PC, on family members' PCs etc. Now I keep it down to just a few must-have changes, and generally keep my Windows and less important tools at default settings. I use multiple PCs, each dedicated to specific tasks. My work PC is a laptop, which I keep 'clean' for lack of a better word -- no private stuff, almost no games/multimedia/accessories, just my primary work tools. As such it rarely (actually, almost never) breaks, and I spend often keep the same Windows installation until it's time to replace the hardware (2-3 years). My home gaming PC on the other hand gets reinstalled far more frequently. But I don't care, it is easy to just reinstall and allow Steam to redownload all my games. Optional, use full-disk backup with system state. Actually I'm thinking about quitting this habit, because I haven't had to reload a system backup in ~3 years. But in the olden day Acronis Trueimage saved me a few times, by allowing me to just overwrite my full Windows + applications state with a known working backup. The built-in Windows Vista / 7 backup tool can AFAIK do something similar. Embrace Virtualization. I do all testing of new software in a VM, and I keep 'invasive' software (mostly enterprise server software) contained in VMs. I have my VMs on a external USB2 2.5\" HDD; it's not the fastest but it works for me.  ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "actually": 0.10979498857935686,
                "allow": 0.07664723661414252,
                "allowing": 0.0962697579708487,
                "applications": 0.06983448377382942,
                "backup": 0.37338535492426456,
                "better": 0.04992434190626873,
                "breaks": 0.08515554943027548,
                "built": 0.0797604144419166,
                "care": 0.086844943509636,
                "changes": 0.06650510833077661,
                "clean": 0.08873352541192306,
                "come": 0.06650510833077661,
                "day": 0.06333308855239926,
                "dedicated": 0.09087462298248984,
                "default": 0.09087462298248984,
                "dependent": 0.09334633873106614,
                "desktop": 0.08515554943027548,
                "disk": 0.0962697579708487,
                "easy": 0.06374959024341882,
                "embrace": 0.09984773395249628,
                "enterprise": 0.086844943509636,
                "external": 0.09334633873106614,
                "family": 0.09984773395249628,
                "far": 0.0675399456682721,
                "fastest": 0.09334633873106614,
                "frequently": 0.0797604144419166,
                "games": 0.15523863374269967,
                "generally": 0.06864620590134338,
                "gets": 0.0797604144419166,
                "greatly": 0.09334633873106614,
                "habit": 0.09984773395249628,
                "habits": 0.09984773395249628,
                "hand": 0.0711179216499197,
                "hardware": 0.07664723661414252,
                "home": 0.08094869231440263,
                "important": 0.06374959024341882,
                "known": 0.07664723661414252,
                "lack": 0.08094869231440263,
                "laptop": 0.09087462298248984,
                "members": 0.0797604144419166,
                "multiple": 0.07046336490805466,
                "new": 0.04730064005723913,
                "pc": 0.2662005762357692,
                "primary": 0.0797604144419166,
                "private": 0.08094869231440263,
                "quitting": 0.09984773395249628,
                "rarely": 0.07573073496906277,
                "realized": 0.09334633873106614,
                "replace": 0.086844943509636,
                "saved": 0.0962697579708487,
                "server": 0.0711179216499197,
                "set": 0.06292713234912901,
                "settings": 0.18174924596497968,
                "similar": 0.06506822991969578,
                "software": 0.141450243232172,
                "specific": 0.06506822991969578,
                "spend": 0.06983448377382942,
                "state": 0.16725461318451007,
                "stopped": 0.0962697579708487,
                "stuff": 0.06292713234912901,
                "tasks": 0.07325901922048647,
                "testing": 0.05872027523325618,
                "thinking": 0.06292713234912901,
                "time": 0.039353724865076864,
                "times": 0.06601170283025165,
                "tool": 0.06983448377382942,
                "tools": 0.1320234056605033,
                "tweaks": 0.0962697579708487,
                "use": 0.07521826963078886,
                "used": 0.048723343355967653,
                "vm": 0.09984773395249628,
                "vms": 0.19969546790499257,
                "windows": 0.3590017005391088,
                "word": 0.08223213019049291,
                "work": 0.08455428820971884,
                "workers": 0.09984773395249628,
                "working": 0.1065623001133771,
                "works": 0.13402836017812914,
                "years": 0.17616082569976854
            },
            "Max term": "backup",
            "Max score": 0.37338535492426456
        }
    },
    {
        "ID": "5415",
        "Question": "Frequently, I have been finding myself overloaded with contracts.  Most of the time, I find myself juggling with at least 2 projects, in addition to the numerous websites I have to upkeep and perform maintenance on.  Unfortunately, many of my clients will expect updates constantly - are constantly adding more to the to-do list than any one programmer could keep up with, and freaking out because the deadline was already overdue when I started on a project.  I constantly run into the fact most clients do not really understand the amount of work that can be involved behind the scenes, especially if it is non-visually-impacting. Does anyone know of good ways to handle these situations I might be overlooking? ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "adding": 0.16897196500349124,
                    "addition": 0.17264653006396677,
                    "clients": 0.3060707153521625,
                    "constantly": 0.5069158950104737,
                    "contracts": 0.17264653006396677,
                    "deadline": 0.16568495454878196,
                    "especially": 0.1425381827848231,
                    "expect": 0.1574997812429915,
                    "fact": 0.13141072899115536,
                    "finding": 0.17264653006396677,
                    "frequently": 0.15518777965752378,
                    "good": 0.08495255318375163,
                    "handle": 0.15102190137904087,
                    "involved": 0.14108686321989483,
                    "know": 0.08471886112052653,
                    "list": 0.1303877604743984,
                    "maintenance": 0.16897196500349124,
                    "non": 0.11485632435564708,
                    "numerous": 0.19427115874889264,
                    "perform": 0.17681240834244968,
                    "programmer": 0.1004235138882381,
                    "project": 0.0917386957461333,
                    "projects": 0.11307311076093879,
                    "really": 0.09059369587795434,
                    "run": 0.12017945565221111,
                    "situations": 0.15999693319126607,
                    "started": 0.1266015754574131,
                    "time": 0.07656952669813145,
                    "understand": 0.10634348980545243,
                    "unfortunately": 0.17264653006396677,
                    "updates": 0.19427115874889264,
                    "ways": 0.1303877604743984,
                    "websites": 0.16897196500349124,
                    "work": 0.08225754805564735
                },
                "Max term": "constantly",
                "Max score": 0.5069158950104737
            }
        ],
        "Best Answer": "Charge more. Learn to say no. Get some help. They're freaking out because they don't know what they are doing and are trying to motivate you. Every feature 'must' be included. They're all #1 priority. And they were due yesterday. Basically their boss is on their case. Take control of the project and bring some sanity to the situation. Start with a small piece of the project. Make a plan. Set a time-frame for your development and for their part (reviews, testing, approval, etc.). When they want to change the plan, just ask them, \"What other part should I remove or how far should I backup the due date?\" Remind them that this is what you agreed on and you don't mind making changes, but something has to give. This should help create a history of what they should expect from you in the future. So far, you haven't mentioned that anyone is trying to dump you. You must be doing something right or you found clients no on else wants. Maybe you could dump the clients and stick it to your competition ;) Edit: The art of saying no is in your mind you're saying no, but don't actually use the word. Features, Time, and resources are a constant compromise. It is important to let the client know the problems and don't just assume they will expect the form to take longer to load when you add 50 more fields. ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "50": 0.11768828535228011,
                "actually": 0.07856773207896048,
                "add": 0.09590878809415462,
                "agreed": 0.13359462443358186,
                "art": 0.1300571751706926,
                "ask": 0.08839990734929408,
                "assume": 0.11968502212788089,
                "backup": 0.13359462443358186,
                "basically": 0.11256758791520426,
                "boss": 0.10596586072021943,
                "bring": 0.12699289723859705,
                "case": 0.09312379957101324,
                "change": 0.08839990734929408,
                "changes": 0.09518021907599356,
                "charge": 0.12429001254726493,
                "client": 0.09907906157964627,
                "clients": 0.2251351758304085,
                "constant": 0.12699289723859705,
                "control": 0.09590878809415462,
                "create": 0.09184858282057963,
                "date": 0.11585146557583341,
                "development": 0.07222827055586477,
                "edit": 0.09518021907599356,
                "expect": 0.23170293115166682,
                "far": 0.19332249766780502,
                "feature": 0.08949287565133915,
                "features": 0.09005952163891769,
                "fields": 0.12187219980152118,
                "form": 0.10275860415418286,
                "future": 0.11585146557583341,
                "help": 0.15509530637312835,
                "history": 0.11585146557583341,
                "important": 0.0912365999795759,
                "included": 0.12429001254726493,
                "know": 0.12463260768072001,
                "learn": 0.07754765318656417,
                "let": 0.09312379957101324,
                "load": 0.11585146557583341,
                "longer": 0.10714293906087764,
                "make": 0.06484857067129901,
                "making": 0.09590878809415462,
                "maybe": 0.09590878809415462,
                "mentioned": 0.12699289723859705,
                "mind": 0.19332249766780502,
                "piece": 0.12699289723859705,
                "plan": 0.23537657070456022,
                "priority": 0.13777853888282293,
                "problems": 0.08635874075049929,
                "project": 0.13495970938280843,
                "remove": 0.12187219980152118,
                "resources": 0.11585146557583341,
                "reviews": 0.11968502212788089,
                "right": 0.08193198809325897,
                "say": 0.07444184040781528,
                "saying": 0.2251351758304085,
                "set": 0.09005952163891769,
                "situation": 0.10484622420307395,
                "small": 0.08540243585888292,
                "start": 0.07963527323545526,
                "stick": 0.12429001254726493,
                "testing": 0.08403878741322993,
                "time": 0.11264386294912604,
                "trying": 0.17679981469858816,
                "use": 0.05382512382633415,
                "want": 0.06747985469140422,
                "wants": 0.1110865581572953,
                "word": 0.11768828535228011
            },
            "Max term": "plan",
            "Max score": 0.23537657070456022
        }
    },
    {
        "ID": "5427",
        "Question": "Other than being annoyed at whitespace as syntax, I'm not a hater, I just don't get the fascination with Python. I appreciate the poetry of Perl, and have programmed beautiful web services in bash & korn, and shebang gnuplot.  I write documents in troff and don't mind REXX.  Didn't find tcl any more useful years ago, but what's the big stink about Python?  I see job listings and many candidates with this as a prize & trophy on their resumes.  I guess in reality, I'm trying to personally become sold on this, I just can't find a reason. ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "ago": 0.18581062351854577,
                    "annoyed": 0.25585404845624177,
                    "appreciate": 0.24668569176004213,
                    "beautiful": 0.25585404845624177,
                    "big": 0.1592424862698146,
                    "documents": 0.23286097011542012,
                    "guess": 0.20742634635786625,
                    "job": 0.1419359798961488,
                    "mind": 0.1730672079144366,
                    "perl": 0.22737453131621854,
                    "personally": 0.18972665747999562,
                    "programmed": 0.25585404845624177,
                    "python": 0.3461344158288732,
                    "reality": 0.22253514932512372,
                    "reason": 0.1592424862698146,
                    "services": 0.2107150817506595,
                    "sold": 0.23286097011542012,
                    "syntax": 0.20154672505445984,
                    "trying": 0.15827568264844588,
                    "useful": 0.16557611504507722,
                    "web": 0.15126514798410887,
                    "write": 0.12614155718912973,
                    "years": 0.15046731207781977
                },
                "Max term": "python",
                "Max score": 0.3461344158288732
            }
        ],
        "Best Answer": "I've found Python to be the most natural programming language that I've ever written code in. I've coded in a lot of languages before and after Python, and to a greater or lesser extent, you have to fight the language to get it to do what you want. Python reduces this struggle massively. Eric S Raymond said it much better than I can in Why Python? As a related point, Python maintains its cleanness even while evolving rapidly. In most languages I've worked with, introduction of new language features introduces a lot of wrinkles. But with Python, even major language features (decorators come to mind) are added all the time, without feeling like ugly hacks. ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "added": 0.1296796746140635,
                "better": 0.07997871526547537,
                "code": 0.05598921142377918,
                "coded": 0.14215096468864846,
                "come": 0.10654107635255376,
                "eric": 0.15422399710110046,
                "extent": 0.13641905293305312,
                "features": 0.20161832919391687,
                "feeling": 0.13397081036977576,
                "fight": 0.15995590885669578,
                "greater": 0.15422399710110046,
                "introduction": 0.15422399710110046,
                "language": 0.30118160942131667,
                "languages": 0.1751188356765887,
                "like": 0.05701912194199107,
                "lot": 0.16411715209711644,
                "major": 0.1243460205206011,
                "mind": 0.10819888409926423,
                "natural": 0.1391254595252127,
                "new": 0.07577554913222903,
                "point": 0.09171151615222639,
                "programming": 0.06790568285302337,
                "python": 0.6491933045955854,
                "reduces": 0.15995590885669578,
                "related": 0.11993168498601528,
                "said": 0.10145950578027461,
                "struggle": 0.14558099954566195,
                "time": 0.06304460380327279,
                "ugly": 0.15995590885669578,
                "want": 0.07553435388918371,
                "worked": 0.10498380534731269,
                "written": 0.10906971680510899
            },
            "Max term": "python",
            "Max score": 0.6491933045955854
        }
    },
    {
        "ID": "5452",
        "Question": "I've enjoyed a number of (fiction/non-fiction books) about hacker culture and running a software business in the 80's, 90's. For some reason things seemed so much more exciting back then. Examples are:  Microserfs (Douglas Coupland) Accidental Empires (Robert X. Cringely Almost Pefect (W.E. Peterson, online!) Coders at Work (Peter Seibel)  Today I'm an entrepeneur and programmer. Back in the 80's a I was a young geek hacking DOS TSR's and coding GWBasic / QBasic. In the 90's I was a C.S. university student, experiencing the rise of the Internet world wide. When reading these books running a software business seemed so much more fun than it is nowadays. Things used to be so much simpler, opportunities seemed to be everywhere and the startups seemed to work with much more real problems (inventing spreadsheets, writing word processors in assembly on 6 different platforms) than all our current web 2.0 social networking toys. Does anyone share these feelings? Does anyone have any good (personal) stories from back then or know of other good books to read? ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "80": 0.22728485600236162,
                    "90": 0.2353650178491884,
                    "assembly": 0.12900194308289306,
                    "books": 0.3037255436986273,
                    "business": 0.1798448274824871,
                    "coders": 0.12900194308289306,
                    "coding": 0.07835116896137732,
                    "culture": 0.1155705214777685,
                    "current": 0.10124184789954244,
                    "different": 0.07424857996763164,
                    "examples": 0.10124184789954244,
                    "experiencing": 0.1379866834349558,
                    "fiction": 0.2759733668699116,
                    "fun": 0.10592426644225729,
                    "geek": 0.1379866834349558,
                    "good": 0.1206799932491204,
                    "hacker": 0.13304202400630646,
                    "hacking": 0.13304202400630646,
                    "internet": 0.11022658825160514,
                    "inventing": 0.1379866834349558,
                    "know": 0.060174010108820196,
                    "networking": 0.1379866834349558,
                    "non": 0.0815800110084823,
                    "nowadays": 0.1255861033333174,
                    "number": 0.08641631278239112,
                    "online": 0.12262716835324354,
                    "opportunities": 0.12900194308289306,
                    "personal": 0.10124184789954244,
                    "peter": 0.1379866834349558,
                    "platforms": 0.1155705214777685,
                    "problems": 0.08338992235832686,
                    "processors": 0.12900194308289306,
                    "programmer": 0.07132869186328042,
                    "read": 0.0829233978377563,
                    "reading": 0.09261166065122987,
                    "real": 0.08338992235832686,
                    "reason": 0.08588233281783017,
                    "robert": 0.1379866834349558,
                    "running": 0.20248369579908487,
                    "share": 0.10726765327153127,
                    "simpler": 0.12900194308289306,
                    "social": 0.12262716835324354,
                    "software": 0.13032009949577322,
                    "startups": 0.1379866834349558,
                    "stories": 0.1255861033333174,
                    "student": 0.12900194308289306,
                    "things": 0.13115631661493715,
                    "today": 0.10869776857253148,
                    "university": 0.11186875393862514,
                    "used": 0.06733425276082071,
                    "web": 0.0815800110084823,
                    "wide": 0.12001720273083036,
                    "word": 0.11364242800118081,
                    "work": 0.11685158328994599,
                    "world": 0.08536091826116977,
                    "writing": 0.07689759246576745,
                    "young": 0.1379866834349558
                },
                "Max term": "books",
                "Max score": 0.3037255436986273
            }
        ],
        "Best Answer": " In no particular order:  The Fugitive Game: Online with Kevin Mitnick The Cuckoo's Egg: Tracking a Spy Through the Maze of Computer Espionage  Insanely Great: The Life and Times of Macintosh, the Computer That Changed Everything Where Wizards Stay Up Late: The Origins Of The Internet  CYBERPUNK: Outlaws and Hackers on the Computer Frontier The Watchman: The Twisted Life and Crimes of Serial Hacker Kevin Poulsen  Takedown: The Pursuit and Capture of Kevin Mitnick, America's Most Wanted Computer Outlaw-By the Man Who Did It  Geeks: How Two Lost Boys Rode the Internet Out of Idaho  Soul of a New Machine - about DEC and one of their products in development. The Hacker Crackdown: Law and Disorder on the Electronic Frontier by Bruce Sterling tells the story of the 'meeting' of law enforcement and the cracker/phreaker subculture of the 1990s. Also, it describes in detail the Secret Service raid on Steve Jackson Games. That little incident almost put SJG out of business, all for a role-playing supplement not, as the Secret Service described it, a \"hacker's manual\".  Turns out that the Secret Service were actually after copies of a leaked Bell South E911 document. Programmers at Work - This likely inspired the Founders at Work and \"Coders at Work\" books. Free as in Freedom: Richard Stallman's Crusade for Free Software by Sam Williams.  It is a free biography of Richard Stallman, and contains lots of stories of programming culture at MIT.  If you're interested in the FSF and how the whole free software movement started this is worth a read. Hackers: Heroes of the Computer Revolution by Steven Levy (Wikipedia page on Hackers)  \"describes the people, the machines, and the events that defined the Hacker Culture and the Hacker Ethic, from the early mainframe hackers at MIT, to the self-made hardware hackers and game hackers.\"  Show Stoppers  Startup Founders at Work - interviews with startup founders, starting from the early 80's. It's more about how the founders built up their companies, but it has interesting insights into the programming culture prevalent then as well. The case of IBM 386 PC - A detective story for techies.  ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "80": 0.07352787301211033,
                "actually": 0.0490866037334054,
                "america": 0.08927886807260292,
                "books": 0.06550456433218407,
                "built": 0.07131778796065481,
                "business": 0.05818076870409614,
                "capture": 0.08927886807260292,
                "case": 0.05818076870409614,
                "changed": 0.07131778796065481,
                "coders": 0.08346564444413217,
                "companies": 0.06420028615876242,
                "computer": 0.28314645879646266,
                "contains": 0.07238028681978512,
                "copies": 0.08607962024806608,
                "culture": 0.22432611067775943,
                "defined": 0.07614184881604424,
                "described": 0.08125555939267665,
                "describes": 0.16693128888826433,
                "development": 0.04512591112547023,
                "document": 0.0747753702259198,
                "early": 0.13706827896683635,
                "events": 0.08607962024806608,
                "free": 0.22800682726490223,
                "fsf": 0.08927886807260292,
                "game": 0.13706827896683635,
                "games": 0.06940332520855926,
                "great": 0.055229432074781135,
                "hacker": 0.4303981012403304,
                "hardware": 0.06853413948341817,
                "ibm": 0.08607962024806608,
                "interested": 0.06620407738402241,
                "interesting": 0.0624425153877633,
                "internet": 0.14263557592130963,
                "interviews": 0.07614184881604424,
                "late": 0.08125555939267665,
                "law": 0.17215924049613215,
                "life": 0.1388066504171185,
                "likely": 0.06039085375555166,
                "little": 0.05662929175929254,
                "lost": 0.07131778796065481,
                "lots": 0.06693947824824739,
                "machine": 0.06853413948341817,
                "machines": 0.07614184881604424,
                "mainframe": 0.08927886807260292,
                "man": 0.08346564444413217,
                "manual": 0.08346564444413217,
                "meeting": 0.0747753702259198,
                "mit": 0.17215924049613215,
                "new": 0.0422938752463731,
                "online": 0.07934109664058109,
                "order": 0.06940332520855926,
                "page": 0.07032862518757349,
                "particular": 0.05818076870409614,
                "pc": 0.07934109664058109,
                "people": 0.03993003887090507,
                "products": 0.07614184881604424,
                "programmers": 0.047839106519595914,
                "programming": 0.07580267017514818,
                "read": 0.053652330148066675,
                "role": 0.0776524208156614,
                "sam": 0.08927886807260292,
                "self": 0.0747753702259198,
                "service": 0.2329572624469842,
                "software": 0.08431850581854193,
                "soul": 0.08927886807260292,
                "started": 0.05818076870409614,
                "starting": 0.06620407738402241,
                "startup": 0.16693128888826433,
                "stay": 0.07032862518757349,
                "steve": 0.08125555939267665,
                "stories": 0.08125555939267665,
                "story": 0.1625111187853533,
                "times": 0.05902437516542722,
                "tracking": 0.08125555939267665,
                "turns": 0.0776524208156614,
                "wanted": 0.07614184881604424,
                "wikipedia": 0.07352787301211033,
                "work": 0.15120846198952925,
                "worth": 0.05992074037465594
            },
            "Max term": "hacker",
            "Max score": 0.4303981012403304
        }
    },
    {
        "ID": "5466",
        "Question": "Sometimes I can't stand it when project managers ask me to estimate time to complete for various tasks.  An estimate is a guess, and guesses can be wrong.  Generally, bad requirements and documentation will lead to bad guesses. So I often wonder if the project managers were ever in my shoes trying to guess at how long task X and Y will take, and how difficult it is to assign a number to it based on what little is known and collected from the client. My question then is: Do good project managers need to have a programming background? Or maybe the question should be, do good project managers need to have been a good programmer before?  Is there any correlation? ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "ask": 0.09904835276269527,
                    "assign": 0.1601125430211904,
                    "background": 0.12790117795557712,
                    "bad": 0.18932237078401803,
                    "based": 0.10222674673106559,
                    "client": 0.11101389285354245,
                    "complete": 0.11101389285354245,
                    "difficult": 0.11627961969495887,
                    "documentation": 0.11513666449274786,
                    "estimate": 0.25580235591115424,
                    "generally": 0.1100787985919589,
                    "good": 0.210046144996357,
                    "guess": 0.2596133225590316,
                    "known": 0.12290898835697049,
                    "lead": 0.12446778429395394,
                    "little": 0.10155885831455434,
                    "long": 0.0888230255667175,
                    "managers": 0.5691606546302886,
                    "maybe": 0.10746173566287426,
                    "need": 0.150738268252612,
                    "number": 0.10027297746181006,
                    "programmer": 0.08276608988858099,
                    "programming": 0.06797217836403102,
                    "project": 0.30243327859791,
                    "question": 0.1642778610898739,
                    "requirements": 0.10664540493033572,
                    "stand": 0.14572355731919537,
                    "task": 0.10585419609361561,
                    "tasks": 0.11747575435423391,
                    "time": 0.063106339183436,
                    "trying": 0.09904835276269527,
                    "various": 0.12612721542133948,
                    "wonder": 0.12790117795557712,
                    "wrong": 0.10361693709126744
                },
                "Max term": "managers",
                "Max score": 0.5691606546302886
            }
        ],
        "Best Answer": "Managing IT projects is definitely not the same as managing other types of projects. I once heard of a project manager with no IT experience. He ended up frustrating the programmers and basically scaring them away. On the other hand, a programmer that becomes a Project Manager may become a control freak, thinking he can fix things if (s)he can't get the programmers to do it properly (that has been my problem in similar situations) ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "away": 0.16132904459442005,
                "basically": 0.18329222260608255,
                "control": 0.15616693279841512,
                "definitely": 0.17071963450539038,
                "ended": 0.2243428600271199,
                "experience": 0.13340870563435203,
                "fix": 0.16573011378047572,
                "frustrating": 0.2326808197535194,
                "hand": 0.16573011378047572,
                "heard": 0.18329222260608255,
                "manager": 0.352959226926902,
                "managing": 0.4135615024030261,
                "problem": 0.1212126033429273,
                "programmer": 0.1202784071733827,
                "programmers": 0.2493589527188767,
                "project": 0.21975299953730956,
                "projects": 0.2708579520848274,
                "properly": 0.2117702719264277,
                "similar": 0.15163217509601554,
                "situations": 0.19163018233248202,
                "things": 0.1105815376749782,
                "thinking": 0.14664265437110088,
                "types": 0.17071963450539038
            },
            "Max term": "managing",
            "Max score": 0.4135615024030261
        }
    },
    {
        "ID": "5473",
        "Question": "I was reading the wikipedia article on programming style and noticed something in an argument against vertically aligned code:  Reliance on mono-spaced font; tabular   formatting assumes that the editor   uses a fixed-width font. Most modern   code editors support proportional   fonts, and the programmer may prefer   to use a proportional font for   readability.  To be honest, I don't think I've ever met a programmer who preferred a proportional font.  Nor can I think of any really good reasons for using them.  Why would someone prefer a proportional font? ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "argument": 0.21967495497519832,
                    "article": 0.18509936243155597,
                    "code": 0.16449607095430885,
                    "editor": 0.20039930586756272,
                    "fixed": 0.19049917309236153,
                    "fonts": 0.23497489841120506,
                    "formatting": 0.21967495497519832,
                    "good": 0.10275183245252721,
                    "honest": 0.2265547319284548,
                    "met": 0.2265547319284548,
                    "modern": 0.187702760381538,
                    "noticed": 0.20437501153919158,
                    "prefer": 0.34129483311623415,
                    "preferred": 0.2138581864424301,
                    "programmer": 0.24292854509078787,
                    "programming": 0.09975330729562322,
                    "readability": 0.19680284261900918,
                    "reading": 0.15770663524552092,
                    "really": 0.10957490871371696,
                    "reasons": 0.16582371332392035,
                    "style": 0.1742438798066706,
                    "support": 0.15534747312211034,
                    "think": 0.19950661459124644,
                    "use": 0.08850679211993956,
                    "uses": 0.18509936243155597,
                    "using": 0.11026100585979748,
                    "wikipedia": 0.1935195289143062
                },
                "Max term": "prefer",
                "Max score": 0.34129483311623415
            }
        ],
        "Best Answer": "I used to use a proportional font, mostly because I find punctuation is actually easier to differentiate, but over time I've given up because nobody else does it and everybody unconsciously assumes mono spaced fonts (as the wikipedia article mentions, trying to do tabular formatting, ascii art in comments and so on). Plus, issues in Visual Studio, that Microsoft don't want to fix, basically make it impossible to use well-designed proportional fonts anyway. ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "actually": 0.13331360267786488,
                "art": 0.2206808077225155,
                "article": 0.1910045039183689,
                "basically": 0.1910045039183689,
                "comments": 0.17980270372671564,
                "designed": 0.19657658230357491,
                "easier": 0.15691539372009228,
                "everybody": 0.2206808077225155,
                "fix": 0.17270344435183974,
                "fonts": 0.484942393260777,
                "formatting": 0.2266831459986411,
                "given": 0.16811719391174557,
                "impossible": 0.1996932951752404,
                "issues": 0.17980270372671564,
                "make": 0.11003495144816687,
                "microsoft": 0.17980270372671564,
                "plus": 0.21089509536689366,
                "studio": 0.1996932951752404,
                "time": 0.09556696363723233,
                "trying": 0.14999682201950337,
                "use": 0.18266076879142443,
                "used": 0.11832023521911289,
                "visual": 0.19657658230357491,
                "want": 0.11449970998334237,
                "wikipedia": 0.1996932951752404
            },
            "Max term": "fonts",
            "Max score": 0.484942393260777
        }
    },
    {
        "ID": "5490",
        "Question": "At my first workplace we were using Digital Standard MUMPS on a PDP 11-clone (TPA 440), then we've switched to Micronetics Standard MUMPS running on a Hewlett-Packard machine, HP-UX 9, around early 90's. Is still MUMPS alive? Are there anyone using it? If yes, please write some words about it: are you using it in character mode, does it acts as web server? etc. (I mean CachÃ©, too.) If you've been used it, what was your feelings about it? Did you liked it? ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "11": 0.24550173969423703,
                    "90": 0.21715890815973266,
                    "character": 0.21715890815973266,
                    "clone": 0.24550173969423703,
                    "early": 0.19546148580975725,
                    "liked": 0.24550173969423703,
                    "machine": 0.19546148580975725,
                    "mean": 0.16959759885034034,
                    "mode": 0.25462609345385345,
                    "running": 0.18682104376297543,
                    "server": 0.18136093677290263,
                    "standard": 0.33423730855050576,
                    "switched": 0.23804659984191134,
                    "used": 0.12425153869434051,
                    "using": 0.3584467452337097,
                    "ux": 0.25462609345385345,
                    "web": 0.15053916066331074,
                    "words": 0.20970376830740695,
                    "write": 0.12553614892182247,
                    "yes": 0.16593335208079668
                },
                "Max term": "using",
                "Max score": 0.3584467452337097
            }
        ],
        "Best Answer": "Intersystems sell a MUMPS derivative : http://www.intersystems.com Some of the most interesting people in MUMPS are probably here : http://www.outoftheslipstream.com/ I started blogging about Cache (the MUMPS derivative) a couple of years ago : http://cachetastic.blogspot.com/ (but then changed jobs) Having been out of that world for a couple of years, my thinking is that the NoSQL movement is probably the best and worst thing to happen to MUMPS. Ultimately it's likely to both vindicate and kill it. Because somebody, at some point, is going to reinvent MUMPS's database and query structure almost identically, but with no connection to the MUMPS tradition. Then people will rave about this new storage system. But no-one will ever choose a MUMPS derivative again. For example, a month or two ago, I was talking with a colleague about using redis to cache a look-up of something in our Django application. We had a large number of records addressed by a triple of three keys, and needed to quickly get subsets matching one or two of these keys (but different combinations at different times). This is the kind of thing that MUMPS eats for breakfast. But we were finding it hard to squash into redis's key,val pair structure. Even with dictionaries. (Same would be true of memcached etc.) For the first time in my life, I found myself actually regretting that I couldn't write this module in Cache ObjectScript. Some more thoughts on Cache here : Good : http://cachetastic.blogspot.com/2008/07/ok-after-mentioning-some-bad-things.html Bad : http://cachetastic.blogspot.com/2008/07/some-mumps-dissing-and-more-positive.html ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "2008": 0.18872525014076272,
                "actually": 0.05549517786535645,
                "ago": 0.14660513475212333,
                "application": 0.05787147129979665,
                "bad": 0.11934865178091791,
                "best": 0.05320843705902146,
                "cache": 0.40373921082138553,
                "changed": 0.08062878722136728,
                "choose": 0.07655523555967612,
                "com": 0.3923218947693298,
                "connection": 0.08779044743541634,
                "couple": 0.15135772162100375,
                "database": 0.07484744859905307,
                "different": 0.10862302917393737,
                "django": 0.09731787235053346,
                "example": 0.05386123606414966,
                "finding": 0.08969959082960617,
                "going": 0.0521756684140059,
                "good": 0.044137633450782573,
                "happen": 0.07655523555967612,
                "hard": 0.06673038974109664,
                "html": 0.15311047111935225,
                "http": 0.3827761777983807,
                "interesting": 0.07059479031436706,
                "jobs": 0.07951048283982824,
                "key": 0.07748171540116418,
                "keys": 0.18872525014076272,
                "kill": 0.10093480270534638,
                "kind": 0.06774378123561987,
                "large": 0.06827527096408804,
                "life": 0.07846437895386597,
                "likely": 0.06827527096408804,
                "look": 0.058158363469886884,
                "module": 0.09731787235053346,
                "month": 0.07951048283982824,
                "needed": 0.06998305792471111,
                "new": 0.04781561466668292,
                "number": 0.06321199454964596,
                "ok": 0.07748171540116418,
                "pair": 0.07748171540116418,
                "people": 0.09028632827589367,
                "point": 0.05787147129979665,
                "positive": 0.09436262507038136,
                "probably": 0.11462497081579215,
                "query": 0.08608266047479327,
                "quickly": 0.07258204944748846,
                "sell": 0.08453777925180188,
                "somebody": 0.08779044743541634,
                "started": 0.06577664499081416,
                "structure": 0.17939918165921234,
                "talking": 0.07484744859905307,
                "thing": 0.11517913762501816,
                "things": 0.04796925548010895,
                "thinking": 0.06361223672331286,
                "thoughts": 0.07846437895386597,
                "time": 0.03978217930180387,
                "times": 0.06673038974109664,
                "true": 0.07846437895386597,
                "ultimately": 0.09186399909710748,
                "using": 0.04736324155389438,
                "world": 0.062439992243887285,
                "worst": 0.08969959082960617,
                "write": 0.04976303194986386,
                "www": 0.17558089487083267,
                "years": 0.11871915687725372
            },
            "Max term": "cache",
            "Max score": 0.40373921082138553
        }
    },
    {
        "ID": "5494",
        "Question": "We're developing a new project that is to be deployed on a large number of client sites. The project contains a web-based GUI as one of it's \"access points\". Speed of the web interface is a priority for this project, second only to security. In the past, we've always created \"web sites\" in Visual Studio, which, when published, results in one dll and one aspx file for each page within the system. However, I am aware that you can actually create a \"web application\" and have it compile everything down to a single dll. To me (based on no real data, just gut feeling), compiling the site as a single dll sounds like it would be better for both security and speed (if only marginally). What are the considerations we should look at, and are there any obvious pitfalls we should be aware of when choosing the method that's right for us? ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "access": 0.09579373476645499,
                    "actually": 0.07660781740634437,
                    "application": 0.07988815023041722,
                    "aware": 0.23766406340764476,
                    "based": 0.17792130705737202,
                    "better": 0.0696679314488571,
                    "choosing": 0.13933453739633136,
                    "client": 0.09660748067231112,
                    "compile": 0.12118953079979375,
                    "compiling": 0.13933453739633136,
                    "contains": 0.11296148795756691,
                    "create": 0.08955737012593122,
                    "created": 0.10975952840555357,
                    "data": 0.08517747827807094,
                    "deployed": 0.13434157853303622,
                    "developing": 0.10019523506244266,
                    "dll": 0.41800361218899407,
                    "feeling": 0.11669941436304085,
                    "file": 0.09280589690868984,
                    "gui": 0.12382499056711753,
                    "interface": 0.10695893470571545,
                    "large": 0.09424998157633974,
                    "like": 0.04966826818289035,
                    "look": 0.08028418793724115,
                    "method": 0.09745194112835309,
                    "new": 0.06600663370148545,
                    "number": 0.0872604273491864,
                    "obvious": 0.10831544373790368,
                    "page": 0.10975952840555357,
                    "past": 0.10332248487460854,
                    "points": 0.10118986753382701,
                    "priority": 0.13434157853303622,
                    "project": 0.19738959939471412,
                    "published": 0.12681282842488267,
                    "real": 0.0842044751426356,
                    "results": 0.11130328159566882,
                    "right": 0.07988815023041722,
                    "second": 0.10332248487460854,
                    "security": 0.20446155659480006,
                    "single": 0.18289877575300323,
                    "site": 0.10019523506244266,
                    "sites": 0.2113599679411598,
                    "sounds": 0.10695893470571545,
                    "speed": 0.24764998113423506,
                    "studio": 0.11475248726884871,
                    "visual": 0.11296148795756691,
                    "web": 0.3295075383129312
                },
                "Max term": "dll",
                "Max score": 0.41800361218899407
            }
        ],
        "Best Answer": "If it is a large application, there should be natural areas of division in your business logic (software tiers, if you will) which can go in their own DLL's.   It would be nice if the core website functionality could go into a single DLL.  It eases deployment concerns, and is a natural unit anyway. One DLL per page seems excessively granular. ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "application": 0.12212211423743788,
                "areas": 0.17839415697046795,
                "business": 0.13880384882752808,
                "concerns": 0.19385416579315948,
                "core": 0.17839415697046795,
                "deployment": 0.18928676655889848,
                "dll": 0.6389869427715177,
                "excessively": 0.19912684125295643,
                "functionality": 0.15627647842400258,
                "granular": 0.21299564759050593,
                "large": 0.14407652428732504,
                "logic": 0.1596998016065948,
                "natural": 0.3705160698308139,
                "nice": 0.1546852759388605,
                "page": 0.1677854053189325,
                "single": 0.13979535839779292,
                "software": 0.10058077089462684,
                "unit": 0.13784027285219205,
                "website": 0.16350423942940037
            },
            "Max term": "dll",
            "Max score": 0.6389869427715177
        }
    },
    {
        "ID": "5513",
        "Question": "In the past I have worked with designers, BAs and project managers, all who regularly produce project artifacts, yet very really do they understand the concept of versioning.  When I try to explain it to them (even in its most simple form of multiple differently named files) they seem to have some kind of mental block.  Why do you think this is? ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "block": 0.2352329409899536,
                    "concept": 0.21559889493281137,
                    "designers": 0.2707945432977876,
                    "differently": 0.2556187170986094,
                    "explain": 0.18175804253076785,
                    "files": 0.20004563758547558,
                    "form": 0.201965193617823,
                    "kind": 0.18850233629120602,
                    "managers": 0.24959608287786894,
                    "mental": 0.26257133806084704,
                    "multiple": 0.198204453004649,
                    "named": 0.2556187170986094,
                    "past": 0.2082688428224161,
                    "produce": 0.21559889493281137,
                    "project": 0.2652543216255289,
                    "really": 0.13097182790866693,
                    "regularly": 0.26257133806084704,
                    "simple": 0.1737441312146419,
                    "think": 0.11923234205539639,
                    "try": 0.16103186662520116,
                    "understand": 0.15374139570120046,
                    "worked": 0.1843360446951256
                },
                "Max term": "designers",
                "Max score": 0.2707945432977876
            }
        ],
        "Best Answer": "This is because the human has difficulties projecting himself in time. Use the time machine analogy. Your life is versionned. Every day you have a new version of your life: new things and lost things. Hopefully more assets, less debts,... but more fat, less hairs, ... hopefully more knowledge, less doubts, .... Then you will have to explain branching ;) And there you hope they are fans of Fringe ;) ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "day": 0.17921000316485283,
                "explain": 0.18284167360905884,
                "hope": 0.2366353863615324,
                "hopefully": 0.5021683209636194,
                "human": 0.24095976734623223,
                "knowledge": 0.17694094741221544,
                "life": 0.43926984582978645,
                "lost": 0.22569346373720078,
                "machine": 0.21688428324213382,
                "new": 0.26768780895136884,
                "things": 0.2685479416297463,
                "time": 0.22271394996895338,
                "use": 0.10642040872075678,
                "version": 0.20316929857785676
            },
            "Max term": "hopefully",
            "Max score": 0.5021683209636194
        }
    },
    {
        "ID": "5531",
        "Question": "I define defect as :  \"something within the application design or code which prevents it functioning as per requirements.\"  I'm looking for ideas about the causes of defects, eg the human factor, lack of testing, lack of prototyping, and possible ideas to mitigate these. ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "application": 0.152099438560463,
                    "causes": 0.2480065215543761,
                    "code": 0.09285559742426243,
                    "defect": 0.2652797047990075,
                    "defects": 0.2652797047990075,
                    "define": 0.2119108602691442,
                    "design": 0.152099438560463,
                    "factor": 0.23575100300472743,
                    "human": 0.2262448842915978,
                    "ideas": 0.4072792741061713,
                    "lack": 0.4301358548857391,
                    "looking": 0.15683775201417427,
                    "mitigate": 0.2652797047990075,
                    "possible": 0.15601052385430947,
                    "prevents": 0.25577358608587786,
                    "requirements": 0.17669359941616733,
                    "testing": 0.15601052385430947
                },
                "Max term": "lack",
                "Max score": 0.4301358548857391
            }
        ],
        "Best Answer": "The prime cause of software defects is interpretation. The customer interpretation of a feature differs from the designer interpretation. The designer interpretation differs from the programmer interpretation. Most methodologies have invented ways to counter this effect. But in the end, we are only humans and we are not flawless. Besides, often there is a time pressure and most methodology magic is often skipped while under pressure. Testing can only detect the problems early. But even testers are human, and it is imposible to test 100%. If you want to release before the universe ends. ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "100": 0.10864324298717853,
                "cause": 0.10721384506865024,
                "counter": 0.13297528671877287,
                "customer": 0.10119106239500605,
                "defects": 0.13791746577957972,
                "designer": 0.27583493155915945,
                "detect": 0.13791746577957972,
                "differs": 0.27583493155915945,
                "early": 0.10587113211662492,
                "effect": 0.11995699902732053,
                "end": 0.0768590186634117,
                "ends": 0.13297528671877287,
                "feature": 0.08637296414607243,
                "human": 0.11762347636330814,
                "humans": 0.13791746577957972,
                "interpretation": 0.6895873288978986,
                "invented": 0.12893723240345012,
                "magic": 0.11762347636330814,
                "methodologies": 0.11358542204798538,
                "methodology": 0.115512548343491,
                "pressure": 0.25787446480690024,
                "problems": 0.08334809183697546,
                "programmer": 0.07129291156413187,
                "release": 0.10864324298717853,
                "software": 0.06512736379765241,
                "test": 0.07793962227624907,
                "testers": 0.11762347636330814,
                "testing": 0.0811090169948483,
                "time": 0.05435842945579977,
                "want": 0.06512736379765241,
                "ways": 0.09256520426970677
            },
            "Max term": "interpretation",
            "Max score": 0.6895873288978986
        }
    },
    {
        "ID": "5540",
        "Question": "How should code in version control be stored?  Developer friendly? so that programmer can quickly take the latest and able to run from his editor without doing many changes? (like config files pointing to dev DB..etc) or  Should it be production friendly? source should be in a manner which is easy to deploy on production environment and when developer takes the latest, he should perform changes as per his development needs. ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "able": 0.12402947758941309,
                    "changes": 0.26216334783950207,
                    "code": 0.06888572751592915,
                    "config": 0.17911402591999875,
                    "control": 0.13208505516213262,
                    "db": 0.1748939192151199,
                    "deploy": 0.19680004186280434,
                    "dev": 0.1748939192151199,
                    "developer": 0.21737111843300963,
                    "development": 0.09947237672601028,
                    "easy": 0.1256505434025204,
                    "editor": 0.16784172288478194,
                    "environment": 0.12916570219220616,
                    "files": 0.14017353628234164,
                    "friendly": 0.37949569106493275,
                    "latest": 0.3582280518399975,
                    "like": 0.07015286690795142,
                    "manner": 0.1748939192151199,
                    "needs": 0.14151858414438898,
                    "perform": 0.17911402591999875,
                    "pointing": 0.19680004186280434,
                    "production": 0.3100549251993762,
                    "programmer": 0.10173075542706013,
                    "quickly": 0.14151858414438898,
                    "run": 0.12174386592286178,
                    "source": 0.11697728125907514,
                    "stored": 0.18398578157771048,
                    "takes": 0.12916570219220616,
                    "version": 0.14151858414438898
                },
                "Max term": "friendly",
                "Max score": 0.37949569106493275
            }
        ],
        "Best Answer": "Why choose ? It should be both. Your development environment should be configured so it's as easy as doing a checkout, open, build, run, debug (eg: no absolute path!). You can do that easily with compilation directives, configuration class + dependancy injection, or even tricks like the perso.config in ASP.NET Your automated build script should be customized enought to take care of specific production configuration, clean up, packaging etc. ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "absolute": 0.23176163189266025,
                "asp": 0.19411157649135904,
                "automated": 0.19765885833789945,
                "build": 0.30644621297527147,
                "care": 0.20158019649193978,
                "choose": 0.17578244418857672,
                "class": 0.15436837498257105,
                "clean": 0.20596387958929718,
                "config": 0.21093368959251718,
                "configuration": 0.41192775917859437,
                "debug": 0.18256814063753923,
                "development": 0.1171436760889168,
                "easily": 0.17377015470492782,
                "easy": 0.14797240240156473,
                "environment": 0.15211203026824646,
                "injection": 0.2166709141923,
                "like": 0.08261554602650907,
                "net": 0.14167967063381598,
                "open": 0.14424746728543086,
                "path": 0.19411157649135904,
                "production": 0.18256814063753923,
                "run": 0.14337170242511255,
                "script": 0.22345661064126252,
                "specific": 0.15103316373439332,
                "tricks": 0.20596387958929718
            },
            "Max term": "configuration",
            "Max score": 0.41192775917859437
        }
    },
    {
        "ID": "5560",
        "Question": "It's all the rage nowadays. \"Everyone\" recommends it. That in and of itself makes me suspicious. What are some disadvantages you have found when doing test-first (test-driven) development? I'm looking for personal experiences from knowledgeable practitioners--I can read the hypothetical musings of a hundred wannabes elsewhere on the internet. I ask not because I am looking to hate TDD, but because it is my job to improve software development process, and the more we can learn about the problems people encounter, the better chance we have of improving the process. ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "ask": 0.15133804905634957,
                    "better": 0.12232081466841944,
                    "chance": 0.19017692995403387,
                    "development": 0.24730536219789465,
                    "disadvantages": 0.22871007937041077,
                    "driven": 0.1877952130511265,
                    "encounter": 0.22871007937041077,
                    "experiences": 0.19833431172374952,
                    "hate": 0.23587281821429792,
                    "improve": 0.20147889331632043,
                    "improving": 0.24463930206221451,
                    "internet": 0.19542288391388798,
                    "job": 0.13571455784585323,
                    "learn": 0.1327593081719078,
                    "looking": 0.28926960861046486,
                    "makes": 0.1376006622932799,
                    "nowadays": 0.22265406996797832,
                    "people": 0.10941510630210338,
                    "personal": 0.17949366122208427,
                    "problems": 0.1478436316963855,
                    "process": 0.29910400144501953,
                    "read": 0.1470165212081398,
                    "software": 0.11552353238619793,
                    "tdd": 0.19017692995403387,
                    "test": 0.27650007472044635
                },
                "Max term": "process",
                "Max score": 0.29910400144501953
            }
        ],
        "Best Answer": "There are quite a few, but the advantages far outweigh the disadvantages. There's a steep learning curve. Many developers seem to expect that they can be efficient with test-first programming right from day one.  Unfortunately it takes a lot of time to gain experience and program at the same speed as before.  You can't get around it. To be more specific, it's very easy to get wrong.  You can very easily (with very good intentions) end up writing a whole bunch of tests which are either difficult to maintain or testing the wrong stuff.  It's difficult to give examples here - these kind of issues simply take experience to solve.  You need to have a good feel of separating concerns and designing for testability.  My best advice here would be to do pair-programming with someone who knows TDD really well. You do more coding up front. Test-first means you can't skip tests (which is good) and means you'll end up writing more code up front.  This means more time.  Again, you can't get around it.  You get rewarded with code that's easier to maintain, extend and generally less bugs, but it takes time. Can be a tough sell to managers. Software managers are generally only concerned with timelines.  If you switch to test-first programming and you're suddenly taking 2 weeks to complete a feature instead of one, they're not gonna like it.  This is definitely a battle worth fighting and many managers are enlightened enough to get it, but it can be a tough sell. Can be a tough sell to fellow developers. Since there's a steep learning curve not all developers like test-first programming.  In fact, I would guess that most developers don't like it at first.  You can do things like pair-programming to help them get up to speed, but it can be a tough sell. In the end, the advantages outweigh the disadvantages, but it doesn't help if you just ignore the disadvantages.  Knowing what you're dealing with right from the start helps you to negotiate some, if not all, of the disadvantages. ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "advantages": 0.13746004964727945,
                "advice": 0.07100432006604719,
                "best": 0.044690420408368604,
                "bugs": 0.05734523943065226,
                "bunch": 0.07715770217963304,
                "code": 0.05934838905888238,
                "coding": 0.04813746107005968,
                "complete": 0.05877963069370545,
                "concerned": 0.08477638164289705,
                "concerns": 0.07715770217963304,
                "curve": 0.1695527632857941,
                "day": 0.05377337945692417,
                "dealing": 0.07230188479736782,
                "definitely": 0.06220105681291749,
                "designing": 0.07373627606042099,
                "developers": 0.19348074731177126,
                "difficult": 0.12313545498113933,
                "disadvantages": 0.3170253154066361,
                "easier": 0.054863090909465936,
                "easily": 0.06356360555932367,
                "easy": 0.05412701298384613,
                "efficient": 0.07925632885165902,
                "end": 0.14173323433860577,
                "examples": 0.06220105681291749,
                "expect": 0.06873002482363973,
                "experience": 0.09721392038521622,
                "extend": 0.08173847737284534,
                "fact": 0.05734523943065226,
                "far": 0.05734523943065226,
                "feature": 0.05309253132433837,
                "feel": 0.05094655112522645,
                "fellow": 0.07533978906741953,
                "gain": 0.08477638164289705,
                "generally": 0.11656903405735596,
                "gonna": 0.07925632885165902,
                "good": 0.11121522283531377,
                "guess": 0.06873002482363973,
                "help": 0.0920118205157927,
                "helps": 0.065903196491942,
                "ignore": 0.07373627606042099,
                "instead": 0.054863090909465936,
                "issues": 0.0628652922218903,
                "kind": 0.05689883467379717,
                "knowing": 0.07100432006604719,
                "knows": 0.0628652922218903,
                "learning": 0.10426226983018427,
                "like": 0.1208801819763415,
                "lot": 0.043490917027627245,
                "maintain": 0.139639472552363,
                "managers": 0.2260193672022586,
                "means": 0.16458927272839782,
                "need": 0.03990644554275039,
                "outweigh": 0.1695527632857941,
                "pair": 0.13015569058713777,
                "program": 0.05182518663941424,
                "programming": 0.17994952879255446,
                "quite": 0.05412701298384613,
                "really": 0.03953343247474599,
                "right": 0.09721392038521622,
                "sell": 0.28401728026418877,
                "separating": 0.08477638164289705,
                "simply": 0.05689883467379717,
                "skip": 0.08477638164289705,
                "software": 0.040033089482152194,
                "solve": 0.06038314370070398,
                "specific": 0.05524661275862627,
                "speed": 0.15067957813483907,
                "start": 0.04724441144620192,
                "stuff": 0.05342869964641277,
                "suddenly": 0.07533978906741953,
                "switch": 0.07230188479736782,
                "takes": 0.1112825054361827,
                "taking": 0.0698197362761815,
                "tdd": 0.065903196491942,
                "test": 0.19163458742069897,
                "testability": 0.08477638164289705,
                "testing": 0.04985683967268468,
                "tests": 0.10754675891384834,
                "things": 0.040289967391910715,
                "time": 0.10024062438368177,
                "tough": 0.30135915626967813,
                "unfortunately": 0.07533978906741953,
                "weeks": 0.06507784529356889,
                "worth": 0.05689883467379717,
                "writing": 0.09448882289240385,
                "wrong": 0.10972618181893187
            },
            "Max term": "disadvantages",
            "Max score": 0.3170253154066361
        }
    },
    {
        "ID": "5564",
        "Question": "Need a Free, Fast(development and runtime) and Reliable(transactions and locking) tool set for creating an enterprise application for SMBs. I'm thinking of an application framework + UI framework + DB which will help me in developing the software faster.  As it is known, business softwares need lot of similar UIs to be created.  My idea is ...to create a new form with N number of fields and connecting it to the database for basic CRUD operations within 30min to 1hr.  I got the taste of Intersystems Cache technology stack with an app framework on top of it. To be frank...it is amazing...  I'm looking out for something similar to this in opensource. Any suggestions? ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "amazing": 0.17724514703709168,
                    "app": 0.1197990752511507,
                    "application": 0.21080274757422932,
                    "basic": 0.13219376580937992,
                    "business": 0.1197990752511507,
                    "cache": 0.1838326662365722,
                    "create": 0.11815857316521265,
                    "created": 0.14481252910229966,
                    "creating": 0.1411175327538915,
                    "crud": 0.1838326662365722,
                    "database": 0.13631973975454056,
                    "db": 0.16336996259529665,
                    "developing": 0.13219376580937992,
                    "development": 0.09291803018608691,
                    "enterprise": 0.1598928376495393,
                    "fast": 0.1411175327538915,
                    "faster": 0.13783399172190666,
                    "fields": 0.15678244339581612,
                    "form": 0.13219376580937992,
                    "framework": 0.36196448733784775,
                    "free": 0.1173712880806311,
                    "got": 0.11815857316521265,
                    "help": 0.09976114787458791,
                    "idea": 0.10645582305765848,
                    "known": 0.1411175327538915,
                    "looking": 0.10868491481909946,
                    "lot": 0.09430753093402537,
                    "need": 0.17306962486439237,
                    "new": 0.08708663113532067,
                    "number": 0.11512807460590171,
                    "operations": 0.1514000483017802,
                    "reliable": 0.17186275194305575,
                    "runtime": 0.17186275194305575,
                    "set": 0.11585703611326502,
                    "similar": 0.2395981505023014,
                    "software": 0.08680943246895365,
                    "stack": 0.13943013400826373,
                    "suggestions": 0.15678244339581612,
                    "taste": 0.17186275194305575,
                    "technology": 0.13631973975454056,
                    "thinking": 0.11585703611326502,
                    "tool": 0.12857436858312138,
                    "ui": 0.15396874953969011
                },
                "Max term": "framework",
                "Max score": 0.36196448733784775
            }
        ],
        "Best Answer": " What is the best toolset for living a   fullfilling life for suburban   professionals? Need a convenient, functional toolset   for living my life.  I'm thinking of a   moral code + religion + culture which   will help me life happier and better.  Ok I couldn't help myself.  You're asking for religion and any answer you get will be based more on personal preferences than one being actually \"better\" than another.   That being said, go with Ruby.  It's free, fully functional and comes with a lot of stuff, like Rails and an active community.  And, you get to look down on everyone else as a bonus. My background is in Java and .NET, but if I had to start from scratch at this moment, I'd probably learn Ruby. ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "active": 0.17590098487081052,
                "actually": 0.09671249341610832,
                "answer": 0.10399557352161384,
                "asking": 0.12413476795111829,
                "background": 0.14051330860159583,
                "based": 0.11230716276708884,
                "best": 0.09272734707215761,
                "better": 0.17590265823193868,
                "bonus": 0.17590098487081052,
                "code": 0.0615704508947281,
                "comes": 0.1350288471691114,
                "community": 0.1563211691758793,
                "convenient": 0.16444752691824419,
                "culture": 0.14732558275853708,
                "free": 0.11230716276708884,
                "fully": 0.16009312429652706,
                "functional": 0.2379692055269337,
                "help": 0.19091366645795305,
                "java": 0.10691029118154284,
                "learn": 0.09545683322897652,
                "life": 0.41022406044284415,
                "like": 0.06270302721389728,
                "living": 0.32889505383648837,
                "look": 0.10135367721173338,
                "lot": 0.09023851914698101,
                "moment": 0.14486771122331296,
                "need": 0.0828011639283179,
                "net": 0.10753114481090056,
                "ok": 0.1350288471691114,
                "personal": 0.12905985064902953,
                "preferences": 0.16444752691824419,
                "probably": 0.0998795495550999,
                "rails": 0.15299406896567788,
                "ruby": 0.28102661720319166,
                "said": 0.11157341494176959,
                "scratch": 0.1563211691758793,
                "start": 0.09802657700153199,
                "stuff": 0.11085824502110195,
                "thinking": 0.11085824502110195
            },
            "Max term": "life",
            "Max score": 0.41022406044284415
        }
    },
    {
        "ID": "5597",
        "Question": "I've been doing design and programming for about as long as I can remember. If there's a programming problem, I can figure it out. (Though admittedly Stack Overflow has allowed me to skip the figuring out and get straight to the doing in many instances.) I've made games, esoteric programming languages, and widgets and gizmos galore. I'm currently working on a general-purpose programming language. There's nothing I do better than programming. Is a university education really more than just a formality? ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "admittedly": 0.23280540108197842,
                    "allowed": 0.21659094701026468,
                    "better": 0.12451111205044654,
                    "currently": 0.18465881251256813,
                    "design": 0.14277677287066293,
                    "education": 0.23280540108197842,
                    "figure": 0.1888721546915705,
                    "games": 0.1935822705163038,
                    "general": 0.17573535450883246,
                    "language": 0.11722011598246848,
                    "languages": 0.13631277333410585,
                    "long": 0.13814468587891546,
                    "overflow": 0.19616315075954857,
                    "problem": 0.12972425040977684,
                    "programming": 0.5285788886774402,
                    "purpose": 0.1888721546915705,
                    "really": 0.11612443746488138,
                    "remember": 0.1741669274373862,
                    "skip": 0.24901985515369213,
                    "stack": 0.1888721546915705,
                    "straight": 0.22130106283499798,
                    "university": 0.20188571975608036,
                    "working": 0.13288297835433252
                },
                "Max term": "programming",
                "Max score": 0.5285788886774402
            }
        ],
        "Best Answer": "Hooboy.  This is a tough position to be in; you have my sympathies. I'm biased towards getting a degree, most likely because 1) I have one (BS in Computer Science) and 2) I've often found the knowledge gained pursuing it to be very useful.  But it's hardly a pre-requisite for a successful career; the IT world is rich with people who kick ass, are acknowledged as kicking ass, and who technically don't have more than a high school diploma. The nice thing about a university degree is that you can put it on hold and come back to it later when life permits.  (Though the dangerous thing about the previous sentence is that it's a good way to simply quit without admitting to yourself you're quitting.)  You can test the waters and see what kind of job you could get by sending your resume out today and seeing what kind of nibbles you get; you haven't committed to anything until you actually say yes to a job offer. And it sounds like your school is a bad fit for you, regardless.  If you're so consistently bored with everything they're throwing at you, then you may need to find a school that will do a better job of giving you your money's worth and making you work for that degree.  Have you considered transferring somewhere better?  Edit:  Based on your comments elsewhere, given how much you love the high-level theoretic aspects of programming, have you considered that the best way to continue to explore that and get paid may be a career in academia?  Which would definitely require you to get your degree.  :-) ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "academia": 0.1220116867135638,
                "actually": 0.06708350414661006,
                "aspects": 0.1084303736797918,
                "bad": 0.07213532855109177,
                "based": 0.07790056644248579,
                "best": 0.06431925340871379,
                "better": 0.12201284742118507,
                "biased": 0.11763948048253269,
                "career": 0.17220929636791515,
                "come": 0.08126774761224784,
                "comments": 0.0904768544149887,
                "committed": 0.1220116867135638,
                "computer": 0.07739161073734653,
                "considered": 0.18508251201833523,
                "consistently": 0.1140671278782517,
                "continue": 0.10405816744876069,
                "dangerous": 0.11763948048253269,
                "definitely": 0.08952087491865882,
                "degree": 0.39566993042572246,
                "edit": 0.08126774761224784,
                "fit": 0.10405816744876069,
                "getting": 0.07415708879446357,
                "given": 0.08459669717385553,
                "giving": 0.10048581484447972,
                "good": 0.0533543134828929,
                "hardly": 0.1140671278782517,
                "high": 0.16377964371797082,
                "hold": 0.1084303736797918,
                "job": 0.20305930373542755,
                "kind": 0.16377964371797082,
                "knowledge": 0.07641172191167696,
                "later": 0.09148187947625779,
                "level": 0.07458773674436452,
                "life": 0.09484906064601982,
                "like": 0.04349323068334705,
                "likely": 0.0825322955796766,
                "love": 0.10405816744876069,
                "making": 0.08188982185898541,
                "money": 0.08610464818395758,
                "need": 0.05743407110631155,
                "nice": 0.08860937601569413,
                "offer": 0.10048581484447972,
                "paid": 0.10048581484447972,
                "people": 0.05456981588538248,
                "position": 0.09484906064601982,
                "previous": 0.08860937601569413,
                "programming": 0.051797316907851665,
                "pursuing": 0.1220116867135638,
                "quit": 0.11763948048253269,
                "quitting": 0.1220116867135638,
                "regardless": 0.1084303736797918,
                "require": 0.08533616957265865,
                "resume": 0.11104674678774289,
                "say": 0.06356069314384916,
                "school": 0.28454718193805945,
                "science": 0.09891748260643062,
                "seeing": 0.10048581484447972,
                "simply": 0.08188982185898541,
                "sounds": 0.09366120042017587,
                "successful": 0.11763948048253269,
                "technically": 0.1140671278782517,
                "test": 0.06895098254590462,
                "thing": 0.13923047828078616,
                "throwing": 0.11763948048253269,
                "today": 0.09611360861344859,
                "tough": 0.1084303736797918,
                "transferring": 0.11763948048253269,
                "university": 0.09891748260643062,
                "useful": 0.07895994297539562,
                "way": 0.10730238659659101,
                "work": 0.051661719875589984,
                "world": 0.07547851254337462,
                "worth": 0.08188982185898541,
                "yes": 0.07951191448916779
            },
            "Max term": "degree",
            "Max score": 0.39566993042572246
        }
    },
    {
        "ID": "5613",
        "Question": "With all of the frameworks available these days, ORMs, dependency injection (DI), Inversion of control (IoC), etc., I find that many programmers are losing or don't have the problem solving skills needed to solve difficult issues. Many times, I've seen unexpected behaviour creep into applications and the developers unable to really dig in and find the issues. It seems to me that deep understanding of what's going on under the hood is being lost. Don't get me wrong, I'm not suggesting these frameworks aren't good and haven't moved the industry forward, only asking if, as a unintended consequence, developers aren't gaining the knowledge and skill needed for deep understanding of systems. ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "applications": 0.12208066715150655,
                    "asking": 0.12318004133280441,
                    "available": 0.121022788830531,
                    "behaviour": 0.1682933078972599,
                    "control": 0.1171503728785363,
                    "creep": 0.17454812172686104,
                    "days": 0.12000338745249298,
                    "deep": 0.3365866157945198,
                    "dependency": 0.16318275288389342,
                    "developers": 0.199181071302591,
                    "difficult": 0.12676326807314917,
                    "forward": 0.17454812172686104,
                    "frameworks": 0.2647763153469972,
                    "going": 0.0902281936201362,
                    "good": 0.07632789493622988,
                    "hood": 0.1682933078972599,
                    "industry": 0.12806724497695254,
                    "injection": 0.16318275288389342,
                    "issues": 0.2588697103248111,
                    "knowledge": 0.1093134837887274,
                    "lost": 0.13943261381992014,
                    "moved": 0.16318275288389342,
                    "needed": 0.242045577661062,
                    "problem": 0.09092899133475303,
                    "programmers": 0.09352970493864426,
                    "really": 0.08139633055996037,
                    "seen": 0.11901976201872265,
                    "skill": 0.14619249444057636,
                    "skills": 0.121022788830531,
                    "solve": 0.12432430014903909,
                    "solving": 0.14375352651646622,
                    "suggesting": 0.16318275288389342,
                    "systems": 0.121022788830531,
                    "times": 0.11539789923018154,
                    "unable": 0.15511889535943385,
                    "understanding": 0.2788652276398403,
                    "unexpected": 0.15511889535943385,
                    "wrong": 0.11295893130607143
                },
                "Max term": "deep",
                "Max score": 0.3365866157945198
            }
        ],
        "Best Answer": "This is an argument that pops up regularly, in many fields and in many forms. The general form of this argument is: Does having [x:tool/technology] make people worse at [y:function affected by x]? For example:  Does CAD software make for worse engineers? Do calculators in high school make students worse at math? Does social software stunt people's in-person social skills? Does accounting software produce worse accountants?  From memory, the ubiquitous answer is almost always: not really. You'll always have people that are good and bad at doing [y] but now they're just bad at a different facet of the skill.  A deeper understanding of the fundamentals with any job is going to help, no matter what you do - even jobs that are considered 'remedial'. Knowledge always helps. ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "accounting": 0.14696712814340043,
                "affected": 0.14696712814340043,
                "answer": 0.0868893985518196,
                "argument": 0.2747952864415082,
                "bad": 0.1737787971036392,
                "considered": 0.11146901577042635,
                "deeper": 0.1373976432207541,
                "different": 0.07908082356158797,
                "engineers": 0.130607985615719,
                "example": 0.07842519101870234,
                "fields": 0.12534151802779173,
                "form": 0.10568381842682928,
                "forms": 0.14170066055547312,
                "function": 0.10189953084778003,
                "fundamentals": 0.14696712814340043,
                "general": 0.103715907912183,
                "going": 0.07597090339745229,
                "good": 0.06426704226335209,
                "help": 0.07975519097650152,
                "helps": 0.11424884308803761,
                "high": 0.098639009647031,
                "job": 0.0815305580326748,
                "jobs": 0.11577203310514537,
                "knowledge": 0.09204045635575077,
                "make": 0.2000838165663035,
                "math": 0.1373976432207541,
                "matter": 0.10673293575702669,
                "memory": 0.12309207828470811,
                "people": 0.19719346580667863,
                "person": 0.10021300970270372,
                "produce": 0.11281802600214734,
                "really": 0.0685345956488019,
                "regularly": 0.1373976432207541,
                "school": 0.11424884308803761,
                "skill": 0.12309207828470811,
                "skills": 0.10189953084778003,
                "social": 0.261215971231438,
                "software": 0.2082023817677041,
                "students": 0.130607985615719,
                "technology": 0.1089823755001103,
                "tool": 0.10279024990691851,
                "understanding": 0.11740035137535357,
                "worse": 0.5013660721111669
            },
            "Max term": "worse",
            "Max score": 0.5013660721111669
        }
    },
    {
        "ID": "5705",
        "Question": "I've used Emacs quite a bit, and I'm comfortable with the most basic commands/shortcuts, but I know Emacs has a lot more to offer than what I'm using. What are some of the lesser known features of emacs that can help me become a more productive programmer? ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "basic": 0.1801342753463216,
                    "bit": 0.16561161459468815,
                    "comfortable": 0.22798825651436877,
                    "emacs": 0.751500585101513,
                    "features": 0.15787297620471274,
                    "help": 0.13593986047737674,
                    "know": 0.10923953596821522,
                    "known": 0.1922942761002678,
                    "lot": 0.12850847118613568,
                    "offer": 0.20630578016489284,
                    "productive": 0.20630578016489284,
                    "programmer": 0.12948967812305462,
                    "quite": 0.15993637669234662,
                    "shortcuts": 0.2415236900522071,
                    "used": 0.12223819740543442,
                    "using": 0.11754618752583011
                },
                "Max term": "emacs",
                "Max score": 0.751500585101513
            }
        ],
        "Best Answer": "Learn elisp.     It allows you to program any shortcut you can think of.  Any time you find yourself performing a multi-step process for something useful, you make a function out of it and bind it to a hotkey combo. It lets you experiment with functional programming - learning a new paradigm is a good way to expand your horizons.  ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "allows": 0.24956331697896683,
                "expand": 0.30952862112646834,
                "experiment": 0.32103260737683736,
                "function": 0.22258767992404482,
                "functional": 0.21715590331064533,
                "good": 0.14038388316379302,
                "learn": 0.17421594362272125,
                "learning": 0.19741104589485522,
                "lets": 0.30012917995888494,
                "make": 0.14568661291277482,
                "multi": 0.26026799736688794,
                "new": 0.1520820474042327,
                "paradigm": 0.29218206568749483,
                "process": 0.19625247589269293,
                "program": 0.19625247589269293,
                "programming": 0.13628717174519145,
                "step": 0.26888033629272573,
                "think": 0.13628717174519145,
                "time": 0.12653095271483067,
                "useful": 0.20775646214306195,
                "way": 0.1411650222807368
            },
            "Max term": "experiment",
            "Max score": 0.32103260737683736
        }
    },
    {
        "ID": "5727",
        "Question": "Especially when writing 'standard' (non-HPC) applications, do you consider what sorting algorithm to pick, or just settle with quicksort (which is what most libraries just call sort)? To some extent it may be profitable in specific situations, but on the other hand proper optimization requires some time to analyse the problem and make benchmarks.  ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "algorithm": 0.22610123073340585,
                    "applications": 0.20074798194345356,
                    "consider": 0.18574830914088103,
                    "especially": 0.2105922385751301,
                    "extent": 0.24479030667396603,
                    "hand": 0.20443738508144124,
                    "libraries": 0.2105922385751301,
                    "make": 0.13025367169746865,
                    "non": 0.16969383212273123,
                    "optimization": 0.2870248337126262,
                    "pick": 0.21769749548619344,
                    "problem": 0.1495225405997479,
                    "proper": 0.24479030667396603,
                    "requires": 0.24039718097054227,
                    "settle": 0.2870248337126262,
                    "situations": 0.23638657142675362,
                    "sort": 0.2105922385751301,
                    "sorting": 0.2767394930192784,
                    "specific": 0.18704678747703005,
                    "standard": 0.18838290806329142,
                    "time": 0.11312721769674904,
                    "writing": 0.15995397628925748
                },
                "Max term": "optimization",
                "Max score": 0.2870248337126262
            }
        ],
        "Best Answer": "In general, using the default methods unless there is a specific need to do something more exotic keeps everything a lot more readable/understandable down the road IMHO. If you experience (or in some cases, strongly suspect) that you have a performance problem that is the time to add complexity. On the other hand, if you are using a low enough language that there is not a built-in sort for the kind of objects you need to sort try to pick one or two that cover all your bases and implement those. ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "add": 0.14867807336751418,
                "built": 0.17695694753644706,
                "cases": 0.1535926402517113,
                "complexity": 0.1855360583167056,
                "cover": 0.1855360583167056,
                "default": 0.20161499917001238,
                "experience": 0.1270111986496708,
                "general": 0.15633045608553547,
                "hand": 0.15778265971110952,
                "imho": 0.20709876297824012,
                "implement": 0.16087800668314028,
                "keeps": 0.2215227985247219,
                "kind": 0.14867807336751418,
                "language": 0.10427653698458067,
                "lot": 0.11364285032768517,
                "low": 0.1745025917586469,
                "methods": 0.1535926402517113,
                "need": 0.20855307396916134,
                "objects": 0.1824407113446748,
                "performance": 0.17005003200202207,
                "pick": 0.16801667579819304,
                "problem": 0.11539995061662653,
                "readable": 0.18892662730512869,
                "road": 0.2215227985247219,
                "sort": 0.32506582397993067,
                "specific": 0.14436077631685384,
                "strongly": 0.19267472743175837,
                "suspect": 0.20161499917001238,
                "time": 0.08731041676550545,
                "try": 0.1270111986496708,
                "unless": 0.16426857567156336,
                "using": 0.20789732649203133
            },
            "Max term": "sort",
            "Max score": 0.32506582397993067
        }
    },
    {
        "ID": "5748",
        "Question": "I'm not talking about a diff tool.  I'm really looking to see if a project contains code that may have been \"refactored\" from another project.  It would be likely that function names, variable names and whatnot would be changed.  Conditionals might be reversed, etc. ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "changed": 0.2653358634752062,
                    "code": 0.11626549054531995,
                    "contains": 0.2692888611815329,
                    "function": 0.23030254755174662,
                    "likely": 0.22468250608213441,
                    "looking": 0.19637823329742102,
                    "names": 0.5233114213094731,
                    "project": 0.3137046757625852,
                    "really": 0.15489464811104958,
                    "refactored": 0.3321595667437413,
                    "talking": 0.24631044428859863,
                    "tool": 0.23231565660893083,
                    "variable": 0.2832836488612007
                },
                "Max term": "names",
                "Max score": 0.5233114213094731
            }
        ],
        "Best Answer": "You might be able to use the PMD tool to find what you are looking for.  It is meant to detect cut and paste within a code base but if you include the suspected origin project source it might help you see where code was copied from it. ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "able": 0.24577910261300395,
                "base": 0.3031634421259117,
                "code": 0.2730104588161895,
                "cut": 0.37600783381596087,
                "detect": 0.3899825962612163,
                "help": 0.21163328722037006,
                "include": 0.29578706968008067,
                "looking": 0.2305641653537053,
                "meant": 0.33259825674830856,
                "project": 0.18415751970130662,
                "source": 0.23180434016774853,
                "tool": 0.27275765020002135,
                "use": 0.14689274816615835
            },
            "Max term": "detect",
            "Max score": 0.3899825962612163
        }
    },
    {
        "ID": "5749",
        "Question": "I work as the back-end developer, front-end developer, systems admin, help desk and all-around 'guy who knows computers' at a small marketing company of about 15 people.  I was wondering if others could share their experiences flying solo at companies that aren't necessarily inclined toward the technology industry.  I originally took the job in order to transition from front-end developer/designer to full-time coder. It's been a good experience to a point. I definitely get to occupy the role of 'rock star' programmer - because frankly, no one really understands my job. Lately, it feels like a very solitary position. I rarely get to bounce ideas off of people, and everyone looks to me like I have magic powers that will make all the computers work and land us first on Google searches. I've also felt a strong disconnect versus between what we say we want (projects with large, months-long development schedules) versus what we actually do (copy-edit our sites over and over). So who else finds themselves being the 'tech guy' in a company that thinks technology is all a bit magical, and what is your take on your situation? ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "15": 0.11007066389542798,
                    "actually": 0.07225634650799569,
                    "admin": 0.12286290082774855,
                    "bit": 0.0868849213429818,
                    "bounce": 0.1314200685452086,
                    "coder": 0.11960961664949457,
                    "companies": 0.09450395362030464,
                    "company": 0.1553954392085582,
                    "computers": 0.2241642889653564,
                    "copy": 0.10823432599276243,
                    "definitely": 0.0964238740970484,
                    "designer": 0.1314200685452086,
                    "desk": 0.12286290082774855,
                    "developer": 0.21773567993544723,
                    "development": 0.06642613712857065,
                    "edit": 0.08753434404025025,
                    "end": 0.21971439463380665,
                    "experience": 0.07535035013872868,
                    "experiences": 0.10654505887599894,
                    "feels": 0.11960961664949457,
                    "felt": 0.1267107193176643,
                    "frankly": 0.1314200685452086,
                    "good": 0.057468491125488574,
                    "google": 0.09450395362030464,
                    "guy": 0.21646865198552487,
                    "help": 0.07131821106785846,
                    "ideas": 0.10088346215672528,
                    "inclined": 0.12286290082774855,
                    "industry": 0.0964238740970484,
                    "job": 0.14581153841052827,
                    "knows": 0.09745356964769208,
                    "large": 0.08889640193023202,
                    "lately": 0.1314200685452086,
                    "like": 0.09369403065587842,
                    "long": 0.07290576920526413,
                    "looks": 0.09967715827530237,
                    "magic": 0.1120821444826782,
                    "magical": 0.11960961664949457,
                    "make": 0.05963925226025978,
                    "months": 0.10823432599276243,
                    "necessarily": 0.09853609269117486,
                    "order": 0.10216291887523637,
                    "originally": 0.11007066389542798,
                    "people": 0.1175554430452625,
                    "point": 0.07535035013872868,
                    "position": 0.10216291887523637,
                    "programmer": 0.06793424800539616,
                    "projects": 0.07649141572285621,
                    "rarely": 0.09967715827530237,
                    "really": 0.061284597254261275,
                    "role": 0.1143057331102885,
                    "say": 0.0684618897971273,
                    "schedules": 0.1267107193176643,
                    "share": 0.10216291887523637,
                    "sites": 0.09967715827530237,
                    "situation": 0.0964238740970484,
                    "small": 0.07854201508380827,
                    "solo": 0.1143057331102885,
                    "strong": 0.10823432599276243,
                    "systems": 0.09111999055784233,
                    "tech": 0.10823432599276243,
                    "technology": 0.19490713929538417,
                    "thinks": 0.1267107193176643,
                    "time": 0.05179756229358453,
                    "took": 0.1143057331102885,
                    "transition": 0.1267107193176643,
                    "understands": 0.1267107193176643,
                    "versus": 0.2628401370904172,
                    "want": 0.06205916390702332,
                    "wondering": 0.10216291887523637,
                    "work": 0.1112907615670006
                },
                "Max term": "versus",
                "Max score": 0.2628401370904172
            }
        ],
        "Best Answer": "Take advantage of the situation you have - to a certain extent, I think you have a little bit of \"grassisgreeneritis\".  Sorry, I'm not trying to be funny.  What I am saying is every position at every company has short-comings.  Yours are starting to get to you more because they are very familiar.  But, at tech companies, schedules and time commitments become an issue.  At larger non-tech companies, overcoming political stupidity and procedure can be big issues. So take advantage of what you have now; learn what you can.  Once you believe you can't really learn more, it is probably time to move on.  There is no harm in that; it sounds like you are one of those people that have to grow to be happy with a job. Your current company should understand that when you reach that point and honestly, if they don't, leaving is definitely the right thing to do. Having said all that, there is more you can do in your current position.   If you are feeling solitary, make some changes to eliminate that feeling.    Use on-line communities to bounce ideas off of people (StackOverflow is great for this). Do some research with Google to find out what it would take to land your company first and then put a proposal together to get it to happen.   When going through projects, take the initiative and change how things happen.  Don't go for the impractical, long projects. Instead, propose month long incremental improvements.  Over a year, those add up and can really help you feel like you've accomplished something.   ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "accomplished": 0.12074109431342739,
                "add": 0.08668112267136949,
                "advantage": 0.2163395511745541,
                "believe": 0.09198920709731216,
                "big": 0.08038271826612427,
                "bit": 0.08538444405602372,
                "bounce": 0.1291504822366231,
                "certain": 0.09198920709731216,
                "change": 0.07989469333675037,
                "changes": 0.08602265141245023,
                "communities": 0.12074109431342739,
                "companies": 0.1857437957298158,
                "company": 0.22906770784691743,
                "current": 0.18951732374836383,
                "definitely": 0.09475866187418192,
                "extent": 0.11014651849061534,
                "familiar": 0.10173713056741962,
                "feel": 0.07761326348925453,
                "feeling": 0.2163395511745541,
                "funny": 0.12452246209867296,
                "going": 0.06676104332772502,
                "google": 0.0928718978649079,
                "great": 0.07989469333675037,
                "grow": 0.1291504822366231,
                "happen": 0.1959115255643481,
                "happy": 0.10816977558727706,
                "help": 0.07008656633365457,
                "honestly": 0.11233170639023168,
                "ideas": 0.09914123414689248,
                "improvements": 0.1291504822366231,
                "instead": 0.08357981917411643,
                "issue": 0.0880643086177687,
                "issues": 0.0957705748825577,
                "job": 0.07164670780439261,
                "larger": 0.11477453862856547,
                "learn": 0.14017313266730913,
                "leaving": 0.12452246209867296,
                "like": 0.09207596203419281,
                "line": 0.0880643086177687,
                "little": 0.08191972520847203,
                "long": 0.14329341560878522,
                "make": 0.05860929974324675,
                "month": 0.10173713056741962,
                "non": 0.07635590261563914,
                "people": 0.11552529478108434,
                "point": 0.07404907153710359,
                "political": 0.11754399340543523,
                "position": 0.2007971900410157,
                "probably": 0.07333382470878037,
                "projects": 0.15034086250184145,
                "proposal": 0.12074109431342739,
                "propose": 0.12074109431342739,
                "reach": 0.11754399340543523,
                "really": 0.12045246021679448,
                "research": 0.10816977558727706,
                "right": 0.07404907153710359,
                "said": 0.08191972520847203,
                "saying": 0.10173713056741962,
                "schedules": 0.12452246209867296,
                "short": 0.0928718978649079,
                "situation": 0.09475866187418192,
                "sorry": 0.12452246209867296,
                "sounds": 0.09914123414689248,
                "stackoverflow": 0.10636515070536977,
                "starting": 0.0957705748825577,
                "tech": 0.21273030141073954,
                "thing": 0.07368836500971108,
                "things": 0.0613787545201165,
                "think": 0.05482793195800119,
                "time": 0.10180606695691552,
                "trying": 0.07989469333675037,
                "understand": 0.07069661332926949,
                "use": 0.04864645100730326,
                "year": 0.09379383197921944
            },
            "Max term": "company",
            "Max score": 0.22906770784691743
        }
    },
    {
        "ID": "5757",
        "Question": "I have found that there are only 3 ways to unit test (mock/stub) dependencies that are static in C#.NET:  Moles TypeMock JustMock  Given that two of these are not free and one has not hit release 1.0, mocking static stuff is not too easy. Does that make static methods and such \"evil\" (in the unit testing sense)?  And if so, why does resharper want me to make anything that can be static, static? (Assuming resharper is not also \"evil\".) Clarification: I am talking about the scenario when you want to unit test a method and that method calls a static method in a different unit/class.  By most definitions of unit testing, if you just let the method under test call the static method in the other unit/class then you are not unit testing, you are integration testing.  (Useful, but not a unit test.) ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "assuming": 0.08278120839570506,
                    "calls": 0.07895343947685617,
                    "class": 0.1316644875088881,
                    "definitions": 0.09883752579119898,
                    "different": 0.053183001104377854,
                    "easy": 0.06310460458581842,
                    "evil": 0.17193258182609497,
                    "free": 0.06310460458581842,
                    "given": 0.06852891279505345,
                    "hit": 0.08596629091304749,
                    "integration": 0.08995520015577448,
                    "let": 0.06440990294216699,
                    "make": 0.08970617956135828,
                    "method": 0.3456396714218254,
                    "methods": 0.06852891279505345,
                    "net": 0.06042099369944002,
                    "release": 0.07785837181743406,
                    "scenario": 0.08783576511228067,
                    "sense": 0.07107390109223675,
                    "static": 0.5900579247955686,
                    "stuff": 0.06229046789867318,
                    "talking": 0.07329222857759149,
                    "test": 0.2234194018383898,
                    "testing": 0.23250469442178703,
                    "unit": 0.5117021564416869,
                    "useful": 0.06396276955521087,
                    "want": 0.0933460814796431,
                    "ways": 0.0663361649857791
                },
                "Max term": "static",
                "Max score": 0.5900579247955686
            }
        ],
        "Best Answer": "Looking at the other answers here, I think there might be some confusion between static methods that hold static state or cause side-effects (which sounds to me like a really bad idea), and static methods that merely return a value.   Static methods which hold no state and cause no side effects should be easily unit testable.  In fact, I consider such methods a \"poor-man's\" form of functional programming; you hand the method an object or value, and it returns an object or value.  Nothing more.  I don't see how such methods would negatively affect unit testing at all. ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "affect": 0.11472664938167312,
                "answers": 0.0930857391733153,
                "bad": 0.07798383153883418,
                "cause": 0.2050782415663906,
                "confusion": 0.13190400617223724,
                "consider": 0.08536176399263118,
                "easily": 0.0988989392746648,
                "effects": 0.22945329876334625,
                "fact": 0.08922375158297323,
                "form": 0.0948519523663569,
                "functional": 0.08922375158297323,
                "hand": 0.09395044238791325,
                "hold": 0.23444312695543257,
                "idea": 0.0763844088710412,
                "like": 0.04701952348199924,
                "looking": 0.07798383153883418,
                "man": 0.12331532777695518,
                "merely": 0.13190400617223724,
                "method": 0.09225495476062232,
                "methods": 0.4572776414593505,
                "object": 0.1897039047327138,
                "poor": 0.11249487267277627,
                "programming": 0.05599687860358924,
                "really": 0.0615102699608497,
                "return": 0.1039061942774942,
                "returns": 0.13190400617223724,
                "sounds": 0.10125495262863722,
                "state": 0.2209519701300463,
                "static": 0.4499794906911051,
                "testable": 0.12717731536729723,
                "testing": 0.07757251206610133,
                "think": 0.05599687860358924,
                "unit": 0.17072352798526236,
                "value": 0.30013262006145647
            },
            "Max term": "methods",
            "Max score": 0.4572776414593505
        }
    },
    {
        "ID": "5898",
        "Question": "In another question, it was revealed that one of the pains with TDD is keeping the testing suite in sync with the codebase during and after refactoring. Now, I'm a big fan of refactoring. I'm not going to give it up to do TDD. But I've also experienced the problems of tests written in such a way that minor refactoring leads to lots of test failures. How do you avoid breaking tests when refactoring?   Do you write the tests 'better'? If so, what should you look for?  Do you avoid certain types of refactoring?  Are there test-refactoring tools?  Edit: I wrote a new question that asked what I meant to ask (but kept this one as an interesting variant). ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "ask": 0.08736199082450614,
                    "asked": 0.09336483697030114,
                    "avoid": 0.19583151901778226,
                    "better": 0.07061138923979161,
                    "big": 0.08789562863725037,
                    "breaking": 0.12550185465125785,
                    "certain": 0.10058690922707848,
                    "codebase": 0.12283070493307051,
                    "edit": 0.09406269389781022,
                    "experienced": 0.1204412800881504,
                    "failures": 0.1320260699805261,
                    "fan": 0.14122143502798168,
                    "going": 0.07300081408471173,
                    "interesting": 0.09877165582616539,
                    "keeping": 0.11630648960380227,
                    "kept": 0.12853015443815358,
                    "leads": 0.1320260699805261,
                    "look": 0.08137141330798213,
                    "lots": 0.10588495779935633,
                    "meant": 0.1204412800881504,
                    "minor": 0.11827978239448055,
                    "new": 0.06690050942771887,
                    "problems": 0.08534478986782865,
                    "question": 0.14489530207117526,
                    "refactoring": 0.6978389376228136,
                    "tdd": 0.2195645485490681,
                    "test": 0.15961350857449438,
                    "testing": 0.08305207544944156,
                    "tests": 0.2687288723361294,
                    "tools": 0.09336483697030114,
                    "types": 0.1036152090139742,
                    "way": 0.06209813758526329,
                    "write": 0.06962520949110483,
                    "written": 0.09629517305992469,
                    "wrote": 0.10978227427453405
                },
                "Max term": "refactoring",
                "Max score": 0.6978389376228136
            }
        ],
        "Best Answer": "What you're trying to do is not really refactoring.  With refactoring, by definition, you don't change what your software does, you change how it does it. Start with all green tests (all pass), then make modifications \"under the hood\" (e.g. move a method from a derived class to base, extract a method, or encapsulate a Composite with a Builder, etc.).  Your tests should still pass. What you're describing seems to be not refactoring, but a redesign, which also augments the functionality of your software under test.  TDD and refactoring (as I tried to define it here) are not in conflict.  You can still refactor (green-green) and apply TDD (red-green) to develope the \"delta\" functionality. ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "apply": 0.1196732849235285,
                "base": 0.11107566418233741,
                "change": 0.17678247639244352,
                "class": 0.09517088499507233,
                "define": 0.11413964160852469,
                "definition": 0.11413964160852469,
                "derived": 0.13776502729350715,
                "describing": 0.14288522255686756,
                "encapsulate": 0.14288522255686756,
                "extract": 0.14288522255686756,
                "functionality": 0.20967188440344864,
                "green": 0.520177683183159,
                "hood": 0.13776502729350715,
                "make": 0.06484221113764646,
                "method": 0.19987065026262632,
                "pass": 0.2353534879256042,
                "really": 0.06663109687064893,
                "red": 0.13776502729350715,
                "refactor": 0.12698044336960249,
                "refactoring": 0.4707069758512084,
                "software": 0.13494647422890027,
                "start": 0.07962746360765885,
                "tdd": 0.22215132836467483,
                "test": 0.08074699032491153,
                "tests": 0.18126325144902553,
                "tried": 0.1071324318265695,
                "trying": 0.08839123819622176
            },
            "Max term": "green",
            "Max score": 0.520177683183159
        }
    },
    {
        "ID": "5916",
        "Question": "Someone once said we should prefix all our methods with the  /// <summary> comment blocks (C#) but did not explain why. I started to use them and found they annoyed me quite a bit, so stopped using them except for libraries and static methods. They're bulky and I'm always forgetting to update them.  Is there any good reason to use /// <summary> comment blocks in your code? I normally use // comments all the time, it's just the /// <summary> blocks I was wondering about. ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "annoyed": 0.17497932683342365,
                    "bit": 0.11568297914363097,
                    "blocks": 0.524937980500271,
                    "code": 0.061247843827039794,
                    "comment": 0.2882173128066502,
                    "comments": 0.12975461208651937,
                    "explain": 0.11323798597322651,
                    "good": 0.07651645599173744,
                    "libraries": 0.1283836233456862,
                    "methods": 0.242643529034447,
                    "normally": 0.1555021023463759,
                    "prefix": 0.17497932683342365,
                    "quite": 0.1117187135364241,
                    "reason": 0.10890639885863843,
                    "said": 0.11098881028639881,
                    "started": 0.11402957902888045,
                    "static": 0.14923183657356712,
                    "stopped": 0.1687090610606149,
                    "summary": 0.4907576426711186,
                    "time": 0.06896589449446144,
                    "update": 0.1327152104602743,
                    "use": 0.19772570189472988,
                    "using": 0.0821083303441212,
                    "wondering": 0.13602487785932812
                },
                "Max term": "blocks",
                "Max score": 0.524937980500271
            }
        ],
        "Best Answer": " Use them as much as possible.  Yes, those are special comments that become the documentation for the method. The contents of <summary>, the parameter tags, etc. that are generated show up in intellisense when you or someone else is getting ready to call your method.  They can essentially see all the documentation for your method or class without having to go to the file itself to figure out what it does (or try to just read the method signature and hope for the best). ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "best": 0.11268017835053976,
                "class": 0.142372055174604,
                "comments": 0.15850538605125605,
                "contents": 0.2137509049175619,
                "documentation": 0.30741584338283157,
                "essentially": 0.1899579550032426,
                "figure": 0.16212198804041572,
                "file": 0.142372055174604,
                "getting": 0.12991497177709646,
                "hope": 0.17902672151195076,
                "intellisense": 0.2137509049175619,
                "method": 0.5979979118287696,
                "parameter": 0.20609128587989464,
                "possible": 0.12570652804287308,
                "read": 0.1284540716931906,
                "ready": 0.18591493795473502,
                "signature": 0.2137509049175619,
                "special": 0.17603997152182915,
                "summary": 0.19983292143614845,
                "try": 0.12255514478344563,
                "use": 0.08051245913885018,
                "yes": 0.13929603082766034
            },
            "Max term": "method",
            "Max score": 0.5979979118287696
        }
    },
    {
        "ID": "5951",
        "Question": "A well-tested codebase has a number of benefits, but testing certain aspects of the system results in a codebase that is resistant to some types of change. An example is testing for specific output--e.g., text or HTML. Tests are often (naively?) written to expect a particular block of text as output for some input parameters, or to search for specific sections in a block.  Changing the behavior of the code, to meet new requirements or because usability testing has resulted in change to the interface, requires changing the tests as well--perhaps even tests that are not specifically unit tests for the code being changed.  How do you manage the work of finding and rewriting these tests? What if you can't just \"run 'em all and let the framework sort them out\"? What other sorts of code-under-test result in habitually fragile tests?  ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "aspects": 0.11804481337773778,
                    "behavior": 0.11328492690796314,
                    "benefits": 0.1093958164845577,
                    "block": 0.22250372120657666,
                    "certain": 0.09461025863680274,
                    "change": 0.1643422709862417,
                    "changed": 0.10610762047398536,
                    "changing": 0.21221524094797073,
                    "code": 0.139483457495266,
                    "codebase": 0.23106475487826525,
                    "example": 0.07088147783822775,
                    "expect": 0.10768842140629746,
                    "finding": 0.11804481337773778,
                    "framework": 0.08718051078339191,
                    "html": 0.10074681959137763,
                    "input": 0.11125186060328833,
                    "interface": 0.10196606863114689,
                    "let": 0.08656217615645571,
                    "manage": 0.11804481337773778,
                    "meet": 0.11328492690796314,
                    "new": 0.06292542984496452,
                    "number": 0.08318709183436637,
                    "output": 0.21537684281259492,
                    "parameters": 0.1328303712254928,
                    "particular": 0.08656217615645571,
                    "requirements": 0.0884736976822278,
                    "requires": 0.11125186060328833,
                    "result": 0.1093958164845577,
                    "results": 0.10610762047398536,
                    "rewriting": 0.12807048475571814,
                    "run": 0.08217113549312086,
                    "search": 0.10768842140629746,
                    "sort": 0.0974586235808053,
                    "sorts": 0.1241813743323127,
                    "specific": 0.17312435231291143,
                    "specifically": 0.1032592555299828,
                    "test": 0.07506481431927307,
                    "tested": 0.10768842140629746,
                    "testing": 0.23435191713236245,
                    "tests": 0.5055231999921744,
                    "text": 0.2092718600295661,
                    "types": 0.0974586235808053,
                    "unit": 0.08596126174362263,
                    "usability": 0.1241813743323127,
                    "work": 0.05624252572896506,
                    "written": 0.09057352789424968
                },
                "Max term": "tests",
                "Max score": 0.5055231999921744
            }
        ],
        "Best Answer": "I know the TDD folks will hate this answer, but a large part of it for me is to choose carefully where to test something. If I go too crazy with unit tests in the lower tiers then no meaningful change can be made without altering the unit tests.  If the interface is never exposed and not intended to be reused outside the app then this is just needless overhead to what might have been a quick change otherwise. Conversely if what you are trying to change is exposed or re-used every one of those tests you are going to have to change is evidence of something you might be breaking elsewhere. In some projects this may amount to designing your tests from the acceptance tier down rather than from the unit tests up. and having fewer unit tests and more integration style tests. It does not mean that you cannot still identify a single feature and code until that feature meets its acceptance criteria.  It simply means that in some cases you do not end up measuring the acceptance criteria with unit tests. ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "acceptance": 0.3265065554275404,
                "answer": 0.06673682892070695,
                "app": 0.07356136224794611,
                "breaking": 0.1003156073927256,
                "cases": 0.07826560743463894,
                "change": 0.27931925617993947,
                "choose": 0.08561560742066782,
                "code": 0.039511457159070944,
                "crazy": 0.10883551847584681,
                "designing": 0.09818051538821725,
                "end": 0.06290635916031656,
                "evidence": 0.10273617506747319,
                "exposed": 0.21767103695169362,
                "feature": 0.14138636685197545,
                "fewer": 0.10273617506747319,
                "folks": 0.10553051537424614,
                "going": 0.058350699481060614,
                "hate": 0.10883551847584681,
                "identify": 0.10553051537424614,
                "integration": 0.10273617506747319,
                "intended": 0.11288051536027503,
                "interface": 0.08665173687428528,
                "know": 0.04922557092677614,
                "large": 0.07635570255471906,
                "lower": 0.09627061050829738,
                "mean": 0.07518579145762674,
                "meaningful": 0.11288051536027503,
                "means": 0.07305069945311839,
                "needless": 0.11288051536027503,
                "outside": 0.08665173687428528,
                "overhead": 0.10273617506747319,
                "projects": 0.06570069946708951,
                "quick": 0.09818051538821725,
                "reused": 0.11288051536027503,
                "simply": 0.07576131060218987,
                "single": 0.07408682890673585,
                "style": 0.08370570254074795,
                "tdd": 0.08775069942517617,
                "test": 0.06379079458716963,
                "tests": 0.5727979107511056,
                "trying": 0.06982981404498487,
                "unit": 0.3652534972655919,
                "used": 0.055083033839445066
            },
            "Max term": "tests",
            "Max score": 0.5727979107511056
        }
    },
    {
        "ID": "5972",
        "Question": "This has nothing to do with having a favourite editor or anything like that. I was just wondering, per language, what are the most popular Integrated Development Environments? Maybe a top 2-3 if there is some contention. (Perceived popularity is enough) Thus Far: C# - Visual Studio, SharpDevelop Java - Eclipse, NetBeans, IDEA Objective-C - Xcode Delphi - RAD Studio Object Pascal - Delphi, Lazarus C, C++ - Visual Studio, Vim PL/SQL - RapidSQL, Oracle SQLDeveloper PHP - Eclipse, NetBeans, Nusphere PHPed Actionscript (AS2, AS3) - FlashDevelop Flex - Flash Builder 4 Python - Eclipse, IDLE Perl - Padre Common Lisp - Lispworks, Emacs Ruby - TextMate Haskell - Vim Fortran - Vim Visual Basic - Visual Studio ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "basic": 0.09103475691581804,
                    "common": 0.07694319033990189,
                    "delphi": 0.25319139645608923,
                    "development": 0.06398766416325864,
                    "eclipse": 0.36617768113884447,
                    "editor": 0.10796766047036535,
                    "emacs": 0.12659569822804462,
                    "environments": 0.11250413165212846,
                    "far": 0.08563305587112263,
                    "favourite": 0.12205922704628148,
                    "fortran": 0.12205922704628148,
                    "haskell": 0.10426109362880188,
                    "idea": 0.07331041607742467,
                    "integrated": 0.12205922704628148,
                    "java": 0.07694319033990189,
                    "language": 0.05959188443031647,
                    "like": 0.04512728292559237,
                    "lisp": 0.10426109362880188,
                    "maybe": 0.08496644424190213,
                    "netbeans": 0.24411845409256297,
                    "object": 0.09103475691581804,
                    "objective": 0.11250413165212846,
                    "oracle": 0.11521880259347629,
                    "pascal": 0.12659569822804462,
                    "perl": 0.11250413165212846,
                    "php": 0.08933962271268608,
                    "popular": 0.10112723601756014,
                    "python": 0.08563305587112263,
                    "ruby": 0.10112723601756014,
                    "sql": 0.0938760938944492,
                    "studio": 0.41704437451520754,
                    "vim": 0.3550579806141541,
                    "visual": 0.41053535492610926,
                    "wondering": 0.09841256507621231
                },
                "Max term": "studio",
                "Max score": 0.41704437451520754
            }
        ],
        "Best Answer": "All languages - VIM I don't like IDE's.  If I'm on OSX I'll use TextMate at time, but mostly I do everything (JavaScript, Java, Python, PHP) in VIM. I'm also quicker then several colleagues who use an IntelliJ. ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "colleagues": 0.3196913511573424,
                "ide": 0.2432775913506596,
                "intellij": 0.33157304692651424,
                "java": 0.20152571073379727,
                "javascript": 0.26881335702794235,
                "languages": 0.18150215998438088,
                "like": 0.11819509595183694,
                "php": 0.2339938191323809,
                "python": 0.22428576681704776,
                "time": 0.13068533400697205,
                "use": 0.2497838444474505,
                "vim": 0.6199665976840185
            },
            "Max term": "vim",
            "Max score": 0.6199665976840185
        }
    },
    {
        "ID": "6005",
        "Question": "To the outside world, programmers, computer scientists, software engineers, and developers may all seem alike, but that's far from the case for the people who create software for a living.  Any single programmer's ability and knowledge can range very widely, as well as their tools (OS, language, and yes, preferred editor), and that diversity spawns many sub-cultures in software - like programmers who actively use Stack Overflow and this site, versus many more who don't. I'm curious to hear from others what software sub-cultures they've encountered, belonged to, admired, disliked, or even created.  For starters, I've encountered:  Microsoft-driven companies and developers: their entire stack is from Redmond, WA.  E-mail is Outlook is e-mail.  The web is IE and IIS.  They have large binders of their MS Developer Network subscription full of multiple versions of VB, .net, Visual Studio, etc.  Avoids working with a shell/command-line.  Don't see what the fuss with open-source and such is all about.  MS-centric companies tend to be 9-5 and quite corporate (driven by business managers, not software people). Nowadays (given the wide availability of non-MS tools), this is the antithesis of hacker culture. Old-school CS people: they often know Lisp and Unix extremely well; sometimes, they may have written a semi-popular Lisp themselves, or a system utility. Few, if any, \"software engineering\" things are new to them, nor are they impressed by such.  Know the references, history, and higher-level implications of programming languages like Lisp, C, Prolog, and Smalltalk.  Can be bitter about AI outcomes of the 80's and 90's. Tend to be Emacs users.  Can type out multi-line shell commands without blinking an eye.  Their advice can by cryptic, but contains gold once understood. New-school web developers: played with computers and video games growing up, but often only really started programming in the late '90s or early '00's.  Comfortable with 1 to 1.5 scripting/dynamic languages; think C and languages outside of Ruby/Perl/Python are unnecessary/magical.  May have considered HTML as programming initially.  Tend to get a Mac and be fanatical/irrational about it.  Use frameworks more than build them.  Often overly-enthusiastic about NoSQL and/or Ruby On Rails. New-school CS: lots of training in statistics, Bayesian models and inference; don't say \"AI,\" say \"machine learning.\" More Java than Lisp, but could also be expert Haskell programmers.  Seeing major real-world successes by experts in their field (Google, finance/quants) often makes them (over) confident.  But big data, and the distributed processing of such, really are changing the world.  The examples above are by no means complete, correct, orthogonal, or objective. :)  Just what I've seen personally, and provided to spark some discussion and outline of the broader question.  Feel free to disagree! ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "80": 0.06323245818836341,
                    "90": 0.06548042360551101,
                    "ability": 0.05693414461200152,
                    "advice": 0.06430528012895341,
                    "avoids": 0.07677798991377692,
                    "big": 0.04778629878416651,
                    "build": 0.05075974840353991,
                    "business": 0.05003426420131411,
                    "case": 0.05003426420131411,
                    "centric": 0.07677798991377692,
                    "changing": 0.061331830509580014,
                    "comfortable": 0.06987810950308952,
                    "command": 0.07177873718187291,
                    "companies": 0.11042185075981426,
                    "complete": 0.05323395272455541,
                    "computer": 0.048700025945484976,
                    "computers": 0.06548042360551101,
                    "confident": 0.06677948444996891,
                    "considered": 0.0582332054564594,
                    "contains": 0.06224555767089848,
                    "corporate": 0.06823171092026742,
                    "correct": 0.056332577777676016,
                    "create": 0.04934910603445387,
                    "created": 0.060481170873607014,
                    "cryptic": 0.07677798991377692,
                    "cs": 0.15355597982755384,
                    "culture": 0.06430528012895341,
                    "curious": 0.06823171092026742,
                    "data": 0.046935639148193514,
                    "developer": 0.04240171236912309,
                    "developers": 0.1314198239332778,
                    "disagree": 0.06987810950308952,
                    "discussion": 0.06323245818836341,
                    "distributed": 0.06823171092026742,
                    "driven": 0.11787590016773497,
                    "dynamic": 0.07402670259902053,
                    "early": 0.058937950083867485,
                    "editor": 0.06548042360551101,
                    "emacs": 0.07677798991377692,
                    "encountered": 0.13646342184053484,
                    "engineering": 0.061331830509580014,
                    "engineers": 0.06823171092026742,
                    "entire": 0.06224555767089848,
                    "examples": 0.056332577777676016,
                    "expert": 0.06677948444996891,
                    "extremely": 0.06323245818836341,
                    "far": 0.05193489188009751,
                    "feel": 0.04613990020134441,
                    "field": 0.06430528012895341,
                    "frameworks": 0.0582332054564594,
                    "free": 0.04902029523319245,
                    "games": 0.05968543192675791,
                    "given": 0.05323395272455541,
                    "google": 0.05521092537990713,
                    "hacker": 0.07402670259902053,
                    "haskell": 0.06323245818836341,
                    "hear": 0.06987810950308952,
                    "higher": 0.06224555767089848,
                    "history": 0.06224555767089848,
                    "html": 0.0582332054564594,
                    "implications": 0.07677798991377692,
                    "initially": 0.06823171092026742,
                    "java": 0.04666464638639762,
                    "know": 0.0669635565722442,
                    "knowledge": 0.04808341374709367,
                    "language": 0.0361413947375364,
                    "languages": 0.1260841718388948,
                    "large": 0.05193489188009751,
                    "late": 0.06987810950308952,
                    "learning": 0.04721272214193441,
                    "level": 0.046935639148193514,
                    "like": 0.05473775368031802,
                    "line": 0.10470577394253752,
                    "lisp": 0.25292983275345365,
                    "living": 0.07177873718187291,
                    "lots": 0.05756657422670196,
                    "mac": 0.06987810950308952,
                    "machine": 0.058937950083867485,
                    "magical": 0.06987810950308952,
                    "major": 0.05968543192675791,
                    "makes": 0.04318481197675976,
                    "managers": 0.06823171092026742,
                    "means": 0.0496869264629499,
                    "microsoft": 0.05693414461200152,
                    "models": 0.06823171092026742,
                    "ms": 0.22208010779706158,
                    "multi": 0.06224555767089848,
                    "multiple": 0.05418285729724512,
                    "net": 0.046935639148193514,
                    "network": 0.07177873718187291,
                    "new": 0.10911558794987868,
                    "non": 0.04539241835845398,
                    "nowadays": 0.06987810950308952,
                    "objective": 0.06823171092026742,
                    "old": 0.05418285729724512,
                    "open": 0.04778629878416651,
                    "os": 0.06224555767089848,
                    "outlook": 0.07402670259902053,
                    "outside": 0.11787590016773497,
                    "overflow": 0.060481170873607014,
                    "people": 0.10301703598640913,
                    "perl": 0.06823171092026742,
                    "personally": 0.05693414461200152,
                    "popular": 0.061331830509580014,
                    "preferred": 0.06987810950308952,
                    "processing": 0.07402670259902053,
                    "programmer": 0.0396884209991419,
                    "programmers": 0.12342194240832122,
                    "programming": 0.09778310542779271,
                    "prolog": 0.07177873718187291,
                    "provided": 0.06677948444996891,
                    "python": 0.05193489188009751,
                    "question": 0.03938768232588094,
                    "quite": 0.04902029523319245,
                    "rails": 0.06677948444996891,
                    "range": 0.06823171092026742,
                    "real": 0.04639948188012127,
                    "really": 0.0716071486180807,
                    "references": 0.06987810950308952,
                    "ruby": 0.12266366101916003,
                    "say": 0.07999335782592068,
                    "school": 0.17905629578027374,
                    "seeing": 0.06323245818836341,
                    "seen": 0.05235288697126876,
                    "semi": 0.07402670259902053,
                    "single": 0.050391671090357984,
                    "site": 0.05521092537990713,
                    "smalltalk": 0.07677798991377692,
                    "software": 0.217536541256868,
                    "source": 0.04563657830373562,
                    "stack": 0.1164664109129188,
                    "started": 0.05003426420131411,
                    "studio": 0.06323245818836341,
                    "sub": 0.14355747436374583,
                    "subscription": 0.07677798991377692,
                    "tend": 0.1746996163693782,
                    "things": 0.03648873247590061,
                    "think": 0.032594368475930904,
                    "tools": 0.10151949680707982,
                    "training": 0.06677948444996891,
                    "type": 0.05369927867738899,
                    "understood": 0.07677798991377692,
                    "unix": 0.07177873718187291,
                    "unnecessary": 0.07177873718187291,
                    "use": 0.05783914485021796,
                    "users": 0.0496869264629499,
                    "utility": 0.06823171092026742,
                    "vb": 0.06823171092026742,
                    "versions": 0.06430528012895341,
                    "versus": 0.07677798991377692,
                    "video": 0.06823171092026742,
                    "visual": 0.06224555767089848,
                    "web": 0.09078483671690796,
                    "wide": 0.06677948444996891,
                    "widely": 0.07177873718187291,
                    "working": 0.040970580299730414,
                    "world": 0.14248852624339317,
                    "written": 0.05235288697126876,
                    "yes": 0.05003426420131411
                },
                "Max term": "lisp",
                "Max score": 0.25292983275345365
            }
        ],
        "Best Answer": "I'd consider myself part of the Real-Time Systems group.   There are some 'Old School' characteristics but with less focus on CS, more on hardware.   The archetype:  Has expert knowledge of 'C'  Has an original copy of K&R Writes in other languages as if they were just an alternate syntax for 'C'  Can predict the assembler output from their code. Can read a circuit diagram Doesn't know how to write code without doing 'premature optimization'. Is quite comfortable with the command line.  ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "alternate": 0.23348514248744315,
                "code": 0.1695280793231027,
                "comfortable": 0.22040020399744087,
                "command": 0.22639491008073184,
                "consider": 0.1567158700530647,
                "copy": 0.19943937784062082,
                "cs": 0.24216288562817695,
                "diagram": 0.22040020399744087,
                "expert": 0.21062693453328674,
                "focus": 0.19632662798345943,
                "group": 0.19632662798345943,
                "hardware": 0.18589421371081968,
                "know": 0.10560375512351451,
                "knowledge": 0.1516582843198448,
                "languages": 0.13255928736362554,
                "line": 0.16512448677239108,
                "old": 0.17089633486648725,
                "optimization": 0.24216288562817695,
                "original": 0.18825182114795488,
                "output": 0.19632662798345943,
                "predict": 0.24216288562817695,
                "quite": 0.15461327082600473,
                "read": 0.1455283133603988,
                "real": 0.14634705123644118,
                "school": 0.18825182114795488,
                "syntax": 0.190761634699887,
                "systems": 0.16790342674573064,
                "time": 0.09544544674472397,
                "write": 0.11939151899633015
            },
            "Max term": "cs",
            "Max score": 0.24216288562817695
        }
    },
    {
        "ID": "6014",
        "Question": "A lot of us started seeing this phenomenon with jQuery about a year ago when people started asking how to do absolutely insane things like retrieve the query string with jQuery.  The difference between the library (jQuery) and the language (JavaScript) is apparently lost on many programmers, and results in a lot of inappropriate, convoluted code being written where it is not necessary. Maybe it's just my imagination, but I swear I'm starting to see an uptick in the number of questions where people are asking to do similarly insane things with Linq, like find ranges in a sorted array.  I can't get over how thoroughly inappropriate the Linq extensions are for solving that problem, but more importantly the fact that the author just assumed that the ideal solution would involve Linq without actually thinking about it (as far as I can tell).  It seems that we are repeating history, breeding a new generation of .NET programmers who can't tell the difference between the language (C#/VB.NET) and the library (Linq). What is responsible for this phenomenon?  Is it just hype?  Magpie tendencies?  Has Linq picked up a reputation as a form of magic, where instead of actually writing code you just have to utter the right incantation?  I'm hardly satisfied with those explanations but I can't really think of anything else. More importantly, is it really a problem, and if so, what's the best way to help enlighten these people? ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "absolutely": 0.08942693285677081,
                    "actually": 0.11940137083827147,
                    "ago": 0.07885754553217074,
                    "apparently": 0.09649715993948575,
                    "array": 0.1085837929698058,
                    "asking": 0.153256946838117,
                    "author": 0.09444333880437591,
                    "best": 0.057240651975413226,
                    "code": 0.0760149591876466,
                    "difference": 0.17885386571354162,
                    "fact": 0.07344927308139715,
                    "far": 0.07344927308139715,
                    "form": 0.07808242567766803,
                    "generation": 0.10469276622475221,
                    "hardly": 0.10151356588709086,
                    "help": 0.05892556556463303,
                    "history": 0.08803120210645356,
                    "ideal": 0.0988255903016729,
                    "importantly": 0.20938553244950442,
                    "instead": 0.0702700727437358,
                    "involve": 0.10151356588709086,
                    "javascript": 0.08803120210645356,
                    "jquery": 0.27781839958329646,
                    "language": 0.10222642526140162,
                    "library": 0.15771509106434148,
                    "like": 0.07741323939231393,
                    "linq": 0.523463831123761,
                    "lost": 0.08673895727135285,
                    "lot": 0.11140859373987079,
                    "magic": 0.09260613319443216,
                    "maybe": 0.07287750626663417,
                    "necessary": 0.07528647869134092,
                    "net": 0.13275809199736444,
                    "new": 0.05143915343895644,
                    "number": 0.06800229400977156,
                    "people": 0.14569254184009434,
                    "picked": 0.1085837929698058,
                    "problem": 0.11313114884726577,
                    "programmers": 0.11636687942683151,
                    "query": 0.09260613319443216,
                    "questions": 0.06979230791152309,
                    "ranges": 0.1085837929698058,
                    "really": 0.10127089559697616,
                    "repeating": 0.10151356588709086,
                    "reputation": 0.09444333880437591,
                    "responsible": 0.10151356588709086,
                    "results": 0.08673895727135285,
                    "right": 0.06225705792301834,
                    "satisfied": 0.10469276622475221,
                    "seeing": 0.08942693285677081,
                    "similarly": 0.10151356588709086,
                    "solution": 0.07404042547406992,
                    "solving": 0.08942693285677081,
                    "started": 0.14152259499195838,
                    "starting": 0.08051950016411209,
                    "string": 0.0988255903016729,
                    "tell": 0.15468059965290154,
                    "things": 0.10320887476588837,
                    "think": 0.0460968066830957,
                    "thinking": 0.06843286713379204,
                    "thoroughly": 0.10469276622475221,
                    "vb": 0.09649715993948575,
                    "way": 0.04774665626385055,
                    "writing": 0.060511870075602894,
                    "written": 0.07404042547406992,
                    "year": 0.07885754553217074
                },
                "Max term": "linq",
                "Max score": 0.523463831123761
            }
        ],
        "Best Answer": "It's basically because programming is fundamentally difficult.  It requires a lot of logical, structured thought in a way that a lot of people just don't know how to do.  (Or simply can't do, depending on who you listen to.) Stuff like LINQ and jQuery makes certain common data-manipulation tasks a whole lot easier.  That's great for those of us who know what we're doing, but the unfortunate side effect is that it lowers the bar. It makes it easier for people who have no idea what they're doing to start writing code and make things work.  And then when they run into reality, and find something fundamentally difficult that their simple, high-abstraction-level techniques are not well suited to, they're lost, because they don't understand the platform that their library is built upon. Your question is sort of on the right track, but much like the perennial controversy about violent video games \"turning kids violent,\" it has the direction of the link backwards.  Easy programming techniques don't make programmers stupid; they just attract stupid people to programming.  And there's really not much you can do about it. ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "abstraction": 0.1175009091037243,
                "backwards": 0.1426717207031748,
                "bar": 0.12409212542354357,
                "basically": 0.11238836453481944,
                "built": 0.11396909195596318,
                "certain": 0.10161989514408944,
                "code": 0.049939243831254344,
                "common": 0.08671398409139498,
                "data": 0.08721755293536895,
                "depending": 0.13755917613426993,
                "difficult": 0.20722690566965693,
                "direction": 0.1426717207031748,
                "easier": 0.1846601950085476,
                "easy": 0.091091338522295,
                "effect": 0.12409212542354357,
                "fundamentally": 0.27511835226853987,
                "games": 0.11090969278390503,
                "great": 0.0882591623043458,
                "high": 0.09575608785841898,
                "idea": 0.08261989430628872,
                "jquery": 0.12167816217463505,
                "know": 0.12443417509751907,
                "level": 0.08721755293536895,
                "library": 0.10361345283482847,
                "like": 0.10171573277403789,
                "link": 0.1175009091037243,
                "linq": 0.13755917613426993,
                "listen": 0.13755917613426993,
                "logical": 0.11396909195596318,
                "lost": 0.11396909195596318,
                "lot": 0.2195749752600037,
                "make": 0.12949064531182958,
                "makes": 0.16049525234736112,
                "people": 0.191430093473762,
                "platform": 0.11396909195596318,
                "programmers": 0.07644908354463892,
                "programming": 0.18170420875501214,
                "question": 0.07319165842000122,
                "reality": 0.12409212542354357,
                "really": 0.0665315354013738,
                "requires": 0.11949446679446335,
                "right": 0.0818015408824794,
                "run": 0.0882591623043458,
                "simple": 0.0882591623043458,
                "simply": 0.09575608785841898,
                "sort": 0.10467929431614757,
                "start": 0.07950848271669707,
                "structured": 0.12679070674353993,
                "stuff": 0.08991613425536528,
                "stupid": 0.2667638461267184,
                "suited": 0.12167816217463505,
                "tasks": 0.10467929431614757,
                "techniques": 0.2350018182074486,
                "things": 0.06780472182797294,
                "thought": 0.09892131382409308,
                "track": 0.11949446679446335,
                "understand": 0.07809810150839441,
                "video": 0.12679070674353993,
                "way": 0.06273585975101124,
                "work": 0.06040951213500801,
                "writing": 0.07950848271669707
            },
            "Max term": "fundamentally",
            "Max score": 0.27511835226853987
        }
    },
    {
        "ID": "6042",
        "Question": "I offered to do a little bit training in F# at my company and they seemed to show some interest. They are generally VB6 and C# programmers who don't follow programming with too much passion. That being said I feel like it is easier to write correct code when you think in a functional matter so they should definitely get some benefit out of it. Can anyone offer up some advice on how I should approach this? Ideas  Don't focus on the syntax, instead focus on how this language and the idioms it promotes can be used. Try and think of examples that are a pain to write in an imperative fashion but translates to elegant code when written in a declarative fashion.  ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "advice": 0.1614818530342895,
                    "approach": 0.13484832054289062,
                    "benefit": 0.15878780871017006,
                    "bit": 0.12746664372382305,
                    "code": 0.1349733062849369,
                    "company": 0.11398833525849922,
                    "correct": 0.14146099709845728,
                    "declarative": 0.19280301802063654,
                    "definitely": 0.14146099709845728,
                    "easier": 0.12477259939970362,
                    "elegant": 0.19280301802063654,
                    "examples": 0.14146099709845728,
                    "fashion": 0.3856060360412731,
                    "feel": 0.1158653934543018,
                    "focus": 0.3126190563416495,
                    "follow": 0.14002064540635537,
                    "functional": 0.13041763539659296,
                    "generally": 0.1325537911530554,
                    "ideas": 0.14800354456896567,
                    "imperative": 0.17134181039270238,
                    "instead": 0.12477259939970362,
                    "language": 0.09075739008923718,
                    "like": 0.06872805683690995,
                    "little": 0.12229431886035828,
                    "matter": 0.14002064540635537,
                    "offer": 0.15878780871017006,
                    "offered": 0.1754762064089237,
                    "pain": 0.17134181039270238,
                    "programmers": 0.10331139177176948,
                    "programming": 0.08185018414383535,
                    "said": 0.12229431886035828,
                    "syntax": 0.15187884302452712,
                    "think": 0.1637003682876707,
                    "training": 0.1676950146555719,
                    "try": 0.11054456961161158,
                    "used": 0.09408333344405793,
                    "vb6": 0.18589405233499356,
                    "write": 0.19011208202981722,
                    "written": 0.13146729448751385
                },
                "Max term": "fashion",
                "Max score": 0.3856060360412731
            }
        ],
        "Best Answer": "I would recommend:  the presentation Taming Effects with Functional Programming by Simon Peyton-Jones the book Real World Functional Programming: With Examples in F# and C# by Tomas Petricek and Jon Skeet  ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "book": 0.22084478661672105,
                "effects": 0.2988483921761732,
                "examples": 0.2520968892566157,
                "functional": 0.46483314640856777,
                "jon": 0.3312808002642693,
                "jones": 0.3435932312032301,
                "presentation": 0.3312808002642693,
                "programming": 0.29172955416651863,
                "real": 0.20764476802857645,
                "recommend": 0.26710142365677314,
                "world": 0.21255263909328942
            },
            "Max term": "functional",
            "Max score": 0.46483314640856777
        }
    },
    {
        "ID": "6045",
        "Question": "Some projects we run internally using are Scrum, while still being \"fixed everything\" to the customer.  We're experiencing mixed success on our part (the customer likes the visibility of the burndown chart). Can the types of projects we work be successfully executed using the agile methods? ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "agile": 0.18944326769120315,
                    "customer": 0.3865839066539389,
                    "executed": 0.2540051690904464,
                    "experiencing": 0.26344556255747015,
                    "fixed": 0.21358094912003958,
                    "internally": 0.24629180599517317,
                    "likes": 0.24629180599517317,
                    "methods": 0.18265975233823853,
                    "projects": 0.3066704236117956,
                    "run": 0.16297192288367793,
                    "scrum": 0.2540051690904464,
                    "success": 0.2397702504216071,
                    "successfully": 0.2397702504216071,
                    "types": 0.19329195332696944,
                    "using": 0.2472414961197547,
                    "visibility": 0.26344556255747015,
                    "work": 0.11154710849348692
                },
                "Max term": "customer",
                "Max score": 0.3865839066539389
            }
        ],
        "Best Answer": "I would like to pose a counter-question: Can fixed scope + fixed deadline + fixed price contract ever be made to work, period? The \"good/fast/cheap - pick two\" saying isn't just some silly engineering joke.  Every project manager worth his salt knows about the Project Management Triangle:  You're telling us that the cost, scope, and schedule are all fixed.  That leaves no room for maneuverability or error.  None.  You could choose to view \"Quality\" as an attribute, but it's not a \"real\" attribute, it's more like a meta-attribute that's derived from the other attributes (cost/scope/schedule). The problem is that this never happens in reality as long as your project is being planned and executed by humans.  Requirements and specifications never cover every edge case unless they've been drawn up in immense detail by qualified architects and designers, in which case the project is already half-done; and even then there's still the possibility of error. Unexpected costs will pop up leading to budget overruns.  A subscription expired.  A manufacturer discontinued their support for a product you're using and you have to find a new one.  An hourly contractor raised his rate under threat of departure.  Your entire team just went on strike, demanding a 10% raise and an extra week of vacation. Schedules slip.  Unforeseeable problems crop up; that charting component you've been using for 5 straight years isn't compatible with Windows 95, which your client is still using.  An obscure bug in 64-bit Windows causes serious UI glitches and you spend nearly a week tracking it down and developing a workaround (this actually happened to me).  Your senior developer got hit by a bus and you have to go recruit and train a new one.  Your estimated delivery date is always wrong.  Always. See Hofstadter's Law:  Hofstadter's Law: It always takes longer than you expect, even when you take into account Hofstadter's Law.   Agile methods are all about juggling around the cost, schedule, and scope.  Most of the time, they're specifically about juggling around the scope and sometimes the schedule, which is why you start with nebulous user stories and plan revisions instead of full versions.  Different methodologies use different terminology but it's all the same basic premise: Frequent releases and a rebalancing of the schedule and scope with each release. This makes no sense with a project that is (or claims to be) either fixed scope or fixed schedule. If one project attribute (cost/scope/schedule) were fixed, I would tell you that it might not be a good fit for agile methodologies. If two project attributes are fixed, then your project is definitely not a good fit for agile methodologies. If all three attributes are fixed, then your project is probably going to fail.  If it actually ships, then either the original schedule was massively fudged, or the client has managed to delude itself into thinking that you actually delivered what was promised. If this contract is still on the table, I urge you to reject it.  And if you've already accepted it, may God have mercy on your soul. ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "10": 0.04140001423906563,
                "accepted": 0.05066076769906957,
                "account": 0.047745466360111836,
                "actually": 0.09402813173125756,
                "agile": 0.12297923476038684,
                "architects": 0.057006219820115785,
                "attributes": 0.16489032152276523,
                "basic": 0.04099307825346228,
                "bit": 0.03768816269813206,
                "budget": 0.05329436827918223,
                "bug": 0.0402297569529686,
                "case": 0.07429900852577691,
                "causes": 0.05329436827918223,
                "cheap": 0.05329436827918223,
                "choose": 0.043237064617202454,
                "claims": 0.054963440507588404,
                "client": 0.0790504261525378,
                "component": 0.05188318781750826,
                "contract": 0.08863063115604672,
                "contractor": 0.057006219820115785,
                "cost": 0.1656000569562625,
                "costs": 0.04861798838654219,
                "counter": 0.054963440507588404,
                "cover": 0.047745466360111836,
                "date": 0.046216161003926164,
                "deadline": 0.04861798838654219,
                "definitely": 0.041825884155528494,
                "delivered": 0.05188318781750826,
                "delivery": 0.054963440507588404,
                "derived": 0.054963440507588404,
                "designers": 0.054963440507588404,
                "developer": 0.03148247744930636,
                "developing": 0.04099307825346228,
                "different": 0.061348396317698776,
                "drawn": 0.057006219820115785,
                "edge": 0.05188318781750826,
                "engineering": 0.045537735696462044,
                "entire": 0.046216161003926164,
                "error": 0.08454507253099196,
                "executed": 0.054963440507588404,
                "expect": 0.046216161003926164,
                "extra": 0.04861798838654219,
                "fail": 0.043237064617202454,
                "fast": 0.04376032430649866,
                "fit": 0.09723597677308438,
                "fixed": 0.4159454490353355,
                "frequent": 0.054963440507588404,
                "god": 0.057006219820115785,
                "going": 0.02946790941428913,
                "good": 0.07478450150183129,
                "got": 0.036640787153786665,
                "half": 0.04861798838654219,
                "happened": 0.04694891615813601,
                "happens": 0.04490613684560863,
                "hit": 0.049582516738248664,
                "hourly": 0.049582516738248664,
                "humans": 0.057006219820115785,
                "instead": 0.03689161249615624,
                "joke": 0.057006219820115785,
                "knows": 0.04227253626549598,
                "law": 0.16489032152276523,
                "leaves": 0.05329436827918223,
                "like": 0.040641757126799204,
                "long": 0.031624411335930934,
                "longer": 0.042742103411977046,
                "makes": 0.032063914244201824,
                "managed": 0.04490613684560863,
                "management": 0.03741487218545245,
                "manager": 0.043237064617202454,
                "methodologies": 0.14084674847440803,
                "methods": 0.0395252130762689,
                "nearly": 0.054963440507588404,
                "new": 0.05401085388713991,
                "obscure": 0.054963440507588404,
                "original": 0.04431531557802336,
                "period": 0.05188318781750826,
                "pick": 0.043237064617202454,
                "plan": 0.04694891615813601,
                "possibility": 0.057006219820115785,
                "price": 0.049582516738248664,
                "probably": 0.03236909424727735,
                "problem": 0.02969678514307753,
                "problems": 0.03445074645179069,
                "product": 0.03741487218545245,
                "project": 0.2422752126694743,
                "promised": 0.057006219820115785,
                "quality": 0.0406034640370898,
                "question": 0.02924461658081462,
                "rate": 0.047745466360111836,
                "real": 0.03445074645179069,
                "reality": 0.049582516738248664,
                "release": 0.04490613684560863,
                "releases": 0.05329436827918223,
                "requirements": 0.03796986345697714,
                "room": 0.05188318781750826,
                "saying": 0.04490613684560863,
                "schedule": 0.4150655025400661,
                "schedules": 0.054963440507588404,
                "scope": 0.3889439070923375,
                "senior": 0.047745466360111836,
                "sense": 0.04099307825346228,
                "silly": 0.05329436827918223,
                "soul": 0.057006219820115785,
                "specifically": 0.04431531557802336,
                "specifications": 0.057006219820115785,
                "spend": 0.039870708882879954,
                "start": 0.03176858049354872,
                "stories": 0.05188318781750826,
                "straight": 0.05066076769906957,
                "subscription": 0.057006219820115785,
                "support": 0.03768816269813206,
                "table": 0.05188318781750826,
                "takes": 0.03741487218545245,
                "team": 0.03406925157280831,
                "tell": 0.0406034640370898,
                "telling": 0.05188318781750826,
                "terminology": 0.057006219820115785,
                "thinking": 0.03592708414444976,
                "time": 0.02246828246964778,
                "tracking": 0.05188318781750826,
                "train": 0.057006219820115785,
                "ui": 0.047745466360111836,
                "unexpected": 0.05066076769906957,
                "unless": 0.04227253626549598,
                "use": 0.021472240997985545,
                "user": 0.03445074645179069,
                "using": 0.08024980344876219,
                "vacation": 0.054963440507588404,
                "versions": 0.047745466360111836,
                "view": 0.04694891615813601,
                "week": 0.08752064861299733,
                "went": 0.04376032430649866,
                "windows": 0.08198615650692456,
                "work": 0.02413735469805396,
                "worth": 0.038260508576384494,
                "wrong": 0.03689161249615624,
                "years": 0.03352525676183374
            },
            "Max term": "fixed",
            "Max score": 0.4159454490353355
        }
    },
    {
        "ID": "6133",
        "Question": "There are some really common usability errors in everyday software we used; errors that result from the ways the particular programmer has learned without learning of all the other ways there are. For example, talking about Windows software in particular, the following common flaws come to mind:  Failure to support multiple screens. For example, windows centered in the virtual desktop (instead of a specific screen) and hence displayed spanning the monitor boundary in a dual monitor setup. Failure to support serious keyboard users. For example, utterly messed up tab order; duplicate or completely missing accelerator keys. Alt+Tab order mess-ups. For example, a window that doesn't go to the end of the tab order when minimized. Subtle breakage of common controls that were reimplemented for one reason or another. E.g. failure to implement Ctrl+Left/Right on a textbox; failure to add an Alt+Space window menu to a skinnable window, failure to make Ctrl+Insert copy to clipboard, etc, etc. This one is a huge category in its own right.  There are a gazillion of things like this. How can we ever make sure we don't break a large proportion of these? After all they aren't all written down anywhere... or are they? ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "add": 0.0718143263164981,
                    "alt": 0.2139994173918885,
                    "break": 0.08547355831643783,
                    "come": 0.07126879035202585,
                    "common": 0.19509902155622225,
                    "completely": 0.07934483430965412,
                    "controls": 0.0973838644310773,
                    "copy": 0.0881223201321308,
                    "desktop": 0.0912551404242936,
                    "dual": 0.10699970869594425,
                    "duplicate": 0.09306554379759628,
                    "end": 0.05962908730345041,
                    "errors": 0.15868966861930825,
                    "everyday": 0.10699970869594425,
                    "example": 0.22839046253219591,
                    "failure": 0.4653277189879814,
                    "flaws": 0.10699970869594425,
                    "following": 0.07694331330004688,
                    "huge": 0.07850647586726386,
                    "implement": 0.07770712524995081,
                    "insert": 0.10699970869594425,
                    "instead": 0.06924493156831735,
                    "keyboard": 0.09306554379759628,
                    "keys": 0.10003262624677026,
                    "large": 0.07237775186048015,
                    "learned": 0.07934483430965412,
                    "learning": 0.06579681913531134,
                    "left": 0.09306554379759628,
                    "like": 0.03814194474902123,
                    "make": 0.09711427926240246,
                    "menu": 0.10316544653893306,
                    "mess": 0.10003262624677026,
                    "mind": 0.07237775186048015,
                    "missing": 0.0912551404242936,
                    "monitor": 0.1947677288621546,
                    "multiple": 0.07551057215264295,
                    "order": 0.24953728939999595,
                    "particular": 0.13945798008957436,
                    "programmer": 0.05531076666996941,
                    "really": 0.04989674808683012,
                    "reason": 0.06659616975262439,
                    "result": 0.0881223201321308,
                    "right": 0.12269763064699477,
                    "screen": 0.08674695112339258,
                    "setup": 0.09508940258130477,
                    "software": 0.10105477091089904,
                    "space": 0.08674695112339258,
                    "specific": 0.06972899004478718,
                    "support": 0.14148008560155365,
                    "sure": 0.06292633889411366,
                    "talking": 0.07934483430965412,
                    "things": 0.05085160148097374,
                    "ups": 0.10699970869594425,
                    "usability": 0.10003262624677026,
                    "used": 0.05221333864483431,
                    "users": 0.06924493156831735,
                    "virtual": 0.0973838644310773,
                    "ways": 0.1436286526329962,
                    "window": 0.29215159329323187,
                    "windows": 0.15388662660009375,
                    "written": 0.07296028017415293
                },
                "Max term": "failure",
                "Max score": 0.4653277189879814
            }
        ],
        "Best Answer": "I think one thing to keep in mind is to remember the source reason for most software usability problems â€” usability is a human issue, and as such, is difficult to define with a set of rules.  This is totally at odds with the rules-world that most programmers want to live in. Because of that I think you need to throw out the belief that a checklist of usability problems could ever be helpful.  Believing that is thinking like a programmer and will only result in more usability problems that you simply hadn't thought of (or that are the result of sticking to a usability \"rule\" that never really should have been a rule).  One of the biggest differences can be made by designing first (read Alan Cooper's The Inmates are Running the Asylum). Second, make sure your software goes through usability testing with real users. Third, don't think like a programmer. The possible idea in your question is a perfect example of why this is important to remember.  Even good ideas (avoiding non-standard controls) are not always going to hold true.  Those controls may be faulty themselves or may be used for something they shouldn't.  The perfect solution for your form or user input may not have been invented yet, or may simply be not widely used or implemented (the iPhone is a great case study for this).  As another illustration of the problem with \"usability checklists\", the list you presented may well be common to you, and I agree they are problems, but I hadn't really thought of most of them prior to reading your list.  On the other hand, I've experienced tons of annoyances with Windows since being given a PC for my day-job:  (Windows 7) Mousing over a task bar button and then over a Window thumbnail drops all other windows to just outlines.  I've done this by accident a number of times and had what I was reading simply disappear. The Alt+tab pane can now be moused over to temporarily bring the window to the front.  However, when you let go you think it's going to stay there, and it doesn't. (MS Outlook - I know, sort of a cheap shot) If I open a new email and then close it, even if I haven't added any text it asks me if I want to save the draft.  Then if I say no, it moves it to my deleted items folder.  As an unread email, leaving me with a big blue \"(1)\" until I go delete it or \"read\" it.  ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "accident": 0.07851556854610466,
                "added": 0.06602003302068739,
                "agree": 0.06330466516971714,
                "alt": 0.08143368971275841,
                "asks": 0.08143368971275841,
                "avoiding": 0.07613128994659209,
                "bar": 0.07082889018042576,
                "big": 0.0506839868050871,
                "biggest": 0.07851556854610466,
                "bring": 0.07236917744123778,
                "button": 0.08143368971275841,
                "case": 0.053068265404599656,
                "cheap": 0.07613128994659209,
                "checklist": 0.08143368971275841,
                "close": 0.06945105627458402,
                "common": 0.049494319122616384,
                "controls": 0.14823082222858935,
                "day": 0.05165312098300045,
                "define": 0.06505089884277404,
                "delete": 0.08143368971275841,
                "designing": 0.07082889018042576,
                "differences": 0.07236917744123778,
                "difficult": 0.05914014162465478,
                "email": 0.13890211254916804,
                "example": 0.04345497358327198,
                "experienced": 0.06945105627458402,
                "folder": 0.07613128994659209,
                "form": 0.05855883139413701,
                "given": 0.05646197814273883,
                "goes": 0.05855883139413701,
                "going": 0.08419013221010378,
                "good": 0.035610020040155184,
                "great": 0.05037627079828262,
                "hand": 0.058002265403550836,
                "helpful": 0.05974849907660774,
                "hold": 0.07236917744123778,
                "human": 0.06945105627458402,
                "idea": 0.047157508186480394,
                "ideas": 0.06251185717190139,
                "implemented": 0.06505089884277404,
                "important": 0.05199281091013954,
                "input": 0.06820465389617542,
                "invented": 0.07613128994659209,
                "iphone": 0.07411541111429468,
                "issue": 0.055527485910651785,
                "items": 0.07613128994659209,
                "job": 0.04517564062667589,
                "know": 0.035512062077235916,
                "leaving": 0.07851556854610466,
                "let": 0.053068265404599656,
                "like": 0.05805696728687827,
                "list": 0.10931068200955123,
                "live": 0.06706677767507145,
                "make": 0.03695511969385582,
                "mind": 0.05508414423689707,
                "ms": 0.07851556854610466,
                "need": 0.03833295359969757,
                "new": 0.0385773967335969,
                "non": 0.04814494513421444,
                "number": 0.0509991183646291,
                "open": 0.0506839868050871,
                "outlook": 0.07851556854610466,
                "pc": 0.07236917744123778,
                "perfect": 0.14473835488247555,
                "possible": 0.04789100847764614,
                "presented": 0.07851556854610466,
                "prior": 0.07613128994659209,
                "problem": 0.04242201630697282,
                "problems": 0.19685230178606417,
                "programmer": 0.08419013221010378,
                "programmers": 0.04363535336586388,
                "question": 0.04177609109892757,
                "read": 0.0978755062640604,
                "reading": 0.10931068200955123,
                "real": 0.04921307544651604,
                "really": 0.07594929651490932,
                "reason": 0.0506839868050871,
                "remember": 0.11391104149833355,
                "result": 0.1341335553501429,
                "rule": 0.13010179768554808,
                "rules": 0.1341335553501429,
                "running": 0.05974849907660774,
                "save": 0.07082889018042576,
                "say": 0.04242201630697282,
                "second": 0.06038654400306339,
                "set": 0.05132203173154276,
                "simply": 0.16396602301432683,
                "software": 0.07690920805903055,
                "solution": 0.055527485910651785,
                "sort": 0.05974849907660774,
                "source": 0.04840391056488901,
                "standard": 0.05344734490038076,
                "stay": 0.06414865650841771,
                "sticking": 0.08143368971275841,
                "study": 0.07236917744123778,
                "sure": 0.04789100847764614,
                "task": 0.05383774185848846,
                "testing": 0.04789100847764614,
                "text": 0.06414865650841771,
                "thing": 0.04646297363913116,
                "think": 0.13828336437737304,
                "thinking": 0.05132203173154276,
                "thought": 0.11292395628547766,
                "throw": 0.07411541111429468,
                "times": 0.05383774185848846,
                "tons": 0.08143368971275841,
                "totally": 0.07082889018042576,
                "true": 0.06330466516971714,
                "usability": 0.5329190296261446,
                "used": 0.07947544661365571,
                "user": 0.04921307544651604,
                "users": 0.05269986563738451,
                "want": 0.07690920805903055,
                "widely": 0.07613128994659209,
                "window": 0.14823082222858935,
                "windows": 0.17567649418241105,
                "world": 0.05037627079828262
            },
            "Max term": "usability",
            "Max score": 0.5329190296261446
        }
    },
    {
        "ID": "6146",
        "Question": "I've recently been frequented by erroneous error messages from mod_security. Its filter sets cover outdated PHP exploits, and I have to rewrite my stuff because Wordpress&Co had bugs years ago.   Does this happen to anyone else?  Apache mod_security blocks possibly   dangerous HTTP requests before they   reach applications (PHP specifically).   It uses various filter sets, mostly   regex based.  So I have a nice shared hosting provider, technically apt and stuff. But this bugged me: Just last week I had to change a parameter name &src= in one of my apps because mod_security blocks ANY requests with that. I didn't look up its details, but this filter rule was preventing the exploitability of another app which I don't use and probably never had heard about. Still I had to rewrite my code (renaming parameter often suffices to trick mod_security) which had nothing to do or in common with that! And today, a silly regex blocks form submissions, because I wanted to submit php sample code. Given, this is the simple stuff that mod_security is there to protect against. But I don't believe mod_security can detect seriously obfuscated code, and just goes off at obvious (and in this case totally trivial) php snippets. Basically I'm getting penalized by mod_security because other people released bug-prone apps. (Not saying my apps are ultra secure - I'm pretty security wary, but make no hyperbolic claims.) I've already asked my provider to disable it anyway, the benefits are too minuscle IMO and for my apps.  What do you think? Does mod_security make much sense outside of WP hosting? Or is it really just a bunch of blacklists of long passed security bugs? Which of its rules are actually helpful? Is there an application level equivalent? ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "actually": 0.051184652107305995,
                    "ago": 0.06760887259104156,
                    "apache": 0.08975881566089786,
                    "app": 0.06066751779423222,
                    "application": 0.05337636961187544,
                    "applications": 0.06511141907853554,
                    "apps": 0.2933383807086491,
                    "asked": 0.06154718148971256,
                    "based": 0.05943806071320445,
                    "basically": 0.07333459517716227,
                    "believe": 0.06630805513704817,
                    "benefits": 0.07667058451945473,
                    "blocks": 0.2792844150095709,
                    "bug": 0.06569776755379225,
                    "bugs": 0.1259441315895114,
                    "bunch": 0.08472856590133783,
                    "case": 0.06066751779423222,
                    "change": 0.05759003581068579,
                    "claims": 0.08975881566089786,
                    "code": 0.09775765253752794,
                    "common": 0.05658179070281955,
                    "cover": 0.07797140197344814,
                    "dangerous": 0.08975881566089786,
                    "details": 0.07146340997605177,
                    "detect": 0.09309480500319031,
                    "disable": 0.09309480500319031,
                    "equivalent": 0.0870331139018613,
                    "error": 0.06903375689608471,
                    "filter": 0.2792844150095709,
                    "form": 0.06694432008522612,
                    "getting": 0.05658179070281955,
                    "given": 0.06454720231679673,
                    "goes": 0.06694432008522612,
                    "happen": 0.07060889341812572,
                    "heard": 0.07333459517716227,
                    "helpful": 0.06830434541760226,
                    "hosting": 0.18618961000638062,
                    "http": 0.07060889341812572,
                    "imo": 0.09309480500319031,
                    "level": 0.056910374693426705,
                    "long": 0.05164468747356403,
                    "look": 0.053640977754118115,
                    "make": 0.08449401405988512,
                    "messages": 0.0870331139018613,
                    "nice": 0.06760887259104156,
                    "obvious": 0.07236974623837716,
                    "outdated": 0.09309480500319031,
                    "outside": 0.07146340997605177,
                    "parameter": 0.1795176313217957,
                    "passed": 0.09309480500319031,
                    "people": 0.04163671944668664,
                    "php": 0.262791070215169,
                    "possibly": 0.07667058451945473,
                    "pretty": 0.05830207370237734,
                    "probably": 0.052860802322781585,
                    "prone": 0.0870331139018613,
                    "protect": 0.0870331139018613,
                    "provider": 0.1795176313217957,
                    "reach": 0.08472856590133783,
                    "really": 0.04341252971666109,
                    "recently": 0.07333459517716227,
                    "released": 0.0809714228005323,
                    "requests": 0.15879257255698256,
                    "rewrite": 0.15879257255698256,
                    "rule": 0.07436603651893126,
                    "rules": 0.07667058451945473,
                    "sample": 0.08975881566089786,
                    "saying": 0.07333459517716227,
                    "secure": 0.08472856590133783,
                    "security": 0.13660869083520452,
                    "sense": 0.06694432008522612,
                    "seriously": 0.07436603651893126,
                    "sets": 0.1795176313217957,
                    "shared": 0.08975881566089786,
                    "silly": 0.0870331139018613,
                    "simple": 0.05759003581068579,
                    "specifically": 0.07236974623837716,
                    "src": 0.09309480500319031,
                    "stuff": 0.1760136825410344,
                    "submit": 0.08975881566089786,
                    "technically": 0.0870331139018613,
                    "think": 0.03952130527090602,
                    "today": 0.07333459517716227,
                    "totally": 0.0809714228005323,
                    "trick": 0.09309480500319031,
                    "trivial": 0.0809714228005323,
                    "use": 0.035065543637110314,
                    "uses": 0.07333459517716227,
                    "various": 0.07333459517716227,
                    "wanted": 0.07939628627849128,
                    "week": 0.07146340997605177,
                    "wordpress": 0.08975881566089786,
                    "years": 0.054748889696128955
                },
                "Max term": "apps",
                "Max score": 0.2933383807086491
            }
        ],
        "Best Answer": "I personally see mod_security as a patch. I use it on some of our servers where we can't control the code that's uploaded (shared hosting servers, for example), but it's never really felt like a good solution to me. Based on it's wide and very general blacklist approach, it's more of a patch to cover up security holes than a good security policy. It can also provide a false sense of security. mod_security can reveal some common attacks but can by no means prevent any attack. Again, it's a blacklist of common known attacks. If you simply install mod_security and think that you're magically secure, you're horribly mistaken. I have found a much better policy to me managed servers where my team reviews all code that is placed on them, combined with lots of logs, logfile analysis, reporting systems, and intrusion detection/intrusion prevention systems (IPS). Everytime third-party or open-source software is installed (I'm looking at you, WordPress!) we keep a log of where it was installed, and when new versions are released we update every copy that was installed. Again, you're more likely to find mod_security on a shared hosting server, as you're experiencing now. As you grow you can move to a VPS or clod based hosting provider where you get your own managed environment and can more tightly control the available software. ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "analysis": 0.09446385174682914,
                "approach": 0.07888373535921482,
                "available": 0.07820017591068625,
                "based": 0.1440207053669032,
                "better": 0.056393609032346206,
                "code": 0.07895684967135132,
                "combined": 0.11278614512043812,
                "common": 0.13709985336268263,
                "control": 0.15139594543524335,
                "copy": 0.09288788640551636,
                "cover": 0.09446385174682914,
                "environment": 0.07402489092044681,
                "example": 0.060185397150190154,
                "experiencing": 0.11278614512043812,
                "false": 0.10874452992969641,
                "felt": 0.10874452992969641,
                "general": 0.0795941078039413,
                "good": 0.09864017956591267,
                "grow": 0.11278614512043812,
                "horribly": 0.10874452992969641,
                "hosting": 0.3383584353613144,
                "install": 0.11278614512043812,
                "installed": 0.32623358978908923,
                "known": 0.0865792943879535,
                "like": 0.040204622686060655,
                "likely": 0.07629186774726796,
                "log": 0.09288788640551636,
                "looking": 0.06668103567303174,
                "lots": 0.08456475615095829,
                "managed": 0.1776925424295493,
                "means": 0.07298962769059461,
                "new": 0.0534299241715741,
                "open": 0.07019762350502111,
                "party": 0.09288788640551636,
                "patch": 0.22557229024087624,
                "personally": 0.08363572299468303,
                "prevent": 0.09446385174682914,
                "prevention": 0.11278614512043812,
                "provide": 0.08190944827932245,
                "provider": 0.10874452992969641,
                "really": 0.05259511394326327,
                "released": 0.09809843462560798,
                "reveal": 0.10874452992969641,
                "reviews": 0.09446385174682914,
                "secure": 0.10265028568744955,
                "security": 0.24825608091758342,
                "sense": 0.081104330148848,
                "server": 0.0803334829380097,
                "servers": 0.32623358978908923,
                "shared": 0.21748905985939282,
                "simply": 0.07569797271762167,
                "software": 0.10651971109059016,
                "solution": 0.07690589860514031,
                "source": 0.06703970433643461,
                "systems": 0.1564003518213725,
                "team": 0.0674056193194476,
                "think": 0.04788082075558124,
                "update": 0.08554403115810129,
                "use": 0.042482579916748815,
                "versions": 0.09446385174682914,
                "wide": 0.09809843462560798,
                "wordpress": 0.10874452992969641
            },
            "Max term": "hosting",
            "Max score": 0.3383584353613144
        }
    },
    {
        "ID": "6166",
        "Question": "To quote Arthur C. Clarke:  Any sufficiently advanced technology is indistinguishable from magic.  Used to be I looked on technology with wonder and amazement. I wanted to take it apart, understand how it worked, figure it all out. Technology was magical. I'm older, I know more and I spend my days creating stuff that, hopefully, fills other people with that kind of wonder. But lately I've found my own awe for technology has been seriously curtailed. More often I'm just annoyed that it isn't as elegant or seamless or as polished or perfectly delivered as it seemed to be in my youth. It all looks broken and awkward, or cobbled together and poorly tested. Has programming ruined your ability to enjoy technology? Have you stopped wondering in awe and just started saying, \"They could have done this better\" every time you pick up a bit of technology? ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "ability": 0.10540311459305907,
                    "advanced": 0.12631848417185867,
                    "annoyed": 0.14214035047433843,
                    "apart": 0.12631848417185867,
                    "awkward": 0.13288515199596407,
                    "better": 0.07107085133383063,
                    "bit": 0.0939723537457934,
                    "broken": 0.13288515199596407,
                    "creating": 0.10911279248868105,
                    "days": 0.09772275623393456,
                    "delivered": 0.12936648883889404,
                    "elegant": 0.14214035047433843,
                    "enjoy": 0.14214035047433843,
                    "figure": 0.10780808721510997,
                    "hopefully": 0.12631848417185867,
                    "kind": 0.09539945142011833,
                    "know": 0.0619853646264777,
                    "lately": 0.14214035047433843,
                    "looked": 0.12362995351758972,
                    "looks": 0.10780808721510997,
                    "magic": 0.1212249808955388,
                    "magical": 0.12936648883889404,
                    "older": 0.12631848417185867,
                    "people": 0.06357237543545985,
                    "perfectly": 0.13288515199596407,
                    "pick": 0.10780808721510997,
                    "poorly": 0.14214035047433843,
                    "programming": 0.06034248830767075,
                    "quote": 0.1135446225364143,
                    "saying": 0.11196978241716446,
                    "seriously": 0.1135446225364143,
                    "spend": 0.09941435429600398,
                    "started": 0.09262925295761469,
                    "stopped": 0.13704684719801855,
                    "stuff": 0.08958124829057931,
                    "sufficiently": 0.13704684719801855,
                    "technology": 0.6324186875583544,
                    "tested": 0.11523622059848371,
                    "time": 0.056022826191068124,
                    "understand": 0.07780723092895744,
                    "used": 0.06936114448219408,
                    "wanted": 0.1212249808955388,
                    "wonder": 0.2270892450728286,
                    "wondering": 0.11049661786937892,
                    "worked": 0.0932909261862013
                },
                "Max term": "technology",
                "Max score": 0.6324186875583544
            }
        ],
        "Best Answer": "It has ruined my ability to enjoy technology in fiction. I can suspend my disbelief whilst the hero of the [book / film / drama] can withstand numerous karate kicks, fire an infinite number of bullets, leap across a 50ft gap between two buildings, fall from a great height onto a pile of conveniently stacked boxes etc. What makes me shout at the screen in disbelief is when the hero then steps up to a computer, and:   performs a search with some application that has more apparent power than google. hacks into a supposedly secure system with a few key presses and a wink. copies the entire hard disk to a memory stick in a matter of seconds with a convenient \"% complete\" window (which just happens to work with the operating system of the computer he's copying) does anything that involves zooming an image from a CCTV camera to get a high resolution print out of the suspects face.  AAAARHG!!!!  ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "ability": 0.14283690953056238,
                "apparent": 0.192621332488428,
                "application": 0.11044039930780182,
                "book": 0.1238074944674156,
                "complete": 0.13355383383890707,
                "computer": 0.2443581526522116,
                "convenient": 0.1800791609136422,
                "copies": 0.18571887738088955,
                "disk": 0.18571887738088955,
                "enjoy": 0.192621332488428,
                "entire": 0.15616223182605518,
                "face": 0.17118034856326445,
                "fall": 0.192621332488428,
                "fiction": 0.192621332488428,
                "google": 0.13851368115445525,
                "great": 0.11915884495950584,
                "happens": 0.15173572188094017,
                "hard": 0.1273465271134009,
                "high": 0.1292804568856455,
                "image": 0.18571887738088955,
                "key": 0.14786407526480322,
                "makes": 0.10834245641970192,
                "matter": 0.1398886986881867,
                "memory": 0.16132968261335026,
                "number": 0.12063211392951095,
                "numerous": 0.192621332488428,
                "operating": 0.18571887738088955,
                "pile": 0.18571887738088955,
                "power": 0.15616223182605518,
                "print": 0.1800791609136422,
                "screen": 0.15616223182605518,
                "search": 0.15616223182605518,
                "secure": 0.17531084858268922,
                "steps": 0.15863817698847862,
                "stick": 0.1675369893388564,
                "technology": 0.14283690953056238,
                "window": 0.17531084858268922,
                "work": 0.08155898495560916
            },
            "Max term": "computer",
            "Max score": 0.2443581526522116
        }
    },
    {
        "ID": "6190",
        "Question": "I am planning to create a utility, which will query the database and store some information (on another table in the database). Its a multi-threaded utility and require to run for every 5 or 10 minutes/later may be thrice in a day. I see two options to achieve this in C#/DotNet programming.   creating windows service having timer approach inside it. a console program and schedule it using windows task scheduler.  Which one do you prefer and why?  ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "10": 0.1499908178104889,
                    "achieve": 0.19913064144872142,
                    "approach": 0.14445019746838764,
                    "console": 0.19913064144872142,
                    "create": 0.13274830290349568,
                    "creating": 0.1585421394418363,
                    "database": 0.3063038697896058,
                    "day": 0.13100228788553542,
                    "information": 0.13756350032098769,
                    "inside": 0.17963574098616103,
                    "later": 0.1548531604043143,
                    "minutes": 0.16498163935183202,
                    "multi": 0.16743955074534686,
                    "options": 0.17298017108744815,
                    "planning": 0.1548531604043143,
                    "prefer": 0.1499908178104889,
                    "program": 0.12625611572909853,
                    "programming": 0.08767832787832407,
                    "query": 0.17614128817176217,
                    "require": 0.14445019746838764,
                    "run": 0.1277639492856248,
                    "schedule": 0.18797099262879127,
                    "service": 0.17963574098616103,
                    "store": 0.1835422068749062,
                    "table": 0.18797099262879127,
                    "task": 0.1365429082276367,
                    "threaded": 0.19308365056901325,
                    "using": 0.09691408621990928,
                    "utility": 0.3670844137498124,
                    "windows": 0.2970330056555529
                },
                "Max term": "utility",
                "Max score": 0.3670844137498124
            }
        ],
        "Best Answer": "Services are either used for administrative purposes or to offer a service to multiple applications. Schedules are used for running a task multiple times which don't necessarily require extra permissions. ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "applications": 0.21588399769608912,
                "extra": 0.26324702988502824,
                "multiple": 0.4356561997862107,
                "necessarily": 0.23143145464562764,
                "offer": 0.2542096689951002,
                "purposes": 0.2809267834229602,
                "require": 0.21588399769608912,
                "running": 0.22647049254110924,
                "schedules": 0.29760512407153006,
                "service": 0.2684695664862529,
                "services": 0.2542096689951002,
                "task": 0.20406637998320112,
                "times": 0.20406637998320112,
                "used": 0.3012434423907731
            },
            "Max term": "multiple",
            "Max score": 0.4356561997862107
        }
    },
    {
        "ID": "6246",
        "Question": "Most software developers want to keep application logic in the application layer, and it probably feels natural for us to keep it here. Database developers seem to want to put application logic in the database layer, as triggers and stored procedures. Personally I would prefer to keep as much as possible in the application layer to make it easier to debug and keep the responsibilities of the layers separate. What are your thoughts on this, and what should or should not be ok to implement in the database layer? Edit This question is also covered on dba.se, from the DBAs perspective. As programmers.se & dba.se have different audiences and biases, future readers might want to review both sets of answers before deciding what works best for them. ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "answers": 0.09677336837494845,
                    "application": 0.3144953791459092,
                    "best": 0.07228867355017894,
                    "covered": 0.12186534311980175,
                    "database": 0.3050619268428621,
                    "debug": 0.10802248018391904,
                    "deciding": 0.13712943671931058,
                    "developers": 0.15648170740911432,
                    "different": 0.07378730827289903,
                    "easier": 0.088743404793872,
                    "edit": 0.09133715592078413,
                    "feels": 0.12480589562099917,
                    "future": 0.11117376570128255,
                    "implement": 0.09958844229083941,
                    "layer": 0.45174568302636514,
                    "layers": 0.13712943671931058,
                    "logic": 0.20563372149839318,
                    "make": 0.0622301993853926,
                    "natural": 0.11927159199288963,
                    "ok": 0.10526620852496879,
                    "personally": 0.1016873089476207,
                    "perspective": 0.11927159199288963,
                    "possible": 0.08064557850226493,
                    "prefer": 0.09958844229083941,
                    "probably": 0.07786440980036911,
                    "procedures": 0.13712943671931058,
                    "programmers": 0.07347931119436318,
                    "question": 0.0703484253376893,
                    "responsibilities": 0.1282005143561001,
                    "review": 0.10660124952029294,
                    "se": 0.39664648843991496,
                    "separate": 0.11293642075659129,
                    "sets": 0.13221549614663833,
                    "software": 0.06475524083990249,
                    "stored": 0.1282005143561001,
                    "thoughts": 0.10660124952029294,
                    "want": 0.19426572251970747,
                    "works": 0.09203630772624173
                },
                "Max term": "layer",
                "Max score": 0.45174568302636514
            }
        ],
        "Best Answer": "Off the top of my head, advantages of putting logic in the application layer.  Testability.  This should be a good enough reason on it's own actually. Better code structure.  It's very difficult to follow proper OO-architecture with SQL.  This usually also makes the code easier to maintain. Easier to code.  Due to all the different language features available in whatever language you're using it's usually easier to code in the application layer. Code re-use.  It's a whole lot easier to share code with libraries than sharing code in the database.  ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "actually": 0.09387149878453166,
                "advantages": 0.13841752106397248,
                "application": 0.19578211861788491,
                "architecture": 0.14061212463530676,
                "available": 0.11837811481307758,
                "better": 0.08536769958649963,
                "code": 0.4183324420167841,
                "database": 0.12660635483028876,
                "different": 0.09186930237265503,
                "difficult": 0.12399314911720619,
                "easier": 0.4419618972105288,
                "features": 0.10760170940872879,
                "follow": 0.12399314911720619,
                "good": 0.07465992477544116,
                "head": 0.13638563552336538,
                "language": 0.16073764793991535,
                "layer": 0.2812242492706135,
                "libraries": 0.12526863061225083,
                "logic": 0.128012709641617,
                "lot": 0.08758770186988968,
                "maintain": 0.14061212463530676,
                "makes": 0.09603150562231202,
                "oo": 0.17073377496798128,
                "proper": 0.1456110002518487,
                "putting": 0.16461564567340867,
                "reason": 0.10626398519069086,
                "share": 0.13272448412486137,
                "sharing": 0.15172912954642134,
                "sql": 0.12660635483028876,
                "structure": 0.15172912954642134,
                "testability": 0.17073377496798128,
                "use": 0.06430941701057491,
                "using": 0.08011612257095553,
                "usually": 0.22252572161446563
            },
            "Max term": "easier",
            "Max score": 0.4419618972105288
        }
    },
    {
        "ID": "6255",
        "Question": "Joel Spolsky said in one of his famous posts:  The single worst strategic mistake   that any software company can make:    rewrite the code from scratch.  Chad Fowler wrote:  Youâ€™ve seen the videos, the weblog   posts and the hype, and youâ€™ve decided   youâ€™re going to re-implement your   product in Rails (or Java, or .NET, or   Erlang, etc.). Beware. This is a longer, harder, more   failure-prone path than you expect.  Have you ever been involved in a BIG Rewrite? I'm interested in your experience about this tragic topic, and in particular, in any big rewrite that was completed succesfully (if any). ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "big": 0.21917432722844502,
                    "code": 0.06163069895648988,
                    "company": 0.1040973355136966,
                    "completed": 0.1564741329323293,
                    "decided": 0.16024977899533288,
                    "erlang": 0.1564741329323293,
                    "expect": 0.14274623242006443,
                    "experience": 0.1009523924178821,
                    "failure": 0.15314377708024063,
                    "famous": 0.17607310791435574,
                    "fowler": 0.16976364723664691,
                    "going": 0.09101649628207273,
                    "harder": 0.15314377708024063,
                    "implement": 0.12787076915067863,
                    "interested": 0.13056569727259407,
                    "involved": 0.12787076915067863,
                    "java": 0.1070149052899743,
                    "joel": 0.1335448020982142,
                    "longer": 0.13201603281696608,
                    "make": 0.07990308189148371,
                    "mistake": 0.14746974413270503,
                    "net": 0.10763636643847899,
                    "particular": 0.11474236835357121,
                    "path": 0.14746974413270503,
                    "posts": 0.3292168849945964,
                    "product": 0.11556200093075415,
                    "prone": 0.1646084424972982,
                    "rails": 0.15314377708024063,
                    "rewrite": 0.4504940167638614,
                    "said": 0.11168259202098046,
                    "scratch": 0.1564741329323293,
                    "seen": 0.1200596098917435,
                    "single": 0.11556200093075415,
                    "software": 0.0831452150697755,
                    "spolsky": 0.16976364723664691,
                    "topic": 0.1646084424972982,
                    "worst": 0.1564741329323293,
                    "wrote": 0.13687515795030292
                },
                "Max term": "rewrite",
                "Max score": 0.4504940167638614
            }
        ],
        "Best Answer": "I've been involved in a few rewrites over my career and they were all disasters. I think they all fail for the same reasons  Vast underestimate of effort required:  Every time someone wants a rewrite, it's because the old system is using old technology and difficult to maintain.  What they fail to consider is that because of it's age, it may have 30-40 man years of development effort into it.  Thinking you can then rewrite the whole thing in 6 months with a team of 5 is silly. Lost knowledge:  The old system has been around so long, it does a lot of stuff, and is hooked into everything.  There is no up-to-date documentation, and no single point of authority that actually knows all the things the system does.  There will be pieces of knowledge with particular users in particular departments, and finding them all is difficult or impossible. Poor Management Decisions: The rewrites I've been involved in had a similar expectations from management: The new system should be 'done', and the old system could simply be turned off on a particular date, period.  No other option was acceptable.  I think they get this in their head, because they are spending all this money to hire new people for this huge project.  In reality, the better risk mitigation strategy is to rewrite the major functions of the old system, say tackle 50-75% of the old system for a first release, and then see how it works!  Because of #1 and #2 above, this would probably work out much better, as we find out some of the features that were missed, and what's needed to actually turn off the old system.  ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "30": 0.08637289269420467,
                "40": 0.09641101246900564,
                "50": 0.08493191095571058,
                "75": 0.10312585639625474,
                "acceptable": 0.09641101246900564,
                "actually": 0.11339969148073095,
                "age": 0.09385814728869708,
                "authority": 0.10312585639625474,
                "better": 0.10312683744135535,
                "career": 0.07277676280727718,
                "consider": 0.06673796551516643,
                "date": 0.16721267250894858,
                "decisions": 0.08969616854175655,
                "development": 0.052124856989573164,
                "difficult": 0.14978758236181924,
                "documentation": 0.07415763252758685,
                "effort": 0.16247293134903373,
                "expectations": 0.09164675488295967,
                "fail": 0.156434134056923,
                "features": 0.06499310657517585,
                "finding": 0.09164675488295967,
                "functions": 0.08123646567451687,
                "head": 0.08237904577540202,
                "hire": 0.08969616854175655,
                "huge": 0.07566420184815294,
                "impossible": 0.08493191095571058,
                "involved": 0.14978758236181924,
                "knowledge": 0.12916835219815287,
                "knows": 0.0764722080884709,
                "long": 0.0572094503430745,
                "lost": 0.08237904577540202,
                "lot": 0.0529043346391547,
                "maintain": 0.08493191095571058,
                "major": 0.08016765336966461,
                "man": 0.09641101246900564,
                "management": 0.1353691140460314,
                "missed": 0.08969616854175655,
                "money": 0.07277676280727718,
                "months": 0.08493191095571058,
                "needed": 0.07150222310121242,
                "new": 0.09770715510307931,
                "old": 0.5094373396509403,
                "option": 0.08969616854175655,
                "particular": 0.20161349694273972,
                "people": 0.04612311449949335,
                "period": 0.09385814728869708,
                "pieces": 0.10312585639625474,
                "point": 0.05912772283436273,
                "poor": 0.08795130960176596,
                "probably": 0.058556602692740684,
                "project": 0.04869807553741877,
                "reality": 0.08969616854175655,
                "reasons": 0.07277676280727718,
                "release": 0.08123646567451687,
                "required": 0.07566420184815294,
                "rewrite": 0.26385392880529784,
                "risk": 0.08123646567451687,
                "say": 0.05372232029696482,
                "silly": 0.09641101246900564,
                "similar": 0.06720449898091324,
                "simply": 0.06921433705912208,
                "single": 0.0676845570230157,
                "spending": 0.09943041111506101,
                "strategy": 0.09943041111506101,
                "stuff": 0.06499310657517585,
                "tackle": 0.09943041111506101,
                "team": 0.061632235154549304,
                "technology": 0.0764722080884709,
                "thing": 0.058839700916822245,
                "things": 0.0490105535403691,
                "think": 0.08755952497715266,
                "thinking": 0.06499310657517585,
                "time": 0.040645755476278106,
                "turn": 0.08493191095571058,
                "turned": 0.08795130960176596,
                "underestimate": 0.10312585639625474,
                "users": 0.06673796551516643,
                "using": 0.04839138449803814,
                "vast": 0.09641101246900564,
                "wants": 0.08016765336966461,
                "work": 0.04366515412233348,
                "works": 0.06921433705912208,
                "years": 0.060648133227884184
            },
            "Max term": "old",
            "Max score": 0.5094373396509403
        }
    },
    {
        "ID": "6268",
        "Question": "Just read the question about the Big Rewrites and I remembered a question that I've been wanting answered myself. I have a horrible project passed down to me, written in old Java, using Struts 1.0, tables with inconsistent relationships, or no relationships at all and even tables without primary keys or fields meant to be primary keys but aren't unique at all. Somehow most of the app \"just works\". Most of the pages are reused (copy pasted code) and hard-coded. Everyone who's ever worked on the project has cursed it in one form or the other. Now I had long considered to propose to upper management a total rewrite of this horrendous application.  I'm slowly attempting to on personal time but I really feel that this deserves some dedicated resources to make it happen. Having read the articles on big rewrites I'm having second thoughts. And that's not good when I want to convince my superiors to support my rewrite. (I work in a fairly small company so the proposal has the possibility of being approved) TL;DR When is a big rewrite the answer and what arguments can you use to support it? ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "answer": 0.0779597002441763,
                    "app": 0.08593188863104279,
                    "application": 0.07560441593430624,
                    "arguments": 0.11044179940761677,
                    "articles": 0.11246006229136259,
                    "big": 0.2462132882791278,
                    "code": 0.04615594426866805,
                    "coded": 0.11718529047044388,
                    "company": 0.0779597002441763,
                    "considered": 0.10001324903628091,
                    "convince": 0.1271379616549909,
                    "copy": 0.10859926975336238,
                    "dedicated": 0.1200129155373807,
                    "fairly": 0.1038740415742811,
                    "feel": 0.07924347102610578,
                    "fields": 0.11246006229136259,
                    "form": 0.09482260140518635,
                    "good": 0.05766226299106792,
                    "happen": 0.10001324903628091,
                    "hard": 0.08717787932690697,
                    "horrible": 0.1318631898340722,
                    "java": 0.08014470204155805,
                    "keys": 0.2465543382339814,
                    "long": 0.07315159237955896,
                    "make": 0.05984034348339619,
                    "management": 0.08654572096125779,
                    "meant": 0.11246006229136259,
                    "old": 0.093056934748653,
                    "pages": 0.1318631898340722,
                    "passed": 0.1318631898340722,
                    "personal": 0.09674899545667091,
                    "possibility": 0.1318631898340722,
                    "primary": 0.21067003234750478,
                    "project": 0.12453682914342033,
                    "proposal": 0.1232771691169907,
                    "propose": 0.1232771691169907,
                    "question": 0.13529360269771282,
                    "read": 0.15848694205221156,
                    "really": 0.06149123624040251,
                    "relationships": 0.2637263796681444,
                    "resources": 0.10690430677728074,
                    "reused": 0.1318631898340722,
                    "rewrite": 0.3373801868740877,
                    "second": 0.09778216292773428,
                    "slowly": 0.11718529047044388,
                    "small": 0.07880684251343259,
                    "support": 0.17435575865381395,
                    "tables": 0.2465543382339814,
                    "thoughts": 0.10250739110681557,
                    "time": 0.0519722129600893,
                    "total": 0.11469114839990921,
                    "unique": 0.11718529047044388,
                    "upper": 0.1232771691169907,
                    "use": 0.04966823269135976,
                    "using": 0.06187626016776647,
                    "want": 0.062268414571710166,
                    "wanting": 0.1232771691169907,
                    "work": 0.055833005498089505,
                    "worked": 0.08654572096125779,
                    "works": 0.08850179368981158,
                    "written": 0.08991403240442739
                },
                "Max term": "rewrite",
                "Max score": 0.3373801868740877
            }
        ],
        "Best Answer": "Sorry, this is going to be long, but it's based on personal experience as both architect and developer on multiple rewrite projects. The following conditions should cause you to consider some sort of rewrite.  I'll talk about how to decide which one to do after that.  Developer ramp-up time is very high.  If it takes any longer than below (by experience level) to ramp up a new developer, then the system needs to be redesigned.  By ramp-up time, I mean the amount of time before the new developer is ready to do their first commit (on a small feature)   Fresh out of college - 1.5 months Still green, but have worked on other projects before - 1 month Mid level - 2 weeks Experienced - 1 week Senior level - 1 day  Deployment cannot be automated, because of the complexity of the existing architecture Even simple bug fixes take too long because of the complexity of existing code New features take too long, and cost too much because of the interdependence of the codebase (new features cannot be isolated, and therefore affect existing features) The formal testing cycle takes too long because of the interdependence of the existing codebase. Too many use cases are executed on too few screens. This causes training issues for the users and developers. The technology that the current system is in demands it   Quality developers with experience in the technology are too hard to find It is deprecated (It can't be upgraded to support newer platforms/features) There is simply a much more expressive higher-level technology available The cost of maintaining the infrastructure of the older technology is too high   These things are pretty self-evident. When to decide on a complete rewrite versus an incremental rebuild is more subjective, and therefore more politically charged. What I can say with conviction is that to categorically state that it is never a good idea is wrong. If a system can be incrementally redesigned, and you have the full support of project sponsorship for such a thing, then you should do it.  Here's the problem, though. Many systems cannot be incrementally redesigned. Here are some of the reasons I have encountered that prevent this (both technical and political).  Technical   The coupling of components is so high that changes to a single component cannot be isolated from other components.  A redesign of a single component results in a cascade of changes not only to adjacent components, but indirectly to all components. The technology stack is so complicated that future state design necessitates multiple infrastructure changes. This would be necessary in a complete rewrite as well, but if it's required in an incremental redesign, then you lose that advantage. Redesigning a component results in a complete rewrite of that component anyway, because the existing design is so fubar that there's nothing worth saving. Again, you lose the advantage if this is the case.  Political   The sponsors cannot be made to understand that an incremental redesign requires a long-term commitment to the project. Inevitably, most organizations lose the appetite for the continuing budget drain that an incremental redesign creates. This loss of appetite is inevitable for a rewrite as well, but the sponsors will be more inclined to continue, because they don't want to be split between a partially complete new system and a partially obsolete old system. The users of the system are too attached with their \"current screens.\" If this is the case, you won't have the license to improve a vital part of the system (the front-end). A redesign lets you circumvent this problem, since they're starting with something new. They'll still insist on getting \"the same screens,\" but you have a little more ammunition to push back.   Keep in mind that the total cost of redesiging incrementally is always higher than doing a complete rewrite, but the impact to the organization is usually smaller.  In my opinion, if you can justify a rewrite, and you have superstar developers, then do it. Only do it if you can be certain that there is the political will to see it through to completion.  This means both executive and end user buy-in.  Without it, you will fail. I'm assuming that this is why Joel says it's a bad idea.  Executive and end-user buy-in looks like a two-headed unicorn to many architects. You have to sell it aggressively, and campaign for its continuation continuously until it's complete.  That's difficult, and you're talking about staking your reputation on something that some will not want to see succeed. Some strategies for success:  If you do, however, do not try to convert existing code. Design the system from scratch. Otherwise you're wasting your time. I have never seen or heard of a \"conversion\" project that didn't end up miserably. Migrate users to the new system one team at a time. Identify the teams that have the MOST pain with the existing system, and migrate them first. Let them spread the good news by word of mouth. This way your new system will be sold from within. Design your framework as you need it. Don't start with some I-spent-6-months-building-this framework that has never seen real code. Keep your technology stack as small as possible. Don't over-design. You can add technologies as needed, but taking them out is difficult. Additionally, the more layers you have, the more work it is for developers to do things. Don't make it difficult from the get-go. Involve the users directly in the design process, but don't let them dictate how to do it. Earn their trust by showing them that you can give them what they want better if you follow good design principles.  ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "add": 0.03323121452065338,
                "additionally": 0.04773856778862084,
                "advantage": 0.08293877389705356,
                "affect": 0.043064959445406566,
                "architect": 0.04773856778862084,
                "architects": 0.04951282641922488,
                "architecture": 0.04077754223387845,
                "assuming": 0.04146938694852678,
                "automated": 0.042227217090183566,
                "available": 0.03432967526006015,
                "bad": 0.029272802445791554,
                "based": 0.03161235884953396,
                "better": 0.024756648719490727,
                "budget": 0.04628889293231572,
                "bug": 0.03494160776114226,
                "building": 0.04146938694852678,
                "buy": 0.07910371921443733,
                "case": 0.06453250055635472,
                "cases": 0.03432967526006015,
                "cause": 0.038490125022350344,
                "causes": 0.04628889293231572,
                "certain": 0.035266191535441194,
                "changes": 0.09893632297173922,
                "code": 0.05199277963013775,
                "codebase": 0.08612991889081313,
                "college": 0.043064959445406566,
                "commit": 0.04146938694852678,
                "complete": 0.2059780515603609,
                "complexity": 0.08293877389705356,
                "complicated": 0.03900328360327441,
                "component": 0.18025284122262375,
                "components": 0.1851555717292629,
                "conditions": 0.04400147572078761,
                "consider": 0.03204225804853203,
                "continue": 0.042227217090183566,
                "continuously": 0.04951282641922488,
                "convert": 0.04628889293231572,
                "cost": 0.10787410875026854,
                "coupling": 0.04951282641922488,
                "creates": 0.04506321030565594,
                "current": 0.07265585224061905,
                "cycle": 0.04628889293231572,
                "day": 0.03140582260565108,
                "decide": 0.07800656720654882,
                "deployment": 0.04400147572078761,
                "design": 0.19871897753837364,
                "developer": 0.1093765870540757,
                "developers": 0.11300056066868332,
                "difficult": 0.10787410875026854,
                "directly": 0.04506321030565594,
                "encountered": 0.04400147572078761,
                "end": 0.11037056773985236,
                "executed": 0.04773856778862084,
                "existing": 0.24923214029112242,
                "experience": 0.08516527608787441,
                "experienced": 0.042227217090183566,
                "fail": 0.0375536087469693,
                "feature": 0.03100817983353356,
                "features": 0.12481806277323612,
                "fixes": 0.04628889293231572,
                "follow": 0.03595803625008951,
                "following": 0.035604591470160346,
                "formal": 0.043064959445406566,
                "framework": 0.06499347186540143,
                "fresh": 0.04773856778862084,
                "future": 0.0401411067909975,
                "getting": 0.030093240771723078,
                "going": 0.02559439107471373,
                "good": 0.06495417611258325,
                "green": 0.04506321030565594,
                "hard": 0.03273410276318035,
                "heard": 0.03900328360327441,
                "high": 0.09969364356196014,
                "higher": 0.080282213581995,
                "idea": 0.0573448538420964,
                "identify": 0.04628889293231572,
                "improve": 0.04077754223387845,
                "inclined": 0.04628889293231572,
                "indirectly": 0.04951282641922488,
                "inevitably": 0.04628889293231572,
                "infrastructure": 0.09257778586463145,
                "involve": 0.04628889293231572,
                "isolated": 0.09902565283844976,
                "issues": 0.0367158663917463,
                "joel": 0.0375536087469693,
                "justify": 0.04951282641922488,
                "layers": 0.04951282641922488,
                "let": 0.06453250055635472,
                "lets": 0.04628889293231572,
                "level": 0.12107199767171198,
                "license": 0.0401411067909975,
                "like": 0.017649725524173664,
                "little": 0.03140582260565108,
                "long": 0.13733711812737906,
                "longer": 0.03712370954797123,
                "looks": 0.0375536087469693,
                "lose": 0.1266816512705507,
                "maintaining": 0.04506321030565594,
                "make": 0.022469231507962612,
                "mean": 0.03297877432391307,
                "means": 0.03204225804853203,
                "mid": 0.04773856778862084,
                "mind": 0.033491932904837145,
                "month": 0.03900328360327441,
                "months": 0.0815550844677569,
                "multiple": 0.06988321552228452,
                "necessary": 0.03432967526006015,
                "need": 0.023306973863185615,
                "needed": 0.03432967526006015,
                "needs": 0.035604591470160346,
                "new": 0.1876447897584972,
                "obsolete": 0.04951282641922488,
                "old": 0.03494160776114226,
                "older": 0.04400147572078761,
                "opinion": 0.035604591470160346,
                "organization": 0.039551859607218666,
                "pain": 0.04400147572078761,
                "personal": 0.03632792612030952,
                "platforms": 0.04146938694852678,
                "political": 0.1351896309169678,
                "possible": 0.029118405394122967,
                "pretty": 0.03100817983353356,
                "prevent": 0.04146938694852678,
                "principles": 0.042227217090183566,
                "problem": 0.05158636277367628,
                "process": 0.030267999417927995,
                "project": 0.07014281709631702,
                "projects": 0.05763664912324576,
                "push": 0.04077754223387845,
                "quality": 0.035266191535441194,
                "ready": 0.043064959445406566,
                "real": 0.029922240668874008,
                "reasons": 0.03494160776114226,
                "reputation": 0.043064959445406566,
                "required": 0.03632792612030952,
                "requires": 0.04146938694852678,
                "results": 0.07910371921443733,
                "rewrite": 0.33781773672146853,
                "saving": 0.04951282641922488,
                "say": 0.02579318138683814,
                "says": 0.03800808663113798,
                "scratch": 0.04400147572078761,
                "seen": 0.0675229817312162,
                "self": 0.04146938694852678,
                "sell": 0.04146938694852678,
                "senior": 0.04146938694852678,
                "showing": 0.04773856778862084,
                "simple": 0.03062947977036648,
                "simply": 0.03323121452065338,
                "single": 0.06499347186540143,
                "small": 0.05918178559042492,
                "smaller": 0.04628889293231572,
                "sold": 0.04506321030565594,
                "sorry": 0.04773856778862084,
                "sort": 0.03632792612030952,
                "spent": 0.043064959445406566,
                "spread": 0.04951282641922488,
                "stack": 0.0751072174939386,
                "start": 0.02759264193496309,
                "starting": 0.0367158663917463,
                "state": 0.08293877389705356,
                "strategies": 0.04951282641922488,
                "subjective": 0.04951282641922488,
                "succeed": 0.04951282641922488,
                "success": 0.04506321030565594,
                "support": 0.0654682055263607,
                "systems": 0.03432967526006015,
                "takes": 0.06499347186540143,
                "taking": 0.04077754223387845,
                "talk": 0.039551859607218666,
                "talking": 0.0367158663917463,
                "team": 0.02959089279521246,
                "teams": 0.042227217090183566,
                "technical": 0.06322471769906791,
                "technologies": 0.043064959445406566,
                "technology": 0.2202951983504778,
                "term": 0.03900328360327441,
                "testing": 0.029118405394122967,
                "thing": 0.02825014016717083,
                "things": 0.047061932185661876,
                "time": 0.09757427990912206,
                "total": 0.043064959445406566,
                "training": 0.043064959445406566,
                "trust": 0.042227217090183566,
                "try": 0.028388425362624804,
                "understand": 0.027103182919487212,
                "use": 0.018649742865249033,
                "user": 0.059844481337748015,
                "users": 0.12816903219412812,
                "usually": 0.03226625027817736,
                "versus": 0.04951282641922488,
                "vital": 0.04951282641922488,
                "want": 0.07014281709631702,
                "wasting": 0.04951282641922488,
                "way": 0.021771867044171247,
                "week": 0.03800808663113798,
                "weeks": 0.03800808663113798,
                "word": 0.04077754223387845,
                "work": 0.020964530838129523,
                "worked": 0.032496735932700714,
                "worth": 0.03323121452065338,
                "wrong": 0.03204225804853203
            },
            "Max term": "rewrite",
            "Max score": 0.33781773672146853
        }
    },
    {
        "ID": "6394",
        "Question": "When drafting a project proposal, do you use any standard template?  What features/information should be included? What is nice to have included? What sort of boiler plate information should I shove in? Do you find any design pattern or concept particularly helpful? ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "concept": 0.22661474474061827,
                    "design": 0.16925965859772876,
                    "features": 0.18604996950308525,
                    "helpful": 0.21659716219352074,
                    "included": 0.5135304434920297,
                    "information": 0.39325718223076245,
                    "nice": 0.2143917762887913,
                    "particularly": 0.23933240200508984,
                    "pattern": 0.23581914701182818,
                    "project": 0.1394036374937074,
                    "proposal": 0.27598720656432235,
                    "sort": 0.21659716219352074,
                    "standard": 0.19375454465153538,
                    "template": 0.26234899129354694,
                    "use": 0.1111949349069361
                },
                "Max term": "included",
                "Max score": 0.5135304434920297
            }
        ],
        "Best Answer": "Have you ever looked at the Volere Requirements Template?  While it contains a little too much detail for my taste, particularly for a proposal (it's better suited for detailed up front requirements specification), the section headings are a great checklist to make sure you've thought about all of the different moving parts before giving an estimate or creating a proposal document. Here they are:  PROJECT DRIVERS  The Purpose of the Product Client, Customer and other Stakeholders Users of the Product   PROJECT CONSTRAINTS  Mandated Constraints Naming Conventions and Definitions Relevant Facts and Assumptions   FUNCTIONAL REQUIREMENTS  The Scope of the Work The Scope of the Product Functional and Data Requirements   NON-FUNCTIONAL REQUIREMENTS  Look and Feel Requirements Usability Requirements Performance Requirements Operational Requirements Maintainability and Portability Requirements Security Requirements Cultural and Political Requirements Legal Requirements  PROJECT ISSUES  Open Issues Off-the-Shelf Solutions New Problems Tasks Cutover Risks Costs User Documentation and Training Waiting Room Ideas for Solutions   ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "assumptions": 0.08552360287510319,
                "better": 0.042762208234229555,
                "checklist": 0.08552360287510319,
                "client": 0.0592977158870625,
                "constraints": 0.17104720575020638,
                "contains": 0.06933581304959406,
                "conventions": 0.0799548961950275,
                "costs": 0.0729391554900082,
                "creating": 0.06565144311417904,
                "cultural": 0.08245892243782187,
                "customer": 0.06274929854505522,
                "data": 0.05228197518204321,
                "definitions": 0.08552360287510319,
                "detailed": 0.0729391554900082,
                "different": 0.04601897740505762,
                "document": 0.07163015398940567,
                "documentation": 0.06149988117507168,
                "estimate": 0.0683180052251309,
                "facts": 0.08245892243782187,
                "feel": 0.05139559535158656,
                "functional": 0.17355204558635665,
                "giving": 0.07043512924721386,
                "great": 0.05290636090883132,
                "ideas": 0.06565144311417904,
                "issues": 0.12683877708438912,
                "legal": 0.07600383592728954,
                "little": 0.05424733942170473,
                "look": 0.0492784713295036,
                "looked": 0.07438618951495182,
                "maintainability": 0.08245892243782187,
                "make": 0.038811147966491585,
                "moving": 0.07438618951495182,
                "naming": 0.07600383592728954,
                "new": 0.04051490199986036,
                "non": 0.0505629694862897,
                "open": 0.053229531597241565,
                "particularly": 0.06933581304959406,
                "parts": 0.07043512924721386,
                "performance": 0.06565144311417904,
                "political": 0.07783777217294455,
                "problems": 0.05168474541183554,
                "product": 0.16839502849909616,
                "project": 0.1211578265214359,
                "proposal": 0.159909792390055,
                "purpose": 0.06486642256713818,
                "relevant": 0.06412385683154202,
                "requirements": 0.740535926411609,
                "risks": 0.08245892243782187,
                "room": 0.07783777217294455,
                "scope": 0.1458783109800164,
                "section": 0.07600383592728954,
                "security": 0.06274929854505522,
                "solutions": 0.13474089761986505,
                "specification": 0.0799548961950275,
                "stakeholders": 0.08245892243782187,
                "suited": 0.0729391554900082,
                "sure": 0.05029627915396676,
                "tasks": 0.06274929854505522,
                "taste": 0.0799548961950275,
                "template": 0.07600383592728954,
                "thought": 0.0592977158870625,
                "training": 0.07438618951495182,
                "usability": 0.0799548961950275,
                "user": 0.05168474541183554,
                "users": 0.055346655619324524,
                "waiting": 0.08552360287510319,
                "work": 0.03621207552729955
            },
            "Max term": "requirements",
            "Max score": 0.740535926411609
        }
    },
    {
        "ID": "6395",
        "Question": "What tools and techniques do you use for exploring and learning an unknown code base?  I am thinking of tools like grep, ctags, unit-tests, functional test, class-diagram generators, call graphs, code metrics like sloccount, and so on. I'd be interested in your experiences, the helpers you used or wrote yourself and the size of the code base with which you worked.  I realize that becoming acquainted with a code base is a process that happens over time, and familiarity can mean anything from \"I'm able to summarize the code\" to \"I can refactor and shrink it to 30% of the size\". But how to even begin? ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "30": 0.1565395418314286,
                    "able": 0.11779148304664659,
                    "base": 0.43588007776762017,
                    "begin": 0.17473231761305738,
                    "class": 0.12448899303081774,
                    "code": 0.3271057881784183,
                    "diagram": 0.17010558423389704,
                    "experiences": 0.151525521066147,
                    "functional": 0.12642607517877494,
                    "generators": 0.18690209170598468,
                    "happens": 0.14723044140383057,
                    "interested": 0.13859584927170224,
                    "learning": 0.11493080938131732,
                    "like": 0.13324913389406975,
                    "mean": 0.12448899303081774,
                    "metrics": 0.18690209170598468,
                    "process": 0.11425630108584764,
                    "realize": 0.151525521066147,
                    "refactor": 0.16609772548092905,
                    "size": 0.3188004309935158,
                    "techniques": 0.15392795138800172,
                    "test": 0.10562170895371929,
                    "tests": 0.11855138074816406,
                    "thinking": 0.11779148304664659,
                    "time": 0.07366510187606311,
                    "tools": 0.2471308030268913,
                    "unit": 0.12095381107001876,
                    "unknown": 0.18690209170598468,
                    "use": 0.07039945410873145,
                    "used": 0.0912038203337871,
                    "worked": 0.12266938405036179,
                    "wrote": 0.1452933592558734
                },
                "Max term": "base",
                "Max score": 0.43588007776762017
            }
        ],
        "Best Answer": "How do you eat an elephant?  One bite at a time :) Seriously, I try to talk to the authors of the code first.  ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "authors": 0.4318537745106865,
                "bite": 0.44537856455965175,
                "code": 0.16168945873191673,
                "eat": 0.46193156978500666,
                "seriously": 0.36900039681808045,
                "talk": 0.36900039681808045,
                "time": 0.18206450145840009,
                "try": 0.26485076372836697
            },
            "Max term": "eat",
            "Max score": 0.46193156978500666
        }
    },
    {
        "ID": "6417",
        "Question": "It's not uncommon for projects to fail. As a programmer, how do you deal with projects that fail? Some definitions of failure:  Misses deadline. Code and functionality does not do what it's supposed to. Software becomes vapor-ware or endless number of phases, essentially undeliverable.  Or maybe you have your own definition(s) of failure. Do you start pointing fingers?  Do you blame yourself, the requirements, the technology, the management, the client, etc?  Do you do a lessons learned session as a team? ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "blame": 0.21483249977997076,
                    "client": 0.1544899709896891,
                    "code": 0.07799241672484152,
                    "deadline": 0.19003038898033356,
                    "deal": 0.17552208422381457,
                    "definition": 0.17799077902774088,
                    "definitions": 0.22281699605888325,
                    "essentially": 0.19801488525924604,
                    "fail": 0.33799655149241614,
                    "failure": 0.38760077309169055,
                    "functionality": 0.16348247427122192,
                    "learned": 0.16522827818069635,
                    "management": 0.14624140058042961,
                    "maybe": 0.14954669184478853,
                    "number": 0.13954261922480152,
                    "phases": 0.22281699605888325,
                    "pointing": 0.22281699605888325,
                    "programmer": 0.11517955543353293,
                    "projects": 0.2593757203801038,
                    "requirements": 0.1484106636599716,
                    "session": 0.22281699605888325,
                    "software": 0.10521860650934006,
                    "start": 0.1241720587150657,
                    "supposed": 0.17799077902774088,
                    "team": 0.1331645619965985,
                    "technology": 0.16522827818069635
                },
                "Max term": "failure",
                "Max score": 0.38760077309169055
            }
        ],
        "Best Answer": "You should do lessons learned for all projects, failed or succeeded. There is a lot to learn from a good project.  True failed projects have been very rare for me. In addition to understanding what happened, I do the \"ask why 5 times\" thing to try to get to underlying causes. There is also the matter of why I didn't notice what was happening and either do something about it or at least get out. I think everyone's first position is to blame everything - the client, the tech, the business problem being tackled, the methodology, the team members, the language, the platform, heck even the way we take our coffee in the morning. The nice thing about a retrospective (even if it happens only in your own head) is the chance to reconcile with some or all of those factors and realize they weren't the issue. In my only real failure of the last 30+ years, the project had been in requirements for literally years when we arrived. We got requirements settled. One came from management and hundreds from the end users. We wrote code, lots of code, some of it brilliant. There was testing and acceptance testing and changes and arguments and change requests and unpaid work and paid work and last minute bolt ons and surreal humour and escalations to VPs and all of that. Eventually it just all kind of stumbled to a halt. The reason for the failure was that the single management requirement was unacceptable to the end users. And no matter how many things they got their way on, they could not get past that one and would never accept the system. But management would not have it any other way. So that was that and though we got a lot of money it was, in the end, all horrible. I still work in that technology, I still use those processes and I still work with the same people. I would even do another project for that client. But when the end users say they don't like something their own management has injected into the requirements, I will remember that writing good code that works does not protect you from a failed project. And I will do something about it then, not a year or two later. ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "30": 0.08543766971773532,
                "accept": 0.08543766971773532,
                "acceptance": 0.0983538047616786,
                "addition": 0.09065442791309833,
                "arguments": 0.08543766971773532,
                "ask": 0.06310465547742065,
                "blame": 0.0983538047616786,
                "business": 0.06647682633260238,
                "came": 0.09065442791309833,
                "causes": 0.09536709937042608,
                "chance": 0.07929961909337399,
                "change": 0.06310465547742065,
                "changes": 0.06794481027364965,
                "client": 0.14145603165181714,
                "code": 0.10711858217871521,
                "coffee": 0.09536709937042608,
                "end": 0.22739193431581314,
                "eventually": 0.08401229055070174,
                "factors": 0.0814870671234708,
                "failed": 0.271963283739295,
                "failure": 0.17744992401605897,
                "good": 0.0892149422959925,
                "got": 0.1966995220508554,
                "happened": 0.08401229055070174,
                "happening": 0.09536709937042608,
                "happens": 0.08035685857955767,
                "head": 0.0814870671234708,
                "horrible": 0.10200923673282267,
                "hundreds": 0.10200923673282267,
                "issue": 0.06955740892274358,
                "kind": 0.0684649024124447,
                "language": 0.0480183981864599,
                "later": 0.07648444957707246,
                "learn": 0.05535772699494478,
                "learned": 0.07564418712222992,
                "like": 0.0363630024676939,
                "literally": 0.09536709937042608,
                "lot": 0.10466300082224574,
                "lots": 0.07648444957707246,
                "management": 0.26780674572968866,
                "matter": 0.14816572179602197,
                "members": 0.0814870671234708,
                "methodology": 0.08543766971773532,
                "minute": 0.09536709937042608,
                "money": 0.07198875515108585,
                "morning": 0.10200923673282267,
                "nice": 0.07408286089801099,
                "notice": 0.08270106882386463,
                "paid": 0.08401229055070174,
                "past": 0.07564418712222992,
                "people": 0.0456237055404931,
                "platform": 0.0814870671234708,
                "position": 0.07929961909337399,
                "problem": 0.053140629135261505,
                "processes": 0.08699899594195426,
                "project": 0.19268314230881264,
                "projects": 0.11874641401236848,
                "protect": 0.09536709937042608,
                "rare": 0.09536709937042608,
                "real": 0.06164755988929963,
                "realize": 0.08270106882386463,
                "reason": 0.06349012094134987,
                "remember": 0.07134626000414031,
                "requests": 0.08699899594195426,
                "requirement": 0.08872496200802948,
                "requirements": 0.203834430820949,
                "say": 0.053140629135261505,
                "single": 0.06695168643242216,
                "team": 0.060964897514118925,
                "tech": 0.08401229055070174,
                "technology": 0.07564418712222992,
                "testing": 0.11998290236883193,
                "thing": 0.11640520020603849,
                "things": 0.048479880150481464,
                "think": 0.04330572672913215,
                "times": 0.0674407235356144,
                "true": 0.07929961909337399,
                "try": 0.058487503394951526,
                "underlying": 0.09536709937042608,
                "understanding": 0.0814870671234708,
                "unpaid": 0.10200923673282267,
                "use": 0.0384232970026687,
                "users": 0.19804603310574245,
                "way": 0.13456704252468568,
                "work": 0.17276943724860336,
                "works": 0.0684649024124447,
                "writing": 0.056847983578953286,
                "wrote": 0.07929961909337399,
                "year": 0.07408286089801099,
                "years": 0.11998290236883193
            },
            "Max term": "failed",
            "Max score": 0.271963283739295
        }
    },
    {
        "ID": "6442",
        "Question": "Assuming the language provides it, what are some things to do or libraries to use that every programmer should know? My list would be  Regular Expressions Named Pipes standard IO (std in/out/error) Executing outside executables (like imagemagik and your own scripts) How to grab an HTTP page as a string (mostly for updates and grabbing configs from servers)  I have a similar questions about tools. Also I am looking for specific answers. I don't want answers that can be done in different ways (such as learn how to synchronize threads). I know how to do the above in 3+ languages. There always seems to be things programmers don't know how to do which can make their lives easier. For a long time I didn't know what regular expression was (although I did hear of it) and I was surprised how many people who tried to make a toolchain or complex app and did not know how to (or that you could) get the stdout from an exe they launched (they checked for errors in a very weird way or just didn't and hope it produce the expected results). What do you think is useful, not well known and should be something every senior (or starting out) programmer should know? ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "answers": 0.2169235932160232,
                    "app": 0.10015725375026262,
                    "assuming": 0.12872459228026678,
                    "complex": 0.11276504965045366,
                    "different": 0.08269944672319142,
                    "easier": 0.0994619623423903,
                    "error": 0.11396925007260553,
                    "errors": 0.11396925007260553,
                    "expected": 0.14368475900579822,
                    "expression": 0.1536921296032028,
                    "hear": 0.13988013328085988,
                    "hope": 0.12872459228026678,
                    "http": 0.11656967537539197,
                    "io": 0.1536921296032028,
                    "know": 0.402137577199557,
                    "known": 0.11798041434803767,
                    "language": 0.07234687871198409,
                    "languages": 0.08413064256626117,
                    "learn": 0.08340467220757282,
                    "libraries": 0.11276504965045366,
                    "like": 0.05478628668366619,
                    "list": 0.10315258688195182,
                    "long": 0.08526127747119613,
                    "looking": 0.09086533071763143,
                    "make": 0.13949290681839527,
                    "named": 0.13988013328085988,
                    "outside": 0.11798041434803767,
                    "page": 0.12106959250820262,
                    "people": 0.06873891707741435,
                    "produce": 0.11798041434803767,
                    "programmer": 0.15889444229516236,
                    "programmers": 0.08235424930938864,
                    "provides": 0.13367738840839363,
                    "questions": 0.09878572243122136,
                    "regular": 0.2492029897506535,
                    "results": 0.1227724202478582,
                    "scripts": 0.14818467613860886,
                    "senior": 0.12872459228026678,
                    "servers": 0.14818467613860886,
                    "similar": 0.10015725375026262,
                    "specific": 0.10015725375026262,
                    "standard": 0.100872701315036,
                    "starting": 0.11396925007260553,
                    "string": 0.13988013328085988,
                    "surprised": 0.14368475900579822,
                    "things": 0.14608434023971276,
                    "think": 0.06524653627638699,
                    "threads": 0.13658441657020112,
                    "time": 0.06057581422137986,
                    "tools": 0.10160950864986054,
                    "tried": 0.11523523078422095,
                    "updates": 0.1536921296032028,
                    "use": 0.05789042768924467,
                    "useful": 0.0994619623423903,
                    "want": 0.07257647304440076,
                    "way": 0.06758177331919019,
                    "ways": 0.10315258688195182,
                    "weird": 0.14368475900579822
                },
                "Max term": "know",
                "Max score": 0.402137577199557
            }
        ],
        "Best Answer": "how about basic graphics operations? DrawLine, DrawRectangle, DrawPixel?  ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "basic": 0.5103781540129878,
                "graphics": 0.6307442670994856,
                "operations": 0.5845304178803938
            },
            "Max term": "graphics",
            "Max score": 0.6307442670994856
        }
    },
    {
        "ID": "6476",
        "Question": "Lately I've been experimenting with using a collaborative text editor (or plugin such as NppNetNote for Notepad++) for two or more partners to edit source code. I've been met with unexpected success, and the workflow differs from anything I've ever experienced. My findings:  It's fun to fight over code, but also very satisfying to collaborate on it in real time. Two people can work collaboratively or separately, and be constantly aware of each other's changes. The comments end up becoming a free-form IM conversation about the code around them. The medium is enormously less restrictive than trying to work back and forth over IM proper. It's like pair programming, but with no overhead to switch roles between driver and navigator.  Has anyone tried this before? What were some of the advantages and problems that you encountered? For those that haven't tried it, I strongly encourage you to find a friend (or two, or more!) and make an attempt. Edit: See Wikipedia for something like more explanation, though in the context of pair programming specifically. ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "advantages": 0.12022274051184312,
                    "attempt": 0.13863537925243125,
                    "aware": 0.12647064738904903,
                    "changes": 0.09877153234926812,
                    "code": 0.15571853776999864,
                    "collaborate": 0.14829107013913712,
                    "comments": 0.10996413479242603,
                    "constantly": 0.1289796883657254,
                    "context": 0.12212886665580826,
                    "conversation": 0.13496445594824769,
                    "differs": 0.14829107013913712,
                    "driver": 0.14829107013913712,
                    "edit": 0.19754306469853625,
                    "editor": 0.12647064738904903,
                    "encountered": 0.1317845575425141,
                    "encourage": 0.1289796883657254,
                    "end": 0.08264004898159001,
                    "experienced": 0.12647064738904903,
                    "explanation": 0.13496445594824769,
                    "fight": 0.14829107013913712,
                    "form": 0.10663586292312348,
                    "free": 0.09467911372556218,
                    "fun": 0.11383433845505596,
                    "im": 0.285954319971344,
                    "lately": 0.14829107013913712,
                    "like": 0.10572196640446725,
                    "make": 0.0672954187124742,
                    "medium": 0.1289796883657254,
                    "met": 0.142977159985672,
                    "notepad": 0.142977159985672,
                    "overhead": 0.13496445594824769,
                    "pair": 0.22766867691011192,
                    "people": 0.06632328929224987,
                    "plugin": 0.142977159985672,
                    "problems": 0.08961720448310453,
                    "programming": 0.1259072759584669,
                    "proper": 0.12647064738904903,
                    "real": 0.08961720448310453,
                    "roles": 0.142977159985672,
                    "satisfying": 0.14829107013913712,
                    "separately": 0.13863537925243125,
                    "source": 0.08814371204233795,
                    "specifically": 0.11527804494589113,
                    "strongly": 0.1289796883657254,
                    "success": 0.13496445594824769,
                    "switch": 0.12647064738904903,
                    "text": 0.11681495650234316,
                    "time": 0.0584470547622029,
                    "tried": 0.22237125264437035,
                    "trying": 0.09173538780628156,
                    "unexpected": 0.1317845575425141,
                    "using": 0.06958497551918648,
                    "wikipedia": 0.12212886665580826,
                    "work": 0.12557767099088735,
                    "workflow": 0.14829107013913712
                },
                "Max term": "im",
                "Max score": 0.285954319971344
            }
        ],
        "Best Answer": "I often use GNU screen to share terminals (and terminal based editors) for pair programming and remote collaboration. I think one of the most important things that can make this go smoothly is a voice connection (phone, VoIP, etc.) with the other collaborators. Without a voice connection, you incur a lot of overhead and clunkiness as you have to IM (preferably in a separate window) at the same time. Short sharing the same terminal, each sharing a separate terminal (her read/my write, her write, my read). This allows for simultaneous use but also prevents you from working on exactly the same file. I've also been using tmux recently (a program similar to GNU screen) and while I find it better in some aspects I find other aspects less desirable. ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "allows": 0.11050754088213273,
                "aspects": 0.2526619424730664,
                "based": 0.090761046785818,
                "better": 0.07107787695896299,
                "collaboration": 0.1328982882008365,
                "connection": 0.24728434962147872,
                "exactly": 0.11355584685607228,
                "file": 0.09468411052773226,
                "gnu": 0.2843088031818673,
                "im": 0.13706039480235865,
                "important": 0.090761046785818,
                "lot": 0.0729262698512598,
                "make": 0.06451055999465967,
                "overhead": 0.12937927721047274,
                "pair": 0.10912357870501001,
                "phone": 0.14215440159093365,
                "preferably": 0.14215440159093365,
                "prevents": 0.13706039480235865,
                "program": 0.08690130731336346,
                "programming": 0.06034845339313753,
                "read": 0.17085599427527026,
                "recently": 0.11198085105786104,
                "remote": 0.12937927721047274,
                "screen": 0.23049522427814345,
                "separate": 0.23414971569287207,
                "share": 0.11050754088213273,
                "sharing": 0.2526619424730664,
                "short": 0.10222299473425092,
                "similar": 0.09263840971309682,
                "terminal": 0.4264632047728009,
                "things": 0.06755886596859922,
                "think": 0.06034845339313753,
                "time": 0.05602836426143434,
                "use": 0.10708914148374582,
                "using": 0.06670536901088198,
                "voice": 0.2843088031818673,
                "window": 0.12937927721047274,
                "working": 0.07585700448633907,
                "write": 0.14017036420696757
            },
            "Max term": "terminal",
            "Max score": 0.4264632047728009
        }
    },
    {
        "ID": "6526",
        "Question": "Prevalence is a simple technique to provide ACID properties to an in-memory object model based on binary serialization and write-ahead logging.  It works like this:  Start with a snapshot.  Serialize the object model and write it to a file. Create a journal file.  For every call into the object model, serialize the call and its arguments. When the journal gets too big, you're shutting down, or it's otherwise convenient, perform a checkpoint: write a new snapshot and truncate the journal. To roll back or recover from a crash or power hit, load the last snapshot and re-execute all the calls recorded in the journal.  The precautions needed to make this work are:  Don't let mutable object references escape or enter the prevalence layer.  You need some sort of proxy or OID scheme, as if you were doing RPC.  (This is such a common newbie mistake it's been nicknamed the 'baptism problem'.) All the logic reachable from a call must be completely deterministic, and must not perform business-logic-meaningful I/O or OS calls.  Writing to a diagnostic log is probably OK, but getting the system time or launching an asynchronous delegate is generally not.  This is so that the journal replays identically even if it's restored on a different machine or at a different time.  (Most prevalence code provides an alternate time call to get the transaction timestamp.) Writer concurrency introduces ambiguity in journal interpretation, so it is prohibited.  Is it because ...  people developed a bad taste for them after trying to use one on a project that wasn't well suited* to it?   Klaus Wuestefeld's strident advocacy turned people off? people who like the imperative programming model dislike separating I/O from calculation, preferring instead to interleave computation with I/O and threading calls? prevalence layers are so conceptually simple and so intimately bound to the characteristics of the framework they inhabit that they're usually custom-rolled for the project, which makes them too alien/nonstandard/risky? it's just too hard to keep straight what you have to be careful not to do? newbies' heads just seem to explode when faced with something that isn't the same kind of two-tier database-driven app they learned to write in school? ;)   *The entire data set fits in RAM, you don't need writer concurrency, and you don't need to do ad-hoc queries, reporting, or export to a data warehouse.  With apologies to SQLite, prevalence is an improvement on save-files, not a replacement for Oracle. ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "ad": 0.08902350700386197,
                    "ahead": 0.08462431123028873,
                    "alternate": 0.09181154386428779,
                    "app": 0.06205494613638372,
                    "arguments": 0.0797545593681872,
                    "asynchronous": 0.09181154386428779,
                    "bad": 0.0562979014720891,
                    "based": 0.06079737213774177,
                    "big": 0.059266909275957895,
                    "bound": 0.09181154386428779,
                    "business": 0.06205494613638372,
                    "calculation": 0.0952238252048504,
                    "calls": 0.22820022435452403,
                    "code": 0.03333110305260339,
                    "common": 0.05787578101139024,
                    "completely": 0.07061251591516444,
                    "concurrency": 0.1595091187363744,
                    "convenient": 0.08902350700386197,
                    "crash": 0.08902350700386197,
                    "create": 0.06120517940516237,
                    "data": 0.11642375902637515,
                    "database": 0.07061251591516444,
                    "developed": 0.0797545593681872,
                    "different": 0.10247704524152695,
                    "dislike": 0.08902350700386197,
                    "driven": 0.07309773364763922,
                    "enter": 0.0952238252048504,
                    "entire": 0.07719999064951417,
                    "execute": 0.09181154386428779,
                    "file": 0.12685056656233076,
                    "files": 0.06782447905473862,
                    "framework": 0.062498219673077546,
                    "generally": 0.06546722747694633,
                    "gets": 0.076066741451508,
                    "getting": 0.05787578101139024,
                    "hard": 0.06295472719263709,
                    "hit": 0.08282318880287352,
                    "hoc": 0.0952238252048504,
                    "imperative": 0.08462431123028873,
                    "improvement": 0.0952238252048504,
                    "instead": 0.06162416085375017,
                    "interpretation": 0.0952238252048504,
                    "kind": 0.06391078012930619,
                    "layer": 0.07842399302930028,
                    "layers": 0.0952238252048504,
                    "learned": 0.07061251591516444,
                    "let": 0.06205494613638372,
                    "like": 0.0678884442587558,
                    "load": 0.07719999064951417,
                    "log": 0.07842399302930028,
                    "logging": 0.08666625542606968,
                    "logic": 0.1427937722246069,
                    "machine": 0.07309773364763922,
                    "make": 0.04321316976505266,
                    "makes": 0.05355991986502125,
                    "meaningful": 0.0952238252048504,
                    "memory": 0.0797545593681872,
                    "mistake": 0.0797545593681872,
                    "model": 0.2855875444492138,
                    "mutable": 0.08902350700386197,
                    "need": 0.1344729860346002,
                    "needed": 0.06602335662732342,
                    "new": 0.045110166276091795,
                    "object": 0.27390117994380764,
                    "ok": 0.07309773364763922,
                    "oracle": 0.08666625542606968,
                    "os": 0.07719999064951417,
                    "people": 0.12776677585474758,
                    "perform": 0.17333251085213935,
                    "power": 0.07719999064951417,
                    "probably": 0.05406969594490482,
                    "problem": 0.04960584102109771,
                    "programming": 0.04042513290462684,
                    "project": 0.08993315924513726,
                    "properties": 0.08902350700386197,
                    "provide": 0.06915504539362553,
                    "provides": 0.08282318880287352,
                    "queries": 0.09181154386428779,
                    "ram": 0.09181154386428779,
                    "recover": 0.09181154386428779,
                    "references": 0.08666625542606968,
                    "risky": 0.0952238252048504,
                    "roll": 0.0952238252048504,
                    "save": 0.08282318880287352,
                    "scheme": 0.08902350700386197,
                    "school": 0.07402479725572705,
                    "separating": 0.0952238252048504,
                    "set": 0.060013001940602766,
                    "simple": 0.11781416811367479,
                    "sort": 0.06986642325051957,
                    "start": 0.05306659107496946,
                    "straight": 0.08462431123028873,
                    "suited": 0.08121202988972612,
                    "taste": 0.08902350700386197,
                    "technique": 0.09181154386428779,
                    "threading": 0.09181154386428779,
                    "time": 0.11259380867355673,
                    "transaction": 0.0952238252048504,
                    "trying": 0.058907084056837394,
                    "turned": 0.08121202988972612,
                    "use": 0.03586747077776057,
                    "usually": 0.06205494613638372,
                    "work": 0.04031930641827807,
                    "works": 0.06391078012930619,
                    "write": 0.18778958809244192,
                    "writer": 0.1904476504097008,
                    "writing": 0.05306659107496946
                },
                "Max term": "model",
                "Max score": 0.2855875444492138
            }
        ],
        "Best Answer": "I think you first need to demonstrate that so many developers absolutely hate them. I don't think that's the case. Consider that fowler, a while back, formalized a pattern of sorts for this here. ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "absolutely": 0.3077601146129355,
                "case": 0.24352288881921252,
                "consider": 0.24183235352719631,
                "demonstrate": 0.3736878756986747,
                "developers": 0.2132121236197676,
                "fowler": 0.3602970235385357,
                "hate": 0.3602970235385357,
                "need": 0.17590459244145717,
                "pattern": 0.29850952703469485,
                "sorts": 0.3493559006682788,
                "think": 0.31728156283301934
            },
            "Max term": "demonstrate",
            "Max score": 0.3736878756986747
        }
    },
    {
        "ID": "6543",
        "Question": "I'm starting to use the ORM recommended by the framework I choose, and though I like the idea of the added layer of abstraction the ORM provides, I'm starting to realize what this really means. It means I'm no longer working with my database (mysql) and any mysql-specific features are gone, out the window, like they don't exist. The idea the ORM has is that it's trying to help me by making everything database agnostic. This sounds great, but often there is a reason why I choose a specific database system. But by going the database agnostic route, the ORM takes the lowest common denominator, which means I end up with the smallest set of features (the ones supported by all databases).  What if I know that for the long term I won't be switching the underlying database? Why not access the database-specific features, too? ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "abstraction": 0.09343255790179049,
                    "access": 0.07799616272566187,
                    "added": 0.09197430936325245,
                    "agnostic": 0.21212115454644545,
                    "choose": 0.17209128022224454,
                    "common": 0.06895188642636131,
                    "database": 0.5047568526154834,
                    "databases": 0.10606057727322273,
                    "end": 0.06322232714432545,
                    "exist": 0.08708697386743668,
                    "features": 0.21449436819344497,
                    "framework": 0.07445895449600443,
                    "going": 0.05864378515835364,
                    "gone": 0.10938218084544504,
                    "great": 0.07018055736985732,
                    "help": 0.0615649686356931,
                    "idea": 0.13139282270229613,
                    "know": 0.049472822629386716,
                    "layer": 0.09343255790179049,
                    "like": 0.08088074521656718,
                    "long": 0.06293541757816198,
                    "longer": 0.08506062287854985,
                    "making": 0.07614184682931183,
                    "means": 0.22025286221907012,
                    "mysql": 0.21876436169089009,
                    "ones": 0.07865872232045408,
                    "orm": 0.43752872338178017,
                    "provides": 0.09867365948255452,
                    "realize": 0.09197430936325245,
                    "really": 0.05290351862891972,
                    "reason": 0.07060924493499367,
                    "recommended": 0.10938218084544504,
                    "set": 0.07149812273114833,
                    "sounds": 0.08708697386743668,
                    "specific": 0.22179254552164793,
                    "starting": 0.16825228420516114,
                    "supported": 0.11344749506389093,
                    "switching": 0.10606057727322273,
                    "takes": 0.07445895449600443,
                    "term": 0.0893672436833446,
                    "trying": 0.07018055736985732,
                    "underlying": 0.10606057727322273,
                    "use": 0.04273168721441972,
                    "window": 0.10325220146852634,
                    "working": 0.06053830937145154
                },
                "Max term": "database",
                "Max score": 0.5047568526154834
            }
        ],
        "Best Answer": "I see it the same way.  Any abstraction that doesn't allow you to get underneath it when necessary is evil, because it leads to all sorts of ugly abstraction inversions in your code. At work we've got a homegrown ORM that works fairly well, but for the times when we need something that its features don't explicitly provide for, there's a method that takes a string and drops it directly into the query it's generating, allowing for the use of raw SQL when it's necessary. IMO any ORM that doesn't have this feature isn't worth the bits it's compiled from. ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "abstraction": 0.3206603601855945,
                "allow": 0.14944116395249923,
                "allowing": 0.18769971782563227,
                "bits": 0.18769971782563227,
                "code": 0.06814217879876253,
                "compiled": 0.18199984926920182,
                "directly": 0.17718067907150142,
                "evil": 0.16932390539797204,
                "explicitly": 0.18769971782563227,
                "fairly": 0.15335410477799796,
                "feature": 0.12191875195778377,
                "features": 0.1226907102964186,
                "generating": 0.18199984926920182,
                "got": 0.1251280004701541,
                "imo": 0.1946757931404316,
                "leads": 0.18199984926920182,
                "method": 0.136158157817491,
                "necessary": 0.2699565847006755,
                "need": 0.09163895399752862,
                "orm": 0.37539943565126455,
                "provide": 0.1413807236025722,
                "query": 0.1660300486492277,
                "sorts": 0.18199984926920182,
                "sql": 0.14436037947282315,
                "string": 0.17718067907150142,
                "takes": 0.12777149477609467,
                "times": 0.12870477973134242,
                "ugly": 0.1946757931404316,
                "use": 0.07332753443353716,
                "way": 0.0856031818722098,
                "work": 0.0824288767959572,
                "works": 0.13065933641219307,
                "worth": 0.13065933641219307
            },
            "Max term": "orm",
            "Max score": 0.37539943565126455
        }
    },
    {
        "ID": "6587",
        "Question": "Recently reading the question What languages do you use without an IDE? One question asked in a few answers was \"is Notepad++ and IDE?\" One answers to the original question said \"None, I use vim...\", implying that vim is an IDE. But then another answer suggested vim isn't an IDE. So where is the line? What about notepad, ed, or nano? Is the only non-IDE coding technique the butterfly technique? ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "answer": 0.09365596554666497,
                    "answers": 0.22358569998091143,
                    "asked": 0.1047301161638578,
                    "coding": 0.08994917125010812,
                    "ed": 0.15273568932587742,
                    "ide": 0.5811413176797904,
                    "languages": 0.0867144432246659,
                    "line": 0.10801716136228769,
                    "non": 0.09365596554666497,
                    "notepad": 0.30547137865175483,
                    "original": 0.12314604417037374,
                    "question": 0.24380005861851137,
                    "reading": 0.10632058505445863,
                    "recently": 0.1247878535756741,
                    "said": 0.1004803911537481,
                    "suggested": 0.15273568932587742,
                    "technique": 0.30547137865175483,
                    "use": 0.1193366899856242,
                    "vim": 0.44429271536509335
                },
                "Max term": "ide",
                "Max score": 0.5811413176797904
            }
        ],
        "Best Answer": "Taken literally, IDE = Integrated Development Environment. This is the way i look at it:  Integrated: Means you can code / launch / compile / debug your app from the tool. Development: Means it can group files into projects, and does syntax highlighting for your language, maybe has refactoring tools, ability to generate files from templates (like unit test files, class files etc.), auto complete / intellisense Environment: Means both of the above are available from the same tool  Notepad++ allows for development (eg. you can write code), but the other areas of development are not covered. I've never used notepad++ for development, only for occasionally editing files.   ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "ability": 0.10102183527034156,
                "allows": 0.10590361747303953,
                "app": 0.08877894329429199,
                "areas": 0.11410090483437099,
                "auto": 0.13623201862986323,
                "available": 0.09445635197609639,
                "class": 0.09073941689462768,
                "code": 0.09537032233787776,
                "compile": 0.11849104124629323,
                "complete": 0.09445635197609639,
                "covered": 0.12106781805145138,
                "debug": 0.10731554715696841,
                "development": 0.3442916615013139,
                "editing": 0.12736152993807823,
                "environment": 0.17882622565349948,
                "files": 0.48516564390627276,
                "generate": 0.11849104124629323,
                "group": 0.1104462096724736,
                "ide": 0.09995443738361683,
                "integrated": 0.2627004728543305,
                "intellisense": 0.13623201862986323,
                "language": 0.06412795081927268,
                "launch": 0.13135023642716526,
                "like": 0.04856232031802561,
                "literally": 0.12736152993807823,
                "look": 0.07849652491857811,
                "maybe": 0.09143399323115242,
                "means": 0.26448792026840856,
                "notepad": 0.2627004728543305,
                "occasionally": 0.11618603584875342,
                "projects": 0.07929215139768453,
                "refactoring": 0.11219732935966638,
                "syntax": 0.10731554715696841,
                "taken": 0.11219732935966638,
                "templates": 0.13135023642716526,
                "test": 0.07698714600014471,
                "tool": 0.19056401818812352,
                "tools": 0.09006621556417413,
                "unit": 0.08816264008946952,
                "used": 0.0664780176477251,
                "way": 0.05990418263855751,
                "write": 0.06716531973082503
            },
            "Max term": "files",
            "Max score": 0.48516564390627276
        }
    },
    {
        "ID": "6591",
        "Question": "I'm trying to understand how I should evaluate writing a book, article, or conference presentation. Writing a book is a lot of work. Same for writing an article in a magazine or presenting in a conference. They need time and you may even make a mistake here and there that back fires (bad reviews, people calling you an idiot..) Also you do it for free (at least for magazine articles and conference presentations. For books you get something like a $5K deposit and you rarely get any additional sales royalties after that). So how should I evaluate the benefits? I would appreciate answers that call out if you have done this before. I may not write a book because it's way beyond what I'd like to commit time-wise, but should I bother giving conference presentations or writing shorter articles in magazines? ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "additional": 0.11643653790305974,
                    "answers": 0.09810802946096173,
                    "appreciate": 0.13403896143092142,
                    "article": 0.2190245693891448,
                    "articles": 0.2371287026434599,
                    "bad": 0.08219132286037507,
                    "benefits": 0.11449399644614913,
                    "book": 0.26806690105727343,
                    "books": 0.10200049380757106,
                    "bother": 0.12091653992818308,
                    "commit": 0.11643653790305974,
                    "conference": 0.5560826927299926,
                    "evaluate": 0.25993721311068124,
                    "free": 0.0887602612490429,
                    "giving": 0.11449399644614913,
                    "like": 0.0991127714294342,
                    "lot": 0.07131864377006569,
                    "magazine": 0.2780413463649963,
                    "make": 0.06308845436699798,
                    "mistake": 0.11643653790305974,
                    "need": 0.06544064297345112,
                    "people": 0.06217709749100204,
                    "presentation": 0.13403896143092142,
                    "rarely": 0.1054419298189916,
                    "reviews": 0.11643653790305974,
                    "sales": 0.11643653790305974,
                    "shorter": 0.13902067318249814,
                    "time": 0.10958648947575883,
                    "trying": 0.08600056197261861,
                    "understand": 0.07609952829096611,
                    "way": 0.06113041471906981,
                    "work": 0.05886359961346022,
                    "write": 0.06854018649511658,
                    "writing": 0.3098952682848881
                },
                "Max term": "conference",
                "Max score": 0.5560826927299926
            }
        ],
        "Best Answer": "It all depends: what are your goals? ** [Note: my background is as a programmer, but I've been making a living as a tech writer/speaker for the last 12 years. After 15 titles, dozens of magazine articles, and speaking internationally, I think I'm at least as qualified as anyone else here.] ** If your goal is to make money, don't bother. Really. I know a lot of people in this business, and very few make a decent hourly wage from writing. Of the ones who do make a living at it, all of them write for beginners (tip: there are always more beginners than  intermediate or advanced users). Howeverâ€¦ IF you're currently working as a consultant and if you want more consulting gigs with bigger companies at a higher price and if you've been offered a book contract and/or speaking gigs â€¦ then go for it. Don't think of it in terms of work with low compensation; instead, think of it as just part of the training and prep you already do in order to get those consulting jobs. Screw writing articles for magazines/sites that don't pay â€” or say you'll write for them, on the condition that they run your article without ads. If they're making money, you should be too. However, if the magazine helps you get those high-profile consulting gigs, see the advice in the previous paragraph. ** Speaking gigs, though, are almost always worth it. At a minimum, you'll meet other presenters, which is how I've met some truly amazing people. Networking opportunities abound. ** On the other handâ€¦ IF you have an amazing idea for a great book that no one else has written and if you can't rest until you see that book in print â€¦ then go for it. In this case, it's about love, not money. If you can handle a life where this book doesn't exist, then don't write it. ** But it's really all about where you want your career to go. If a book helps you get to that place, then see if works for you. ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "12": 0.09936816921236673,
                "15": 0.08631882459650492,
                "advanced": 0.09158938542892944,
                "advice": 0.08631882459650492,
                "amazing": 0.19873633842473346,
                "article": 0.081185612900853,
                "articles": 0.17579250687888845,
                "background": 0.08232747776423019,
                "bigger": 0.0896400201246695,
                "book": 0.33121361257116994,
                "bother": 0.0896400201246695,
                "business": 0.06716243000182245,
                "career": 0.07273120567703648,
                "case": 0.06716243000182245,
                "companies": 0.07411121099421433,
                "condition": 0.10306130120185196,
                "contract": 0.08011746965600694,
                "currently": 0.07642433766652171,
                "decent": 0.0937993935371527,
                "depends": 0.07911410330792255,
                "dozens": 0.09936816921236673,
                "exist": 0.07911410330792255,
                "goal": 0.08232747776423019,
                "goals": 0.09936816921236673,
                "great": 0.06375548052017649,
                "hand": 0.07340682911741572,
                "handle": 0.08011746965600694,
                "helps": 0.16023493931201388,
                "high": 0.06917100995241528,
                "higher": 0.08355399997840525,
                "hourly": 0.0896400201246695,
                "idea": 0.059681861061174665,
                "instead": 0.06669618857882446,
                "intermediate": 0.10306130120185196,
                "jobs": 0.081185612900853,
                "know": 0.0449435527108072,
                "life": 0.08011746965600694,
                "living": 0.19270132132652146,
                "lot": 0.05287121734222523,
                "love": 0.08789625343944422,
                "low": 0.081185612900853,
                "magazine": 0.20612260240370392,
                "make": 0.14030959674625637,
                "making": 0.13834201990483055,
                "meet": 0.08789625343944422,
                "met": 0.09936816921236673,
                "minimum": 0.10306130120185196,
                "money": 0.21819361703110945,
                "networking": 0.10306130120185196,
                "note": 0.07727326610399202,
                "offered": 0.0937993935371527,
                "ones": 0.07145746381315576,
                "opportunities": 0.09635066066326073,
                "order": 0.08011746965600694,
                "pay": 0.08631882459650492,
                "people": 0.09218848428341246,
                "place": 0.07145746381315576,
                "previous": 0.0748469088235824,
                "price": 0.0896400201246695,
                "print": 0.09635066066326073,
                "profile": 0.10306130120185196,
                "programmer": 0.05327490750164203,
                "really": 0.09612033240544046,
                "rest": 0.08789625343944422,
                "run": 0.06375548052017649,
                "say": 0.053688690953638804,
                "sites": 0.07816810435174698,
                "speaker": 0.09936816921236673,
                "speaking": 0.2890519819897822,
                "tech": 0.08487874489033821,
                "terms": 0.07816810435174698,
                "think": 0.1312570710989384,
                "training": 0.0896400201246695,
                "truly": 0.10306130120185196,
                "users": 0.06669618857882446,
                "want": 0.09733518258753054,
                "work": 0.04363782040980494,
                "working": 0.05499598675905818,
                "works": 0.06917100995241528,
                "worth": 0.06917100995241528,
                "write": 0.15243432454534273,
                "writer": 0.10306130120185196,
                "writing": 0.11486856182825045,
                "written": 0.07027478394513519,
                "years": 0.06061016843256023
            },
            "Max term": "book",
            "Max score": 0.33121361257116994
        }
    },
    {
        "ID": "6595",
        "Question": "As part of being a programmer, you often are asked to provide estimates/ make slideware / do technical demos for Sales teams to present to end-clients. Sometimes we go along for the 'technical' discussions or 'strategic capability planning' or some similar mumbo-jumbo. Sometimes, you kind of know which ones are totally going to fail and are not worth pursuing but the Sales guys present fake optimism and extract 'few more slides' out of you or the 'last conference call'. These don't lead to anywhere and are just a waste of time from other tasks for the week. My question is how do you get out of these situations without coming across as non-cooperative. Updated after Kate Gregory's answer: The problem is related to projects we know are doomed (from the technical feedback we've received)  But Sales ain't convinced since they've just had a call higher up the management chain - so it's definitely going ahead ! ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "ahead": 0.1363063395068494,
                    "answer": 0.090680334764499,
                    "asked": 0.10140263824338601,
                    "clients": 0.1208231026260383,
                    "coming": 0.12846251731226305,
                    "conference": 0.15337922233944942,
                    "convinced": 0.14788298169491534,
                    "definitely": 0.11253546728196001,
                    "demos": 0.14788298169491534,
                    "discussions": 0.14788298169491534,
                    "doomed": 0.15337922233944942,
                    "end": 0.08547558821308296,
                    "estimates": 0.12434781426772715,
                    "extract": 0.15337922233944942,
                    "fail": 0.11633234703429537,
                    "fake": 0.15337922233944942,
                    "feedback": 0.1363063395068494,
                    "going": 0.1585709434582827,
                    "guys": 0.14339222610317243,
                    "higher": 0.12434781426772715,
                    "kind": 0.102942574867715,
                    "know": 0.13377295034252473,
                    "lead": 0.11923345667424937,
                    "make": 0.06960445412823824,
                    "management": 0.100667331000776,
                    "non": 0.090680334764499,
                    "ones": 0.10634535079801838,
                    "planning": 0.11500061928624919,
                    "present": 0.28678445220634485,
                    "problem": 0.07990127788862207,
                    "programmer": 0.07928547172914135,
                    "projects": 0.08927246796541835,
                    "provide": 0.11138963447966302,
                    "pursuing": 0.15337922233944942,
                    "question": 0.07868468674005834,
                    "received": 0.14788298169491534,
                    "related": 0.11500061928624919,
                    "sales": 0.38538755193678914,
                    "similar": 0.09995334004110289,
                    "situations": 0.1263193432705724,
                    "tasks": 0.11253546728196001,
                    "teams": 0.13081009886231532,
                    "technical": 0.29378320936094743,
                    "time": 0.060452485770361705,
                    "totally": 0.1334052298668954,
                    "updated": 0.1334052298668954,
                    "waste": 0.1363063395068494,
                    "week": 0.11774021383337605,
                    "worth": 0.102942574867715
                },
                "Max term": "sales",
                "Max score": 0.38538755193678914
            }
        ],
        "Best Answer": "One-by-one, you can't. You're at your desk, sales calls and says excitedly that they've set up another meeting with Mr Big, and are you free at 2? And can you make another demo by then? It's just never going to be an appropriate response for you to say \"dude, Mr Big is totally not buying this software, that meeting would waste my time, no, I'm not going.\" Whether Mr Big is buying or not is something the sales guy is supposed to know more about than you. (In fact, he might even be right.) So for that call, you have to suck it up and say sure. And do a good job on the slides! Longer term, a chat with your boss about this \"supporting the sales team\" role would probably be helpful. Is your issue the time spent? Or that you object to investing time in something that is doomed? In my experience, it is highly unusual for the number of technical people in the room to shrink as the sales process goes on - normally the tech people only show up once things are getting warm, and more of them come to each meeting until the client is landed. So you wanting to bail from the process before the sale is closed will appear strange to management and sales. Discussing this with management may help you to understand how your presence increases the chance of a sale. I think it's unlikely management will grant you a pass to bail on selected client pitches based on your opinion of whether they are going to buy or not, but you could talk about it. Finally, you clearly are expected to produce slides and demos as part of your job, so approach them with the same dignity as \"real code\". Reuse, have a repository, be modular, don't repeat yourself, figure out how to waste as little time as possible giving sales what they need. Remember, when Mr Big does write that cheque, he's funding your salary. You want him to buy. You want to help sales. You just want to do so as quickly and efficiently as possible. ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "appear": 0.08477241897255237,
                "approach": 0.06342014263958227,
                "appropriate": 0.08058329544989164,
                "based": 0.057894150396335685,
                "big": 0.22574708336897117,
                "boss": 0.06724059729085557,
                "buy": 0.14486874070068514,
                "buying": 0.17485464064323222,
                "calls": 0.07243437035034257,
                "chance": 0.07048993393451136,
                "clearly": 0.07142972081351633,
                "client": 0.12574116294346616,
                "closed": 0.08252773186572285,
                "code": 0.031739462170031534,
                "come": 0.060396572419131093,
                "demo": 0.0906766569652719,
                "demos": 0.08742732032161611,
                "desk": 0.08477241897255237,
                "discussing": 0.08742732032161611,
                "doomed": 0.0906766569652719,
                "expected": 0.08477241897255237,
                "experience": 0.051989912403616174,
                "fact": 0.06133635929813605,
                "figure": 0.06877481946445259,
                "finally": 0.07733395880623585,
                "free": 0.057894150396335685,
                "getting": 0.05511207232094803,
                "giving": 0.07467905745717211,
                "goes": 0.0652054338363283,
                "going": 0.14061894589089988,
                "good": 0.03965186378140637,
                "guy": 0.07467905745717211,
                "help": 0.09841566865645703,
                "helpful": 0.06653013235762306,
                "highly": 0.07467905745717211,
                "increases": 0.08742732032161611,
                "issue": 0.06183002157736306,
                "job": 0.10060642180750166,
                "know": 0.039542787296821445,
                "little": 0.057515904646862744,
                "longer": 0.06798751191171597,
                "make": 0.04114963626737552,
                "management": 0.17854133502968733,
                "meeting": 0.22783825809416722,
                "modular": 0.0906766569652719,
                "need": 0.04268385844097254,
                "normally": 0.08058329544989164,
                "number": 0.05678767077597187,
                "object": 0.0652054338363283,
                "opinion": 0.0652054338363283,
                "pass": 0.07467905745717211,
                "people": 0.08111040194556692,
                "possible": 0.106653562248404,
                "presence": 0.08742732032161611,
                "probably": 0.0514877370328844,
                "process": 0.11086424261083308,
                "produce": 0.06960713985860938,
                "quickly": 0.0652054338363283,
                "real": 0.0547989066467491,
                "remember": 0.06342014263958227,
                "repeat": 0.08058329544989164,
                "repository": 0.08477241897255237,
                "response": 0.08058329544989164,
                "reuse": 0.08252773186572285,
                "right": 0.051989912403616174,
                "role": 0.07886818097983286,
                "room": 0.08252773186572285,
                "salary": 0.08477241897255237,
                "sales": 0.5316226022197236,
                "say": 0.09447408398197328,
                "says": 0.06960713985860938,
                "set": 0.05714723577547531,
                "software": 0.04281931655828451,
                "spent": 0.07886818097983286,
                "suck": 0.0906766569652719,
                "supporting": 0.0906766569652719,
                "supposed": 0.07243437035034257,
                "sure": 0.053326781124202,
                "talk": 0.07243437035034257,
                "team": 0.05419208373541325,
                "tech": 0.07467905745717211,
                "technical": 0.057894150396335685,
                "term": 0.07142972081351633,
                "things": 0.04309407268320673,
                "think": 0.0384947349183118,
                "time": 0.14295624221553205,
                "totally": 0.07886818097983286,
                "understand": 0.049636148812201714,
                "unlikely": 0.08742732032161611,
                "want": 0.12845794967485355,
                "wanting": 0.08477241897255237,
                "waste": 0.16116659089978327,
                "write": 0.04470554513136883
            },
            "Max term": "sales",
            "Max score": 0.5316226022197236
        }
    },
    {
        "ID": "6633",
        "Question": "I always had this question in mind but couldn't find a proper place to ask. There are some really nice and great open source free software available on the net. How do these products sustain themselves financially? It is one thing writing a small utility which does something nice but writing a complicated product with whole lot of features is a totally different ball game. So to repeat myself again, how do they work financially? ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "ask": 0.15497010913946613,
                    "available": 0.17369127917481103,
                    "ball": 0.24153368309970008,
                    "complicated": 0.1973374396859586,
                    "different": 0.13479600237932785,
                    "features": 0.1578795082022519,
                    "free": 0.1599429940631221,
                    "game": 0.19230223227977666,
                    "great": 0.15497010913946613,
                    "lot": 0.12851378822669404,
                    "mind": 0.16945271472014256,
                    "net": 0.15314119627221717,
                    "nice": 0.363859970452941,
                    "open": 0.15591672115347166,
                    "place": 0.17369127917481103,
                    "product": 0.1644175073139606,
                    "products": 0.21364895813388404,
                    "proper": 0.21364895813388404,
                    "question": 0.12851378822669404,
                    "really": 0.11681959167948591,
                    "repeat": 0.22262583451858728,
                    "small": 0.1497153696500229,
                    "software": 0.11829605663411065,
                    "source": 0.14890263181754868,
                    "thing": 0.14293182051192563,
                    "totally": 0.21788752258855248,
                    "utility": 0.22262583451858728,
                    "work": 0.10607021916140637,
                    "writing": 0.27921040541109243
                },
                "Max term": "nice",
                "Max score": 0.363859970452941
            }
        ],
        "Best Answer": "There's lots of different answers. Some projects are maintained by people who just want to do it for assorted reasons, including prestige or the knowledge that they're doing something good or because they thought somebody had to do it and nobody else was.  This section is almost certainly not as large as it was. Some projects are maintained by people who want to be paid for support and the like.  Most Open Source companies are like that:  they want to create a popular product for free so that they can charge for related things.  It's a form of advertising. Some projects are maintained by companies who aren't in that exact business.  Quite a few companies benefit from being able to use Linux, for example, or Apache, because they then have access to high-quality software that they don't have to write all themselves.   Suppose your company wants to sell web servers.  You want to have as much of the customers' money going to you as possible.  If you sell them Windows-based servers with IIS, a chunk of that money is going to Microsoft.  If you sell them Linux-based servers with Apache, you get to keep that money, and you have a lot more control over what you sell.  That may well be worth donating resources to assorted projects.  (Obviously, Microsoft has the opposite opinion.  They'd like the server people to produce cheap hardware that runs Windows and IIS.  Microsoft is likely the company most inherently opposed to Open Source, but even they take advantage of it in some ways.) Let's look at Apple's use.  Apple makes their money selling hardware, but the main distinguishing feature is their ability to make user interfaces.  The iPhone does nothing previous smart phones didn't do, it's just a lot easier to use, and so it sold millions really fast and redefined the market.  They have a good idea as to what they're selling.  Nobody's going to buy Apple for operating internals, so by having the Darwin part of the OS as Open Source they can get some outside help on it.  They also started with Open Source after failing to produce a top-quality operating system themselves.  Nobody's going to buy Apple for the printer software, so it was easier and faster to use CUPS.  They will for the interface, so that's closed down tight. ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "ability": 0.05799181813924693,
                "able": 0.049286773731599925,
                "access": 0.053766156052066784,
                "advantage": 0.0654998882664428,
                "advertising": 0.0782043053166046,
                "answers": 0.05518941977718324,
                "apache": 0.15080381390908185,
                "apple": 0.2924487230840748,
                "based": 0.09986190415851941,
                "benefit": 0.0644071363633717,
                "business": 0.0509637576900031,
                "buy": 0.12494240091942757,
                "certainly": 0.06079421650131061,
                "charge": 0.06802005622543279,
                "cheap": 0.0731121807710187,
                "closed": 0.07117624486736078,
                "companies": 0.16870975927103937,
                "company": 0.09247135926194905,
                "control": 0.052487895245779945,
                "create": 0.050265871244532495,
                "customers": 0.06160473800130802,
                "different": 0.04208057236081114,
                "easier": 0.1012199348202776,
                "exact": 0.06802005622543279,
                "example": 0.041731696471304064,
                "failing": 0.0731121807710187,
                "fast": 0.06003284858420743,
                "faster": 0.058635996486906705,
                "feature": 0.048976666015419994,
                "form": 0.05623658642367979,
                "free": 0.049930952079259704,
                "going": 0.161702873275868,
                "good": 0.06839569444473777,
                "hardware": 0.12006569716841486,
                "help": 0.04243941747044688,
                "high": 0.052487895245779945,
                "idea": 0.04528740108908511,
                "including": 0.06003284858420743,
                "interface": 0.06003284858420743,
                "internals": 0.0782043053166046,
                "iphone": 0.07117624486736078,
                "knowledge": 0.048976666015419994,
                "large": 0.05289969359366102,
                "let": 0.0509637576900031,
                "like": 0.08363193682137335,
                "likely": 0.05289969359366102,
                "linux": 0.13339372509378786,
                "look": 0.045061111644419796,
                "lot": 0.08023878556304591,
                "lots": 0.058635996486906705,
                "main": 0.0593150118177858,
                "maintained": 0.22620572086362278,
                "make": 0.035489604778367025,
                "makes": 0.043987062238323556,
                "market": 0.0731121807710187,
                "microsoft": 0.1739754544177408,
                "money": 0.22075767910873295,
                "obviously": 0.06160473800130802,
                "open": 0.19469612602592354,
                "operating": 0.15080381390908185,
                "opinion": 0.05623658642367979,
                "opposed": 0.0782043053166046,
                "opposite": 0.0782043053166046,
                "os": 0.06340190205765965,
                "outside": 0.06003284858420743,
                "paid": 0.0644071363633717,
                "people": 0.10493079779947666,
                "popular": 0.062471200459713785,
                "possible": 0.04599181324236566,
                "previous": 0.0567948438587958,
                "produce": 0.12006569716841486,
                "product": 0.05132780417656043,
                "projects": 0.18207137145821162,
                "quality": 0.11140418391144943,
                "quite": 0.049930952079259704,
                "really": 0.03646870229129958,
                "reasons": 0.05518941977718324,
                "related": 0.058635996486906705,
                "resources": 0.06340190205765965,
                "runs": 0.06802005622543279,
                "section": 0.06949926090895761,
                "sell": 0.2619995530657712,
                "selling": 0.14235248973472156,
                "server": 0.05570209195572472,
                "servers": 0.22620572086362278,
                "smart": 0.06802005622543279,
                "software": 0.07385924928518088,
                "sold": 0.07117624486736078,
                "somebody": 0.06802005622543279,
                "source": 0.18593750147814497,
                "started": 0.0509637576900031,
                "support": 0.0517027193132099,
                "suppose": 0.07117624486736078,
                "things": 0.0371665887367702,
                "thought": 0.0542228872721999,
                "use": 0.11782726138565179,
                "user": 0.04726145151182383,
                "want": 0.14771849857036176,
                "wants": 0.06079421650131061,
                "ways": 0.052487895245779945,
                "web": 0.046235679630974524,
                "windows": 0.11247317284735958,
                "worth": 0.052487895245779945,
                "write": 0.03855640710417683
            },
            "Max term": "apple",
            "Max score": 0.2924487230840748
        }
    },
    {
        "ID": "6662",
        "Question": "I've been on the constant road of learning new concepts in OOP, Software Design, Architecture, etc. But there are times when you are in a team where those concepts are foreign to them and they don't have the time or the same eagerness to learn as you. The problem is if you design your code the \"right\" way, the people who code with 2kLOC classes won't understand it. Would you sacrifice good coding principles to support your team? What about a scenario where this will be a long term arrangement? ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "architecture": 0.19879417907163968,
                    "classes": 0.19879417907163968,
                    "code": 0.16897964546178967,
                    "coding": 0.13705934118917715,
                    "concepts": 0.40433396832766666,
                    "constant": 0.2145111442392757,
                    "design": 0.27679224425698057,
                    "foreign": 0.22566250849149097,
                    "good": 0.10555247987169296,
                    "learn": 0.1309902851248956,
                    "learning": 0.14843032532413075,
                    "long": 0.13390615597972189,
                    "new": 0.11434814941506996,
                    "oop": 0.20216698416383333,
                    "people": 0.10795714567090549,
                    "principles": 0.2058614741363369,
                    "problem": 0.1257440747662906,
                    "right": 0.13839612212849028,
                    "road": 0.241379473659127,
                    "scenario": 0.2145111442392757,
                    "software": 0.11398417673515147,
                    "support": 0.15958168957634603,
                    "team": 0.2885165176205206,
                    "term": 0.1901445089687009,
                    "time": 0.09513667479902645,
                    "times": 0.15958168957634603,
                    "understand": 0.13213044983941116,
                    "way": 0.1061398063443622
                },
                "Max term": "concepts",
                "Max score": 0.40433396832766666
            }
        ],
        "Best Answer": "Welcome in the real world. I worked with hundred of different developers around the world, in startups and large enterprises. The vast majority of them doen't understand advanced concepts, and won't in the future. It's just too complicated to master something unless you spend over a decade in that particular field. Very few are able to do that. That's why I'm really upset when one of my developers is too \"CV driven\" and try to implement design patterns that do nothing better but allow him to put something new in his resume (or the title \"Architect\"), while the rest of the team is strugling to understand and maintain HIS code. That's why I think that a good developer is not the technically supperior, but the most pragmatic of the pack:  An excellent developer try to convert   a functionnality the business ask by   maximizing the ROI.  IMHO, keeping things simple, is the way to go. If you want to do the \"right\" stuff, do it at home. Your boss is especting something else from you. ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "able": 0.10368529731909773,
                "advanced": 0.14620659834714844,
                "allow": 0.12629197009856433,
                "architect": 0.15862408003378825,
                "ask": 0.10177458762485163,
                "better": 0.08226054550352335,
                "boss": 0.12199822489066124,
                "business": 0.10721319267847504,
                "code": 0.05758660987169336,
                "complicated": 0.12959877655443755,
                "concepts": 0.13779306039095743,
                "convert": 0.15380715001092474,
                "design": 0.09432808869954402,
                "developer": 0.18171639098506714,
                "developers": 0.18773719876494444,
                "different": 0.08852550747891842,
                "driven": 0.12629197009856433,
                "enterprises": 0.16451952591871194,
                "excellent": 0.14973449370652575,
                "field": 0.13779306039095743,
                "future": 0.13337949652058426,
                "good": 0.07194250482358151,
                "home": 0.13337949652058426,
                "imho": 0.15380715001092474,
                "implement": 0.11948013281939393,
                "keeping": 0.13549422243936124,
                "large": 0.11128584898287404,
                "maintain": 0.13549422243936124,
                "majority": 0.15862408003378825,
                "master": 0.13549422243936124,
                "new": 0.07793746107018248,
                "particular": 0.10721319267847504,
                "patterns": 0.14309477410313753,
                "pragmatic": 0.13779306039095743,
                "real": 0.09942459773125228,
                "really": 0.07671973541028757,
                "rest": 0.14031115246222475,
                "resume": 0.14973449370652575,
                "right": 0.09432808869954402,
                "roi": 0.15862408003378825,
                "simple": 0.10177458762485163,
                "spend": 0.11506656894902077,
                "startups": 0.16451952591871194,
                "stuff": 0.10368529731909773,
                "team": 0.09832360635121253,
                "technically": 0.15380715001092474,
                "things": 0.07818788919912435,
                "think": 0.06984306381688354,
                "title": 0.16451952591871194,
                "try": 0.18865617739908805,
                "understand": 0.18011505814868295,
                "unless": 0.12199822489066124,
                "vast": 0.15380715001092474,
                "want": 0.07768938441378827,
                "way": 0.07234281505451484,
                "welcome": 0.16451952591871194,
                "worked": 0.10797904252700082,
                "world": 0.20354917524970326
            },
            "Max term": "world",
            "Max score": 0.20354917524970326
        }
    },
    {
        "ID": "6665",
        "Question": "The class diagram is modeled on the system requirements, and it is important to create solutions based on those requirements. If I have said class diagram should I strictly adhere to it? What about refactoring? What if the diagram did not provide some design principle that I feel were left out? ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "based": 0.15171035412343511,
                    "class": 0.31653579253934494,
                    "create": 0.1527279735168247,
                    "design": 0.13623842767538397,
                    "diagram": 0.6487863458038672,
                    "feel": 0.1427959698216213,
                    "important": 0.15171035412343511,
                    "left": 0.20667234225927816,
                    "principle": 0.22214426870732934,
                    "provide": 0.1725656234338495,
                    "refactoring": 0.19569483574542665,
                    "requirements": 0.31653579253934494,
                    "said": 0.15071916941469715,
                    "solutions": 0.18718002018115032,
                    "strictly": 0.22910137959110416
                },
                "Max term": "diagram",
                "Max score": 0.6487863458038672
            }
        ],
        "Best Answer": "Short Answer: No.  Your output should be working (hopefully tested) code that performs the business function it's supposed to do. How you accomplish that task shouldn't be mandated (again, unless you work for NASA).  A lame analogy: I get into a taxi and tell them where to go. I leave it up to them to drive me there. I trust them to get me there safely and in a timely manner. I am not going to sit there and micromanage the taxi driver and tell him when to turn on his turn signal, how much to press the accelerator, or when to get gas. That's his job.  ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "accomplish": 0.21560361001353026,
                "answer": 0.14343432303439543,
                "business": 0.15810197107295088,
                "code": 0.08492011384669523,
                "drive": 0.206909888732833,
                "driver": 0.24260877488967766,
                "function": 0.16821258367851533,
                "going": 0.1254104100240296,
                "hopefully": 0.21560361001353026,
                "job": 0.13458811538508808,
                "leave": 0.1911128799544947,
                "manner": 0.21560361001353026,
                "output": 0.19668811993932783,
                "short": 0.174459568191185,
                "sit": 0.2339150536089804,
                "supposed": 0.19380085722979554,
                "task": 0.16039440974842906,
                "tell": 0.34560287271808915,
                "tested": 0.19668811993932783,
                "trust": 0.206909888732833,
                "turn": 0.39961320247038384,
                "unless": 0.1799047238566856,
                "work": 0.10272447587036973,
                "working": 0.12946187187499125
            },
            "Max term": "turn",
            "Max score": 0.39961320247038384
        }
    },
    {
        "ID": "6677",
        "Question": "The way I see it if you create one before you get the advantage of:  Planning ahead Overview of the project  but you lose:  Time (doing work you'll probably end up repeating when writing code)  On the other hand, I could just create them all after writing my code just to keep it as a reference for future developers. Which one serves the purpose of class diagrams and which is more advantageous? ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "advantage": 0.2376189332246308,
                    "ahead": 0.2521277619575344,
                    "class": 0.18896785678628078,
                    "code": 0.19861187155449447,
                    "create": 0.3647066588616372,
                    "developers": 0.16187285764078313,
                    "diagrams": 0.2521277619575344,
                    "end": 0.1581054031392684,
                    "future": 0.2300079088695489,
                    "hand": 0.2020747213347638,
                    "lose": 0.24196128798501035,
                    "planning": 0.21271827025268683,
                    "probably": 0.16109403113740076,
                    "project": 0.13397241192629816,
                    "purpose": 0.2151815858832468,
                    "reference": 0.2376189332246308,
                    "repeating": 0.2652346265060174,
                    "time": 0.11181981701801252,
                    "way": 0.12475245481120514,
                    "work": 0.12012643108263227,
                    "writing": 0.3162108062785368
                },
                "Max term": "create",
                "Max score": 0.3647066588616372
            }
        ],
        "Best Answer": "When I've had them created before coding, we view them as \"temporary\" documents. That is, we create the diagrams and get our thoughts onto paper. We start coding from those class diagrams. We then throw them out. It's not worth spending the time to maintain them once coding has started. And if you want up-to-date class models, use a tool to create them from the code.  ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "class": 0.30482242516546254,
                "code": 0.08009477561885502,
                "coding": 0.3897890949770361,
                "create": 0.2941525879555522,
                "created": 0.18025344696854906,
                "date": 0.1855118901733312,
                "diagrams": 0.40670512519151225,
                "documents": 0.20825936276763116,
                "maintain": 0.18845317284889077,
                "models": 0.20335256259575613,
                "paper": 0.18845317284889077,
                "spending": 0.22062351172192687,
                "start": 0.12751923326087555,
                "started": 0.1491182868742646,
                "thoughts": 0.1778818875892437,
                "throw": 0.20825936276763116,
                "time": 0.09018779274069497,
                "tool": 0.1600412151668188,
                "use": 0.0861896775341249,
                "view": 0.18845317284889077,
                "want": 0.10805487293753706,
                "worth": 0.15357786347496635
            },
            "Max term": "diagrams",
            "Max score": 0.40670512519151225
        }
    },
    {
        "ID": "6723",
        "Question": "Here is a theoretical problem.  It could apply to many systems.  Let's assume RESTful Web services for example.  You want to find out something but as it happens you can't get it in a single query.  You can make multiple queries.  For example, you have a joint bank account (or a company bank account) and you want to find out how much money is in there.  Meanwhile someone else transfers money from checking to savings. Checking:  $5,000   Savings:  $3,000   Me:  Query Checking.    Response: $5,000  Â   Joe:  Transfer $4,000 from Checking to Savings  Checking: $1,000   Savings:  $7,000  Me:  Query Savings.  Response:  $7,000 Total $12,000. How do you avoid anomalies like this?  The example shows two accounts at one bank, but it can also happen with two accounts at two different banks.  ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "000": 0.6944833922042531,
                    "12": 0.08952915158635305,
                    "account": 0.15554379623398606,
                    "apply": 0.07777189811699303,
                    "assume": 0.07777189811699303,
                    "avoid": 0.06438204668973779,
                    "bank": 0.2785698155996335,
                    "checking": 0.41260295106388206,
                    "company": 0.054898361826249346,
                    "different": 0.049964756779996435,
                    "example": 0.14865154729790495,
                    "happen": 0.070428227864084,
                    "happens": 0.07314695542490542,
                    "joe": 0.09285660519987785,
                    "let": 0.06051228903785267,
                    "like": 0.03310038455506249,
                    "make": 0.042138910463601104,
                    "money": 0.13105933599725078,
                    "multiple": 0.06552966799862539,
                    "problem": 0.04837266288552068,
                    "queries": 0.08952915158635305,
                    "query": 0.23757940979775485,
                    "response": 0.16504118042555282,
                    "services": 0.0764744090384302,
                    "shows": 0.08252059021277641,
                    "single": 0.060944543000595555,
                    "systems": 0.06438204668973779,
                    "theoretical": 0.08681042402553164,
                    "total": 0.08076424285118543,
                    "transfer": 0.08681042402553164,
                    "want": 0.08769746273517781,
                    "web": 0.054898361826249346
                },
                "Max term": "000",
                "Max score": 0.6944833922042531
            }
        ],
        "Best Answer": "You need some form of concurrency control to deal with problems like this. Some possible solutions in your example:  Ensure that the service can return both Savings and Checking figures in a single query, perhaps as a Total. Implement some kind of session so that the user requesting values can lock the data until she has finished reading all the values in which she is interested. This approach is often called \"pessimistic concurrency control\". Design the service so that you can pass your previous Checking figure back when you request a Savings figure. If the Checking figure no longer matches its previous value, the service should indicate an error rather than return a value for Savings. This approach is a variation of \"optomistic concurrency control\".  ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "approach": 0.18330737958363186,
                "called": 0.10322899320116011,
                "checking": 0.3493727413484386,
                "concurrency": 0.32926789756283714,
                "control": 0.2638566167437371,
                "data": 0.08010953995328987,
                "deal": 0.10322899320116011,
                "design": 0.07513491937135298,
                "ensure": 0.12251162908238049,
                "error": 0.09717494456825915,
                "example": 0.06992840406557133,
                "figure": 0.2981765275035307,
                "figures": 0.13104433138986515,
                "finished": 0.12251162908238049,
                "form": 0.09423376165422917,
                "implement": 0.09516921491389345,
                "interested": 0.09717494456825915,
                "kind": 0.0879522055812457,
                "like": 0.04671307715190183,
                "longer": 0.09825437261922325,
                "matches": 0.13104433138986515,
                "need": 0.06168597164625439,
                "pass": 0.10792487814199489,
                "possible": 0.0770669388514303,
                "previous": 0.1903384298277869,
                "problems": 0.07919442911497217,
                "query": 0.11176169550864475,
                "reading": 0.0879522055812457,
                "request": 0.11645758044947953,
                "return": 0.20645798640232021,
                "service": 0.34193678032468755,
                "session": 0.13104433138986515,
                "single": 0.08600827988685113,
                "solutions": 0.10322899320116011,
                "total": 0.11397892677489585,
                "user": 0.07919442911497217,
                "value": 0.19878435166902048,
                "values": 0.2235233910172895,
                "variation": 0.13104433138986515
            },
            "Max term": "checking",
            "Max score": 0.3493727413484386
        }
    },
    {
        "ID": "6815",
        "Question": "As I advance in my career, I have found that I do less technical work and more project management work.  I joke that I am getting dumber every day.  Each time I go back to doing technical work it seems to be a little harder to get things going.  What suggestions do people have for maintaining technical expertise throughout your career? ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "advance": 0.2559305678757516,
                    "career": 0.37464992902164557,
                    "day": 0.1683693161818168,
                    "getting": 0.16133245207587976,
                    "going": 0.13721373190728461,
                    "harder": 0.23087495157398244,
                    "joke": 0.26544252099716853,
                    "little": 0.1683693161818168,
                    "maintaining": 0.2415877463039436,
                    "management": 0.17421779635682508,
                    "people": 0.11871936114589403,
                    "project": 0.1253472251293948,
                    "suggestions": 0.22638374275399564,
                    "technical": 0.508429724247934,
                    "things": 0.1261515331056659,
                    "time": 0.10462082137772735,
                    "work": 0.33717795890371033
                },
                "Max term": "technical",
                "Max score": 0.508429724247934
            }
        ],
        "Best Answer": "Keep on coding I've always tried to steer away from a position where I'm forced to do more management than coding.  In fact it's something I always point out in interviews - I'm a coder - always will be. I would say that's #1 on keeping your technical skills sharp - as simply as it sounds - keep on coding.  Whether or not that's what you want to do is a different story. You can also try being more involved with group code reviews.  Not only is this a great way of sharing knowledge and elimination key-person dependency, it will also show you what's going on in the codebase and keep your skills sharp. The problem (in my opinion) with programmers moving into project manager positions is that there is absolutely nothing that says if you're good at programming you will be good at project management.  In my experience the exact opposite is usually true. ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "absolutely": 0.14602828266287501,
                "away": 0.12293785372959105,
                "code": 0.06206370716436868,
                "codebase": 0.15421974268803168,
                "coder": 0.16137567032531328,
                "coding": 0.3020391287646495,
                "dependency": 0.16576495715467365,
                "different": 0.0954079635003727,
                "exact": 0.15421974268803168,
                "experience": 0.10166166904888066,
                "fact": 0.11993781815251964,
                "forced": 0.17095638160275892,
                "going": 0.09165596477115041,
                "good": 0.1550714154554432,
                "great": 0.10968709943503803,
                "group": 0.14374914641143907,
                "interviews": 0.15121970711096028,
                "involved": 0.12876917032943386,
                "keeping": 0.14602828266287501,
                "key": 0.13611059700983255,
                "knowledge": 0.11104326061688252,
                "management": 0.23274784503606782,
                "manager": 0.134483068196233,
                "moving": 0.15421974268803168,
                "opinion": 0.12750345073473174,
                "opposite": 0.17731017162131565,
                "person": 0.12090313101673598,
                "point": 0.10166166904888066,
                "position": 0.13783682263771838,
                "positions": 0.17095638160275892,
                "problem": 0.09236785191047454,
                "programmers": 0.09500971921263573,
                "programming": 0.0752730447208371,
                "project": 0.1674587621942135,
                "reviews": 0.1485058448212325,
                "say": 0.09236785191047454,
                "says": 0.13611059700983255,
                "sharing": 0.15757349712951702,
                "simply": 0.11900416065833735,
                "skills": 0.2458757074591821,
                "sounds": 0.13611059700983255,
                "story": 0.16137567032531328,
                "technical": 0.11320688351552263,
                "tried": 0.1329435580073213,
                "true": 0.13783682263771838,
                "try": 0.10166166904888066,
                "usually": 0.11554853132315923,
                "want": 0.08372938109710674,
                "way": 0.0779671402604389
            },
            "Max term": "coding",
            "Max score": 0.3020391287646495
        }
    },
    {
        "ID": "6827",
        "Question": "This includes architecture decisions, platform choices or any situation where a such a bad choice led to negative consequences. ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "architecture": 0.3242184995602491,
                    "bad": 0.23274536833200987,
                    "choice": 0.2951672108809421,
                    "consequences": 0.39367194321219184,
                    "decisions": 0.34240554408432505,
                    "includes": 0.3795649755154398,
                    "negative": 0.39367194321219184,
                    "platform": 0.3144732093739626,
                    "situation": 0.2888400098100293
                },
                "Max term": "consequences",
                "Max score": 0.39367194321219184
            }
        ],
        "Best Answer": "Years ago, I was the lead developer on a database centered application that started throwing errors. I tracked it down to the fact there were duplicate values in a database field that shouldn't have allowed them.  I was beating myself up about forgetting to set a unique constraint on the database when I had pushed it to production because it was just so obvious that this field needed one. I commiserated to one of my fellow developers who corrected me... Other Developer: \"Oh you didn't forget, there was a unique constraint on that field. I just removed it.\" Me: \"Why did you remove it?\" Other Developer: \"I did that a few weeks back. I was getting data files from the customer and they wouldn't import because the unique constraint was blocking the new data. So I removed the constraint so that I could finish importing it.\" Me: \"Did you stop to consider that maybe there was a problem if we were getting new data that overlapped with existing data and think about mentioning it to someone before importing it?\" Other Developer: (blank stare) Me: Facepalm. ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "ago": 0.1041125415245802,
                "allowed": 0.12468985645741687,
                "application": 0.08219556523686311,
                "consider": 0.09277483615671034,
                "customer": 0.10518351698622562,
                "data": 0.35055066125944556,
                "database": 0.3189202662015874,
                "developer": 0.31668788535291525,
                "developers": 0.08179517565346642,
                "duplicate": 0.12468985645741687,
                "errors": 0.10630675540052913,
                "existing": 0.10308918101425953,
                "fact": 0.09697221035769525,
                "fellow": 0.12740143639273138,
                "field": 0.3602101550248004,
                "files": 0.10210938119954424,
                "finish": 0.13047557217941275,
                "forget": 0.12740143639273138,
                "getting": 0.1742633417278125,
                "lead": 0.1114439262423781,
                "maybe": 0.09621732893394992,
                "needed": 0.09939780126422974,
                "new": 0.1358262157986591,
                "obvious": 0.1114439262423781,
                "oh": 0.13822177570123567,
                "problem": 0.07468132156915355,
                "production": 0.11292972050804852,
                "remove": 0.1222642655508824,
                "set": 0.09034924525017586,
                "started": 0.09342338103685725,
                "stop": 0.1180668913498975,
                "think": 0.06085981585600382,
                "throwing": 0.13822177570123567,
                "unique": 0.38220430917819415,
                "values": 0.1222642655508824,
                "weeks": 0.11004823706534708,
                "years": 0.08430914218007779
            },
            "Max term": "unique",
            "Max score": 0.38220430917819415
        }
    },
    {
        "ID": "6832",
        "Question": "Both in Code Complete by Steve McConnell and The Pragmatic Programmer by Andrew Hunt & David Thomas, they allege that most programmers don't read programming-related books as a habit, or at least not often enough. Does this still hold? Are programmers who do read such books still rare? I must admit that only quite recently did I start reading (and now I can't stop; it's burning a whole in my wallet!). Before I was actually against it and argued that it's better to write programs than to waste time reading about it. Now I realize that the best outcome, for me at least, is to do both. EDIT: I actually meant any kind of books that on way or another was related to programming; be it either on a particular language, technology, pattern, paradigm - anything as long as it may benefit you as a programmer. I was just referring to Code Complete and The Pragmatic Programmer because that's where I read that programmers don't usually read such books. It would have looked stranged if the title just read \"Are programmers who read books still rare?\" ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "actually": 0.1342638540890189,
                    "admit": 0.11772439620995045,
                    "benefit": 0.1005583485383356,
                    "best": 0.0643656809870044,
                    "better": 0.06105045998842454,
                    "books": 0.4479274689397504,
                    "burning": 0.12209975843139402,
                    "code": 0.08547691971457316,
                    "complete": 0.169315523246074,
                    "david": 0.11772439620995045,
                    "edit": 0.08132640912516673,
                    "habit": 0.12209975843139402,
                    "hold": 0.10850864199598492,
                    "hunt": 0.11772439620995045,
                    "kind": 0.08194893240387005,
                    "language": 0.05747552875221879,
                    "long": 0.06773529268975763,
                    "looked": 0.10619917151609538,
                    "meant": 0.10413327977454134,
                    "paradigm": 0.11112690368100848,
                    "particular": 0.07956930858874672,
                    "pattern": 0.09753578724559939,
                    "pragmatic": 0.2045289067459539,
                    "programmer": 0.18934905518993575,
                    "programmers": 0.2617032888394724,
                    "programming": 0.10366941154891801,
                    "programs": 0.084657761623037,
                    "quite": 0.0779567974224135,
                    "rare": 0.2282989299474894,
                    "read": 0.4402566940051045,
                    "reading": 0.1638978648077401,
                    "realize": 0.0989888842307442,
                    "recently": 0.09618298631689204,
                    "related": 0.1830958277156452,
                    "start": 0.06804408389489167,
                    "steve": 0.11112690368100848,
                    "stop": 0.1005583485383356,
                    "technology": 0.09054216333913225,
                    "time": 0.04812407962796132,
                    "title": 0.12209975843139402,
                    "usually": 0.07956930858874672,
                    "waste": 0.10850864199598492,
                    "way": 0.05368992034883219,
                    "write": 0.06019781103282703
                },
                "Max term": "books",
                "Max score": 0.4479274689397504
            }
        ],
        "Best Answer": "Everyone seems to be answering this question personally, as in \"I do read such-and-such.\"  However, as a person hanging out at this site, you are already a cut above your \"average\" programmer IMO.  So this skews the numbers dramatically.  To answer the question directly: yes, programmers that read books are a rare breed.  I've worked with dozens of programmers, and only know two or three that would pick up a book to solve a problem.  Most of them would search Google for a particular program, or just stare blankly at the screen hoping for divine inspiration. :-) And the \"theory\" books such as Pragmatic Programmer and Code Complete are even more rarely read by average programmers.  If a programmer is going to read a book, it is more likely to be a technical book on the specific language, framework, or technology they are working on.  The \"soft\" books are not even on most programmers radar. ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "answer": 0.08754795946206201,
                "answering": 0.1384390213231777,
                "average": 0.2365803279651324,
                "book": 0.28553756491729576,
                "books": 0.32594444715820653,
                "code": 0.05183266129949495,
                "complete": 0.10267185806959142,
                "cut": 0.1427746525217279,
                "directly": 0.1347732973764911,
                "dozens": 0.1427746525217279,
                "dramatically": 0.1427746525217279,
                "framework": 0.09718997439189273,
                "going": 0.07654670974583583,
                "google": 0.10648482790348665,
                "hoping": 0.14808103625300842,
                "imo": 0.14808103625300842,
                "know": 0.06457601234117198,
                "language": 0.06970559128174163,
                "likely": 0.10016637080404742,
                "numbers": 0.12402503020369812,
                "particular": 0.0965006468573608,
                "person": 0.10097255427301843,
                "personally": 0.10980838573387812,
                "pick": 0.11231387299942211,
                "pragmatic": 0.12402503020369812,
                "problem": 0.07714124408259936,
                "program": 0.09052435587421673,
                "programmer": 0.22964012923750748,
                "programmers": 0.3173904248462893,
                "question": 0.1519333554048715,
                "rare": 0.1384390213231777,
                "rarely": 0.11231387299942211,
                "read": 0.35595848456561213,
                "screen": 0.12005246155056075,
                "search": 0.12005246155056075,
                "site": 0.10648482790348665,
                "solve": 0.10547275453532794,
                "specific": 0.0965006468573608,
                "technical": 0.09454501379511901,
                "technology": 0.10980838573387812,
                "theory": 0.12879700639334699,
                "worked": 0.09718997439189273,
                "working": 0.07901959915184657,
                "yes": 0.0965006468573608
            },
            "Max term": "read",
            "Max score": 0.35595848456561213
        }
    },
    {
        "ID": "6834",
        "Question": "Modern IDEs have a lot of tricks up their sleeves to help with code writing, refactoring,  searching. All those are very helpful, but rarely any of them looks like a real \"magic\" and makes me think \"Wow! How did it figure that out?\" Can you name any impressive IDE code automation (or other) features that blew your mind first time you saw them? ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "code": 0.20533384440577893,
                    "features": 0.18485287425603142,
                    "figure": 0.22246435688320007,
                    "help": 0.15917147151658528,
                    "helpful": 0.21520351814144306,
                    "ide": 0.21520351814144306,
                    "ides": 0.2933097365166354,
                    "like": 0.1045554600186639,
                    "looks": 0.22246435688320007,
                    "lot": 0.15047008573653817,
                    "magic": 0.25015041180810865,
                    "makes": 0.16497600206320306,
                    "mind": 0.1984033376033717,
                    "modern": 0.2343018235701414,
                    "rarely": 0.22246435688320007,
                    "real": 0.1772567870043276,
                    "refactoring": 0.24156266231189844,
                    "saw": 0.25511312565923866,
                    "searching": 0.27421143108793705,
                    "think": 0.12451805055508422,
                    "time": 0.11560433285962696,
                    "tricks": 0.26066096774059677,
                    "writing": 0.16345644393670605
                },
                "Max term": "ides",
                "Max score": 0.2933097365166354
            }
        ],
        "Best Answer": "Backwards Debugging Visual Studio 2010 (and now 2012) lets me debug backwards with IntelliTrace. Never again will I have to re-live the moment where I hit F10 one too many times and have to restart debugging. ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "2010": 0.2355666505071496,
                "backwards": 0.5416733616807239,
                "debug": 0.21334915893398773,
                "debugging": 0.5064033313475116,
                "hit": 0.2355666505071496,
                "lets": 0.2532016656737558,
                "live": 0.22305440812328833,
                "moment": 0.22305440812328833,
                "studio": 0.22305440812328833,
                "times": 0.1790565472389342,
                "visual": 0.21957308670851822
            },
            "Max term": "backwards",
            "Max score": 0.5416733616807239
        }
    },
    {
        "ID": "6884",
        "Question": "I'm sure that many of you have encountered a bad client. I'm also sure you took some measures to prevent such encounters in the future. What is the most influential characteristic of a client that warns you to walk away? ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "away": 0.23058319125081256,
                    "bad": 0.1966175372668929,
                    "client": 0.4611663825016251,
                    "encountered": 0.29554607244562026,
                    "future": 0.2696170130970138,
                    "measures": 0.3325643320860359,
                    "prevent": 0.2785387134998884,
                    "sure": 0.39116098763236506,
                    "took": 0.28925574462283077,
                    "walk": 0.3325643320860359
                },
                "Max term": "client",
                "Max score": 0.4611663825016251
            }
        ],
        "Best Answer": "Some time ago I read 6 Warning Signs of a Problem Client and found it a good 'bad client smell' list.  Have you ever had a project that turned out to cause way more stress that it was worth? Of course you have. We all have. Most of the time youâ€™re left saying â€œWhy didnâ€™t I see this coming?â€ Here are some early warning signs of a problem project and some tips for upgrading them from hopeless to profitable. 1. â€œI tried doing it myself, butâ€¦â€ 2. Thereâ€™s No Real Deadline 3. â€œSomebody Told Me I Shouldâ€¦â€ 4. Multiple Points Of Contact 5. â€œTrust Me, This Is Going To Be Huge!â€ 6. Repeated Meeting Cancellations ...  ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "ago": 0.13668896575995895,
                "bad": 0.11127607368160669,
                "cause": 0.14631431329244207,
                "client": 0.26099800186731226,
                "coming": 0.15763952105920565,
                "contact": 0.15763952105920565,
                "course": 0.13282516858380444,
                "deadline": 0.16052029623736994,
                "early": 0.1444819182001976,
                "going": 0.09729315641506522,
                "good": 0.08230444967265729,
                "huge": 0.13809504543165774,
                "left": 0.163704845452247,
                "list": 0.1263233707253447,
                "meeting": 0.15763952105920565,
                "multiple": 0.13282516858380444,
                "points": 0.13668896575995895,
                "problem": 0.19609765466083554,
                "project": 0.17775811518557133,
                "read": 0.11310846877385117,
                "real": 0.11374481358777731,
                "saying": 0.14826500701802572,
                "signs": 0.3519202693431825,
                "smell": 0.17596013467159125,
                "somebody": 0.163704845452247,
                "stress": 0.18821542389093546,
                "time": 0.14836547038096315,
                "tips": 0.15259026754298505,
                "told": 0.16726486859168876,
                "tried": 0.14112009421183752,
                "trust": 0.16052029623736994,
                "turned": 0.16052029623736994,
                "warning": 0.3519202693431825,
                "way": 0.08276241695272485,
                "worth": 0.1263233707253447
            },
            "Max term": "signs",
            "Max score": 0.3519202693431825
        }
    },
    {
        "ID": "6905",
        "Question": "I've used TestNG and JUnit.  What other frameworks are out there? What makes them special and/or different from the rest? ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "different": 0.27513105950344163,
                    "frameworks": 0.38781321475286124,
                    "junit": 0.5113151312439351,
                    "makes": 0.28759606533641996,
                    "rest": 0.4360772068578541,
                    "special": 0.42110652667214626,
                    "used": 0.24950974565484435
                },
                "Max term": "junit",
                "Max score": 0.5113151312439351
            }
        ],
        "Best Answer": "I suggest to use TestNG as core unit test framework for Java project, because TestNG is more advance in parameterize testing, dependency testing and suite testing (Grouping concept). TestNG is meant for high-level testing and complex integration test. Its flexibility is especially useful with large test suites. In addition, TestNG also cover the entire core JUnit4 functionality. Itâ€™s just no reason for me to use JUnit anymore. ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "addition": 0.16906504445755974,
                "advance": 0.1834239182507796,
                "anymore": 0.1778538927001492,
                "complex": 0.13958128321772428,
                "concept": 0.14603689423544416,
                "core": 0.31867220965810517,
                "cover": 0.15933610482905258,
                "dependency": 0.1778538927001492,
                "entire": 0.154232509092633,
                "especially": 0.13958128321772428,
                "flexibility": 0.1834239182507796,
                "framework": 0.1248608601231996,
                "functionality": 0.13958128321772428,
                "grouping": 0.1834239182507796,
                "high": 0.1276829167267848,
                "integration": 0.17314450319962393,
                "java": 0.11562601039173381,
                "junit": 0.1902410785698043,
                "large": 0.12868466415663538,
                "level": 0.11629747828698031,
                "meant": 0.16224788413853505,
                "project": 0.08983561192369219,
                "reason": 0.11840524910547971,
                "suggest": 0.1778538927001492,
                "test": 0.3225258901331725,
                "testing": 0.4475217634725755,
                "unit": 0.12311463860600498,
                "use": 0.14331426639610656,
                "useful": 0.12311463860600498
            },
            "Max term": "testing",
            "Max score": 0.4475217634725755
        }
    },
    {
        "ID": "6929",
        "Question": "I've got an itch and it needs to be scratched. I've got nothing to program these days. Normally I'd just pick my flavour of the month technology and fiddle with it, but I want to make something and take a break from serious research/experimentation for a while and just write something for fun (ie. not necessarily purely educational/professional development). Problem is,   I can't think of software that I need that I don't already have. Sifting through the open-source projects on various sites to help out on is excruciating (5 hrs down the tubes so far - not worth the trouble)  I'm not looking for a specific suggestion for what to work on because that would be a terribly hard task. I don't think that here knows nearly enough about eachother to effectively give good suggestions. So I ask, is there any mental exercise that you use to decide what to make when you're not \"fiddlin'\"? ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "ask": 0.12252546124213762,
                    "break": 0.1582171776239984,
                    "days": 0.1361704177228875,
                    "decide": 0.15602273852762602,
                    "development": 0.10011098913951418,
                    "effectively": 0.1722704420375879,
                    "exercise": 0.17601673774558252,
                    "far": 0.1339759786265151,
                    "fun": 0.15204170558315638,
                    "good": 0.08661089955889552,
                    "got": 0.25461089976171936,
                    "hard": 0.1309444714528436,
                    "help": 0.10748384540026301,
                    "knows": 0.14687250643106786,
                    "looking": 0.11709841787749273,
                    "make": 0.17976491764858663,
                    "mental": 0.18516696984214065,
                    "month": 0.15602273852762602,
                    "nearly": 0.19096602623328968,
                    "necessarily": 0.14850397948270144,
                    "need": 0.09323363452970246,
                    "needs": 0.14242713310592667,
                    "normally": 0.17601673774558252,
                    "open": 0.12327388991833475,
                    "pick": 0.150223682136477,
                    "problem": 0.10317907682460938,
                    "professional": 0.15396997784447158,
                    "program": 0.12107945082196239,
                    "projects": 0.11528039443081337,
                    "purely": 0.19096602623328968,
                    "research": 0.16588775915850726,
                    "sites": 0.150223682136477,
                    "software": 0.09352951341846344,
                    "source": 0.11772827511655323,
                    "specific": 0.12907294630948377,
                    "suggestion": 0.18516696984214065,
                    "suggestions": 0.16891926633217877,
                    "task": 0.1309444714528436,
                    "technology": 0.14687250643106786,
                    "think": 0.1681668048662886,
                    "trouble": 0.17601673774558252,
                    "use": 0.07460356374784624,
                    "various": 0.15602273852762602,
                    "want": 0.09352951341846344,
                    "work": 0.08386328562955228,
                    "worth": 0.13293304089084626,
                    "write": 0.0976495707854801
                },
                "Max term": "got",
                "Max score": 0.25461089976171936
            }
        ],
        "Best Answer": "When I run out of applications or utilities I want to write, I usually go solve math problems on Project Euler (I also often use those problems when I'm learning a new language).  Solving math-based problems programatically may not be the most rounded use for programming skills, but I've had a lot of fun and learned some things as well (ymmv). ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "applications": 0.1750042135409684,
                "based": 0.1597555577304833,
                "euler": 0.24125063107835876,
                "fun": 0.1920768743302903,
                "language": 0.11778363728709561,
                "learned": 0.18554653706450033,
                "learning": 0.15386473545046955,
                "lot": 0.12836318361096935,
                "math": 0.46784916888527245,
                "new": 0.11853472476449642,
                "problems": 0.45364323516834204,
                "programming": 0.10622399334754291,
                "project": 0.11815742612296504,
                "run": 0.15478850050386514,
                "skills": 0.17348773130095405,
                "solve": 0.17822049042877786,
                "solving": 0.20607253743570703,
                "things": 0.11891559974977059,
                "use": 0.18849590358942067,
                "usually": 0.1630600498240763,
                "utilities": 0.25021698751001276,
                "want": 0.11815742612296504,
                "write": 0.12336236471585146
            },
            "Max term": "math",
            "Max score": 0.46784916888527245
        }
    },
    {
        "ID": "6974",
        "Question": "What's the worst programming-related or technical book you've ever read? This can be any book which one way or another can be connected to programming, as long as it's not fiction. ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "book": 0.5250121802089781,
                    "fiction": 0.4084104365391373,
                    "long": 0.22656720055735421,
                    "programming": 0.34676292705557726,
                    "read": 0.2454351410380172,
                    "related": 0.3062178332148711,
                    "technical": 0.2607570242194253,
                    "way": 0.17958695487295992,
                    "worst": 0.36294962754369153
                },
                "Max term": "book",
                "Max score": 0.5250121802089781
            }
        ],
        "Best Answer": "Any book that allows you to teach yourself X in Y hours. I've read some in the past but once read you don't know any details whatsoever about X and you can't use the book as a reference for X either. After discovering that it seems better to go for the big books.  ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "allows": 0.2677247650464391,
                "better": 0.17219917986533353,
                "big": 0.21435005497035461,
                "book": 0.4427203554307474,
                "books": 0.25268521418251205,
                "details": 0.2643718631019597,
                "hours": 0.24530013444815185,
                "know": 0.1501857477715655,
                "past": 0.25538360027406554,
                "read": 0.4139299504719888,
                "reference": 0.28844754001103656,
                "teach": 0.3219704528724667,
                "use": 0.12972153309130538
            },
            "Max term": "book",
            "Max score": 0.4427203554307474
        }
    },
    {
        "ID": "7000",
        "Question": "Processors are getting more and more cores these days, which leaves me wondering... Should we, programmers, adapt to this behaviour and spent more effort on programming for multiple cores? To what extent should we do and optimize this? Thread? Affinity? Hardware optimizations? Something else? ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "adapt": 0.30452899011379786,
                    "behaviour": 0.2936163998204523,
                    "days": 0.2093663915119557,
                    "effort": 0.23988997247419008,
                    "extent": 0.25971879825460026,
                    "getting": 0.18508869083478316,
                    "hardware": 0.2337690064375725,
                    "leaves": 0.2847001643333877,
                    "multiple": 0.21490860639540266,
                    "optimize": 0.30452899011379786,
                    "processors": 0.2847001643333877,
                    "programmers": 0.16317853385542153,
                    "programming": 0.12928093228956955,
                    "spent": 0.2648713385529775,
                    "thread": 0.30452899011379786,
                    "wondering": 0.23673378698209388
                },
                "Max term": "adapt",
                "Max score": 0.30452899011379786
            }
        ],
        "Best Answer": "No matter how good you are, it will be unlikely that you'll come up with a better scheme of managing threads etc. than the teams developing the language and compiler you are writing your code in. If you need your application to be multi-threaded then create the threads you need and let the compiler and OS get on with their jobs. You do need to be aware of how those threads are managed so you can make best use of the resources. Not creating too many threads is one thing that springs to mind as an example. You also need to be aware of what is going on (see Lorenzo's comment) so you can provide hints to the thread management (or override it in special cases), but I would have thought that these would be few and far between. ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "application": 0.09037766034484154,
                "aware": 0.26886993799304076,
                "best": 0.08309541720631904,
                "better": 0.07881550176405466,
                "cases": 0.10929227989119983,
                "code": 0.05517490218605437,
                "come": 0.10499153885301002,
                "comment": 0.12981977036891018,
                "compiler": 0.25963954073782036,
                "create": 0.10131647253408185,
                "creating": 0.12100290523435682,
                "developing": 0.11335111523457424,
                "example": 0.08411489097178272,
                "far": 0.10662523538028751,
                "going": 0.08148254627496695,
                "good": 0.06892957712747767,
                "jobs": 0.12417122375766519,
                "language": 0.07420030313644446,
                "let": 0.10272314054030132,
                "make": 0.07153325862553216,
                "managed": 0.12417122375766519,
                "management": 0.10345691685697914,
                "managing": 0.14008351560776539,
                "matter": 0.11447634538957788,
                "mind": 0.10662523538028751,
                "multi": 0.12779360845420806,
                "need": 0.29680121254577785,
                "os": 0.12779360845420806,
                "provide": 0.11447634538957788,
                "resources": 0.12779360845420806,
                "scheme": 0.14736575874628788,
                "special": 0.12981977036891018,
                "teams": 0.13443496899652038,
                "thing": 0.08993741428449072,
                "thought": 0.10929227989119983,
                "thread": 0.15762950398514305,
                "threaded": 0.14736575874628788,
                "threads": 0.5603340624310615,
                "unlikely": 0.15198095737389805,
                "use": 0.05937349834179972,
                "writing": 0.08784419667383594
            },
            "Max term": "threads",
            "Max score": 0.5603340624310615
        }
    },
    {
        "ID": "7008",
        "Question": "What different types of security do there exist? Why and when should they be implemented? Example: SQL Injection Prevention ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "different": 0.23368009703104017,
                    "example": 0.23174273384565425,
                    "exist": 0.3333719361496091,
                    "implemented": 0.34691249111113764,
                    "injection": 0.4060035436360513,
                    "prevention": 0.43428091942133923,
                    "security": 0.3186351153258498,
                    "sql": 0.32203777015176605,
                    "types": 0.3186351153258498
                },
                "Max term": "prevention",
                "Max score": 0.43428091942133923
            }
        ],
        "Best Answer": "Preventing Buffer overflow  a buffer overflow, or buffer overrun, is an anomaly where a program, while writing data to a buffer, overruns the buffer's boundary and overwrites adjacent memory. This is a special case of violation of memory safety. Buffer overflows can be triggered by inputs that are designed to execute code, or alter the way the program operates. This may result in erratic program behavior, including memory access errors, incorrect results, a crash, or a breach of system security. Thus, they are the basis of many software vulnerabilities and can be maliciously exploited...  I cannot count exploits that are based on this. ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "access": 0.1368869539761684,
                "based": 0.12712264445018212,
                "basis": 0.1861413286567848,
                "behavior": 0.16980812883424537,
                "case": 0.12975213527647905,
                "code": 0.06969278134076047,
                "count": 0.1861413286567848,
                "crash": 0.1861413286567848,
                "data": 0.12171657757454264,
                "designed": 0.16141926234346773,
                "errors": 0.14764535766577774,
                "execute": 0.191970900002713,
                "including": 0.1528417574290918,
                "inputs": 0.191970900002713,
                "memory": 0.5002820091075528,
                "overflow": 0.3136874775772556,
                "program": 0.36514973272362794,
                "result": 0.16397855748831716,
                "results": 0.15904972514463603,
                "security": 0.1460853350990185,
                "software": 0.09402167087994995,
                "special": 0.16397855748831716,
                "violation": 0.19910571870240235,
                "way": 0.08755111652522639,
                "writing": 0.11095817388493329
            },
            "Max term": "memory",
            "Max score": 0.5002820091075528
        }
    },
    {
        "ID": "7038",
        "Question": "I'm using VS 2010 since we're developing an app in .Net 4 and the performance is driving me crazy. It's mostly bad when I don't view the IDE for a while (such as when I get pulled away for a help desk call or come in in the morning).  I realize it's probably built in WPF which unloads its resources when unused, but the few minute delay while it loads everything back up is really annoying. I've also noticed some significant delays when opening files or compiling. ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "2010": 0.1945344296941303,
                    "annoying": 0.18420163457606542,
                    "app": 0.14575415087039673,
                    "away": 0.15507512103353027,
                    "bad": 0.1322320513632436,
                    "built": 0.17866494131467894,
                    "come": 0.14897278756866808,
                    "compiling": 0.2236609432366655,
                    "crazy": 0.21564620468171578,
                    "delay": 0.21564620468171578,
                    "desk": 0.2090976864653979,
                    "developing": 0.16083421383272475,
                    "driving": 0.21564620468171578,
                    "files": 0.15930558268673298,
                    "help": 0.12137490517212468,
                    "ide": 0.16410168454341137,
                    "minute": 0.2090976864653979,
                    "morning": 0.2236609432366655,
                    "net": 0.13672758736051566,
                    "noticed": 0.1945344296941303,
                    "opening": 0.2236609432366655,
                    "performance": 0.17169136002384366,
                    "probably": 0.12699846041199703,
                    "realize": 0.18132670777914298,
                    "really": 0.10429891704897436,
                    "resources": 0.18132670777914298,
                    "significant": 0.2090976864653979,
                    "using": 0.10495197886911742,
                    "view": 0.18420163457606542,
                    "vs": 0.17386883945800055,
                    "wpf": 0.2090976864653979
                },
                "Max term": "compiling",
                "Max score": 0.2236609432366655
            }
        ],
        "Best Answer": "Get a faster machine? ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "faster": 0.6987350150602378,
                "machine": 0.7153805831365353
            },
            "Max term": "machine",
            "Max score": 0.7153805831365353
        }
    },
    {
        "ID": "7055",
        "Question": "Which design pattern do you think is the most popular? ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "design": 0.4291228352815563,
                    "pattern": 0.5978706433521765,
                    "popular": 0.5978706433521765,
                    "think": 0.31773413394727906
                },
                "Max term": "pattern",
                "Max score": 0.5978706433521765
            }
        ],
        "Best Answer": "I'm pretty sure the most common is 'The Big Ball of Mud'.  Unfortunately for us all.  http://en.wikipedia.org/wiki/Big_ball_of_mud ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "ball": 0.3586830304583122,
                "big": 0.23153988845260265,
                "common": 0.2261051241442178,
                "en": 0.3586830304583122,
                "http": 0.28215848974881597,
                "org": 0.33858177116209365,
                "pretty": 0.23297950539561957,
                "sure": 0.2187807128006725,
                "unfortunately": 0.33060444389644944,
                "wiki": 0.3720138967142866,
                "wikipedia": 0.3063814668226327
            },
            "Max term": "wiki",
            "Max score": 0.3720138967142866
        }
    },
    {
        "ID": "7057",
        "Question": "How should I be keeping track of a php script's versions/changes when it pertains to a single script in one file? Should I have a separate changelog, and if so (1) what should it be named, (2) how should the contents of the log be formatted, and (3) how should the log be associated with the php script/file? Or, should I include the changes in a comment at the top of the php file?  Currently, I have the following comments at the top of the file:  /**  * @author    John Doe <contact@John Doe.com>  * @version   1.0  * @copyright Copyright (c) 2010, John Doe  */   Thanks in advance for your response! ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "2010": 0.12402240346264115,
                    "advance": 0.1374818876240807,
                    "associated": 0.1374818876240807,
                    "author": 0.12402240346264115,
                    "changes": 0.1899505726965221,
                    "com": 0.11084737745779077,
                    "comment": 0.11743489046021596,
                    "comments": 0.10573770540502124,
                    "contact": 0.11942732805771061,
                    "contents": 0.14259155967685025,
                    "currently": 0.10573770540502124,
                    "file": 0.3799011453930442,
                    "following": 0.10253735438977028,
                    "formatted": 0.14259155967685025,
                    "include": 0.10815031235311141,
                    "john": 0.42777467903055066,
                    "keeping": 0.11743489046021596,
                    "log": 0.23486978092043193,
                    "named": 0.12977714879622468,
                    "php": 0.3018841000567551,
                    "response": 0.1267194685673205,
                    "script": 0.4124456628722421,
                    "separate": 0.11743489046021596,
                    "single": 0.09358706816323734,
                    "thanks": 0.1333069815697457,
                    "track": 0.11942732805771061,
                    "version": 0.10253735438977028,
                    "versions": 0.11942732805771061
                },
                "Max term": "john",
                "Max score": 0.42777467903055066
            }
        ],
        "Best Answer": "Aren't you using a VCS such as SVN, Git or Mercurial? There's no better way to keep track of the changes than being able to see the difference of the file. Of course, you would want to include the changelog on both: the main comment block and the last commit you do. ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "able": 0.19236062226478753,
                "better": 0.15261266669468349,
                "block": 0.25563854785505735,
                "changes": 0.20329806149941873,
                "comment": 0.25137366256959554,
                "commit": 0.25563854785505735,
                "course": 0.21539797245777073,
                "difference": 0.25137366256959554,
                "file": 0.20329806149941873,
                "git": 0.2712476403546476,
                "include": 0.2314996847845435,
                "main": 0.2314996847845435,
                "mercurial": 0.2712476403546476,
                "svn": 0.28534845199721,
                "track": 0.25563854785505735,
                "using": 0.14322437139591407,
                "vcs": 0.305222429782262,
                "want": 0.1441320873412975,
                "way": 0.1342129432049162
            },
            "Max term": "vcs",
            "Max score": 0.305222429782262
        }
    },
    {
        "ID": "7126",
        "Question": "Note: this question is an edited excerpt from a blog posting I wrote a few months ago.  After placing a link to the blog in a comment on Programmers.SE someone requested that I post a question here so that they could answer it.  This posting is my most popular, as people seem to type \"I don't get object-oriented programming\" into Google a lot.  Feel free to answer here, or in a comment at Wordpress.  What is object-oriented programming?    No one has given me a satisfactory   answer.  I feel like you will not get   a good definition from someone who   goes around saying â€œobjectâ€ and   â€œobject-orientedâ€ with his nose in the   air. Nor will you get a good   definition from someone who has done   nothing but object-oriented   programming. No one who understands   both procedural and object-oriented   programming has ever given me a   consistent idea of what an   object-oriented program actually does.  Can someone please give me their ideas of the advantages of object-oriented programming? ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "actually": 0.05468813662715785,
                    "advantages": 0.08063998552866819,
                    "ago": 0.07223656133708935,
                    "answer": 0.1764195275857416,
                    "blog": 0.16127997105733638,
                    "comment": 0.16383705774510862,
                    "consistent": 0.09299035215035867,
                    "definition": 0.15891247857038832,
                    "edited": 0.09590262260773272,
                    "feel": 0.11954976463389122,
                    "free": 0.06350647413451992,
                    "given": 0.13793065201660007,
                    "goes": 0.0715265215744323,
                    "good": 0.08699151967445652,
                    "google": 0.0715265215744323,
                    "idea": 0.05760040708453189,
                    "ideas": 0.0763549339051787,
                    "like": 0.03545676052892317,
                    "link": 0.08191852887255431,
                    "lot": 0.05102729016518701,
                    "months": 0.08191852887255431,
                    "note": 0.07457829741232427,
                    "object": 0.5722121725954584,
                    "oriented": 0.5220480818862699,
                    "people": 0.04448666754700908,
                    "popular": 0.07945623928519416,
                    "post": 0.07457829741232427,
                    "posting": 0.18105612512599703,
                    "procedural": 0.09590262260773272,
                    "program": 0.06080577318786972,
                    "programmers": 0.053298280884818465,
                    "programming": 0.21113228803507056,
                    "question": 0.10205458033037403,
                    "requested": 0.09590262260773272,
                    "saying": 0.07835419789780121,
                    "se": 0.09590262260773272,
                    "type": 0.06956816225086386,
                    "understands": 0.09590262260773272,
                    "wordpress": 0.09590262260773272,
                    "wrote": 0.0773233070268771
                },
                "Max term": "object",
                "Max score": 0.5722121725954584
            }
        ],
        "Best Answer": "From your blog, it seems that you're familiar with both imperative and functional programming, and that you're familiar with the basic concepts involved in object-oriented programming, but you've just never really had it \"click\" as to what makes it useful.  I'll try to explain in terms of that knowledge, and hope that it's helpful to you. At its core, OOP is a way to use the imperative paradigm to better manage high degrees of complexity by creating \"smart\" data structures that model the problem domain.  In a (standard procedural non-object-oriented) program, you've got two basic things: variables, and code that knows what to do with them.  The code takes input from the user and various other sources, stores it in variables, operates on it, and produces output data which goes to the user or various other locations. Object-oriented programming is a way to simplify your program by taking that basic pattern and repeating it on a smaller scale.  Just like a program is a large collection of data with code that knows what to do with it, each object is a small piece of data bound to code that knows what to do with it. By breaking down the problem domain into smaller pieces and making sure as much data as possible is bound directly to code that knows what to do with it, you make it a lot easier to reason about the process as a whole and also about the sub-issues that make up the process. By grouping data into object classes, you can centralize code related to that data, making relevant code easier both to find and to debug.  And by encapsulating the data behind access specifiers and only accessing it through methods, (or properties, if your language supports them,) you greatly reduce the potential for data corruption or the violation of invariants. And by using inheritance and polymorphism, you can reuse preexisting classes, customizing them to fit your specific needs, without having to either modify the originals or rewrite everything from the ground up.  (Which is a thing you should never do, if you can avoid it.)  Just be careful you understand your base object, or you could end up with killer kangaroos. To me, these are the fundamental principles of object-oriented programming: complexity management, code centralization and improved problem-domain modeling through the creation of object classes, inheritance and polymorphism, and increased safety without sacrificing power or control through the use of encapsulation and properties.  I hope this helps you understand why so many programmers find it useful. EDIT: In response to Joel's question in the comments,  Can you explain what an \"object-oriented program\" contains   (other than these fancy defintions you've outlined) that is fundamentally   different from an imperative program? How do you \"get the ball rolling?\"  A little disclaimer here.  My model of \"an object-oriented program\" is basically the Delphi model, which is very similar to the C#/.NET model since they were created by former Delphi team members.  What I'm saying here may not apply, or not apply as much, in other OO languages. An object-oriented program is one in which all the logic is structured around objects.  Of course this has to be bootstrapped somewhere.  Your typical Delphi program contains initialization code that creates a singleton object called Application.  At the start of the program, it calls Application.Initialize, then a call to Application.CreateForm for every form you want to load into memory from the beginning, and then Application.Run, which displays the main form on screen and starts up the input/event loop that forms the core of any interactive computer programs. Application and your forms poll for incoming events from the OS and translate them into method calls on your object.  One thing that's very common is the use of event handlers, or \"delegates\" in .NET-speak.  An object has a method that says, \"do X and Y, but also check to see if this particular event handler is assigned, and call it if it is.\"  An event handler is a method pointer--a very simple closure that contains a reference to the method and a reference to the object instance--that's used to extend the behavior of objects.  For example, if I have a button object on my form, I customize its behavior by attaching an OnClick event handler, which causes some other object to execute a method when the button is clicked. So in an object-oriented program, most of the work gets done by defining objects with certain responsibilities and linking them together, either through method pointers or by one object directly calling a method defined in another object's public interface.  (And now we're back to encapsulation.)  This is an idea that I had no concept of back before I took OOP classes in college. ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "access": 0.02776017766146112,
                "application": 0.11575439922290588,
                "apply": 0.06763691766699803,
                "assigned": 0.04037791742779127,
                "avoid": 0.02799599403267711,
                "ball": 0.038931002079523866,
                "base": 0.03138885824814028,
                "basic": 0.08710708063360535,
                "basically": 0.03180734122126882,
                "beginning": 0.038931002079523866,
                "behavior": 0.06887294497939674,
                "better": 0.020189150773188277,
                "blog": 0.032735240798891604,
                "bound": 0.07786200415904773,
                "breaking": 0.03588338783796577,
                "button": 0.08075583485558253,
                "called": 0.03180734122126882,
                "calls": 0.06450941450257322,
                "causes": 0.03774878615936171,
                "certain": 0.028759726979710725,
                "check": 0.02731281163144332,
                "classes": 0.13301702627814485,
                "click": 0.03588338783796577,
                "code": 0.12720098899051593,
                "collection": 0.04037791742779127,
                "college": 0.035119654890932155,
                "comments": 0.029941942899872877,
                "common": 0.024541163954709625,
                "complexity": 0.06763691766699803,
                "computer": 0.025611579940636554,
                "concept": 0.030995753920130417,
                "concepts": 0.033818458833499015,
                "contains": 0.09820572239667481,
                "control": 0.027100194696604154,
                "core": 0.06763691766699803,
                "course": 0.028495027551605476,
                "created": 0.03180734122126882,
                "creates": 0.03674923684111211,
                "creating": 0.030995753920130417,
                "data": 0.22215312326712394,
                "debug": 0.03180734122126882,
                "defined": 0.03443647248969837,
                "defining": 0.038931002079523866,
                "delphi": 0.12113375228337378,
                "different": 0.02172675620888436,
                "directly": 0.07349847368222422,
                "disclaimer": 0.04037791742779127,
                "domain": 0.09976276970860865,
                "easier": 0.05226119142256233,
                "edit": 0.02689432865831478,
                "end": 0.02250191512460201,
                "event": 0.18374618420556055,
                "events": 0.038931002079523866,
                "example": 0.02154662697172748,
                "execute": 0.038931002079523866,
                "explain": 0.05226119142256233,
                "extend": 0.038931002079523866,
                "familiar": 0.06361468244253764,
                "fit": 0.03443647248969837,
                "form": 0.08710708063360535,
                "forms": 0.07786200415904773,
                "functional": 0.02731281163144332,
                "fundamental": 0.04037791742779127,
                "fundamentally": 0.038931002079523866,
                "gets": 0.03225470725128661,
                "goes": 0.02903569354453512,
                "got": 0.025952934308806935,
                "greatly": 0.03774878615936171,
                "ground": 0.038931002079523866,
                "grouping": 0.038931002079523866,
                "helpful": 0.029625575982857064,
                "helps": 0.03138885824814028,
                "high": 0.027100194696604154,
                "hope": 0.06763691766699803,
                "idea": 0.02338248430558063,
                "imperative": 0.1076501635138973,
                "improved": 0.03774878615936171,
                "initialization": 0.038931002079523866,
                "input": 0.06763691766699803,
                "instance": 0.03588338783796577,
                "interactive": 0.04037791742779127,
                "interface": 0.030995753920130417,
                "involved": 0.02932392924367352,
                "issues": 0.029941942899872877,
                "joel": 0.03062512530110666,
                "knowledge": 0.025287300593657382,
                "knows": 0.11976777159949151,
                "language": 0.01900693485302612,
                "languages": 0.02210275924640922,
                "large": 0.02731281163144332,
                "like": 0.01439342512592964,
                "little": 0.025611579940636554,
                "load": 0.032735240798891604,
                "locations": 0.03774878615936171,
                "logic": 0.030274540702836226,
                "loop": 0.038931002079523866,
                "lot": 0.020714173246949207,
                "main": 0.03062512530110666,
                "make": 0.03664750490358467,
                "makes": 0.022711102154282993,
                "making": 0.05420038939320831,
                "manage": 0.03588338783796577,
                "management": 0.026501224330304923,
                "members": 0.03225470725128661,
                "memory": 0.033818458833499015,
                "method": 0.19768497846346278,
                "methods": 0.02799599403267711,
                "model": 0.1210981628113449,
                "modify": 0.03443647248969837,
                "needs": 0.02903569354453512,
                "net": 0.04936736072602754,
                "non": 0.023872093061875366,
                "object": 0.5807138708907024,
                "objects": 0.09976276970860865,
                "oo": 0.04037791742779127,
                "oop": 0.06763691766699803,
                "oriented": 0.2421963256226898,
                "os": 0.032735240798891604,
                "output": 0.032735240798891604,
                "paradigm": 0.03674923684111211,
                "particular": 0.026313262313193718,
                "pattern": 0.03225470725128661,
                "piece": 0.03588338783796577,
                "pieces": 0.04037791742779127,
                "pointer": 0.038931002079523866,
                "pointers": 0.04037791742779127,
                "possible": 0.023746181619240615,
                "potential": 0.032735240798891604,
                "power": 0.032735240798891604,
                "principles": 0.03443647248969837,
                "problem": 0.06310334252096392,
                "procedural": 0.038931002079523866,
                "process": 0.04936736072602754,
                "program": 0.2468368036301377,
                "programmers": 0.021636066121455674,
                "programming": 0.06856614612652073,
                "programs": 0.02799599403267711,
                "properties": 0.07549757231872342,
                "public": 0.033818458833499015,
                "question": 0.020714173246949207,
                "really": 0.01882927345055188,
                "reason": 0.025131046393031566,
                "reduce": 0.033818458833499015,
                "reference": 0.06763691766699803,
                "related": 0.030274540702836226,
                "relevant": 0.030274540702836226,
                "repeating": 0.03774878615936171,
                "response": 0.03588338783796577,
                "responsibilities": 0.03774878615936171,
                "reuse": 0.03674923684111211,
                "rewrite": 0.03443647248969837,
                "rolling": 0.04037791742779127,
                "run": 0.0249784691052065,
                "saying": 0.03180734122126882,
                "says": 0.030995753920130417,
                "scale": 0.03674923684111211,
                "screen": 0.032735240798891604,
                "similar": 0.026313262313193718,
                "simple": 0.0249784691052065,
                "singleton": 0.04037791742779127,
                "small": 0.02413149707478196,
                "smaller": 0.07549757231872342,
                "smart": 0.035119654890932155,
                "sources": 0.03774878615936171,
                "speak": 0.03774878615936171,
                "specific": 0.026313262313193718,
                "standard": 0.026501224330304923,
                "start": 0.02250191512460201,
                "starts": 0.03674923684111211,
                "structured": 0.03588338783796577,
                "structures": 0.03588338783796577,
                "sub": 0.03774878615936171,
                "supports": 0.03674923684111211,
                "sure": 0.023746181619240615,
                "takes": 0.026501224330304923,
                "taking": 0.03325425656953621,
                "team": 0.02413149707478196,
                "terms": 0.03062512530110666,
                "thing": 0.046076215376411975,
                "things": 0.019189601454938674,
                "took": 0.035119654890932155,
                "translate": 0.03674923684111211,
                "try": 0.023150879844581175,
                "typical": 0.035119654890932155,
                "understand": 0.04420551849281844,
                "use": 0.045626830374412314,
                "used": 0.01970347304796293,
                "useful": 0.05226119142256233,
                "user": 0.0488034253085246,
                "using": 0.018947171890339277,
                "variables": 0.06763691766699803,
                "various": 0.06361468244253764,
                "violation": 0.04037791742779127,
                "want": 0.019067253758230596,
                "way": 0.035510097618545886,
                "work": 0.017096662750113095
            },
            "Max term": "object",
            "Max score": 0.5807138708907024
        }
    },
    {
        "ID": "7157",
        "Question": "I was wondering if there was a standard for laying out a class's regions.  I currently use Fields Constructor Properties Public Methods Private Methods  Fields being Private Properties and Properties being the public ones. I'll normally use subregions within that if needed, or will occasionally add other regions below (such as interface or baseClass members).  ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "add": 0.13453964011283026,
                    "class": 0.13351761266937515,
                    "currently": 0.1486475749391053,
                    "fields": 0.3419215741723033,
                    "interface": 0.15387924788461924,
                    "members": 0.16012935530963446,
                    "methods": 0.27797371966698825,
                    "needed": 0.13898685983349413,
                    "normally": 0.17814403696346784,
                    "occasionally": 0.17096078708615164,
                    "ones": 0.13898685983349413,
                    "private": 0.3250299538727366,
                    "properties": 0.5622145702015688,
                    "public": 0.3357852835795059,
                    "standard": 0.1315660357375729,
                    "use": 0.15101041171564714,
                    "wondering": 0.1558308248164215
                },
                "Max term": "properties",
                "Max score": 0.5622145702015688
            }
        ],
        "Best Answer": "Sub Regions? Does your class have a Single Responsibility? (implicit in that ... my answer is \"Rarely any regions, except maybe to group properties, constructors and methods\"... but even then, I don't use it that much) ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "answer": 0.23730062092835427,
                "class": 0.2673431639834586,
                "group": 0.3254047706533999,
                "maybe": 0.2693895760256497,
                "methods": 0.2782942723221303,
                "properties": 0.37524193507833464,
                "rarely": 0.30442916048980695,
                "responsibility": 0.38699375638695294,
                "single": 0.26343550909603103,
                "sub": 0.37524193507833464,
                "use": 0.15118455331611041
            },
            "Max term": "responsibility",
            "Max score": 0.38699375638695294
        }
    },
    {
        "ID": "7166",
        "Question": "Thoughts on these?  Python is one example, and no this is not a stab against Python I like the language.   What languages have a indentation requirement? ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "example": 0.23573638982095513,
                    "indentation": 0.441764945177078,
                    "language": 0.20795023785828481,
                    "languages": 0.24182089738069584,
                    "like": 0.15747495330926245,
                    "python": 0.5976456192706835,
                    "requirement": 0.38423557741123493,
                    "thoughts": 0.3434178413970589
                },
                "Max term": "python",
                "Max score": 0.5976456192706835
            }
        ],
        "Best Answer": "In Makefiles, it's annoying. In python, I find it very apropos and it makes the syntax a lot cleaner. I think the thing that makes it better in python is that no special characters are required, the only requirement is that you be consistent. You should be doing it anyway, so you get no cost added by following it. ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "added": 0.2462802798236884,
                "annoying": 0.2501850425841808,
                "better": 0.15189103792973474,
                "characters": 0.28399918227108206,
                "consistent": 0.28399918227108206,
                "cost": 0.22061562167908308,
                "following": 0.2184471094914047,
                "lot": 0.1558409915148003,
                "makes": 0.341729369154393,
                "python": 0.41097036265524045,
                "required": 0.2228850304728177,
                "requirement": 0.2642191785600978,
                "special": 0.2501850425841808,
                "syntax": 0.2392993210145215,
                "thing": 0.17332487770341223,
                "think": 0.12896261981249274
            },
            "Max term": "python",
            "Max score": 0.41097036265524045
        }
    },
    {
        "ID": "7181",
        "Question": "I have been using mysql for the same amount of time I have been using PHP. However I feel about 10x more confident in PHP; or any other programming language. But I just can't seem to really really grasp SQL. I mean, I can select, update, insert, delete, join, etc. but when it comes to more complex stuff I am lost. How to write a more complicated select statement, how to use indexes properly, which engine to use, etc. For some reason I really find the mysql docs hard to follow, but the php ones easy to follow. I am starting to think that maybe my brain is just wired in a way that makes programming make since but sql confusing. I don't know. Most people think Regex is so confusing but to me it makes more scientific sense than how to construct an sql statement. Please don't get me wrong, I am not hating on SQL, I really like it, I just want to understand it better. Whats the best/fastest way to really master MySQL?  When I say \"master\" I don't mean the guru among gurus, I mean smart enough to figure out most of the questions I ask on SO myself without needing help.  ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "10x": 0.11069401649977274,
                    "ask": 0.07102224252082771,
                    "best": 0.06052182880163589,
                    "better": 0.057404589387107685,
                    "brain": 0.1073325764755625,
                    "comes": 0.08813142001454935,
                    "complex": 0.0842355403532361,
                    "complicated": 0.09043903742238564,
                    "confident": 0.09985706635606627,
                    "confusing": 0.214665152951125,
                    "construct": 0.11480808659505874,
                    "delete": 0.11480808659505874,
                    "easy": 0.07330129775952676,
                    "engine": 0.09455310751767164,
                    "fastest": 0.1073325764755625,
                    "feel": 0.06899416960188991,
                    "figure": 0.0870775973981754,
                    "follow": 0.1667557131412562,
                    "grasp": 0.11480808659505874,
                    "guru": 0.11480808659505874,
                    "gurus": 0.11480808659505874,
                    "hard": 0.07590234645113188,
                    "help": 0.06230332583692668,
                    "insert": 0.11480808659505874,
                    "join": 0.1044905194306232,
                    "know": 0.05006615704769716,
                    "language": 0.05404314936289745,
                    "like": 0.040925379601669504,
                    "lost": 0.09171105047273231,
                    "make": 0.05210063054871304,
                    "makes": 0.12915070161610248,
                    "master": 0.18910621503534328,
                    "maybe": 0.07705502655095393,
                    "mean": 0.2294090391641584,
                    "mysql": 0.33208204949931824,
                    "ones": 0.07960208727867918,
                    "people": 0.05134800047763728,
                    "php": 0.24306302546611505,
                    "programming": 0.09747838104900562,
                    "properly": 0.1044905194306232,
                    "questions": 0.07379297693720521,
                    "really": 0.26768998929909055,
                    "reason": 0.07145607139534522,
                    "say": 0.05980805412216112,
                    "scientific": 0.11480808659505874,
                    "select": 0.20405723527433575,
                    "sense": 0.08255830491431379,
                    "smart": 0.09985706635606627,
                    "sql": 0.34054031433596404,
                    "starting": 0.08513507858399101,
                    "statement": 0.20405723527433575,
                    "stuff": 0.07235560962610013,
                    "think": 0.09747838104900562,
                    "time": 0.04525015915030591,
                    "understand": 0.06284562600558803,
                    "update": 0.0870775973981754,
                    "use": 0.08648834852286784,
                    "using": 0.10774644606214036,
                    "want": 0.05421465642748092,
                    "way": 0.10096722718995403,
                    "write": 0.056602859749088553,
                    "wrong": 0.07429812844028454
                },
                "Max term": "sql",
                "Max score": 0.34054031433596404
            }
        ],
        "Best Answer": "Fastest way I found to \"master\" anything was to challenge myself with it. Take a set of data and write down eight to ten different things you would like to query for. A group of students you might want to find the average age of everyone grouped by the grade point average rounded to the nearest whole number. Then write the queries for them. Start with one table, then add more. Practice data joins and built in functions.  ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "add": 0.16311436563436085,
                "age": 0.22119134279267802,
                "average": 0.3882781043395899,
                "built": 0.19413905216979496,
                "challenge": 0.22720756720699825,
                "data": 0.29713903601134206,
                "different": 0.13077197769168297,
                "fastest": 0.22720756720699825,
                "functions": 0.19144638420155122,
                "group": 0.19703135333814925,
                "like": 0.08663311961429843,
                "master": 0.2001552765841152,
                "number": 0.15220267016962344,
                "point": 0.1393436881912645,
                "practice": 0.17649888386551157,
                "queries": 0.23432325039743143,
                "query": 0.20727095977454837,
                "set": 0.15316637852878226,
                "start": 0.13543761040091762,
                "students": 0.21597985215711238,
                "table": 0.22119134279267802,
                "things": 0.11550100296846771,
                "want": 0.11476459988506613,
                "way": 0.1068665209145,
                "write": 0.23964016299333757
            },
            "Max term": "average",
            "Max score": 0.3882781043395899
        }
    },
    {
        "ID": "7217",
        "Question": "Most programmers defending methodologies politically correct like Agile, Waterfall, RUP, etc. Some of them follow the methodology but not all of them. Frankly, if you can choose the methodology, you certainly would go to mainstream \"correct\" methodologies or you would prefer the \"easier\" methodology like cowboy programming? Why? I know it depends. Please, explain when you would use one or another. Please, say what advantages do you see on Cowboy coding. See about Cowboy coding on Wikipedia ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "advantages": 0.14659206898132815,
                    "agile": 0.1300250826670356,
                    "certainly": 0.14056281735713733,
                    "choose": 0.13714273581435377,
                    "coding": 0.20534169838801156,
                    "correct": 0.2653332843812537,
                    "cowboy": 0.523012142548256,
                    "depends": 0.13880245221663007,
                    "easier": 0.11701572970133846,
                    "explain": 0.11701572970133846,
                    "follow": 0.13131583436031194,
                    "frankly": 0.18081682958316794,
                    "know": 0.07885162147774359,
                    "like": 0.12891073457503338,
                    "mainstream": 0.15421037473640334,
                    "methodologies": 0.2978325592845064,
                    "methodology": 0.45432852141998176,
                    "prefer": 0.13131583436031194,
                    "programmers": 0.09688872358832316,
                    "programming": 0.07676171747530786,
                    "say": 0.09419460815552981,
                    "use": 0.06810734957611471,
                    "waterfall": 0.17433738084941863,
                    "wikipedia": 0.1489162796422532
                },
                "Max term": "cowboy",
                "Max score": 0.523012142548256
            }
        ],
        "Best Answer": "I think almost every experienced programmer has gone through three stages and some go through four:  Cowboy coders or nuggets know little to nothing about design and view it as an unnecessary formality.  If working on small projects for non-technical stakeholders, this attitude may serve them well for a while; it Gets Things Done, it impresses the boss, makes the programmer feel good about himself and confirms the idea that he knows what he's doing (even though he doesn't).  Architecture Astronauts have witnessed the failures of their first ball-of-yarn projects to adapt to changing circumstances.  Everything must be rewritten and to prevent the need for another rewrite in the future, they create inner platforms, and end up spending 4 hours a day on support because nobody else understands how to use them properly.  Quasi-engineers often mistake themselves for actual, trained engineers because they are genuinely competent and understand some engineering principles.  They're aware of the underlying engineering and business concepts: Risk, ROI, UX, performance, maintainability, and so on.  These people see design and documentation as a continuum and are usually able to adapt the level of architecture/design to the project requirements. At this point, many fall in love with methodologies, whether they be Agile, Waterfall, RUP, etc.  They start believing in the absolute infallibility and even necessity of these methodologies without realizing that in the actual software engineering field, they're merely tools, not religions.  And unfortunately, it prevents them from ever getting to the final stage, which is:  Duct tape programmers AKA gurus or highly-paid consultants know what architecture and design they're going to use within five minutes after hearing the project requirements.  All of the architecture and design work is still happening, but it's on an intuitive level and happening so fast that an untrained observer would mistake it for cowboy coding - and many do. Generally these people are all about creating a product that's \"good enough\" and so their works may be a little under-engineered but they are miles away from the spaghetti code produced by cowboy coders.  Nuggets cannot even identify these people when they're told about them, because to them, everything that is happening in the background just doesn't exist.   Some of you will probably be thinking to yourselves at this point that I haven't answered the question.  That's because the question itself is flawed.  Cowboy coding isn't a choice, it's a skill level, and you can't choose to be a cowboy coder any more than you can choose to be illiterate. If you are a cowboy coder, then you know no other way. If you've become an architecture astronaut, you are physically and psychologically incapable of producing software with no design. If you are a quasi-engineer (or a professional engineer), then completing a project with little or no up-front design effort is a conscious choice (usually due to absurd deadlines) that has to be weighed against the obvious risks, and undertaken only after the stakeholders have agreed to them (usually in writing). And if you are a duct-tape programmer, then there is never any reason to \"cowboy code\" because you can build a quality product just as quickly. Nobody \"prefers\" cowboy coding over other methodologies because it isn't a methodology.  It's the software development equivalent of mashing buttons in a video game.  It's OK for the beginner levels but anybody who's moved past that stage simply won't do it.  They might do something that looks similar but it will not be the same thing. ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "able": 0.0394511444830686,
                "absolute": 0.06259791653324001,
                "actual": 0.10000899506176326,
                "adapt": 0.12519583306648002,
                "agile": 0.04501405809836412,
                "agreed": 0.05852197229985047,
                "aka": 0.06259791653324001,
                "anybody": 0.05697237022077989,
                "architecture": 0.25777049804976104,
                "attitude": 0.05697237022077989,
                "aware": 0.05338688986286512,
                "away": 0.04340221114317314,
                "background": 0.05000449753088163,
                "ball": 0.06035476255276338,
                "beginner": 0.05852197229985047,
                "boss": 0.04641901717296686,
                "build": 0.041384965891675375,
                "business": 0.04079347086050674,
                "changing": 0.05000449753088163,
                "choice": 0.0938692876068911,
                "choose": 0.09495631075312534,
                "circumstances": 0.05563004384334175,
                "code": 0.043822175854817694,
                "coder": 0.11394474044155978,
                "coders": 0.11704394459970094,
                "coding": 0.106632462194905,
                "concepts": 0.052428782814963173,
                "conscious": 0.06035476255276338,
                "cowboy": 0.48283810042210706,
                "create": 0.040234854077372005,
                "creating": 0.048052741210514345,
                "day": 0.039705652137098604,
                "deadlines": 0.06035476255276338,
                "design": 0.25123578816110426,
                "development": 0.031640051885754555,
                "documentation": 0.04501405809836412,
                "effort": 0.049310945629475585,
                "end": 0.0348847363742043,
                "engineer": 0.11704394459970094,
                "engineered": 0.06259791653324001,
                "engineering": 0.1500134925926449,
                "engineers": 0.1112600876866835,
                "equivalent": 0.05852197229985047,
                "exist": 0.048052741210514345,
                "experienced": 0.05338688986286512,
                "failures": 0.05852197229985047,
                "fall": 0.06259791653324001,
                "fast": 0.048052741210514345,
                "feel": 0.03761835423015569,
                "field": 0.052428782814963173,
                "final": 0.05697237022077989,
                "future": 0.050749469060386396,
                "game": 0.048052741210514345,
                "generally": 0.04303662484098337,
                "gets": 0.05000449753088163,
                "getting": 0.03804618540846586,
                "going": 0.03235839421988535,
                "gone": 0.06035476255276338,
                "good": 0.054746704222377825,
                "gurus": 0.06259791653324001,
                "happening": 0.17556591689955142,
                "hearing": 0.06035476255276338,
                "highly": 0.05155409960995221,
                "hours": 0.04458622692005396,
                "idea": 0.036249883454690025,
                "identify": 0.05852197229985047,
                "incapable": 0.06259791653324001,
                "inner": 0.06035476255276338,
                "know": 0.08189415605538154,
                "knows": 0.04641901717296686,
                "level": 0.11480138611856339,
                "levels": 0.05697237022077989,
                "little": 0.11911695641129581,
                "looks": 0.04747815537656267,
                "love": 0.05338688986286512,
                "maintainability": 0.06035476255276338,
                "makes": 0.03520903918767218,
                "merely": 0.06259791653324001,
                "methodologies": 0.15466229882985663,
                "methodology": 0.052428782814963173,
                "minutes": 0.05000449753088163,
                "mistake": 0.10485756562992635,
                "moved": 0.05852197229985047,
                "need": 0.029466465763376623,
                "non": 0.03700892428722655,
                "obvious": 0.04866217115344349,
                "ok": 0.048052741210514345,
                "paid": 0.05155409960995221,
                "past": 0.04641901717296686,
                "people": 0.08399089149665125,
                "performance": 0.048052741210514345,
                "platforms": 0.052428782814963173,
                "point": 0.0717816537603155,
                "prevent": 0.052428782814963173,
                "prevents": 0.06035476255276338,
                "principles": 0.05338688986286512,
                "probably": 0.03554415406496834,
                "produced": 0.06259791653324001,
                "producing": 0.06259791653324001,
                "product": 0.08216973704123216,
                "professional": 0.04866217115344349,
                "programmer": 0.09707518265965605,
                "programmers": 0.03354240999676616,
                "project": 0.08867993462592377,
                "projects": 0.07286867690654977,
                "properly": 0.05697237022077989,
                "quality": 0.04458622692005396,
                "question": 0.06422639752465951,
                "quickly": 0.04501405809836412,
                "reason": 0.03896068060759384,
                "requirements": 0.08338859692709046,
                "rewrite": 0.05338688986286512,
                "risk": 0.049310945629475585,
                "risks": 0.06035476255276338,
                "roi": 0.06035476255276338,
                "serve": 0.06259791653324001,
                "similar": 0.04079347086050674,
                "simply": 0.0420134527414971,
                "skill": 0.052428782814963173,
                "small": 0.03741107852852325,
                "software": 0.08867993462592377,
                "spaghetti": 0.06259791653324001,
                "spending": 0.06035476255276338,
                "stage": 0.11704394459970094,
                "stakeholders": 0.12070952510552677,
                "start": 0.0348847363742043,
                "support": 0.041384965891675375,
                "technical": 0.03996677111354729,
                "thing": 0.03571599611914409,
                "things": 0.02974965393721895,
                "think": 0.0265745373068679,
                "thinking": 0.0394511444830686,
                "told": 0.05563004384334175,
                "tools": 0.041384965891675375,
                "trained": 0.06035476255276338,
                "underlying": 0.05852197229985047,
                "understand": 0.03426592470835878,
                "understands": 0.06035476255276338,
                "unfortunately": 0.05563004384334175,
                "unnecessary": 0.05852197229985047,
                "use": 0.04715687354870756,
                "usually": 0.12238041258152023,
                "ux": 0.06259791653324001,
                "video": 0.05563004384334175,
                "view": 0.05155409960995221,
                "waterfall": 0.06035476255276338,
                "way": 0.027525665864121484,
                "work": 0.026504969448769206,
                "working": 0.033403752413954914,
                "works": 0.0420134527414971,
                "writing": 0.0348847363742043
            },
            "Max term": "cowboy",
            "Max score": 0.48283810042210706
        }
    },
    {
        "ID": "7230",
        "Question": "While the basic scenarios are white on black and black on white, most programmers find more varied syntax highlighting useful. What advantages do you find from a general setup?  (E.g. \"a dark background allows...\") What specific tweaks do you find most helpful?  (E.g. \"slightly off-white works to...\", or \"highlighting quote marks and escapes, like \\n, differently shows...\") One answer per person, please; list multiple points as part of your one response, if needed. ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "advantages": 0.1517054139380017,
                    "allows": 0.14546585323229433,
                    "answer": 0.11063079638751043,
                    "background": 0.1494784701620763,
                    "basic": 0.13456054700229395,
                    "black": 0.3742479681130028,
                    "dark": 0.1871239840565014,
                    "differently": 0.17030753557417982,
                    "general": 0.13205493053948886,
                    "helpful": 0.13729424797092768,
                    "like": 0.06670366441259612,
                    "list": 0.12559083586725828,
                    "multiple": 0.13205493053948886,
                    "needed": 0.12974225207095202,
                    "person": 0.12759491096244044,
                    "points": 0.13589632199530946,
                    "programmers": 0.10026834343789355,
                    "quote": 0.1494784701620763,
                    "response": 0.16629491864439788,
                    "scenarios": 0.1749397618653528,
                    "setup": 0.16629491864439788,
                    "shows": 0.16629491864439788,
                    "slightly": 0.1871239840565014,
                    "specific": 0.12194394340357001,
                    "syntax": 0.1474052351068465,
                    "tweaks": 0.18041852271009867,
                    "useful": 0.12109740884999708,
                    "white": 0.5412555681302961,
                    "works": 0.12559083586725828
                },
                "Max term": "white",
                "Max score": 0.5412555681302961
            }
        ],
        "Best Answer": "Either way though, I personally find that a white screen with dark text is too bright and hard on the eyes for long coding sessions.  The black is much less intrusive on my eyes.   ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "black": 0.3325226127351849,
                "coding": 0.18881195464179873,
                "dark": 0.3325226127351849,
                "eyes": 0.5784389164485736,
                "hard": 0.21983857847647328,
                "long": 0.18446814956015084,
                "personally": 0.2465796583302904,
                "screen": 0.2695831903274635,
                "text": 0.26194169686859986,
                "way": 0.14621742762881093,
                "white": 0.32060688991780745
            },
            "Max term": "eyes",
            "Max score": 0.5784389164485736
        }
    },
    {
        "ID": "7242",
        "Question": "Who here is learning Go? Are other companies looking at using it? Is it likely to become widely used? ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "companies": 0.41279420472695905,
                    "learning": 0.3529942299548447,
                    "likely": 0.3883003634463176,
                    "looking": 0.33938440821226723,
                    "used": 0.2801200348363559,
                    "using": 0.2693678640842956,
                    "widely": 0.536666366799927
                },
                "Max term": "widely",
                "Max score": 0.536666366799927
            }
        ],
        "Best Answer": "When it comes to programming languages, the old adage, \"it's not who you are, it's who you know\" definitely holds true.  C and C++ were sponsored by AT&T, Java was brought to us by Sun, the .NET family came out of Microsoft, and all of them got very popular very quickly.  Then we have Objective-C and Python, which were around for quite a while and stayed really obscure until they were discovered and hyped up by Apple and Google, respectively, and then suddenly they really took off.  But languages without a major sponsor tend to languish in obscurity, no matter how good they are. Go is sponsored by Google.  It's not difficult to arrive at the right conclusion here.  Give it five years and it's gonna be huge. ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "apple": 0.1912089613240889,
                "came": 0.18176015748748237,
                "comes": 0.15700282089879541,
                "definitely": 0.15006245733030366,
                "difficult": 0.1485345258243053,
                "family": 0.20452630236119737,
                "gonna": 0.1912089613240889,
                "good": 0.08943701005703052,
                "google": 0.2941490505436157,
                "got": 0.13145942207385655,
                "holds": 0.20452630236119737,
                "huge": 0.15006245733030366,
                "java": 0.12430838039809283,
                "know": 0.08919098190807422,
                "languages": 0.2239142535635784,
                "major": 0.1589940126137674,
                "matter": 0.1485345258243053,
                "microsoft": 0.15166495096664262,
                "net": 0.12503026889242572,
                "objective": 0.18176015748748237,
                "obscure": 0.1971972407140726,
                "old": 0.14433588931951785,
                "popular": 0.1633797983674121,
                "programming": 0.08682704079212049,
                "python": 0.13834760992953415,
                "quickly": 0.14707452527180784,
                "quite": 0.1305835140508158,
                "really": 0.19075187232606616,
                "right": 0.11726617301370736,
                "stayed": 0.20452630236119737,
                "suddenly": 0.18176015748748237,
                "sun": 0.20452630236119737,
                "tend": 0.15512547541326546,
                "took": 0.17789162028698044,
                "true": 0.1589940126137674,
                "years": 0.12028155564154819
            },
            "Max term": "google",
            "Max score": 0.2941490505436157
        }
    },
    {
        "ID": "7245",
        "Question": "I had a question posed to me the other day by another programmer.  I remember (a very long time ago) wondering the very same.  Why was a browser-side include tag never considered?  Or was it? Specifically with a tag that instructed the browser to include additional HTML from other sources. e.g. <include src=\"http://server/foo/bar.html\">.  Many folks will make javascript calls and fill innerHTML to accomplish the same, when the same outside a the javascript engine could be accomplished by the browser. It would have been painful to have nested <HTML>s <BODY>s (i.e.) but we have to consider that aspect anywhere anyway. ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "accomplish": 0.1384000621614831,
                    "accomplished": 0.1455947909536171,
                    "additional": 0.13043575556179027,
                    "ago": 0.11310062607436956,
                    "aspect": 0.1501545264383927,
                    "bar": 0.13545439025833045,
                    "body": 0.1501545264383927,
                    "browser": 0.4252187685981863,
                    "calls": 0.12440446004530809,
                    "consider": 0.10078413128348905,
                    "considered": 0.11811926077090976,
                    "day": 0.09878231876666745,
                    "engine": 0.1282596614661964,
                    "folks": 0.1455947909536171,
                    "foo": 0.14173958953272878,
                    "html": 0.35435778231272924,
                    "http": 0.11811926077090976,
                    "include": 0.35435778231272924,
                    "javascript": 0.2525156978987496,
                    "long": 0.08639467369922102,
                    "make": 0.07067360779342327,
                    "nested": 0.1501545264383927,
                    "outside": 0.11954875299565004,
                    "programmer": 0.08050332989291575,
                    "question": 0.07989331659393345,
                    "remember": 0.10892271946195413,
                    "server": 0.11092453197877575,
                    "sources": 0.1455947909536171,
                    "specifically": 0.12106493267406239,
                    "src": 0.1557351916489038,
                    "tag": 0.2911895819072342,
                    "time": 0.06138106135565183,
                    "wondering": 0.12106493267406239
                },
                "Max term": "browser",
                "Max score": 0.4252187685981863
            }
        ],
        "Best Answer": " Why was a browser-side include tag never considered? Or was it?  It was certainly requested by every newbie web author who hadn't worked out Server Side Includes yet, back in the early days on the www-html list. But in those days W3 were happy to completely ignore web author pressure. If cross-site inclusion were allowed it would be a security disaster. You could pull in a page from the user's bank and read content from it. (Originally, DOM scripting was limited, but you could still have read from document.links, document.images, scripting functions dropped by the target page, etc. Since then you can do what you like with imported content.) If cross-site inclusion weren't allowed... well then the feature wouldn't have any advantage over server-side includes. It'd be more, slower work for the client to do that the server could have dealt with better. Unlike <iframe>, an include would have to block page loading. SSIs would be in every way superior. ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "advantage": 0.10660891369614221,
                "allowed": 0.2214215778276083,
                "author": 0.2214215778276083,
                "bank": 0.12728687417373882,
                "better": 0.06364404253233501,
                "block": 0.10660891369614221,
                "browser": 0.11584786397517385,
                "certainly": 0.0989498692554761,
                "client": 0.08825424382470547,
                "completely": 0.09438863025140103,
                "considered": 0.09654228645467279,
                "content": 0.237997663087543,
                "cross": 0.2316957279503477,
                "days": 0.17502171811382225,
                "document": 0.21321782739228443,
                "dropped": 0.12728687417373882,
                "early": 0.09771065177413805,
                "feature": 0.07971539033964607,
                "functions": 0.10026909008056506,
                "happy": 0.10660891369614221,
                "html": 0.09654228645467279,
                "ignore": 0.11071078891380415,
                "include": 0.19308457290934558,
                "includes": 0.24545127033932754,
                "like": 0.045373664855541694,
                "limited": 0.1085571327105324,
                "links": 0.12272563516966377,
                "list": 0.08543033648526559,
                "loading": 0.12728687417373882,
                "originally": 0.10660891369614221,
                "page": 0.3008072702416952,
                "pressure": 0.1189988315437715,
                "pull": 0.1189988315437715,
                "read": 0.15298664833275483,
                "requested": 0.12272563516966377,
                "security": 0.09339131888607517,
                "server": 0.2719854798765263,
                "site": 0.1830635607871494,
                "slower": 0.12728687417373882,
                "superior": 0.1189988315437715,
                "tag": 0.1189988315437715,
                "unlike": 0.12272563516966377,
                "user": 0.07692367328754329,
                "way": 0.0559708079986071,
                "web": 0.15050821337007872,
                "work": 0.053895319493785336,
                "worked": 0.0835421493150067,
                "www": 0.11071078891380415
            },
            "Max term": "page",
            "Max score": 0.3008072702416952
        }
    },
    {
        "ID": "7305",
        "Question": "What is your favorite method to declare a pointer? int* i;  or int *i;  or int * i;  or int*i;  Please explain why. see also: http://www.stroustrup.com/bs_faq2.html#whitespace ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "com": 0.1899818891827193,
                    "explain": 0.15815611703535554,
                    "favorite": 0.2125626338772525,
                    "html": 0.18535937545630402,
                    "http": 0.18535937545630402,
                    "int": 0.8337106177819329,
                    "method": 0.17092764652183087,
                    "pointer": 0.2356309128664317,
                    "www": 0.2125626338772525
                },
                "Max term": "int",
                "Max score": 0.8337106177819329
            }
        ],
        "Best Answer": "If you write: int* i, j, k;  you misleadingly suggest that all of i, j and k are pointers to int. So I contend it's superior to annex the * to the variable name. ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "int": 0.6625472170101248,
                "pointers": 0.3884294018275337,
                "suggest": 0.3631375603711622,
                "superior": 0.3631375603711622,
                "variable": 0.3312736085050624,
                "write": 0.19150406217999388
            },
            "Max term": "int",
            "Max score": 0.6625472170101248
        }
    },
    {
        "ID": "7325",
        "Question": "A typical curly brace programming lang has two types of AND and OR: logical and bitwise. && and || for logical ops and & and | for bitwise ops. Logical ops are more commonly used than bitwise ops, why logical ops are longer to type? Do you think they should be switched? ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "bitwise": 0.42467791379954445,
                    "commonly": 0.13234193981806666,
                    "curly": 0.14155930459984817,
                    "logical": 0.45232188477567825,
                    "longer": 0.1061382855279103,
                    "ops": 0.7077965229992408,
                    "programming": 0.06009581835244239,
                    "switched": 0.13234193981806666,
                    "think": 0.06009581835244239,
                    "type": 0.09900796511632319,
                    "types": 0.10386310641213808,
                    "typical": 0.12312457503628517,
                    "used": 0.0690776077755741
                },
                "Max term": "ops",
                "Max score": 0.7077965229992408
            }
        ],
        "Best Answer": "Probably a legacy thing. Bitwise operations may not be very common nowadays, but when coding on very low level you use them all the time. So when C was deviced in the 70's or whenever it was created, bitwise OPs were probably more common than logical OPs. And since C has it that way, I take it many other languages (such as Java, indirectly from C++) followed the same convention. Now that I've used the double notation (&& and ||) for so long, I'd only be confused if they were switched. But for completely new programmers, it would probably be a nice thing: you save a whopping 50% per logical operation! Imagine the productivity! ^^ EDIT: Provided these changed were done in a new language, of course, not in any existing languages. ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "50": 0.13225545764187183,
                "70": 0.16058695935275646,
                "bitwise": 0.32117391870551293,
                "changed": 0.1282801514357537,
                "coding": 0.09118398726622516,
                "common": 0.19520525819649062,
                "completely": 0.11908205954413585,
                "convention": 0.13019128074089625,
                "course": 0.11332753452103075,
                "created": 0.12650093261876674,
                "double": 0.15013064503462958,
                "edit": 0.1069613971744832,
                "existing": 0.11547781649100305,
                "followed": 0.16058695935275646,
                "imagine": 0.14615533882851145,
                "indirectly": 0.16058695935275646,
                "java": 0.09760262909824531,
                "language": 0.07559245422010263,
                "languages": 0.17580970623531425,
                "legacy": 0.13967433071650273,
                "level": 0.09816943090788216,
                "logical": 0.2565603028715074,
                "long": 0.08908620978172546,
                "low": 0.12650093261876674,
                "new": 0.15214899049877376,
                "nice": 0.11662415828994126,
                "notation": 0.15483243432965135,
                "nowadays": 0.14615533882851145,
                "operation": 0.15483243432965135,
                "operations": 0.13225545764187183,
                "ops": 0.32117391870551293,
                "probably": 0.2735519617986755,
                "productivity": 0.15013064503462958,
                "programmers": 0.08604876853822949,
                "provided": 0.13967433071650273,
                "save": 0.13967433071650273,
                "switched": 0.15013064503462958,
                "thing": 0.18324965221430617,
                "time": 0.06329332439626849,
                "use": 0.0604874679155509,
                "used": 0.07836265530830866,
                "way": 0.07061357997325736
            },
            "Max term": "bitwise",
            "Max score": 0.32117391870551293
        }
    },
    {
        "ID": "7347",
        "Question": "I'm talking about the way we write simple routines in order to improve performance without making your code harder to read... for instance, this is the typical for we learned: for(int i = 0; i < collection.length(); i++ ){    // stuff here }  But, I usually do this when a foreach is not applicable: for(int i = 0, j = collection.length(); i < j; i++ ){    // stuff here }  I think this is a better approach since it will call the length method once only... my girlfriend says it's cryptic though. Is there any other simple trick you use on your own developments? ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "applicable": 0.1716954721877631,
                    "approach": 0.12454861131121858,
                    "better": 0.08903921270743972,
                    "code": 0.062332025323688575,
                    "collection": 0.35615346271137743,
                    "cryptic": 0.17807673135568872,
                    "girlfriend": 0.17807673135568872,
                    "harder": 0.15488647626518087,
                    "improve": 0.14665960234716294,
                    "instance": 0.15825472989241687,
                    "int": 0.3037469414489825,
                    "learned": 0.1320514692612194,
                    "length": 0.5150864165632894,
                    "making": 0.11951864776840779,
                    "method": 0.12454861131121858,
                    "order": 0.13843272842914503,
                    "performance": 0.13669903986189888,
                    "read": 0.10701559942061925,
                    "says": 0.13669903986189888,
                    "simple": 0.22032261274885395,
                    "stuff": 0.2244589355958951,
                    "talking": 0.1320514692612194,
                    "think": 0.0755984704120935,
                    "trick": 0.17807673135568872,
                    "typical": 0.15488647626518087,
                    "use": 0.06707525080366065,
                    "usually": 0.11604807881481385,
                    "way": 0.07830421325394721,
                    "write": 0.08779566447313294
                },
                "Max term": "length",
                "Max score": 0.5150864165632894
            }
        ],
        "Best Answer": "insert premature-discussion-is-the-root-of-all-evil lecture That said, here are some habits I've gotten into to avoid unnecessary efficiency, and in some cases, make my code simpler and more correct as well. This isn't a discussion of general principles, but of some things to be aware of to avoid introducing unnecessary inefficiencies into code. Know your big-O This should probably be merged into the lengthy discussion above.  It's pretty much common sense that a loop inside of a loop, where the inner loop repeats a calculation, is gonna be slower.  For example: for (i = 0; i < strlen(str); i++) {     ... }  This will take a horrendous amount of time if the string is really long, because the length is being recalculated on every iteration of the loop.  Note that GCC actually optimizes this case because strlen() is marked as a pure function. When sorting a million 32-bit integers, bubble sort would be the wrong way to go.  In general, sorting can be done in O(n * log n) time (or better, in the case of radix sort), so unless you know your data is going to be small, look for an algorithm that's at least O(n * log n). Likewise, when dealing with databases, be aware of indexes.  If you SELECT * FROM people WHERE age = 20, and you don't have an index on people(age), it'll require an O(n) sequential scan rather than a much faster O(log n) index scan. Integer arithmetic hierarchy When programming in C, bear in mind that some arithmetic operations are more expensive than others.  For integers, the hierarchy goes something like this (least expensive first):  + - ~ & | ^ << >> * /  Granted, the compiler will usually optimize things like n / 2 to n >> 1 automatically if you're targeting a mainstream computer, but if you're targeting an embedded device, you might not get that luxury. Also, % 2 and & 1 have different semantics.  Division and modulus usually rounds toward zero, but it's implementation defined.  Good ol' >> and & always rounds toward negative infinity, which (in my opinion) makes a lot more sense.  For instance, on my computer: printf(\"%d\\n\", -1 % 2); // -1 (maybe) printf(\"%d\\n\", -1 & 1); // 1  Hence, use what makes sense.  Don't think you're being a good boy by using % 2 when you were originally going to write & 1. Expensive floating point operations Avoid heavy floating point operations like pow() and log() in code that doesn't really need them, especially when dealing with integers.  Take, for example, reading a number: int parseInt(const char *str) {     const char *p;     int         digits;     int         number;     int         position;      // Count the number of digits     for (p = str; isdigit(*p); p++)         {}     digits = p - str;      // Sum the digits, multiplying them by their respective power of 10.     number = 0;     position = digits - 1;     for (p = str; isdigit(*p); p++, position--)         number += (*p - '0') * pow(10, position);      return number; }  Not only is this use of pow() (and the int<->double conversions needed to use it) rather expensive, but it creates an opportunity for precision loss (incidentally, the code above doesn't have precision issues).  That's why I wince when I see this type of function used in a non-mathematical context. Also, notice how the \"clever\" algorithm below, which multiplies by 10 on each iteration, is actually more concise than the code above: int parseInt(const char *str) {     const char *p;     int         number;      number = 0;     for (p = str; isdigit(*p); p++) {         number *= 10;         number += *p - '0';     }      return number; }  ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "10": 0.16958342153965827,
                "20": 0.047327850349372334,
                "actually": 0.06419326415320355,
                "age": 0.10626238507637217,
                "algorithm": 0.09197262941060165,
                "avoid": 0.12142787255794313,
                "aware": 0.09957490317944484,
                "better": 0.02918900497309684,
                "big": 0.0363338828059821,
                "bit": 0.038594718500492974,
                "calculation": 0.05837745459647034,
                "case": 0.07608620621509393,
                "cases": 0.040475957519314376,
                "code": 0.10216901867351766,
                "common": 0.03548104448607675,
                "compiler": 0.04807823128815755,
                "computer": 0.07405725408211909,
                "concise": 0.05837745459647034,
                "const": 0.23350981838588136,
                "context": 0.04807823128815755,
                "correct": 0.042831969229873305,
                "count": 0.05457631771204875,
                "creates": 0.05313119253818609,
                "data": 0.03568709139698804,
                "databases": 0.05457631771204875,
                "dealing": 0.09957490317944484,
                "defined": 0.04978745158972242,
                "different": 0.03141203917663536,
                "discussion": 0.14423469386447266,
                "double": 0.05457631771204875,
                "embedded": 0.05837745459647034,
                "especially": 0.042831969229873305,
                "evil": 0.05077518082762716,
                "example": 0.06230322502385234,
                "expensive": 0.22514215205445448,
                "faster": 0.043770227339471085,
                "function": 0.08095191503862875,
                "general": 0.08239489716594899,
                "goes": 0.04197913090996795,
                "going": 0.06035346842200317,
                "gonna": 0.05457631771204875,
                "good": 0.05105558486680886,
                "granted": 0.05628553801361362,
                "habits": 0.05837745459647034,
                "heavy": 0.05628553801361362,
                "implementation": 0.047327850349372334,
                "index": 0.11257107602722724,
                "inner": 0.05628553801361362,
                "insert": 0.05837745459647034,
                "inside": 0.05077518082762716,
                "instance": 0.05187936817257914,
                "int": 0.3485121611280569,
                "issues": 0.04328936516583122,
                "iteration": 0.11257107602722724,
                "know": 0.050915138411469475,
                "length": 0.05628553801361362,
                "lengthy": 0.05837745459647034,
                "like": 0.062429038591152716,
                "log": 0.1923129251526302,
                "long": 0.03238510890090555,
                "look": 0.03363693326651249,
                "loop": 0.22514215205445448,
                "lot": 0.02994807026364622,
                "mainstream": 0.04978745158972242,
                "make": 0.02649205543362723,
                "makes": 0.06567036733474144,
                "mathematical": 0.05628553801361362,
                "maybe": 0.03918083165843592,
                "mind": 0.039488228281409625,
                "need": 0.027479784671531973,
                "needed": 0.040475957519314376,
                "negative": 0.05837745459647034,
                "non": 0.03451371733905137,
                "note": 0.043770227339471085,
                "notice": 0.047327850349372334,
                "number": 0.4021577064752818,
                "operations": 0.14423469386447266,
                "opinion": 0.04197913090996795,
                "opportunity": 0.04889394180880576,
                "optimize": 0.05837745459647034,
                "originally": 0.04889394180880576,
                "people": 0.05221871830467073,
                "point": 0.06694200806231658,
                "position": 0.1815251269947518,
                "power": 0.047327850349372334,
                "precision": 0.11257107602722724,
                "pretty": 0.036559791497752896,
                "principles": 0.04978745158972242,
                "probably": 0.03314770450859664,
                "programming": 0.024782835132062368,
                "pure": 0.05628553801361362,
                "reading": 0.03918083165843592,
                "really": 0.05444585188970432,
                "require": 0.04082976392548114,
                "return": 0.09197262941060165,
                "root": 0.05837745459647034,
                "said": 0.037028627041059546,
                "scan": 0.11675490919294068,
                "select": 0.05187936817257914,
                "semantics": 0.05628553801361362,
                "sense": 0.12593739272990387,
                "sequential": 0.05837745459647034,
                "simpler": 0.05457631771204875,
                "slower": 0.05837745459647034,
                "small": 0.03488875763211943,
                "sort": 0.08566393845974661,
                "sorting": 0.11257107602722724,
                "string": 0.05313119253818609,
                "sum": 0.05837745459647034,
                "things": 0.05548775959846835,
                "think": 0.024782835132062368,
                "time": 0.04601747472017764,
                "type": 0.04082976392548114,
                "unless": 0.04328936516583122,
                "unnecessary": 0.1091526354240975,
                "use": 0.06596621094504057,
                "used": 0.02848682340557139,
                "using": 0.027393380769026573,
                "usually": 0.07608620621509393,
                "way": 0.025669836924478148,
                "write": 0.02878134261297768,
                "wrong": 0.03777900797984476,
                "zero": 0.05628553801361362
            },
            "Max term": "number",
            "Max score": 0.4021577064752818
        }
    },
    {
        "ID": "7349",
        "Question": "As a general purpose programmer, what should you learn first and what should you learn later on? Here are some skills I wonder about...  SQL   Regular Expressions   Multi-threading / Concurrency   Functional Programming   Graphics   The mastery of your mother programming language's syntax/semantics/featureset   The mastery of your base class framework libraries   Version Control System   Unit Testing   XML   Do you know other important ones? Please specify them...  On which skills should I focus first? ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "base": 0.17300430415076729,
                    "class": 0.14823204394219908,
                    "concurrency": 0.1863954047544087,
                    "control": 0.1493667048598079,
                    "focus": 0.18042508940112817,
                    "framework": 0.146065391680165,
                    "functional": 0.15053857433564966,
                    "general": 0.15705453108077053,
                    "graphics": 0.1977765643593355,
                    "important": 0.14209031906631128,
                    "know": 0.09705034490206912,
                    "language": 0.10475951410184135,
                    "later": 0.16686257927487952,
                    "learn": 0.24154277530265714,
                    "libraries": 0.163285714869337,
                    "multi": 0.18042508940112817,
                    "ones": 0.15430403451897776,
                    "programmer": 0.11504093103029032,
                    "programming": 0.18895619434678482,
                    "purpose": 0.168794877799097,
                    "regular": 0.18042508940112817,
                    "semantics": 0.2145739380329053,
                    "skills": 0.3086080690379555,
                    "specify": 0.2225488245679037,
                    "sql": 0.16502941761576892,
                    "syntax": 0.17531083454421786,
                    "testing": 0.13088056898399178,
                    "threading": 0.2145739380329053,
                    "unit": 0.14402261759052878,
                    "version": 0.16003449114001603,
                    "wonder": 0.17777655814945623,
                    "xml": 0.20254881835802444
                },
                "Max term": "skills",
                "Max score": 0.3086080690379555
            }
        ],
        "Best Answer": "In my experience, programmers who are \"trying to be good programmers\" by learning things like they would learn basic math are never as good as those who program with a purpose. Just learn what you need to do to accomplish an idea you have; learning any of the points you listed is useless if you're not going to use it. ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "accomplish": 0.2566168490032359,
                "basic": 0.2076461737578399,
                "experience": 0.16556145323277632,
                "going": 0.14926662986093178,
                "good": 0.25254207547313007,
                "idea": 0.16721775188732782,
                "learn": 0.31340389645482647,
                "learning": 0.3551304760065668,
                "like": 0.10293329656772612,
                "listed": 0.28875907666303674,
                "math": 0.26995707879241093,
                "need": 0.13592640007175674,
                "points": 0.20970746566308424,
                "program": 0.17652313948622786,
                "programmers": 0.3094567958847651,
                "purpose": 0.21901285326198422,
                "things": 0.13723272399001654,
                "trying": 0.1786312948946502,
                "use": 0.10876540321441569,
                "useless": 0.24184969332288508
            },
            "Max term": "learning",
            "Max score": 0.3551304760065668
        }
    },
    {
        "ID": "7364",
        "Question": "This question is something that's been bugging me for the past 3 months since I switched from being a freelancer to working at a Web Design firm. Our sales people often ask us something similar to the following series of questions:  How much does it cost to program a widget How many hours will it take to convert this website to this software. (Without knowing what the website currently runs) etc    How can we give a quote without any information? (No, I can't ask for more info!)  I have another question if a project goes over budget it's bad. Recently, I missed an entire menu when calculating the cost of transferring a website over to a new platform so the project went over budget. My boss was not happy at all, and it's my opinion that some things like this can't be avoided. Â Â Â 2.Â Â What is the general practice for dealing with going over budget    Â Â Â Â Â Â Â Â and do projects like web development often go over budget? If you work at a web development/design/similar company: Â Â Â 3.Â Â How does your billable hour system work? For me, we have a time tracking application that we record how many hours we spend on which project and if they are billable or internal (AKA non-billable). If don't meet xx billable hours a week we can get in trouble/fired eventually. Work you do for the company or for clients that isn't billable isn't part of this system, and we often have to do internal work, so I'm wondering if any alternative systems exist. EDIT: Ok I am a developer at this firm not a designer :) Second, I am paid salary, but here is how management looks at it. You have 35 hours a week that you must work. You could be doing work that they bill to clients in that 35 hours and you should. If they figure out a project will take 50 hours and I take 55 hours, that 5 hours could have been spent on another project that wasn't over budget so we just \"lost\" money. Another example is that if I only have 1 project, that is due in two weeks and I spend a day  doing internal work, some how we lost money because I wasn't working. If I worked that day, I would finish a day early and still have no work. Either way, the work is contract so we will get paid the same amount regardless of which days I work! ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "50": 0.059251378754585346,
                    "aka": 0.07194409154306947,
                    "alternative": 0.0639358813912779,
                    "application": 0.04124950282093484,
                    "ask": 0.08901168670347694,
                    "avoided": 0.06725958890637691,
                    "bad": 0.0425345376377967,
                    "billable": 0.35972045771534733,
                    "boss": 0.05334960340186243,
                    "budget": 0.33629794453188455,
                    "clients": 0.1133466218339229,
                    "company": 0.0850690752755934,
                    "contract": 0.05592767123948632,
                    "convert": 0.06725958890637691,
                    "cost": 0.10449689257412217,
                    "currently": 0.05334960340186243,
                    "day": 0.13690170042377475,
                    "days": 0.049462203356565725,
                    "dealing": 0.061357813553653995,
                    "design": 0.08249900564186968,
                    "designer": 0.07194409154306947,
                    "developer": 0.039732124788535335,
                    "development": 0.0727281326715547,
                    "early": 0.05522725042628082,
                    "edit": 0.04791946108769475,
                    "entire": 0.058326612929742366,
                    "eventually": 0.059251378754585346,
                    "example": 0.03839109597642087,
                    "exist": 0.05522725042628082,
                    "figure": 0.05456687611789279,
                    "finish": 0.06547862366014887,
                    "fired": 0.07194409154306947,
                    "following": 0.0517348770678987,
                    "general": 0.05077153556423853,
                    "goes": 0.0517348770678987,
                    "going": 0.03718966069271614,
                    "happy": 0.060256656438852654,
                    "hour": 0.06725958890637691,
                    "hours": 0.40994534882235023,
                    "info": 0.06547862366014887,
                    "information": 0.04791946108769475,
                    "internal": 0.1877252588090531,
                    "knowing": 0.060256656438852654,
                    "like": 0.05129149598812495,
                    "looks": 0.05456687611789279,
                    "lost": 0.11494082701671458,
                    "management": 0.04721904027448925,
                    "meet": 0.061357813553653995,
                    "menu": 0.06936602370544558,
                    "missed": 0.06257508626968436,
                    "money": 0.10154307112847706,
                    "months": 0.059251378754585346,
                    "new": 0.03408191096197343,
                    "non": 0.0425345376377967,
                    "ok": 0.05522725042628082,
                    "opinion": 0.0517348770678987,
                    "paid": 0.11850275750917069,
                    "past": 0.05334960340186243,
                    "people": 0.03217704742303149,
                    "platform": 0.05747041350835729,
                    "practice": 0.05224844628706109,
                    "program": 0.043980598128477336,
                    "project": 0.2038405649291233,
                    "projects": 0.04187416332940868,
                    "question": 0.07381571270893719,
                    "questions": 0.046242114518738095,
                    "quote": 0.05747041350835729,
                    "recently": 0.05667331091696145,
                    "record": 0.06725958890637691,
                    "regardless": 0.0639358813912779,
                    "runs": 0.06257508626968436,
                    "salary": 0.06725958890637691,
                    "sales": 0.060256656438852654,
                    "second": 0.05334960340186243,
                    "series": 0.06547862366014887,
                    "similar": 0.09376827103788365,
                    "software": 0.03397342748818721,
                    "spend": 0.10063680555590161,
                    "spent": 0.06257508626968436,
                    "switched": 0.06725958890637691,
                    "systems": 0.049882373481200254,
                    "things": 0.034191422730457714,
                    "time": 0.028355856183985777,
                    "tracking": 0.06547862366014887,
                    "transferring": 0.06936602370544558,
                    "trouble": 0.0639358813912779,
                    "way": 0.031635382363896056,
                    "web": 0.1276036129133901,
                    "website": 0.16568175127884247,
                    "week": 0.11045450085256164,
                    "weeks": 0.05522725042628082,
                    "went": 0.05522725042628082,
                    "wondering": 0.05592767123948632,
                    "work": 0.30462290983054435,
                    "worked": 0.04721904027448925,
                    "working": 0.07678219195284174
                },
                "Max term": "hours",
                "Max score": 0.40994534882235023
            }
        ],
        "Best Answer": " Our sales people often ask us   something similar to the following   series of questions: How much does it cost to program a   widget How many hours will it take to   convert this website to this software.  Why are your sales people asking the designers? Sales should have a prestocked list of quotes and system for estimation that has little, if any, correlation to your actual costs. I'm assuming you are salaried.   How can we give a quote without any information? (No, I can't ask for more info!)  Short answer? You can't, don't try. The long answer is still short. If I call you up and say I have a website were people can login, post messages to other users, upload pictures, and make friends, what would it cost to build, what would you say? I could have described the worst social network imaginable, or Facebook. You don't have enough information so you can't give an accurate assessment.   I have another question if a project   goes over budget it's bad. Recently, I   missed an entire menu when calculating   the cost of transferring a website   over to a new platform so the project   went over budget. My boss was not   happy at all, and it's my opinion that   some things like this can't be   avoided.  Define \"over budget.\" Again, I'm assuming salary not hourly. If you went over your time budget, pull some long nights and don't make the same mistake (of missing something) again.  For me, we have a time tracking   application that we record how many   hours we spend on which project and if   they are billable or internal (AKA   non-billable). If don't meet xx   billable hours a week we can get in   trouble/fired eventually. Work you do   for the company or for clients that   isn't billable isn't part of this   system, and we often have to do   internal work, so I'm wondering if any   alternative systems exist.  I'm not sure how I would set that up if I had to create a record of \"billable\" hours. You would probably wind up with a hundred hours +/- a few ever week. I don't stop thinking about code, should that count?  ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "accurate": 0.07814337100621756,
                "actual": 0.06677013519835108,
                "aka": 0.08358590839710493,
                "alternative": 0.07428182927378048,
                "answer": 0.09883474488180054,
                "application": 0.04792439643431599,
                "ask": 0.10341534004379753,
                "asking": 0.05898726121674978,
                "assuming": 0.14001448228444408,
                "avoided": 0.07814337100621756,
                "bad": 0.04941737244090027,
                "billable": 0.4179295419855247,
                "boss": 0.061982505683602904,
                "budget": 0.31257348402487023,
                "build": 0.05526062462801021,
                "clients": 0.06584404741603998,
                "code": 0.029257494335435084,
                "company": 0.04941737244090027,
                "convert": 0.07814337100621756,
                "cost": 0.18210948605669275,
                "costs": 0.07128658480692736,
                "count": 0.07814337100621756,
                "create": 0.053724900340673225,
                "define": 0.06677013519835108,
                "described": 0.07607421432167553,
                "designers": 0.08059066393025181,
                "entire": 0.06776488271507668,
                "estimation": 0.07607421432167553,
                "eventually": 0.0688392918828931,
                "exist": 0.0641639889551121,
                "fired": 0.08358590839710493,
                "following": 0.06010648828533906,
                "friends": 0.08358590839710493,
                "goes": 0.06010648828533906,
                "happy": 0.07000724114222204,
                "hourly": 0.07270083361533018,
                "hours": 0.2976760637978433,
                "info": 0.07607421432167553,
                "information": 0.11134734205426314,
                "internal": 0.14540166723066036,
                "like": 0.029795680182071096,
                "list": 0.05609983217943228,
                "little": 0.05301826620086485,
                "login": 0.08358590839710493,
                "long": 0.09273918380761423,
                "make": 0.07586362009213324,
                "meet": 0.07128658480692736,
                "menu": 0.08059066393025181,
                "messages": 0.07814337100621756,
                "missed": 0.07270083361533018,
                "missing": 0.07128658480692736,
                "mistake": 0.07000724114222204,
                "network": 0.07814337100621756,
                "new": 0.03959696239906481,
                "non": 0.04941737244090027,
                "opinion": 0.06010648828533906,
                "people": 0.11215157550974322,
                "platform": 0.06677013519835108,
                "post": 0.06267101294852782,
                "probably": 0.047461490258216624,
                "program": 0.05109743090182815,
                "project": 0.11841277318499373,
                "pull": 0.07814337100621756,
                "question": 0.042880195360188715,
                "questions": 0.053724900340673225,
                "quote": 0.06677013519835108,
                "recently": 0.06584404741603998,
                "record": 0.15628674201243511,
                "salary": 0.07814337100621756,
                "sales": 0.2100217234266661,
                "say": 0.0870863835732493,
                "series": 0.07607421432167553,
                "set": 0.05267842656027844,
                "short": 0.12021297657067812,
                "similar": 0.054470811608173506,
                "social": 0.07428182927378048,
                "software": 0.03947092439499791,
                "spend": 0.05846080359175223,
                "stop": 0.0688392918828931,
                "sure": 0.04915672446842777,
                "systems": 0.05795421710111835,
                "things": 0.039724195093961676,
                "thinking": 0.05267842656027844,
                "time": 0.06588866289588831,
                "tracking": 0.07607421432167553,
                "transferring": 0.08059066393025181,
                "trouble": 0.07428182927378048,
                "try": 0.04792439643431599,
                "users": 0.054092675368681266,
                "website": 0.19249196686533632,
                "week": 0.1283279779102242,
                "went": 0.1283279779102242,
                "wind": 0.08358590839710493,
                "wondering": 0.06497775015045602,
                "work": 0.07078324874395683,
                "worst": 0.07428182927378048
            },
            "Max term": "billable",
            "Max score": 0.4179295419855247
        }
    },
    {
        "ID": "7439",
        "Question": "If you were hiring programmers, and could choose between one of (say) the top 100 coders on topcoder.com, or one of the top 100 on stackoverflow.com, which would you choose? At least to me, it would appear that topcoder.com gives a more objective evaluation of pure ability to solve problems and write code. At the same time, despite obvious technical capabilities, this person may lack any hint of social skills -- he may be purely a \"lone coder\", with little or no ability to help/work with others, may lack mentoring ability to help transfer his technical skills to others, etc. On the other hand, stackoverflow.com would at least appear to give a much better indication of peers' opinion of the coder in question, and the degree to which his presence and useful and helpful to others on the \"team\". At the same time, the scoring system is such that somebody who just throws up a lot of mediocre (or even poor answers) will almost inevitably accumulate a positive total of \"reputation\" points -- a single up-vote (perhaps just out of courtesy) will counteract the effects of no fewer than 5 down-votes, and others are discouraged (to some degree) from down-voting because they have to sacrifice their own reputation points to do so. At the same time, somebody who makes little or no technical contribution seems unlikely to accumulate a reputation that lands them (even close to) the top of the heap, so to speak. So, which provides a more useful indication of the degree to which this particular coder is likely to be useful to your organization? If you could choose between them, which set of coders would you rather have working on your team? ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "100": 0.15659387251527657,
                    "ability": 0.22111521786928598,
                    "answers": 0.07014334647926607,
                    "appear": 0.18584478867076212,
                    "better": 0.04969760409044067,
                    "choose": 0.22616038230629087,
                    "close": 0.08476880455700886,
                    "code": 0.03479087721575465,
                    "coder": 0.271385712604742,
                    "coders": 0.18584478867076212,
                    "com": 0.3090671950676983,
                    "degree": 0.24174316027037734,
                    "despite": 0.09046190420158065,
                    "effects": 0.08645052603601049,
                    "fewer": 0.09046190420158065,
                    "gives": 0.08058105342345911,
                    "hand": 0.07079493046755402,
                    "help": 0.10787729880206057,
                    "helpful": 0.07292630396829657,
                    "hiring": 0.08476880455700886,
                    "inevitably": 0.09292239433538106,
                    "lack": 0.16116210684691823,
                    "likely": 0.06723320432372475,
                    "little": 0.12609090638035003,
                    "lot": 0.05098999916602779,
                    "makes": 0.0559056384293309,
                    "objective": 0.0883305307008381,
                    "obvious": 0.07726679876692458,
                    "opinion": 0.07147424963431438,
                    "organization": 0.07939817226766713,
                    "particular": 0.06477271418992435,
                    "person": 0.06777432703244075,
                    "points": 0.14436754099271507,
                    "poor": 0.08476880455700886,
                    "positive": 0.09292239433538106,
                    "presence": 0.09583253649092238,
                    "problems": 0.060067244444512745,
                    "programmers": 0.053259330234269917,
                    "provides": 0.08645052603601049,
                    "pure": 0.09583253649092238,
                    "purely": 0.09583253649092238,
                    "question": 0.05098999916602779,
                    "reputation": 0.25935157810803144,
                    "say": 0.051778386134582376,
                    "set": 0.0626413406891818,
                    "single": 0.06523540140323887,
                    "skills": 0.1378298516054528,
                    "social": 0.0883305307008381,
                    "solve": 0.07079493046755402,
                    "somebody": 0.17290105207202097,
                    "speak": 0.09292239433538106,
                    "stackoverflow": 0.16371732480293508,
                    "team": 0.11880416380116524,
                    "technical": 0.19038018985568844,
                    "throws": 0.09939426263475164,
                    "time": 0.11752498459572942,
                    "total": 0.08645052603601049,
                    "transfer": 0.09292239433538106,
                    "unlikely": 0.09583253649092238,
                    "useful": 0.1929691865045503,
                    "vote": 0.09583253649092238,
                    "work": 0.04208513702078446,
                    "working": 0.05303916686517564,
                    "write": 0.04900351251059922
                },
                "Max term": "com",
                "Max score": 0.3090671950676983
            }
        ],
        "Best Answer": "Why choose? When you are hiring, you want to post your offer everywhere. Hiring based on reputation points or any other online results is a terrible idea and I'm pretty sure no one is doing it. Sure that having 30K on StackOverflow will helps getting the attention of the hiring guy, but you will get hired for many others facts.  The experience in your domain or industry of the candidate His physical location related to your office The amount of $$$ he is asking for the job His personnal interests (yes it has an influence, at least on me) His recommandations What people said about him during references checks And more importantely, his seduction abilities! (during interview, you have to seduce within the first 5 minutes)  They are so many factors you can't summarize the hiring process to programmer's (supposed) capabilities. ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "asking": 0.11943056389215272,
                "attention": 0.154026244424284,
                "based": 0.10805117695699021,
                "candidate": 0.14719621448779777,
                "choose": 0.12835839436740343,
                "domain": 0.1393778127331646,
                "experience": 0.09703175859122903,
                "factors": 0.13518842430388966,
                "facts": 0.16317062767613078,
                "getting": 0.10285882490805331,
                "guy": 0.1393778127331646,
                "helps": 0.13155941097853147,
                "hiring": 0.5773312302229457,
                "idea": 0.09800247712543673,
                "industry": 0.1241690059381285,
                "interview": 0.13331338918997523,
                "job": 0.09388377073774279,
                "location": 0.14433280755573644,
                "minutes": 0.13518842430388966,
                "offer": 0.1393778127331646,
                "office": 0.1503972310989258,
                "online": 0.1503972310989258,
                "people": 0.07569050010817467,
                "physical": 0.154026244424284,
                "points": 0.12290472078902046,
                "post": 0.12688899707738457,
                "pretty": 0.10598609051145526,
                "process": 0.10345615070381974,
                "programmer": 0.08748173751548674,
                "references": 0.154026244424284,
                "related": 0.12688899707738457,
                "reputation": 0.14719621448779777,
                "results": 0.13518842430388966,
                "said": 0.10734523519724867,
                "stackoverflow": 0.1393778127331646,
                "supposed": 0.13518842430388966,
                "sure": 0.19905366688523105,
                "terrible": 0.15821563285355894,
                "want": 0.07991614902270712,
                "yes": 0.11028618064030596
            },
            "Max term": "hiring",
            "Max score": 0.5773312302229457
        }
    },
    {
        "ID": "7455",
        "Question": "I mean, I still have a MSX2 with a Z80 processor and if you look at any Konami's game made for that computer in its time (roughly between '84 and '90) is amazing the high quality code of those games. I was a kid at the time, trying to learn how to program a computer and still today fascinated me how well made they are, mostly zero bugs or glitches, despite the really complex behavior. What hardware/software tools could they have used to accomplish that quality, which metodology? I know computers are really more complex today but at that time, even a stock control program I made in Basic was plagued with many bugs and was painful to debug. Any light you can shed will be deeply appreciated.  ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "90": 0.15900401626709168,
                    "accomplish": 0.16568487917027777,
                    "amazing": 0.17975667193550615,
                    "appreciated": 0.17975667193550615,
                    "basic": 0.13406692250673058,
                    "behavior": 0.15900401626709168,
                    "bugs": 0.2522236704845528,
                    "code": 0.06525854924661496,
                    "complex": 0.27358119022843186,
                    "computer": 0.23651342771679829,
                    "computers": 0.15900401626709168,
                    "control": 0.12513011603233296,
                    "debug": 0.14686449091069087,
                    "despite": 0.16968277613903118,
                    "game": 0.14311713727361383,
                    "games": 0.1449322235018633,
                    "hardware": 0.14311713727361383,
                    "high": 0.12513011603233296,
                    "know": 0.0813027302836455,
                    "learn": 0.1011747414819153,
                    "light": 0.16968277613903118,
                    "look": 0.1074248091337878,
                    "mean": 0.12417956783344884,
                    "program": 0.22794461977175126,
                    "quality": 0.26558539629092504,
                    "really": 0.17388134646629091,
                    "software": 0.08803950310675443,
                    "stock": 0.18643753483869224,
                    "time": 0.22044600794012245,
                    "today": 0.29372898182138174,
                    "tools": 0.12325827196070037,
                    "trying": 0.11533344215553507,
                    "used": 0.09097712752006505,
                    "zero": 0.17975667193550615
                },
                "Max term": "today",
                "Max score": 0.29372898182138174
            }
        ],
        "Best Answer": "I don't know anything about Konami, so I'm taking an educated guess here.  Games on machines like the MSX would have required direct access to the hardware, so that pretty much limits the choice of languages to either C or Z80 assembly language.  (There were C compilers for the Z80 back then, for example this one.) I doubt if the games were completely written in C, if at all; mostly likely a lot of assembly code for performance reasons. As far as platforms go, since the MSX didn't have a hard drive, I would further assume the programs were initially written on a larger Z80 system, perhaps running CP/M.  For debugging, the code could probably have been downloaded into a special game cartridge for the MSX that had RAM memory in place of ROM -- this would have allowed the developer to download the program over and over again without burning ROM chips.  Debugging (e.g. setting breakpoints) could have been accomplished by replacing the Z80 inside the MSX with an In-Circuit Emulator (ICE) interface. ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "access": 0.11235034133142668,
                "accomplished": 0.15277600387043416,
                "allowed": 0.1421354453331139,
                "assembly": 0.3055520077408683,
                "assume": 0.13686927510270244,
                "burning": 0.1634165624077544,
                "choice": 0.12252641258625124,
                "code": 0.11440108125035937,
                "completely": 0.12118033054222703,
                "debugging": 0.3055520077408683,
                "developer": 0.09024906855917962,
                "doubt": 0.1634165624077544,
                "download": 0.1634165624077544,
                "drive": 0.13937048550806214,
                "example": 0.08720300440206523,
                "far": 0.11053977200490678,
                "game": 0.12544528983998832,
                "games": 0.25407250495216843,
                "guess": 0.132485300424707,
                "hard": 0.10803856159954707,
                "hardware": 0.12544528983998832,
                "initially": 0.1452264074419193,
                "inside": 0.1421354453331139,
                "interface": 0.12544528983998832,
                "know": 0.07126361496258547,
                "language": 0.07692442189828837,
                "languages": 0.08945376992842057,
                "larger": 0.1452264074419193,
                "like": 0.05825273330550486,
                "likely": 0.11053977200490678,
                "limits": 0.15756064047389723,
                "lot": 0.0838339171699148,
                "machines": 0.13937048550806214,
                "memory": 0.13686927510270244,
                "performance": 0.12544528983998832,
                "place": 0.11330473182995855,
                "platforms": 0.13686927510270244,
                "pretty": 0.1023421711379012,
                "probably": 0.09279068366284,
                "program": 0.09989921346758654,
                "programs": 0.11330473182995855,
                "ram": 0.15756064047389723,
                "reasons": 0.11532440860836984,
                "required": 0.11989993775994154,
                "running": 0.11989993775994154,
                "setting": 0.13458584890459904,
                "special": 0.13458584890459904,
                "taking": 0.13458584890459904,
                "written": 0.22285889043394455
            },
            "Max term": "assembly",
            "Max score": 0.3055520077408683
        }
    },
    {
        "ID": "7456",
        "Question": "Linguistic relativity is the idea that language shapes the way we think.  My question is, how much, and to what extent, does this apply to programming?  Are some native, natural languages better-suited for thinking about programming than others?  For instance, can the following be stated more concisely in a non-English language?  Select a pivot.  Move all the items less than the pivot to one side of the list, and all the items greater than the pivot to the other side. Does a Chinese-speaking programmer view programming in a radically different lens than an English-speaking programmer, or do the differences fade away when both are immersed in the subject? Are some programming languages and domains easier to think about in one language or another.  For instance, is it any easier to grok Ruby if you are Japanese because the creator of Ruby is Japanese?  Note that this question is not focused on \"how do programming languages affect the way people think about programming\", but rather \"how do natural languages affect the way people think about programming\". To get it out of the way, one language that clearly has a pragmatic advantage is English.  I think the advantage has little to do with programming languages choosing English keywords like if, for, while, and do, just as musicians who don't speak Italian aren't tripped up by words like forte.  It has more to do with communication of ideas with other programmers, as English is the lingua franca these days, at least in the programming world.  For instance, to ask a question in StackOverflow, you really need to know English and know it pretty well if you want good answers.  Although this sounds like an imperialist attitude, it really is true in practice. That aside, how do the intrinsic properties of languages affect how programmers who speak them think about data structures, algorithms, etc.?  Are any languages particularly concise when it comes to talking about logic and programming, allowing native speakers of those languages to think faster? ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "advantage": 0.13300056732972507,
                    "affect": 0.2071768282485119,
                    "algorithms": 0.06342533798769599,
                    "allowing": 0.07655353824347613,
                    "answers": 0.05603234093396383,
                    "apply": 0.06650028366486253,
                    "aside": 0.07226333661250173,
                    "ask": 0.049117415113099486,
                    "attitude": 0.07226333661250173,
                    "away": 0.05505104634776174,
                    "better": 0.039699746815185934,
                    "choosing": 0.07939873830337697,
                    "clearly": 0.0625456418417339,
                    "comes": 0.06094974458307341,
                    "communication": 0.0677155396186704,
                    "concise": 0.07939873830337697,
                    "creator": 0.07939873830337697,
                    "data": 0.048537745439991675,
                    "days": 0.054587339362890265,
                    "differences": 0.07056073967857124,
                    "different": 0.042723278967903046,
                    "easier": 0.102765890999785,
                    "english": 0.4143536564970238,
                    "extent": 0.0677155396186704,
                    "faster": 0.0595315580308996,
                    "focused": 0.07422884052644048,
                    "following": 0.057095501206133034,
                    "good": 0.034720159090412886,
                    "greater": 0.07655353824347613,
                    "idea": 0.04597908635535023,
                    "ideas": 0.06094974458307341,
                    "instance": 0.21168221903571371,
                    "items": 0.14845768105288096,
                    "know": 0.06924929800993598,
                    "language": 0.1495001963926011,
                    "languages": 0.3477011810381898,
                    "like": 0.08490926731721628,
                    "list": 0.053289555374771605,
                    "little": 0.05036235801113872,
                    "logic": 0.0595315580308996,
                    "native": 0.14845768105288096,
                    "natural": 0.13811788549900794,
                    "need": 0.03737504909815027,
                    "non": 0.04694184818133117,
                    "note": 0.0595315580308996,
                    "particularly": 0.06437025441288095,
                    "people": 0.07102228724890305,
                    "practice": 0.057662285040056806,
                    "pragmatic": 0.06650028366486253,
                    "pretty": 0.04972469830384862,
                    "programmer": 0.08208629989203901,
                    "programmers": 0.08508989375017353,
                    "programming": 0.3370694825028104,
                    "properties": 0.07422884052644048,
                    "question": 0.12219643747698598,
                    "radically": 0.07939873830337697,
                    "really": 0.0740513949396559,
                    "ruby": 0.12685067597539199,
                    "select": 0.07056073967857124,
                    "sounds": 0.06094974458307341,
                    "speak": 0.14845768105288096,
                    "speakers": 0.07655353824347613,
                    "speaking": 0.14845768105288096,
                    "stackoverflow": 0.06539084190163474,
                    "structures": 0.07056073967857124,
                    "subject": 0.06905894274950397,
                    "suited": 0.0677155396186704,
                    "talking": 0.05887754099386467,
                    "think": 0.23594863775196728,
                    "thinking": 0.050039542369058936,
                    "true": 0.061722741053765504,
                    "view": 0.06539084190163474,
                    "want": 0.037493659598001855,
                    "way": 0.13965341095089379,
                    "words": 0.06539084190163474,
                    "world": 0.049117415113099486
                },
                "Max term": "english",
                "Max score": 0.4143536564970238
            }
        ],
        "Best Answer": "I don't know that any particular natural language lends itself to better programming (except maybe Latin?). I do know that knowing more than one language is pretty powerful. Dijkstra said in one of his last interviews (as reprinted in CACM Vol. 53 No. 8, p. 44):  There is an enormous difference   between one who is monolingual and   someone who at least knows a second   language well, because it makes you   much more conscious about language   structure in general. You will   discover that certain constructions in   one language you just can't translate.  ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "better": 0.1177777935595374,
                "certain": 0.1677761103029353,
                "conscious": 0.22711245150922144,
                "difference": 0.19399592430723195,
                "dijkstra": 0.23555334627992564,
                "general": 0.16623192872992382,
                "interviews": 0.20089263750492473,
                "know": 0.20544285995388972,
                "knowing": 0.19728732068726607,
                "knows": 0.17467282350062804,
                "language": 0.5544054018092232,
                "makes": 0.1324901443892824,
                "maybe": 0.15809486848940224,
                "natural": 0.20487813034313165,
                "particular": 0.1535041276088242,
                "powerful": 0.20933353227562895,
                "pretty": 0.14751895720908598,
                "programming": 0.09999887432594493,
                "said": 0.14941071117205384,
                "second": 0.17467282350062804,
                "structure": 0.20933353227562895,
                "translate": 0.21438465038812182
            },
            "Max term": "language",
            "Max score": 0.5544054018092232
        }
    },
    {
        "ID": "7472",
        "Question": "Let's say a large corporation is planning to replace it's existing version control system. Let's say it is only considering systems from major vendors that cost hundreds of thousands of dollars because they have \"support.\"  Does version control in an enterprisey environment have to be expensive?  Does your medium/large corporation use a FOSS VCS such as SVN/Git/Mercurial?  What has the experience been?   I have to think it doesn't need to be expensive since there are so many free options, and there are probably companies that provide paid support for FOSS VCS if that is the main concern.   I don't intend this question to compare VCS or decide which is best, rather just understand experiences with VCS in a corporate IT environment. ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "best": 0.07362696999986891,
                    "companies": 0.10043513158019295,
                    "compare": 0.1346632313228028,
                    "concern": 0.1346632313228028,
                    "considering": 0.11697882668351442,
                    "control": 0.18748039312562342,
                    "corporate": 0.12412146358830461,
                    "cost": 0.10143214549083614,
                    "decide": 0.11002232462174086,
                    "environment": 0.18333668858764643,
                    "existing": 0.10043513158019295,
                    "expensive": 0.2693264626456056,
                    "experience": 0.08007942568416354,
                    "experiences": 0.11323195059567563,
                    "free": 0.0891736511925472,
                    "git": 0.12412146358830461,
                    "hundreds": 0.1396681447809829,
                    "intend": 0.1346632313228028,
                    "large": 0.18895128685812518,
                    "let": 0.1820363587097541,
                    "main": 0.10593301257153731,
                    "major": 0.10857478239562635,
                    "medium": 0.1214796937642156,
                    "mercurial": 0.12412146358830461,
                    "need": 0.06574542467779712,
                    "options": 0.11697882668351442,
                    "paid": 0.11502723807992096,
                    "planning": 0.10472033238522548,
                    "probably": 0.07930593110758613,
                    "provide": 0.10143214549083614,
                    "question": 0.07165080153643581,
                    "replace": 0.1214796937642156,
                    "say": 0.1455172751317742,
                    "support": 0.18467583996490497,
                    "svn": 0.13057391927259923,
                    "systems": 0.09683878706315367,
                    "think": 0.059292968993502504,
                    "understand": 0.07645395243594062,
                    "use": 0.05260808511671474,
                    "vcs": 0.5586725791239316,
                    "vendors": 0.1346632313228028,
                    "version": 0.2008702631603859
                },
                "Max term": "vcs",
                "Max score": 0.5586725791239316
            }
        ],
        "Best Answer": "Yes. Â Â  In my (admittedly limited) experience, the non-FOSS solutions tend to be more \"enterprise-y\".  That is,  They integrate with everything under the sun. They have more built-in controls for complex business logic (permissions, access control, approval, etc). They come with support contracts and reasonably responsive tech support lines. They're well advertised to the non-technical people making VCS decisions at a high level in big companies.  These attributes make them attractive to large companies, especially to people who don't have to use them.  The FOSS alternatives, as counters to the above:  Have plenty of third-party tools to integrate them with everything under the sun (by virtue of being more popular than proprietary alternatives), and tend to be easier to develop third-party tools for, being OS. See previous- easier to to get external tools around a clean, simple, basic tool. By virtue of being more popular, they have a wider community-based support. They don't need said advertising.  Aside from that, my experience with common free VCS (mercurial/svn/etc) has them being faster, more reliable, and easier to use. ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "access": 0.08084810927125854,
                "admittedly": 0.1099387052016732,
                "advertising": 0.11759572723772337,
                "alternatives": 0.23519145447544673,
                "aside": 0.10702764052876786,
                "attributes": 0.11338176392633631,
                "based": 0.07508111730756296,
                "basic": 0.08456289268329543,
                "big": 0.0731910872352084,
                "built": 0.09393787490001321,
                "business": 0.07663414595987149,
                "clean": 0.10450596160896872,
                "come": 0.07832643035145942,
                "common": 0.07147312705454079,
                "community": 0.10450596160896872,
                "companies": 0.16912578536659087,
                "complex": 0.08628085286396306,
                "contracts": 0.10450596160896872,
                "control": 0.07892598991342745,
                "controls": 0.10702764052876786,
                "decisions": 0.10228168316562304,
                "develop": 0.08720223266882701,
                "easier": 0.22830645572434122,
                "enterprise": 0.10228168316562304,
                "especially": 0.08628085286396306,
                "experience": 0.13484819054302563,
                "external": 0.1099387052016732,
                "faster": 0.08817088293631763,
                "free": 0.07508111730756296,
                "high": 0.07892598991342745,
                "integrate": 0.23519145447544673,
                "large": 0.07954521063277685,
                "level": 0.0718881885967267,
                "limited": 0.10029199829758166,
                "lines": 0.09849210939856712,
                "logic": 0.08817088293631763,
                "make": 0.053365679375267545,
                "making": 0.07892598991342745,
                "mercurial": 0.10450596160896872,
                "need": 0.05535536424330895,
                "non": 0.13904908044443468,
                "os": 0.09533736986143085,
                "party": 0.1936978791458371,
                "people": 0.10518954957708716,
                "popular": 0.18787574980002641,
                "previous": 0.08540234376981246,
                "proprietary": 0.11338176392633631,
                "reasonably": 0.10702764052876786,
                "reliable": 0.1099387052016732,
                "responsive": 0.11759572723772337,
                "said": 0.07459058219662605,
                "simple": 0.07274672461661037,
                "solutions": 0.0926349762615315,
                "sun": 0.23519145447544673,
                "support": 0.23323596520128692,
                "svn": 0.1099387052016732,
                "tech": 0.09684893957291855,
                "technical": 0.07508111730756296,
                "tend": 0.17838383507373679,
                "tool": 0.08224760423267621,
                "tools": 0.23323596520128692,
                "use": 0.08858836118408109,
                "vcs": 0.23519145447544673,
                "wider": 0.11759572723772337,
                "yes": 0.07663414595987149
            },
            "Max term": "alternatives",
            "Max score": 0.23519145447544673
        }
    },
    {
        "ID": "7482",
        "Question": "As per this question: I decided to implement the BitTorrent spec to make my own client/tracker. Now, I was going through the spec, I was about 70% done implementing the BEncoding when I found a link to an implementation of BEncoding in C# written by someone else. Normally, if I were working on production code, I'd use it as a reference to check my own work against, and a baseline to write some tests to run my code against, but I found myself thinking \"I'm making this, it's a for-fun project with no deadlines; I should really implement it myself - I could learn a lot\" but some voice in my head was saying \"Why bother re-inventing the wheel? Take the code, work it so that it's you're style/naming convention and you're done.\" So I'm a bit conflicted. I ended up doing the latter, and some parts of it I found better than what I had written, but I almost feel like I 'cheated'. What's your take? Is it cheating myself? Perfectly normal? A missed opportunity to learn on my own? A good opportunity to have learned from someone else's example? ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "70": 0.15726426117603412,
                    "baseline": 0.1516288027937026,
                    "better": 0.07863287862220714,
                    "bit": 0.1039711294751112,
                    "bother": 0.1367843348794985,
                    "check": 0.10637817439546154,
                    "client": 0.10903903910624409,
                    "code": 0.1651411698009458,
                    "convention": 0.12749749830123583,
                    "deadlines": 0.1516288027937026,
                    "decided": 0.14313124471899563,
                    "ended": 0.1516288027937026,
                    "example": 0.08391998863250161,
                    "feel": 0.09450830015280648,
                    "fun": 0.12072252979764732,
                    "going": 0.08129374333298967,
                    "good": 0.06876986062933337,
                    "head": 0.125625912094009,
                    "implement": 0.22842218524675803,
                    "implementation": 0.12749749830123583,
                    "implementing": 0.1516288027937026,
                    "inventing": 0.15726426117603412,
                    "learn": 0.17068634792447968,
                    "learned": 0.11661813754372936,
                    "like": 0.05605963636608763,
                    "link": 0.12951896540277968,
                    "lot": 0.08067774068287392,
                    "make": 0.07136750914548833,
                    "making": 0.10555007212320368,
                    "missed": 0.1367843348794985,
                    "naming": 0.13975892855104752,
                    "normal": 0.13171642524836563,
                    "normally": 0.13975892855104752,
                    "opportunity": 0.26343285049673126,
                    "parts": 0.12951896540277968,
                    "perfectly": 0.14702429802776631,
                    "production": 0.12388350702044816,
                    "project": 0.07426330444868917,
                    "question": 0.08067774068287392,
                    "really": 0.07333641669306215,
                    "reference": 0.13171642524836563,
                    "run": 0.09728635698370575,
                    "saying": 0.12388350702044816,
                    "spec": 0.28626248943799126,
                    "style": 0.11661813754372936,
                    "tests": 0.09975220252798139,
                    "thinking": 0.09911280491874275,
                    "tracker": 0.1516288027937026,
                    "use": 0.05923592420261428,
                    "voice": 0.15726426117603412,
                    "wheel": 0.1516288027937026,
                    "work": 0.13317645917626195,
                    "working": 0.08391998863250161,
                    "write": 0.07753466835736125,
                    "written": 0.21446870644087143
                },
                "Max term": "spec",
                "Max score": 0.28626248943799126
            }
        ],
        "Best Answer": " If I have seen further it is by standing on the shoulders of giants. Isaac Newton  It is not cheating if the code is open source and you've taken the time to understand it. Now obviously this isn't always possible due to time constraints but try and always have high level overview of the code you are using. Always remember that C was derived from B. ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "code": 0.24668756330701924,
                "constraints": 0.35238157842368945,
                "derived": 0.33975422300894487,
                "high": 0.2365057435133065,
                "level": 0.21541661387513564,
                "obviously": 0.2775854184420402,
                "open": 0.21932081592004612,
                "possible": 0.207234981236657,
                "remember": 0.2464591297818863,
                "seen": 0.24027970733136345,
                "source": 0.2094544219585126,
                "taken": 0.2902127738567848,
                "time": 0.2777735084384592,
                "try": 0.2020397311505658,
                "understand": 0.19289269201902287,
                "using": 0.1653536081776057
            },
            "Max term": "constraints",
            "Max score": 0.35238157842368945
        }
    },
    {
        "ID": "7502",
        "Question": "I have the \"user's side\" of the story, I think they want it better if it's on Spanish. But, what about the programmers? Do you make your programs multi-language? Why? Why not?  Who translate your software? Are you ok with paying somebody to translate your app or you prefer doing it yourselves? Is the benefit bigger than the costs? ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "app": 0.1765451783535489,
                    "benefit": 0.2231148151531075,
                    "better": 0.13545630266726913,
                    "bigger": 0.2356304460707581,
                    "costs": 0.23104672864954923,
                    "language": 0.1275243891708274,
                    "make": 0.12294067174961852,
                    "multi": 0.2196325509356899,
                    "ok": 0.20796170535222266,
                    "paying": 0.2612021506039446,
                    "prefer": 0.1967448299162584,
                    "programmers": 0.14516418020757213,
                    "programs": 0.18783523307961805,
                    "software": 0.12792909048648582,
                    "somebody": 0.2356304460707581,
                    "spanish": 0.2709100281442476,
                    "story": 0.2465638998026426,
                    "think": 0.11500875825317682,
                    "translate": 0.4931277996052852,
                    "user": 0.1637199014475189,
                    "want": 0.12792909048648582
                },
                "Max term": "translate",
                "Max score": 0.4931277996052852
            }
        ],
        "Best Answer": "There's really only one question you need to answer:  Is there a demand for the application to be translated into one (or more) other language?  If the demand is there then you need to look into translation. There may be political (both with a lower case \"p\" and upper case \"P\" - bilingual countries like Canada spring to mind), social or ethical reasons that need to be considered as well as the cost. As to the methodology - when I worked on software that was translated we got our German and French distributors to do the translation. The benefit of this is that you are using someone who knows the product and will (hopefully) choose the most appropriate translation when more than one is available. If you don't have distributors familiar with the language then there are services available that will do the translation for you. Failing that there's always Google Translate :) ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "answer": 0.11086763998477353,
                "application": 0.10751815541632861,
                "appropriate": 0.16665093060512134,
                "available": 0.26004002073766036,
                "benefit": 0.15444062385969093,
                "case": 0.24441001343305682,
                "choose": 0.14223031711426054,
                "considered": 0.14223031711426054,
                "cost": 0.1361872552146949,
                "demand": 0.3616095422895479,
                "ethical": 0.18752458785729942,
                "failing": 0.17531428111186903,
                "familiar": 0.14772080714716548,
                "german": 0.18752458785729942,
                "google": 0.13484862053192925,
                "got": 0.12053155833631136,
                "hopefully": 0.16665093060512134,
                "knows": 0.1390574566404178,
                "language": 0.17654539172894804,
                "like": 0.06684646674563521,
                "look": 0.10805116617687581,
                "lower": 0.15993111389259587,
                "methodology": 0.157060912466873,
                "mind": 0.12684714989498738,
                "need": 0.26481808759342207,
                "political": 0.17067213793341005,
                "product": 0.12307794673020393,
                "question": 0.09620151430259961,
                "really": 0.08744759433870287,
                "reasons": 0.13233763992789233,
                "services": 0.15444062385969093,
                "social": 0.16665093060512134,
                "software": 0.08855283111064417,
                "translate": 0.17067213793341005,
                "upper": 0.17531428111186903,
                "using": 0.08799514254669769,
                "worked": 0.12307794673020393
            },
            "Max term": "demand",
            "Max score": 0.3616095422895479
        }
    },
    {
        "ID": "7505",
        "Question": "I've been handed the ER diagram for a quite complex database.  Complex to me at least, 849 tables. One of the architects says to understand the code, you need to understand the database and relationships. Now I am basically a Java programmer hence not too familiar with this How do I start? Should I start from something basic like USER or ORDER and see which relationships they have with other tables around them? Any tips or tutorials would help a lot ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "architects": 0.20776858356907582,
                    "basic": 0.1494060443182153,
                    "basically": 0.16366783265777754,
                    "code": 0.07272503551644299,
                    "complex": 0.304882685957434,
                    "database": 0.3081384807296156,
                    "diagram": 0.18909684728977924,
                    "familiar": 0.16366783265777754,
                    "handed": 0.20776858356907582,
                    "help": 0.11275054000715305,
                    "java": 0.1262789960161993,
                    "like": 0.07406279822306162,
                    "lot": 0.10658683531709087,
                    "need": 0.09780207063588907,
                    "order": 0.1615144869650438,
                    "programmer": 0.10740066292885883,
                    "quite": 0.13265360708421928,
                    "relationships": 0.41553716713815164,
                    "says": 0.15949172961081565,
                    "start": 0.23157167733530948,
                    "tables": 0.3884802551200591,
                    "tips": 0.16844243207296028,
                    "understand": 0.22746388492210756,
                    "user": 0.1255614355025195
                },
                "Max term": "relationships",
                "Max score": 0.41553716713815164
            }
        ],
        "Best Answer": "An ER Diagram is out there to visualize a design, which was made to accomplish a certain job. Understand what the job is first, then ask questions to the diagram.  \"How is an order stored?\", \"How do I retrieve user information\", \"How can I tell which user ordered a certain product between these intervals and with these options?\". Such questions might help you understand the design. If there is a requirements analysis documentation, it will help you a lot with coming up with these questions. You can explore how certain requirements are handled. I suspect that a database with 849 tables is highly normalized so most of those tables might be lookup tables which does not have much effect on the relationships of the entities. Try to focus on the parent tables holding keys to those lookup tables. ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "accomplish": 0.1198042551924431,
                "analysis": 0.11291005438502466,
                "ask": 0.08339588504044554,
                "certain": 0.28806123484500806,
                "coming": 0.11291005438502466,
                "database": 0.09996748869789232,
                "design": 0.15458818600707824,
                "diagram": 0.24539014925351688,
                "documentation": 0.09694178417062918,
                "effect": 0.11725437173945197,
                "focus": 0.1092935026136822,
                "handled": 0.12269507462675844,
                "help": 0.1463158811863775,
                "highly": 0.11102634618229924,
                "information": 0.08979238605784993,
                "job": 0.14957290298110676,
                "keys": 0.12603228074959583,
                "lot": 0.06915863432360529,
                "options": 0.11291005438502466,
                "order": 0.10479832062514652,
                "product": 0.08847992438497751,
                "questions": 0.25994802767496566,
                "relationships": 0.13481018975973968,
                "requirements": 0.17958477211569987,
                "stored": 0.12603228074959583,
                "suspect": 0.12269507462675844,
                "tables": 0.6301614037479791,
                "tell": 0.09602041161500269,
                "try": 0.07729409300353912,
                "understand": 0.14758944284587688,
                "user": 0.16294052407564635
            },
            "Max term": "tables",
            "Max score": 0.6301614037479791
        }
    },
    {
        "ID": "7530",
        "Question": "There are many stories about intentionally bad code, not only on TheDailyWTF but also on SO. Typical cases include:  Having a useless time-wasting construct (e.g. an empty loop counting to some huge value) so programmers can easily \"speed up\" the application by removing it when they are tasked to. Providing intentionally misleading, wrong or no documentation to generate expensive support requests. Readily generating errors, or worse, generating even though everything worked fine, locking up the application so an expensive support call is required to unlock.  These points display a more or less malicious attitude (even though sometimes by accident), especially the first point occurs rather often. How should one deal with such constructs? Ignore the issue, or just remove the offending code? Notify their manager, or speak to the person who introduced the \"feature\"? ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "accident": 0.1487405114228362,
                    "application": 0.17690136518642366,
                    "attitude": 0.1404048185294695,
                    "bad": 0.09120616323987282,
                    "cases": 0.10696201607410544,
                    "code": 0.10799699265834675,
                    "construct": 0.1542686231433418,
                    "deal": 0.12152372010841507,
                    "display": 0.1442237152659342,
                    "documentation": 0.110934311387849,
                    "easily": 0.11566747390763296,
                    "errors": 0.11439674454880919,
                    "especially": 0.11318802721504839,
                    "expensive": 0.2974810228456724,
                    "feature": 0.09661313148632905,
                    "fine": 0.1292074335038102,
                    "generate": 0.13417880738852656,
                    "generating": 0.2884474305318684,
                    "huge": 0.11318802721504839,
                    "ignore": 0.13417880738852656,
                    "include": 0.11700692395151305,
                    "intentionally": 0.2974810228456724,
                    "issue": 0.10519170662981127,
                    "loop": 0.1487405114228362,
                    "malicious": 0.1487405114228362,
                    "manager": 0.11700692395151305,
                    "occurs": 0.1542686231433418,
                    "person": 0.10519170662981127,
                    "point": 0.08845068259321183,
                    "points": 0.11203555006679669,
                    "programmers": 0.08266315707748605,
                    "providing": 0.1442237152659342,
                    "remove": 0.1315686279858227,
                    "removing": 0.1487405114228362,
                    "requests": 0.1315686279858227,
                    "required": 0.11318802721504839,
                    "speak": 0.1442237152659342,
                    "speed": 0.1370967397063283,
                    "stories": 0.1404048185294695,
                    "support": 0.20398128437877813,
                    "time": 0.06080303187837665,
                    "typical": 0.13417880738852656,
                    "useless": 0.1292074335038102,
                    "value": 0.11700692395151305,
                    "wasting": 0.1542686231433418,
                    "worked": 0.10125107111728045,
                    "worse": 0.1315686279858227,
                    "wrong": 0.09983504051449954
                },
                "Max term": "expensive",
                "Max score": 0.2974810228456724
            }
        ],
        "Best Answer": "I've never (in 20-odd years) come across intentionally bad code, but the examples you cite seem (to me at least, but IANAL) to be attempts to defraud either an employer or a customer, so you probably have a legal obligation to point it out to your manager. ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "20": 0.2908517521341999,
                "bad": 0.21210291797799216,
                "code": 0.12557527069436608,
                "come": 0.2389554016358034,
                "customer": 0.26322246216348605,
                "employer": 0.32651600122623986,
                "examples": 0.26322246216348605,
                "intentionally": 0.34590092789398674,
                "legal": 0.3188229556428608,
                "manager": 0.27210343152441047,
                "odd": 0.35875673264638946,
                "point": 0.20569495754168274,
                "probably": 0.20370813092887305,
                "years": 0.21098419812714253
            },
            "Max term": "odd",
            "Max score": 0.35875673264638946
        }
    },
    {
        "ID": "7536",
        "Question": " Possible Duplicate: int* i; or int *i; or int * i;   Thinking about where we place our asterisks; how do those that prefer to keep the \"pointerness\" away from the type and with the identifier (int *i) write code when the identifier is missing? void f(int*); // 1 void f(int *); // 2  The former seems much more common, no matter what your preference when with the identifier.  Is this a special case?  What makes it an exception? However, the first still isn't universal, because I have seen the latter style.  Besides consistency along the lines of \"there's always a space with the identifier, so we have one without\", are there any other reasons to prefer it? What about casts or array and function types?  How would you re-write these: (void*)var /*or*/ (void *)var  int[3] /*or*/ int [3] // more relevant in C++ than C: Example<int[3]>  void(int) /*or*/ void (int) // more relevant in C++ than C: std::function<void(int)>  The latter two would rarely, if ever, be used in C, but are seen with C++ templates. ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "array": 0.08208388825561726,
                    "away": 0.0569127927385754,
                    "case": 0.05349198326584145,
                    "code": 0.028731743684111098,
                    "common": 0.04988950119390443,
                    "consistency": 0.08208388825561726,
                    "duplicate": 0.07139441584124337,
                    "example": 0.043801935149221836,
                    "exception": 0.07139441584124337,
                    "function": 0.1138255854771508,
                    "identifier": 0.32833555302246903,
                    "int": 0.8400669692240725,
                    "lines": 0.06874922662443947,
                    "makes": 0.046169185786460926,
                    "matter": 0.059612339728958436,
                    "missing": 0.0700055807686727,
                    "place": 0.0569127927385754,
                    "possible": 0.04827338908741639,
                    "prefer": 0.11922467945791687,
                    "preference": 0.08208388825561726,
                    "rarely": 0.06225752894576233,
                    "reasons": 0.05792727328172817,
                    "relevant": 0.12308965763208662,
                    "seen": 0.1119416783074046,
                    "space": 0.06654716287837846,
                    "special": 0.06760226515294927,
                    "style": 0.06086869387319168,
                    "templates": 0.07914246766415374,
                    "thinking": 0.05173180697771065,
                    "type": 0.057410275982897434,
                    "types": 0.06022555454559906,
                    "used": 0.040055004887482794,
                    "var": 0.15828493532830748,
                    "write": 0.08093825012483971
                },
                "Max term": "int",
                "Max score": 0.8400669692240725
            }
        ],
        "Best Answer": "I always separate the star from the type, so I use: void f(int *);  void f(int *x) {     char *y = (char *) x;     char x[4]; }  Obviously, I don't separate the brackets from the identifier. That's how I learned to do it from K&R, and who am I to argue? (Also, it seems to be the most readable way.) ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "argue": 0.3109140593930719,
                "identifier": 0.3109140593930719,
                "int": 0.5303286615560174,
                "learned": 0.2305559970932924,
                "obviously": 0.24491975336000482,
                "readable": 0.2651643307780087,
                "separate": 0.5121222965807033,
                "type": 0.2174563405321837,
                "use": 0.1171104071453316,
                "way": 0.1367156765795374
            },
            "Max term": "int",
            "Max score": 0.5303286615560174
        }
    },
    {
        "ID": "7539",
        "Question": "I'm writing a small database-centric application in Java Swing that will be used internally in a small company. I haven't much experience with developing production-level applications. I don't use an ORM, just a few simple methods that run SQL queries with Java JDBC. On every method that access the database I use a try-catch statement for SQLException and IOException. Should I do any logging here? In case I should, how much should I log? Please give me examples of good practice in this case. ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "access": 0.14558332425467976,
                    "application": 0.1214106800142646,
                    "applications": 0.14810339714936266,
                    "case": 0.275990467082515,
                    "catch": 0.21175482078342803,
                    "centric": 0.21175482078342803,
                    "company": 0.1251929547154768,
                    "database": 0.3140504095590768,
                    "developing": 0.15227254089666659,
                    "examples": 0.15536607463905278,
                    "experience": 0.1214106800142646,
                    "good": 0.09259795839161072,
                    "internally": 0.19796680852256732,
                    "java": 0.25740355650286584,
                    "level": 0.12944918025781701,
                    "log": 0.17439604587733365,
                    "logging": 0.19272484954514713,
                    "method": 0.14810339714936266,
                    "methods": 0.14682002135561226,
                    "orm": 0.20416673007000574,
                    "practice": 0.15378414185834544,
                    "production": 0.16680795516391136,
                    "queries": 0.20416673007000574,
                    "run": 0.13099514749061514,
                    "simple": 0.13099514749061514,
                    "small": 0.2531067060327977,
                    "sql": 0.1570252047795384,
                    "statement": 0.18818405813819436,
                    "try": 0.1214106800142646,
                    "use": 0.15952120869247877,
                    "used": 0.10333136699147306,
                    "writing": 0.11800729973295837
                },
                "Max term": "database",
                "Max score": 0.3140504095590768
            }
        ],
        "Best Answer": "Two main things in production system are:  Don't blow up the logs with information that is not interesting Allow raising the log level for troubleshooting purpose.  Use some kind of a logging infrastructure. If the exception can occur during the normal operation, report it in debug level. If it is a real problem, report it in error level. Either way you will have a way to troubleshoot the system by raising the log level. Also - when you report an exception always make sure the the entire stack trace + inner exceptions are printed. ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "allow": 0.13021735710382665,
                "blow": 0.16963309575731067,
                "debug": 0.1336269451940403,
                "entire": 0.13752517689916824,
                "error": 0.12579015438766034,
                "exception": 0.2950848464005629,
                "exceptions": 0.15858775947879605,
                "information": 0.11298671450262693,
                "infrastructure": 0.15858775947879605,
                "inner": 0.1635544085574495,
                "interesting": 0.11864304981427369,
                "kind": 0.11385158559085903,
                "level": 0.4147979273225245,
                "log": 0.279411264787803,
                "logging": 0.15438851751640384,
                "main": 0.12866029611538687,
                "make": 0.07698056393935657,
                "normal": 0.14207592246248782,
                "occur": 0.15858775947879605,
                "operation": 0.1635544085574495,
                "problem": 0.08836856072470795,
                "production": 0.1336269451940403,
                "purpose": 0.12866029611538687,
                "real": 0.10251489732538403,
                "report": 0.43401684441766475,
                "stack": 0.12866029611538687,
                "sure": 0.0997609227293791,
                "things": 0.08061811278334431,
                "trace": 0.16963309575731067,
                "use": 0.06389482980680013,
                "way": 0.14918272594049803
            },
            "Max term": "report",
            "Max score": 0.43401684441766475
        }
    },
    {
        "ID": "7547",
        "Question": "I develop a web application and we test it on several browsers, including Firefox and Internet Explorer. During our development we tested the application on Firefox 3.5.2 and our testing team tested the same on 3.5.6 and found the UI looks good. Once in production, though, we've started receiving client complaints that it doesn't look good in 3.5.8. How do we handle these minor version issues? How can we check the browser compatibility during development and during testing? Is there any tool to test the application on 3.5.X, X being all the minor versions? ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "application": 0.32778019347758114,
                    "browser": 0.17343720905064802,
                    "browsers": 0.18373400175385143,
                    "check": 0.12890220934830854,
                    "client": 0.13212647355425125,
                    "develop": 0.14131033611827967,
                    "development": 0.19263942405827622,
                    "firefox": 0.3811253733639009,
                    "good": 0.16666176162681967,
                    "handle": 0.14813902104637872,
                    "including": 0.14628377388000796,
                    "internet": 0.15222537623286214,
                    "issues": 0.14131033611827967,
                    "look": 0.1098017105972904,
                    "looks": 0.14453460032422233,
                    "minor": 0.31921093435685094,
                    "production": 0.15011404216609442,
                    "started": 0.12418485848697723,
                    "team": 0.11388806578377382,
                    "test": 0.21538075306104537,
                    "tested": 0.30898648732803735,
                    "testing": 0.22413915605689386,
                    "tool": 0.13328141084623282,
                    "ui": 0.15960546717842547,
                    "version": 0.1370333123647444,
                    "versions": 0.15960546717842547,
                    "web": 0.11266381429225097
                },
                "Max term": "firefox",
                "Max score": 0.3811253733639009
            }
        ],
        "Best Answer": "I would say stick with the age-old traditions in web development.   Stick with the standards.  Add small adjustments for the specific browsers your users are using if necessary. You can't really do any better than that.  There is no tool that will ensure your site works on every single browser and version.  Stick with the standards.  Add small adjustments. ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "add": 0.287676783944294,
                "age": 0.19505214603094775,
                "better": 0.10715697857560112,
                "browser": 0.19505214603094775,
                "browsers": 0.20663219580797756,
                "development": 0.10832373652230473,
                "ensure": 0.20035740557773227,
                "necessary": 0.14859298275914962,
                "old": 0.15124167881858616,
                "really": 0.09993922351674474,
                "say": 0.11164351914441452,
                "single": 0.1406592659440139,
                "site": 0.15411134554562148,
                "small": 0.2561631585290531,
                "specific": 0.13966162904155635,
                "standards": 0.33764457159047556,
                "stick": 0.5592086783156681,
                "tool": 0.14989185627403875,
                "users": 0.1386920983580956,
                "using": 0.10056498736032216,
                "version": 0.15411134554562148,
                "web": 0.126704753138171,
                "works": 0.143838391972147
            },
            "Max term": "stick",
            "Max score": 0.5592086783156681
        }
    },
    {
        "ID": "7551",
        "Question": "Why are there so many programming languages? And what prompts someone to create a programming languages in spite of the fact that other languages already exist? ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "create": 0.2910297678032157,
                    "exist": 0.34757869607060443,
                    "fact": 0.3062790947863856,
                    "languages": 0.7435645790283543,
                    "programming": 0.3844418775335006
                },
                "Max term": "languages",
                "Max score": 0.7435645790283543
            }
        ],
        "Best Answer": "Programming languages evolve New programming languages often learn from existing languages and add, remove and combine features in a new way. There is a few different paradigms like object oriented and functional and many modern languages try to mix features from them both. There is also new problems that needs to be solved, e.g. the increase of multi-core CPUs. The most common solution to that have been threads, but some programming languages try to solve the concurrency problem in a different way e.g. the Actor Model. See Erlang - Software for a Concurrent World ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "actor": 0.16858838570395152,
                "add": 0.11735577899666433,
                "common": 0.10627404878942429,
                "concurrency": 0.14644882168943305,
                "concurrent": 0.15914038128892274,
                "core": 0.14644882168943305,
                "different": 0.1881728473547639,
                "erlang": 0.15539087375234198,
                "existing": 0.125737341475791,
                "features": 0.22039701528970285,
                "functional": 0.11827650396913325,
                "increase": 0.15208357371453896,
                "languages": 0.4785734121797862,
                "learn": 0.09488875242733943,
                "like": 0.06232987020920911,
                "mix": 0.17485416643870866,
                "model": 0.13110209530681968,
                "modern": 0.13967708860255607,
                "multi": 0.1417580105090057,
                "needs": 0.125737341475791,
                "new": 0.2484998005010558,
                "object": 0.125737341475791,
                "oriented": 0.13110209530681968,
                "paradigms": 0.15208357371453896,
                "problem": 0.09108842207898749,
                "problems": 0.10567016323881072,
                "programming": 0.22269120890721658,
                "remove": 0.1491250930175848,
                "software": 0.0825696067196381,
                "solution": 0.11922844583846717,
                "solve": 0.12454228470389045,
                "solved": 0.1634688700766238,
                "threads": 0.15539087375234198,
                "try": 0.20050701251673625,
                "way": 0.15377436269098985,
                "world": 0.10816777269695936
            },
            "Max term": "languages",
            "Max score": 0.4785734121797862
        }
    },
    {
        "ID": "7559",
        "Question": "This happened at least once to me. I'm working on some part of the code base and find a small bug in a different part, and the bug stops me from completing what I'm currently trying to do. Fixing the bug could be as simple as changing a single statement. What do you do in that situation?  Fix the bug and commit it together with your current work Save your current work elsewhere, fix the bug in a separate commit, then continue your work [1] Continue what you're supposed to do, commit the code (even if it breaks the build fails some tests), then fix the bug (and the build make tests pass) in a separate commit  [1] In practice, this would mean: clone the original repository elsewhere, fix the bug, commit/push the changes, pull the commit to the repository you're working on, merge the changes, and continue your work. Edit: I changed number three to reflect what I really meant. ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "base": 0.07811449736789951,
                    "breaks": 0.0856988081054418,
                    "bug": 0.496390252858908,
                    "build": 0.13286566269401345,
                    "changed": 0.0802692542928756,
                    "changes": 0.13385876915837325,
                    "changing": 0.0802692542928756,
                    "clone": 0.0968839208941547,
                    "code": 0.07034513995836279,
                    "commit": 0.5049648941007199,
                    "continue": 0.2570964243163254,
                    "current": 0.14745276549028385,
                    "currently": 0.0745136953167289,
                    "different": 0.05406933336902899,
                    "edit": 0.06692938457918662,
                    "fix": 0.28628650328066335,
                    "fixing": 0.0856988081054418,
                    "happened": 0.08275673860887872,
                    "make": 0.045600598191569426,
                    "mean": 0.06692938457918662,
                    "meant": 0.0856988081054418,
                    "merge": 0.09394185139759162,
                    "number": 0.06293012507970296,
                    "original": 0.07811449736789951,
                    "pass": 0.08275673860887872,
                    "practice": 0.07297570289474041,
                    "pull": 0.09394185139759162,
                    "push": 0.08275673860887872,
                    "really": 0.046858640724204724,
                    "repository": 0.18788370279518324,
                    "save": 0.08739897984985794,
                    "separate": 0.16551347721775744,
                    "simple": 0.062161565219990625,
                    "single": 0.06595110283498029,
                    "situation": 0.07372638274514193,
                    "small": 0.06005378564042589,
                    "statement": 0.0892996101566124,
                    "supposed": 0.0802692542928756,
                    "tests": 0.1274742571421269,
                    "trying": 0.062161565219990625,
                    "work": 0.17018742215291638,
                    "working": 0.10724212537866612
                },
                "Max term": "commit",
                "Max score": 0.5049648941007199
            }
        ],
        "Best Answer": "I have done 1 and 2 and in the end, I think I prefer #2. It allows for more visibility for the bug fix, which may be important for QA/release notes/other developers.  I've also come across a situation where what I thought was a bug actually wasn't (not saying that this is the case here), and \"fixing\" it in a separate commit allowed another dev to contact me and explain what was what instead of the \"fix\" just getting lost in my normal check-in. ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "actually": 0.12348762809125816,
                "allowed": 0.19535092128495526,
                "allows": 0.17459859431706154,
                "bug": 0.3170036779423811,
                "case": 0.1463659039605856,
                "check": 0.1519258355942027,
                "come": 0.14959804978319133,
                "commit": 0.18811309820892194,
                "contact": 0.18811309820892194,
                "dev": 0.19959913885093178,
                "developers": 0.12814805770529017,
                "end": 0.12516551953367439,
                "explain": 0.1453498322172148,
                "fix": 0.3199484265342764,
                "fixing": 0.19155076117799627,
                "getting": 0.1365087157845478,
                "important": 0.14339972694217326,
                "instead": 0.1453498322172148,
                "lost": 0.17941482616739132,
                "normal": 0.18811309820892194,
                "notes": 0.20441537070126153,
                "prefer": 0.16311255367505173,
                "qa": 0.20441537070126153,
                "release": 0.1769263801280729,
                "saying": 0.1769263801280729,
                "separate": 0.18497475780100842,
                "situation": 0.164790445117468,
                "think": 0.0953487431494744,
                "thought": 0.15572599570116172,
                "visibility": 0.224599683384802
            },
            "Max term": "fix",
            "Max score": 0.3199484265342764
        }
    },
    {
        "ID": "7565",
        "Question": " Possible Duplicate: What good book shoud I buy to learn Agile from scratch?   It seem that Agile for the solo developer is a good idea. But how to learn it?  Is there any good book, web reference or course that a solo developer could start from? ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "agile": 0.36423343024219773,
                    "book": 0.3255622695441463,
                    "buy": 0.20230690624927708,
                    "course": 0.1787255677920706,
                    "developer": 0.27972943829645164,
                    "duplicate": 0.22027633592127446,
                    "good": 0.3322392056354561,
                    "idea": 0.14665884341875712,
                    "learn": 0.27487185097409494,
                    "possible": 0.1489400136604988,
                    "reference": 0.21211501711741043,
                    "scratch": 0.22506659640980672,
                    "solo": 0.4405526718425489,
                    "start": 0.1411357665743645,
                    "web": 0.1497297512396487
                },
                "Max term": "solo",
                "Max score": 0.4405526718425489
            }
        ],
        "Best Answer": "If you have to purchase only ONE book. Buy Practices of an Agile Developer.  ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "agile": 0.3864437427131894,
                "book": 0.34541448280895437,
                "buy": 0.42928644949317724,
                "developer": 0.2967868463102298,
                "practices": 0.412530705861739,
                "purchase": 0.5374004071859548
            },
            "Max term": "purchase",
            "Max score": 0.5374004071859548
        }
    },
    {
        "ID": "7566",
        "Question": "Developer interviews are different than most other places, because not only do you worry about the people you work with, benefits, job description, etc., you also have EXTRA to worry about after getting the job.  Writing two application with exact requirements can be vastly different if you're working in a loud vs quiet environment, using VS2003/.NET 2.0 vs VS210/.NET 4.0., using SVN vs VSS. Is it ok to give the potential employer the straight-up Joel Test?  I try to ask as many questions to get the type of environment I will be working in, which is extremely important from my perspective, but what's the best way to cut to the chase and just ask the tough questions (like they ask you during the same interview). NOTE: By the \"Joel Test\" I mean a specific list of things that are deal breakers that are important to you (not necessarily Joel), but you may not have time to get out using the traditional casual \"conversational\" way of asking them, so you decide to either email or schedule another meeting, or ask other people, etc. ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "application": 0.07435881750032325,
                    "ask": 0.32091556573237695,
                    "asking": 0.09152380244729515,
                    "benefits": 0.10681007425909361,
                    "best": 0.0683673038180233,
                    "casual": 0.1296907164311953,
                    "cut": 0.12504333736644604,
                    "deal": 0.10216269519434434,
                    "decide": 0.10216269519434434,
                    "description": 0.11803567786146259,
                    "developer": 0.0716235012304522,
                    "different": 0.13956928727169718,
                    "email": 0.11060725943924522,
                    "employer": 0.11803567786146259,
                    "environment": 0.1702397245151371,
                    "exact": 0.11280158794139356,
                    "extra": 0.11060725943924522,
                    "extremely": 0.10681007425909361,
                    "getting": 0.07882430145223612,
                    "important": 0.16560676349044826,
                    "interview": 0.10216269519434434,
                    "interviews": 0.11060725943924522,
                    "job": 0.14389280944478408,
                    "joel": 0.2950965300425782,
                    "like": 0.04623055708157392,
                    "list": 0.08704370828220125,
                    "mean": 0.08638248264959285,
                    "meeting": 0.10862224785512646,
                    "necessarily": 0.09723945967242495,
                    "net": 0.15856410604448534,
                    "note": 0.09723945967242495,
                    "ok": 0.09955594018476938,
                    "people": 0.11600853505628848,
                    "perspective": 0.11280158794139356,
                    "places": 0.11280158794139356,
                    "potential": 0.1051430361496031,
                    "questions": 0.16671759508251774,
                    "quiet": 0.12504333736644604,
                    "requirements": 0.08638248264959285,
                    "schedule": 0.11803567786146259,
                    "specific": 0.08451614294231169,
                    "straight": 0.11525463850399449,
                    "svn": 0.12124615218629443,
                    "test": 0.14658107867988543,
                    "things": 0.06163550077021,
                    "time": 0.05111595997177223,
                    "tough": 0.11525463850399449,
                    "traditional": 0.12504333736644604,
                    "try": 0.07435881750032325,
                    "type": 0.0907069582224023,
                    "using": 0.18257050784237455,
                    "vs": 0.302455681730381,
                    "way": 0.11405565948087126,
                    "work": 0.054913145151923845,
                    "working": 0.13841216519580718,
                    "worry": 0.2256031758827871,
                    "writing": 0.0722743935172592
                },
                "Max term": "ask",
                "Max score": 0.32091556573237695
            }
        ],
        "Best Answer": "A job interview goes both ways -- a company is interviewing you and you are interviewing the company. I wouldn't come out literally with a \"what's your Joel Test score?\", but I would ask the individual questions that were particular deal-breakers for me in a work environment. It doesn't need a huge build-up. A good time to ask these questions as at the technical part of the interview process, when they say \"do you have any questions for us?\". You can lead in with something along the lines of \"can you describe a typical day on the job here?\" and go from there. ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "ask": 0.24602731044112583,
                "build": 0.1314662103781518,
                "come": 0.1324488566143889,
                "company": 0.2351299763759042,
                "day": 0.12613159162002632,
                "deal": 0.1566444000229138,
                "environment": 0.1305129012895113,
                "goes": 0.14299462387920586,
                "good": 0.08695599452284827,
                "huge": 0.1458996696040968,
                "individual": 0.18590475445248827,
                "interview": 0.3132888000458276,
                "interviewing": 0.35343612781498923,
                "job": 0.22062850593567215,
                "joel": 0.15082223770437625,
                "lead": 0.15458346026094175,
                "lines": 0.1665487271262638,
                "literally": 0.18590475445248827,
                "need": 0.09360511730971138,
                "particular": 0.1295872282760815,
                "process": 0.1215618832748018,
                "questions": 0.38343806815126685,
                "say": 0.10359018651148262,
                "score": 0.19885266755404746,
                "technical": 0.12696107937123974,
                "test": 0.11237519272980812,
                "time": 0.0783752706028531,
                "typical": 0.1729568413509291,
                "ways": 0.13346270312952516,
                "work": 0.08419743292139066
            },
            "Max term": "questions",
            "Max score": 0.38343806815126685
        }
    },
    {
        "ID": "7581",
        "Question": "Is Java becoming the de facto standard from Linux application development in the same way .NET is the standard for Windows application development?  If not why not?   ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "application": 0.42614600150360654,
                    "development": 0.3756748665474515,
                    "facto": 0.371624926923103,
                    "java": 0.225868713451766,
                    "linux": 0.3169418431586912,
                    "net": 0.22718038708912203,
                    "standard": 0.48781691491318974,
                    "way": 0.16341156593977207,
                    "windows": 0.267234869429464
                },
                "Max term": "standard",
                "Max score": 0.48781691491318974
            }
        ],
        "Best Answer": "In short: No. It really depends on what sort of application you are writing. For many the answer is still regular old C/C++ (if doing, say Qt or GTK+ GUI development). Many doing GTK+ development may also be using Python + PyGTK. If doing web or web services development, you see lots of Ruby, Python, PHP, and Java. ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "answer": 0.16054467740946132,
                "application": 0.15569437194970037,
                "depends": 0.2084527444356175,
                "development": 0.4117635425277922,
                "gui": 0.24132307585568002,
                "java": 0.16504431514025095,
                "lots": 0.20360243897585656,
                "old": 0.19163485138017586,
                "php": 0.19163485138017586,
                "python": 0.3673684181064411,
                "really": 0.1266306906620239,
                "regular": 0.22015114721432913,
                "ruby": 0.21691946144698962,
                "say": 0.1414609343530408,
                "services": 0.2236416337524214,
                "short": 0.19527094006314855,
                "sort": 0.19923801934373103,
                "using": 0.1274235816303058,
                "web": 0.32108935481892265,
                "writing": 0.15132995231757485
            },
            "Max term": "development",
            "Max score": 0.4117635425277922
        }
    },
    {
        "ID": "7588",
        "Question": "We currently use once cc.net server for our build process, which builds both .net (using msbuild & nant) and java (using maven and ant).    CC.net monitors source control, and triggers a remote build running on a separate server.  CC.net then collates the results. When we run the remote build, it typically:  runs nunit or junit or similar using mocked data optionally runs a DB script to create a fresh database instance or restore a database from a known position. runs selenium or similar to test UI runs emma or ncover for code coverage builds the system for various deployment environments (test, acceptance, production)  We may have several builds running at a time, some .net and some java (from different project teams). It's quite time consuming to get the remote builds working when we set up a new project and we feel that there must be something more suited to remote builds than cc.net.   Does anyone have any experience with remote builds with continuous integration systems? I don't really want feature lists of CI servers, I'd more appreciate hearing about how you've used them in a multi language, multi server environment. ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "acceptance": 0.08461960188222292,
                    "appreciate": 0.08461960188222292,
                    "build": 0.17406974310940793,
                    "builds": 0.47926417891092593,
                    "ci": 0.08776458644947253,
                    "code": 0.030720152955664742,
                    "consuming": 0.08776458644947253,
                    "continuous": 0.08204996238775011,
                    "control": 0.05890440943372242,
                    "coverage": 0.07799537209012934,
                    "create": 0.05641074854432789,
                    "currently": 0.06508117316353655,
                    "data": 0.05365192504009172,
                    "database": 0.1301623463270731,
                    "db": 0.07799537209012934,
                    "deployment": 0.07799537209012934,
                    "different": 0.04722481730196437,
                    "environment": 0.05760250012679121,
                    "environments": 0.07799537209012934,
                    "experience": 0.05032026228531123,
                    "feature": 0.05496394119371605,
                    "feel": 0.05274231930972056,
                    "fresh": 0.08461960188222292,
                    "hearing": 0.08461960188222292,
                    "instance": 0.07799537209012934,
                    "integration": 0.079877363151821,
                    "java": 0.10668430878465,
                    "junit": 0.08776458644947253,
                    "known": 0.0673717144861344,
                    "language": 0.041313071186275724,
                    "lists": 0.0763353383260277,
                    "monitors": 0.08461960188222292,
                    "multi": 0.1423052526756222,
                    "net": 0.3219115502405503,
                    "new": 0.041576518054921366,
                    "position": 0.06822615773078616,
                    "process": 0.05365192504009172,
                    "production": 0.06913576346115731,
                    "project": 0.08288835816314158,
                    "quite": 0.05603488634703365,
                    "really": 0.04092691012326228,
                    "remote": 0.39938681575910495,
                    "results": 0.0701081487924778,
                    "run": 0.05429267160892534,
                    "running": 0.1287870494615108,
                    "runs": 0.3053413533041108,
                    "script": 0.08461960188222292,
                    "separate": 0.07228074802840692,
                    "server": 0.18753460100719124,
                    "servers": 0.08461960188222292,
                    "set": 0.05531195880419336,
                    "similar": 0.11438789973177,
                    "source": 0.05216697423694374,
                    "suited": 0.07485038752287973,
                    "systems": 0.060851499904962095,
                    "teams": 0.07485038752287973,
                    "test": 0.09919466948494189,
                    "time": 0.06918260938546708,
                    "typically": 0.079877363151821,
                    "ui": 0.07350708612420158,
                    "use": 0.03305783750050773,
                    "used": 0.042827051859850924,
                    "using": 0.12354951502760007,
                    "various": 0.06913576346115731,
                    "want": 0.04144417908157079,
                    "working": 0.04683329220573314
                },
                "Max term": "builds",
                "Max score": 0.47926417891092593
            }
        ],
        "Best Answer": "Hudson (Update: in today's world, I would use Jenkins, a fork of Hudson.) I've used hudson in both Java and .NET enterprise environments for high visibility projects (you've probably been to some of the sites).  Hudson is solid from the start, but the best part is that there are lots of plugins to do just about anything you want.  Hudson is highly configurable, has a great community, and is really easy to set up in a cluster environment if you need multiple builds going at once.  It's my favorite CI server of all the ones I've used (CC.NET, Hudson, and TFS). Plus, you can use the ChuckNorris plugin to have him give you the thumbs up or down. ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "best": 0.11517907946652564,
                "builds": 0.19885588521199782,
                "ci": 0.2184912450790747,
                "community": 0.19417064043467033,
                "easy": 0.13949968411092997,
                "enterprise": 0.19003796165539202,
                "environment": 0.14340228196273588,
                "environments": 0.19417064043467033,
                "favorite": 0.19003796165539202,
                "going": 0.11294346894290072,
                "great": 0.13516241457290795,
                "high": 0.1466434045721975,
                "highly": 0.179943998722829,
                "java": 0.13279608780574806,
                "lots": 0.16382028875533433,
                "multiple": 0.15419106395090235,
                "need": 0.1028495060103377,
                "net": 0.26713453289380307,
                "ones": 0.15149071529914637,
                "plugin": 0.21066175915939286,
                "plus": 0.19003796165539202,
                "probably": 0.12406301850020086,
                "projects": 0.12717011065474204,
                "really": 0.10188815229271446,
                "server": 0.1556233940784247,
                "set": 0.13769994522617984,
                "sites": 0.16571735701098766,
                "solid": 0.19885588521199782,
                "start": 0.12176139249950649,
                "today": 0.17211451280314718,
                "update": 0.16571735701098766,
                "use": 0.16459595760223789,
                "used": 0.21323716689104655,
                "visibility": 0.2184912450790747,
                "want": 0.10317590106831712,
                "world": 0.13516241457290795
            },
            "Max term": "net",
            "Max score": 0.26713453289380307
        }
    },
    {
        "ID": "7618",
        "Question": "Perhaps the greatest promise of using object-oriented paradigm is the code reuse. Some dispute that this was achieved. Why was it (not) achieved? Does code reuse as OOP defines it, make projects more productive? Or more manageable? Or easier to maintain? Or with more quality? Probably we all agree that code reuse is a good thing, but there are several ways to achieve this goal. The question is about the method of code reuse offered by OOP. Was it a good thing? Are there better methods to achieved code reuse than object orientation, sub-classing, polymorphism, etc.? What ways are better? Why? Tell us your experience with OOP reuse or other paradigms reuse. ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "achieve": 0.11504528944339096,
                    "agree": 0.09275744495552508,
                    "better": 0.11932221470041916,
                    "code": 0.2088292080036462,
                    "defines": 0.11932107958877382,
                    "easier": 0.07721871481221679,
                    "experience": 0.06841333462592394,
                    "goal": 0.09531612168770286,
                    "good": 0.10435548359301426,
                    "maintain": 0.0982698972004953,
                    "make": 0.054148655105239356,
                    "method": 0.08345433257786725,
                    "methods": 0.08273116705718703,
                    "object": 0.17160718140248266,
                    "offered": 0.10859793900432721,
                    "oop": 0.2998115263317835,
                    "oriented": 0.08946451701420247,
                    "paradigm": 0.10859793900432721,
                    "paradigms": 0.10378234944546552,
                    "probably": 0.06775252390148849,
                    "productive": 0.0982698972004953,
                    "projects": 0.06944934974056266,
                    "promise": 0.11155171451711966,
                    "quality": 0.08498807988387096,
                    "question": 0.061212605108595816,
                    "reuse": 0.7601855730302906,
                    "sub": 0.11155171451711966,
                    "tell": 0.08498807988387096,
                    "thing": 0.13616016160096145,
                    "using": 0.055990926455094785,
                    "ways": 0.16016796775353923
                },
                "Max term": "reuse",
                "Max score": 0.7601855730302906
            }
        ],
        "Best Answer": "Code re-use is achieved in OOP but it is also achieved in functional programming.  Anytime you take a block of code and make it callable by the rest of your code such that you can use this functionality elsewhere is code re-use. This type of code re-use also makes code more manageable because changing this one callable block changes all places that it is called.  I would say this result increased quality too and readability.   I am not sure OOP is simply there to provide code reuse.  I look at OOP as more of a way to interact with objects and abstract away the details of the data structure.   From Wikpedia:  Object-oriented programming has roots that can be traced to the 1960s. As hardware and software became increasingly complex, manageability often became a concern. Researchers studied ways to maintain software quality and developed object-oriented programming in part to address common problems by strongly emphasizing discrete, reusable units of programming logic[citation needed]. The technology focuses on data rather than processes, with programs composed of self-sufficient modules (\"classes\"), each instance of which (\"objects\") contains all the information needed to manipulate its own data structure (\"members\"). This is in contrast to the existing modular programming that had been dominant for many years that focused on the function of a module, rather than specifically the data, but equally provided for code reuse, and self-sufficient reusable units of programming logic, enabling collaboration through the use of linked modules (subroutines). This more conventional approach, which still persists, tends to consider data and behavior separately.  ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "abstract": 0.09553830954047111,
                "address": 0.09263710216097933,
                "approach": 0.06930388803307702,
                "away": 0.06870334183341936,
                "behavior": 0.08450854569533749,
                "block": 0.16598382860100397,
                "called": 0.07805654745412431,
                "changes": 0.06599980886679159,
                "changing": 0.07915440242755721,
                "classes": 0.08160733831584568,
                "code": 0.27747249260698764,
                "collaboration": 0.09263710216097933,
                "common": 0.06022504413318651,
                "complex": 0.07270240418634406,
                "concern": 0.09553830954047111,
                "consider": 0.06412557622949888,
                "contains": 0.08033365187821065,
                "contrast": 0.0990891004021925,
                "data": 0.3028739268388876,
                "details": 0.07606487822770958,
                "developed": 0.08299191430050198,
                "existing": 0.07125480797832015,
                "focused": 0.09263710216097933,
                "function": 0.06870334183341936,
                "functional": 0.06702678360899067,
                "functionality": 0.07270240418634406,
                "hardware": 0.07606487822770958,
                "information": 0.06599980886679159,
                "instance": 0.08805933655705886,
                "linked": 0.09018416627269085,
                "logic": 0.1485899815758626,
                "look": 0.05709487473728995,
                "maintain": 0.08160733831584568,
                "make": 0.04496725591872341,
                "makes": 0.05573399583162453,
                "members": 0.07915440242755721,
                "modular": 0.0990891004021925,
                "module": 0.09553830954047111,
                "needed": 0.13740668366683872,
                "object": 0.1425096159566403,
                "objects": 0.16321467663169137,
                "oop": 0.24897574290150593,
                "oriented": 0.1485899815758626,
                "places": 0.08618510391976617,
                "problems": 0.059882824801643406,
                "processes": 0.08450854569533749,
                "programming": 0.2523962912353897,
                "programs": 0.06870334183341936,
                "provide": 0.07196215045536834,
                "provided": 0.08618510391976617,
                "quality": 0.14115514894142414,
                "readability": 0.08299191430050198,
                "rest": 0.08450854569533749,
                "result": 0.08160733831584568,
                "reuse": 0.1803683325453817,
                "say": 0.0516194151085665,
                "self": 0.16598382860100397,
                "separately": 0.09263710216097933,
                "simply": 0.06650501274646016,
                "software": 0.09358367852538078,
                "specifically": 0.07702957271192522,
                "strongly": 0.08618510391976617,
                "structure": 0.17611867311411772,
                "studied": 0.09553830954047111,
                "sufficient": 0.198178200804385,
                "sure": 0.05827412418794338,
                "technology": 0.07347878185020384,
                "tends": 0.09018416627269085,
                "type": 0.06930388803307702,
                "units": 0.19107661908094223,
                "use": 0.18661692099768687,
                "way": 0.0435716333625707,
                "ways": 0.06650501274646016,
                "years": 0.05827412418794338
            },
            "Max term": "data",
            "Max score": 0.3028739268388876
        }
    },
    {
        "ID": "7629",
        "Question": "What coding standards do you think are important for .NET / C# projects?  This could be anything from dealing with curly braces and spacing and pedantry like that.  Or it could be more fundamental questions such as what namespaces in the .NET Framework to avoid, best practices with config files, etc. Try to avoid creating a post that is simply the corollary to another.  For example, it would be fine to have one post focusing on curly braces.  We don't need two to support one style vs. the other.  The idea is not to vote for your pet standard, but rather to flesh out what should be thought about when creating standards. ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "avoid": 0.2485413308272653,
                    "best": 0.09448355180560342,
                    "braces": 0.34561955742632483,
                    "coding": 0.1017712130528877,
                    "config": 0.16312519963955288,
                    "creating": 0.27517243789635754,
                    "curly": 0.35846490472254966,
                    "dealing": 0.15285913212433452,
                    "example": 0.0956427433178679,
                    "files": 0.1276607790640143,
                    "fine": 0.15011584791728108,
                    "focusing": 0.17923245236127483,
                    "framework": 0.11763557235935089,
                    "fundamental": 0.17923245236127483,
                    "idea": 0.10379188109151287,
                    "important": 0.11443419839443131,
                    "like": 0.06389058791385709,
                    "need": 0.08436937223597686,
                    "net": 0.21913545059259423,
                    "post": 0.26876968996651845,
                    "practices": 0.13758621894817877,
                    "projects": 0.10432001882480475,
                    "questions": 0.11520178252028745,
                    "simply": 0.12029432581872698,
                    "standard": 0.11763557235935089,
                    "standards": 0.2823775040094595,
                    "style": 0.13290848553550663,
                    "support": 0.11849482120884841,
                    "think": 0.07608910576675375,
                    "thought": 0.12427066541363264,
                    "try": 0.10276381827482656,
                    "vote": 0.17280977871316242,
                    "vs": 0.13933115918361905
                },
                "Max term": "curly",
                "Max score": 0.35846490472254966
            }
        ],
        "Best Answer": "Here is the official Microsoft Guide on coding standards for the .NET framework Version 4.0. If you want the older version for 1.1, try here. I don't necessarily follow this to a 'T', as they say.  However, when in doubt, this is the best place to start to be consistent with the current .NET framework, which makes it easier on everyone, no matter if they're new to your particular project or not. ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "best": 0.13209426980937553,
                "coding": 0.14228290341471178,
                "consistent": 0.2342628865820915,
                "current": 0.1838515526592638,
                "doubt": 0.2505788517510218,
                "easier": 0.16216226804199452,
                "follow": 0.18197958158313723,
                "framework": 0.3289246591065359,
                "guide": 0.22805984451377742,
                "makes": 0.14094144181649765,
                "matter": 0.18197958158313723,
                "microsoft": 0.1858148747879893,
                "necessarily": 0.18787892318054225,
                "net": 0.3063658889002575,
                "new": 0.1187061498888933,
                "older": 0.22268652506543843,
                "particular": 0.16329586755074493,
                "place": 0.17373862955864763,
                "project": 0.11832830559741261,
                "say": 0.13053639313974172,
                "standards": 0.19739123630464236,
                "start": 0.13964326080475015,
                "try": 0.1436706313260286,
                "version": 0.3603816745227397,
                "want": 0.11832830559741261
            },
            "Max term": "version",
            "Max score": 0.3603816745227397
        }
    },
    {
        "ID": "7686",
        "Question": "I am curious about experiences of programmers who have gone beyond college or university and now work in the industry. I am not talking about academia (you need PhD there anyway). Do you have a Master's degree? Has it helped your career? Are there any other benefits besides the knowledge one gains while pursuing the degree? ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "academia": 0.27450544974813307,
                    "benefits": 0.22607591567804367,
                    "career": 0.19372074767420172,
                    "college": 0.23875764960079826,
                    "curious": 0.24394981575171104,
                    "degree": 0.44509487217526966,
                    "experiences": 0.22254743608763483,
                    "gone": 0.2646687327075894,
                    "helped": 0.2498362082445311,
                    "industry": 0.20140667417444172,
                    "knowledge": 0.1719133195710699,
                    "master": 0.22607591567804367,
                    "need": 0.1292168475378649,
                    "programmers": 0.14709074761153226,
                    "pursuing": 0.27450544974813307,
                    "talking": 0.2035574647147454,
                    "university": 0.22254743608763483,
                    "work": 0.11623004345889738
                },
                "Max term": "degree",
                "Max score": 0.44509487217526966
            }
        ],
        "Best Answer": "Yes it does. It helps a lot in getting your resume shortlisted by the HR who have no idea what programming is all about. ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "getting": 0.35058543954230925,
                "helps": 0.4484089135284743,
                "idea": 0.3340329966822932,
                "lot": 0.29591455180933196,
                "programming": 0.24487726541669752,
                "resume": 0.5249851789655328,
                "yes": 0.3759009414096168
            },
            "Max term": "resume",
            "Max score": 0.5249851789655328
        }
    },
    {
        "ID": "7705",
        "Question": "When dealing with complicated algorithms in languages with support for nested functions (such as Python and D) I often write huge functions (because the algorithm is complicated) but mitigate this by using nested functions to structure the complicated code.  Are huge (100+ line) functions still considered evil even if they're well-structured internally via the use of nested functions? Edit:  For those of you not familiar with Python or D, nested functions in these languages also allow access to the outer function scope.  In D this access allows mutation of variables in the outer scope.  In Python it only allows reading.  In D you can explicitly disable access to the outer scope in a nested function by declaring it static. ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "100": 0.08385027643090669,
                    "access": 0.2195435218390513,
                    "algorithm": 0.08385027643090669,
                    "algorithms": 0.0850296194329463,
                    "allow": 0.08171077602202738,
                    "allows": 0.16549414945736962,
                    "code": 0.0372584779334858,
                    "complicated": 0.25155082929272005,
                    "considered": 0.08073372761228584,
                    "dealing": 0.0907811727324041,
                    "disable": 0.10644396570187656,
                    "edit": 0.07089862924208894,
                    "evil": 0.09258217309888171,
                    "explicitly": 0.10262961821899998,
                    "familiar": 0.08385027643090669,
                    "function": 0.14760566262157687,
                    "functions": 0.5031016585854401,
                    "huge": 0.15619744626289778,
                    "internally": 0.09951306940037913,
                    "languages": 0.1165342591702018,
                    "line": 0.0725813336793805,
                    "mitigate": 0.10644396570187656,
                    "nested": 0.5131480910949999,
                    "python": 0.21600549283293244,
                    "reading": 0.07144133176155501,
                    "scope": 0.2723435181972123,
                    "static": 0.0907811727324041,
                    "structure": 0.09459552021528068,
                    "structured": 0.09459552021528068,
                    "support": 0.07037262793894487,
                    "use": 0.040093703661534225,
                    "using": 0.0499483936597162,
                    "variables": 0.08915196972703816,
                    "write": 0.052479167978916774
                },
                "Max term": "nested",
                "Max score": 0.5131480910949999
            }
        ],
        "Best Answer": "Always remember the rule, a functions does one thing and does it well! If you can do so, avoid nested functions. It hinders readability and testing. ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "avoid": 0.2742274327299069,
                "functions": 0.6231209733000938,
                "nested": 0.3813384422574693,
                "readability": 0.33125986289209314,
                "remember": 0.2766244957864191,
                "rule": 0.31594254351715284,
                "testing": 0.23259950745030797,
                "thing": 0.22566375456852214
            },
            "Max term": "functions",
            "Max score": 0.6231209733000938
        }
    },
    {
        "ID": "7720",
        "Question": "I'm looking at licensing some open source software and am looking at the GPL.  What are the pros and cons of using this license? ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "cons": 0.3882100745869077,
                    "gpl": 0.3611719801298576,
                    "license": 0.33665056721317826,
                    "looking": 0.49100318028625795,
                    "open": 0.25844871815212794,
                    "pros": 0.40036803189463327,
                    "software": 0.19608842447015937,
                    "source": 0.24682211143244553,
                    "using": 0.19485349758552195
                },
                "Max term": "looking",
                "Max score": 0.49100318028625795
            }
        ],
        "Best Answer": "Ok, my list of pros and cons of GPL: Pros  It makes people think hard about whether they really buy into Open Source; are you prepared to live by it, and let other people use what you've written, rather than just liking it because of what you can get out of it? It makes sure that when something has been developed by the Open Source community, it stays Open Source; no chance of someone taking all the work that others have been doing, repackaging it and selling it on.  Cons  It's a complete no-no for most corporate organisations; they can't afford the risk of GPL-licenced code getting into their products, so virtually all medium-large companies have clauses explicitly banning GPL-licenced code. It puts people off Open Source. Is it really fair, that because I use your Open-Source image picker control in my app, my whole app must now be Open Source too?  Even if I improved the image picker and contributed that code back to the community?  The terms are too onerous for many developers. Lots of people aren't aware of the stringent terms of GPL, so use it as it's the licence they've heard of without realising what restrictions they're placing on anyone else that wants to use it. Its extremely viral.  If your project contains a component that contains a component that contains a component that is under the GPL (phew!), your whole project is subject to the GPL too.  Ultimately for me the cons outweigh the pros.  To me it smacks of Open Source Evangelists trying to trick the world into going Open Source instead of persuading the world of its benefits. ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "afford": 0.08059510513995054,
                "app": 0.10504356231345895,
                "aware": 0.06873586598218158,
                "benefits": 0.06637614011088114,
                "buy": 0.06438102031449842,
                "chance": 0.06265276893628668,
                "code": 0.08463187912823723,
                "community": 0.1432478740762372,
                "companies": 0.05795580661677528,
                "complete": 0.0558805462564062,
                "component": 0.2200565652489911,
                "cons": 0.2260419246381392,
                "contains": 0.1960205237444253,
                "control": 0.054092513433658236,
                "corporate": 0.0716239370381186,
                "developed": 0.06750229875602667,
                "developers": 0.04598450909898827,
                "explicitly": 0.07770703408401351,
                "extremely": 0.06637614011088114,
                "fair": 0.07770703408401351,
                "getting": 0.048984638514943356,
                "going": 0.0416615812273368,
                "gpl": 0.42059706771285355,
                "hard": 0.053283333726957274,
                "heard": 0.06348806905494411,
                "image": 0.15541406816802703,
                "improved": 0.07534730821271306,
                "instead": 0.05215717508181173,
                "large": 0.05451690095311218,
                "let": 0.05252178115672947,
                "licence": 0.07534730821271306,
                "list": 0.054092513433658236,
                "live": 0.06637614011088114,
                "lots": 0.06042856953611509,
                "makes": 0.09066359944105323,
                "medium": 0.07009951128547559,
                "ok": 0.06186812508476605,
                "open": 0.40129644228343225,
                "outweigh": 0.08059510513995054,
                "people": 0.14418487825924697,
                "prepared": 0.07534730821271306,
                "products": 0.06873586598218158,
                "project": 0.07611721551131882,
                "pros": 0.23312110225204055,
                "really": 0.07516718890566716,
                "restrictions": 0.08059510513995054,
                "risk": 0.06348806905494411,
                "selling": 0.07335218841633036,
                "source": 0.3832436697806456,
                "subject": 0.07009951128547559,
                "sure": 0.047397838377811245,
                "taking": 0.06637614011088114,
                "terms": 0.12225668636728731,
                "think": 0.034214838878147885,
                "trick": 0.08059510513995054,
                "trying": 0.04985750806413609,
                "ultimately": 0.07335218841633036,
                "use": 0.12142938270832965,
                "wants": 0.06265276893628668,
                "work": 0.03412526994121932,
                "world": 0.09971501612827217,
                "written": 0.05495567720082019
            },
            "Max term": "gpl",
            "Max score": 0.42059706771285355
        }
    },
    {
        "ID": "7747",
        "Question": " It is practically impossible to teach good programming to students that have had a prior exposure to BASIC: as potential programmers they are mentally mutilated beyond hope of regeneration  -- Edsger W. Dijkstra I have deep respect to Dijkstra but I don't agree with everything he said/wrote. I disagree specially with this quote on linked paper wrote 35 years ago about the Dartmouth BASIC implementation. Many of my coworkers or friends programmers started with BASIC, questions below have answers that indicate many programmers had their first experience on programming at BASIC. AFAIK many good programmers started at BASIC programming. I'm not talking about Visual Basic or other \"modern\" dialects of BASIC running on machines full of resources. I'm talking about old times BASIC running on \"toy\" computer, that the programmer had to worry about saving small numbers that need not be calculated as a string to save a measly byte because the computer had only a few hundreds of them, or have to use computed goto for lack of a more powerful feature, and many other things which require the programmer to think much before doing something and forcing the programmer to be creative. If you had experience with old time BASIC on a machine with limited resources (have in mind that a simple micro-controller today has much more resources than a computer in 1975, do you think that BASIC help your mind to find better solutions, to think like an engineer or BASIC drag you to dark side of programming and mutilated you mentally? Is good to learn a programming language running on a computer full of resources where the novice programmer can do all wrong and the program runs without big problems? Or is it better to learn where the programmer can't go wrong? What can you say about the BASIC have helped you to be a better/worse programmer? Would you teach old BASIC running on a 2KB (virtual) machine to a coming programmer? Sure, only exposure to BASIC is bad. Maybe you share my opinion that modern BASIC doesn't help too much because modern BASIC, as long other programming languages, gives facilities which allow the programmer doesn't think deeper. Additional information: Why BASIC? ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "additional": 0.04867312599509742,
                    "ago": 0.0422043863611797,
                    "agree": 0.04517632988173375,
                    "allow": 0.04461055553404263,
                    "answers": 0.04101139182839474,
                    "bad": 0.034357845787354346,
                    "basic": 0.7104222463981966,
                    "better": 0.08717154298681622,
                    "big": 0.03616979098601062,
                    "coming": 0.04867312599509742,
                    "computer": 0.147445590412215,
                    "controller": 0.05603134012289968,
                    "coworkers": 0.05603134012289968,
                    "creative": 0.058113809149569186,
                    "dark": 0.058113809149569186,
                    "deep": 0.05603134012289968,
                    "deeper": 0.05432983903679862,
                    "dijkstra": 0.11622761829913837,
                    "disagree": 0.05289124036661661,
                    "engineer": 0.05432983903679862,
                    "experience": 0.06663968320498857,
                    "exposure": 0.10865967807359724,
                    "feature": 0.036394679424356306,
                    "friends": 0.058113809149569186,
                    "gives": 0.04711410734974203,
                    "good": 0.07623750989518369,
                    "goto": 0.05289124036661661,
                    "help": 0.06307366831817597,
                    "helped": 0.05289124036661661,
                    "hope": 0.04867312599509742,
                    "hundreds": 0.058113809149569186,
                    "implementation": 0.04711410734974203,
                    "impossible": 0.0478610994028809,
                    "information": 0.03870759024781603,
                    "lack": 0.04711410734974203,
                    "language": 0.027355679909504344,
                    "languages": 0.031811336848210595,
                    "learn": 0.06307366831817597,
                    "like": 0.020715698432757043,
                    "limited": 0.049562600488981964,
                    "linked": 0.05289124036661661,
                    "long": 0.03223885061389832,
                    "machine": 0.08922111106808527,
                    "machines": 0.049562600488981964,
                    "maybe": 0.03900388239019612,
                    "mentally": 0.11622761829913837,
                    "micro": 0.058113809149569186,
                    "mind": 0.07861978148458737,
                    "modern": 0.1392675021980967,
                    "need": 0.027355679909504344,
                    "numbers": 0.04867312599509742,
                    "old": 0.12303417548518424,
                    "opinion": 0.04178954390577627,
                    "paper": 0.0478610994028809,
                    "potential": 0.04711410734974203,
                    "powerful": 0.05164506951565147,
                    "practically": 0.058113809149569186,
                    "prior": 0.05432983903679862,
                    "problems": 0.03512009936243999,
                    "program": 0.035525920629523124,
                    "programmer": 0.240323595445212,
                    "programmers": 0.12455860008909962,
                    "programming": 0.14802546233014316,
                    "questions": 0.0373526909601146,
                    "quote": 0.04642250073269889,
                    "require": 0.04064536771582432,
                    "resources": 0.18845642939896812,
                    "running": 0.17055412247971335,
                    "runs": 0.050545868924028056,
                    "said": 0.03686139760305375,
                    "save": 0.050545868924028056,
                    "saving": 0.058113809149569186,
                    "say": 0.03027377204814392,
                    "share": 0.04517632988173375,
                    "simple": 0.03595019453453237,
                    "small": 0.03473119231582861,
                    "solutions": 0.045778630376211396,
                    "specially": 0.058113809149569186,
                    "started": 0.07574258414422336,
                    "string": 0.05289124036661661,
                    "students": 0.05164506951565147,
                    "sure": 0.0341766280819066,
                    "talking": 0.08618772171012849,
                    "teach": 0.10865967807359724,
                    "things": 0.027618582325423396,
                    "think": 0.09868364155342878,
                    "time": 0.02290482483279787,
                    "times": 0.03842041624840913,
                    "today": 0.045778630376211396,
                    "use": 0.021889431000828508,
                    "virtual": 0.05289124036661661,
                    "visual": 0.04711410734974203,
                    "worry": 0.050545868924028056,
                    "worse": 0.049562600488981964,
                    "wrong": 0.07521677931238524,
                    "wrote": 0.0903526597634675,
                    "years": 0.0341766280819066
                },
                "Max term": "basic",
                "Max score": 0.7104222463981966
            }
        ],
        "Best Answer": "The Basics popular at the time of the quote were very different from what we had even 20 years ago.  (Are you counting those among your \"modern\" dialects? ;) Forget loops, subroutines, local variables, and everything that Structured Programming (of which Dijkstra and Knuth were big proponents) emphasized.  You had GOTO, and you liked it. In this context, programmers who only knew global variables, invented their own subroutines (using more global variables for parameters and return values!), and wrote spaghetti GOTOs really were mutilated. If you're 30-something or younger today and Basic was your first language, it wasn't the same language Dijkstra was talking about.  Even if you're older and your first Basic had some of these features, as Murph comments below, it still may not have been the same language Dijkstra was talking about.  You've updated the question with context I never knew before:  Dijkstra's quote is from 1975. It wasn't until version 6 that you got separately compilable procedures â€” which, I believe, shows the beginning of the shift in focus away from GOTO. \"In 1976, Steve Garland added structured programming features to create Dartmouth SBASIC, a precompiler which produced version 6 output...\" [Wikipedia] The context of the quote is clearly before what we now know as control structures, and many users of the time could've been more familiar with the second-to-latest version â€” i.e. two versions before Garland's, which is v5 and before separately compilable procedures. GOSUB/RETURN still only handle \"simple subroutines\". \"Variable names were limited to A to Z, A0 to A9, B0 to B9, ..., Z0 to Z9, giving a maximum of 286 possible distinct variables.\" ...and they're all global.  ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "20": 0.07453531258024204,
                "30": 0.07700170637578586,
                "added": 0.07453531258024204,
                "ago": 0.06676805115580858,
                "away": 0.06374445751108798,
                "basic": 0.1322235267870288,
                "basics": 0.08864252524935193,
                "beginning": 0.08864252524935193,
                "believe": 0.06548341138910276,
                "big": 0.0572212194766136,
                "clearly": 0.07242256548037862,
                "comments": 0.06817521480939737,
                "context": 0.22715119982724005,
                "control": 0.061704799885425064,
                "create": 0.05909258718961099,
                "different": 0.04946994510694856,
                "dijkstra": 0.3677481055122133,
                "distinct": 0.09193702637805333,
                "familiar": 0.07242256548037862,
                "features": 0.11588311917884017,
                "focus": 0.07453531258024204,
                "forget": 0.08170337115807605,
                "giving": 0.07571706660908002,
                "global": 0.2659275757480558,
                "got": 0.05909258718961099,
                "goto": 0.16734966893112835,
                "handle": 0.07146971593809877,
                "invented": 0.0859507218290573,
                "knew": 0.18387405275610666,
                "know": 0.040092416289254675,
                "knuth": 0.09193702637805333,
                "language": 0.12983144121340026,
                "latest": 0.08367483446556417,
                "liked": 0.08864252524935193,
                "limited": 0.07840887002937465,
                "local": 0.07700170637578586,
                "loops": 0.08864252524935193,
                "modern": 0.0734411792455869,
                "names": 0.07242256548037862,
                "older": 0.08170337115807605,
                "output": 0.07453531258024204,
                "parameters": 0.09193702637805333,
                "popular": 0.0734411792455869,
                "possible": 0.05406800214028749,
                "procedures": 0.18387405275610666,
                "produced": 0.09193702637805333,
                "programmers": 0.04926345162012944,
                "programming": 0.07805959280030433,
                "question": 0.04716438126384344,
                "quote": 0.2203235377367607,
                "really": 0.042872627420637674,
                "return": 0.14484513096075724,
                "second": 0.06817521480939737,
                "separately": 0.1719014436581146,
                "shift": 0.08864252524935193,
                "shows": 0.08170337115807605,
                "simple": 0.056873814186072034,
                "spaghetti": 0.09193702637805333,
                "steve": 0.08367483446556417,
                "structured": 0.1634067423161521,
                "structures": 0.08170337115807605,
                "talking": 0.13635042961879473,
                "time": 0.07247163851943922,
                "today": 0.07242256548037862,
                "updated": 0.07996441728006128,
                "users": 0.059497106840106714,
                "using": 0.0431410719729861,
                "values": 0.07840887002937465,
                "variable": 0.07840887002937465,
                "variables": 0.30800682550314346,
                "version": 0.19833529018054322,
                "versions": 0.07700170637578586,
                "wikipedia": 0.07571706660908002,
                "wrote": 0.07146971593809877,
                "years": 0.05406800214028749
            },
            "Max term": "dijkstra",
            "Max score": 0.3677481055122133
        }
    },
    {
        "ID": "7804",
        "Question": "I tried programming Scala in Netbeans and Eclipse, but it is not what I'm looking for. In Netbeans suggestions for method names etc. are not working. In Eclipse I can't go to some classes sources by pressing F3. (e.g. scala List). Is support in IntelliJ IDEA any better? Are there other IDE's supporting Scala? ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "better": 0.10189270070900172,
                    "classes": 0.1678310321224579,
                    "eclipse": 0.39296204062812223,
                    "ide": 0.1495174304687379,
                    "idea": 0.11800914768269923,
                    "intellij": 0.2037834628084756,
                    "list": 0.1367720741896612,
                    "looking": 0.12048015594996614,
                    "method": 0.14252815125122295,
                    "names": 0.16052858962804342,
                    "netbeans": 0.39296204062812223,
                    "programming": 0.08651168497039216,
                    "scala": 0.5715434710664459,
                    "sources": 0.19051449035548196,
                    "suggestions": 0.17379756208103708,
                    "support": 0.13472607595714411,
                    "supporting": 0.2037834628084756,
                    "tried": 0.15279269294641246,
                    "working": 0.10874375242342235
                },
                "Max term": "scala",
                "Max score": 0.5715434710664459
            }
        ],
        "Best Answer": "IntelliJ IDEA Same question has been asked on Stack Overflow. Check out Which is the best IDE for Scala development? ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "asked": 0.27851473783273634,
                "best": 0.22207773632792624,
                "check": 0.2849626574458774,
                "development": 0.21293289884643088,
                "ide": 0.3090924132732208,
                "idea": 0.24395638776836795,
                "intellij": 0.42127477784481654,
                "overflow": 0.33185541653521766,
                "question": 0.21611710778430096,
                "scala": 0.3938442722222013,
                "stack": 0.3195210075102458
            },
            "Max term": "intellij",
            "Max score": 0.42127477784481654
        }
    },
    {
        "ID": "7823",
        "Question": "In the comment to this great post, Roy Osherove mentioned the OAPT project that is designed to run each assert in a single test. The following is written on the project's home page:  Proper unit tests should fail for exactly one reason, thatâ€™s why you should be using one assert per unit test.  And, also, Roy wrote in comments:  My guideline is usually that you test one logical CONCEPT per test. you can have multiple asserts on the same object. they will usually be the same concept being tested.  I think that, there are some cases where multiple assertions are needed (e.g. Guard Assertion), but in general I try to avoid this. What is your opinion? Please provide a real world example where multiple asserts are really needed. ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "assert": 0.30692405278753704,
                    "asserts": 0.30692405278753704,
                    "avoid": 0.10640276291727253,
                    "cases": 0.10640276291727253,
                    "comment": 0.12638753864672692,
                    "comments": 0.11379861875735062,
                    "concept": 0.23560755527782085,
                    "designed": 0.12441494528462783,
                    "exactly": 0.12258860909238797,
                    "example": 0.0818910247896062,
                    "fail": 0.11639515078199972,
                    "following": 0.11035428900119393,
                    "general": 0.1082994108855615,
                    "great": 0.09493422963069385,
                    "home": 0.12441494528462783,
                    "logical": 0.12258860909238797,
                    "mentioned": 0.1363799265114541,
                    "multiple": 0.3248982326566845,
                    "needed": 0.21280552583454507,
                    "object": 0.11035428900119393,
                    "opinion": 0.11035428900119393,
                    "page": 0.12088833077493781,
                    "post": 0.11506270408092256,
                    "project": 0.14493562748673577,
                    "proper": 0.13088071863966502,
                    "provide": 0.11144976983048403,
                    "real": 0.09274218458884988,
                    "really": 0.0715633356874231,
                    "reason": 0.09551412134534638,
                    "run": 0.09493422963069385,
                    "single": 0.10072167775659602,
                    "test": 0.3468965240412361,
                    "tested": 0.12441494528462783,
                    "tests": 0.09734045753758624,
                    "think": 0.06514885113505654,
                    "try": 0.08798821633388096,
                    "unit": 0.19862610179937062,
                    "using": 0.07201142550064324,
                    "usually": 0.20001460267656893,
                    "world": 0.09493422963069385,
                    "written": 0.10464170957324302,
                    "wrote": 0.11929782662913972
                },
                "Max term": "test",
                "Max score": 0.3468965240412361
            }
        ],
        "Best Answer": "I don't think it's necessarily a bad thing, but I do think we should strive towards only having single asserts in our tests.  This means you write a lot more tests and our tests would end up testing only one thing at a time. Having said that, I would say maybe half of my tests actually only have one assert.  I think it only becomes a code (test?) smell when you have about five or more asserts in your test. How do you solve multiple asserts? ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "actually": 0.10413944710250718,
                "assert": 0.18940915141560835,
                "asserts": 0.568227454246825,
                "bad": 0.11198182515109431,
                "code": 0.06629870131092176,
                "end": 0.10555444461936064,
                "half": 0.1615383716529014,
                "lot": 0.0971683094849294,
                "maybe": 0.12712455737374437,
                "means": 0.12257625640324757,
                "multiple": 0.13366759189019448,
                "necessarily": 0.14201512681470602,
                "said": 0.12014160045882158,
                "say": 0.09867068701400056,
                "single": 0.12431484166696677,
                "smell": 0.1770761348997359,
                "solve": 0.13490927291912005,
                "test": 0.21407698631282618,
                "testing": 0.11139118598438609,
                "tests": 0.4805664018352863,
                "thing": 0.21613935068583331,
                "think": 0.24122818326789516,
                "time": 0.07465322783673628,
                "write": 0.09338279167203703
            },
            "Max term": "asserts",
            "Max score": 0.568227454246825
        }
    },
    {
        "ID": "7826",
        "Question": "I like the GPL license but the project I'm working on is a more general purpose one that will be used inside other programs. It doesn't run independently like a CMS or application would. So I'm looking around at other projects to see what they've done.  JQuery has an interesting MIT/GPL license Zend framework has New BSD license Symfony framework has MIT license   As developers, is there an established preference that we expect from libraries. I rarely cared because I never build applications that were sold or distributed, which eliminated the possibility that I would be in conflict with the license of a library I'm using, but I want to know what others are thinking. Will you avoid using a library or a framework if it's GPL?  I'm a bit torn. I'd like to use GPL and as the only license (unlike JQuery for example) but I also worry that this will scare developers away who want to use the library to build distributable code. The other thing is I'm seeing that many libraries are frameworks are released as MIT, but I find the MIT license, well, a bit too \"loose\" for my taste. ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "application": 0.056925892680065676,
                    "applications": 0.06944132172463914,
                    "avoid": 0.06883958460649892,
                    "away": 0.06883958460649892,
                    "bit": 0.13128012540831915,
                    "bsd": 0.09928559992405689,
                    "build": 0.13128012540831915,
                    "cms": 0.09928559992405689,
                    "code": 0.03475284211266621,
                    "developers": 0.11329719255724777,
                    "distributed": 0.08823396340762996,
                    "example": 0.052981181831716115,
                    "expect": 0.08049295824106606,
                    "framework": 0.19549224853375013,
                    "frameworks": 0.07530437754020926,
                    "general": 0.07006666231296116,
                    "gpl": 0.34542405622654476,
                    "inside": 0.08635601405663619,
                    "interesting": 0.06944132172463914,
                    "jquery": 0.16935226223701805,
                    "know": 0.043297023631317995,
                    "libraries": 0.14569315467118155,
                    "library": 0.21631456691360978,
                    "license": 0.5634507076874625,
                    "like": 0.10617634139840457,
                    "looking": 0.05869928991087303,
                    "mit": 0.3829110705397438,
                    "new": 0.0470343415816444,
                    "possibility": 0.09928559992405689,
                    "preference": 0.09928559992405689,
                    "programs": 0.06883958460649892,
                    "project": 0.046884630235713196,
                    "projects": 0.057787948090071976,
                    "purpose": 0.07530437754020926,
                    "rarely": 0.07530437754020926,
                    "released": 0.08635601405663619,
                    "run": 0.06141976724604461,
                    "scare": 0.09572776763493596,
                    "seeing": 0.0817691704739196,
                    "sold": 0.09036300678572805,
                    "taste": 0.09282080699034655,
                    "thing": 0.05664859627862388,
                    "thinking": 0.06257285808565514,
                    "unlike": 0.09572776763493596,
                    "use": 0.07479479733706697,
                    "used": 0.048449035184960416,
                    "using": 0.0931787198465954,
                    "want": 0.09376926047142639,
                    "working": 0.052981181831716115,
                    "worry": 0.08635601405663619
                },
                "Max term": "license",
                "Max score": 0.5634507076874625
            }
        ],
        "Best Answer": " Will you avoid using a library or a framework if it's GPL?  Yes. Using a GPL'd library would essentially require me to publish the source of my software that uses the library, or even GPL it (altough this is somewhat unclear - but better not take legal risks). Publishing sources (let alone GPL'ing a software product) is typically impossible with commercial software (depending on corporate policies). And even if I could publish the source, I dislike the idea that some 3rd party library's license defines how I should license my software. Consider using LGPL, or even better, another licence widely used in libraries the Apache License. Regardless of the details - all GPL licenses are quite incomprehensible and subject to continuous re-interpretation by lawyers and by the FSF - it's clear that the spirit of GPL is to make all software free via viral licenses. In practice they're better to avoid, unless, of course, you agree with their goals and understand them. ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "3rd": 0.09402892361591246,
                "agree": 0.08031351963486838,
                "apache": 0.09961132626110067,
                "avoid": 0.1432646449683647,
                "better": 0.15497171743701538,
                "clear": 0.08508644586008907,
                "commercial": 0.09402892361591246,
                "consider": 0.06685939625896165,
                "continuous": 0.09658643377326312,
                "corporate": 0.09181350754804243,
                "course": 0.07290918123463674,
                "defines": 0.10331349546121649,
                "depending": 0.09961132626110067,
                "details": 0.07930769801763762,
                "dislike": 0.09658643377326312,
                "essentially": 0.09181350754804243,
                "framework": 0.06780771010446357,
                "free": 0.0659623683137498,
                "fsf": 0.10331349546121649,
                "goals": 0.09961132626110067,
                "gpl": 0.5391562325118585,
                "idea": 0.05982790446031961,
                "impossible": 0.08508644586008907,
                "interpretation": 0.10331349546121649,
                "legal": 0.09181350754804243,
                "let": 0.06732677858944854,
                "lgpl": 0.10331349546121649,
                "libraries": 0.07580187401478505,
                "library": 0.3001202462944379,
                "licence": 0.09658643377326312,
                "license": 0.2512753777665385,
                "licenses": 0.17622267669585323,
                "make": 0.0468843129204511,
                "party": 0.08508644586008907,
                "practice": 0.07503006157360947,
                "product": 0.06780771010446357,
                "publish": 0.19317286754652624,
                "publishing": 0.10331349546121649,
                "quite": 0.0659623683137498,
                "regardless": 0.09181350754804243,
                "require": 0.0722584713423388,
                "risks": 0.09961132626110067,
                "software": 0.24393341213444752,
                "somewhat": 0.08375845925551283,
                "source": 0.1228183866429254,
                "sources": 0.09658643377326312,
                "spirit": 0.10331349546121649,
                "subject": 0.08985937208530975,
                "typically": 0.09402892361591246,
                "unclear": 0.09961132626110067,
                "understand": 0.05655351891706444,
                "unless": 0.07661135043475256,
                "used": 0.05041455337441043,
                "uses": 0.08138427665997325,
                "using": 0.14543830007548758,
                "widely": 0.09658643377326312,
                "yes": 0.06732677858944854
            },
            "Max term": "gpl",
            "Max score": 0.5391562325118585
        }
    },
    {
        "ID": "7834",
        "Question": "I'm two months away from getting my degree in systems engineering, which is to say, I learned how to code and code well using managed languages. The only reason I got into this career was because I wanted to create video games. I know now that with my current skillset, I won't be able to create some of the things I have in my head. Would getting a second degree in pure mathematics would help me with this goal? ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "able": 0.14728187449656516,
                    "away": 0.16203228317509727,
                    "career": 0.1649205371288053,
                    "code": 0.16360012590219394,
                    "create": 0.3004153520136452,
                    "current": 0.17146380697455196,
                    "degree": 0.37892319885051723,
                    "engineering": 0.18668041766869073,
                    "games": 0.18166914745978407,
                    "getting": 0.28407355871805434,
                    "goal": 0.18668041766869073,
                    "got": 0.1502076760068226,
                    "head": 0.18668041766869073,
                    "help": 0.12682016866488838,
                    "know": 0.10191106808343939,
                    "languages": 0.12792403588116893,
                    "learned": 0.1732948422942947,
                    "managed": 0.18409119939788546,
                    "months": 0.19246550456337483,
                    "pure": 0.2253207778897538,
                    "reason": 0.1454508391768224,
                    "say": 0.12174097304442383,
                    "second": 0.1732948422942947,
                    "systems": 0.16203228317509727,
                    "things": 0.11106356621360347,
                    "using": 0.10966045776118218,
                    "video": 0.20768211525751362,
                    "wanted": 0.19930781009202425
                },
                "Max term": "degree",
                "Max score": 0.37892319885051723
            }
        ],
        "Best Answer": "No type of degree will help you as a programmer more than programming. Experience trumps studying. If you want to be a good programmer then start programming. I don't have a degree but I've been programming on various projects for fun since I was around 15-16; needless to say I'm light years ahead of my friends who studied computer science at a university and ask me questions like \"is it better to check admin privileges for my website through PHP or the SQL GRANT option?\". ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "15": 0.1778111787133841,
                "admin": 0.19847611019301772,
                "ahead": 0.18866819209922142,
                "ask": 0.131332153718759,
                "better": 0.10615080698612113,
                "check": 0.14360569338993398,
                "computer": 0.1346609329649771,
                "degree": 0.34423163873757995,
                "experience": 0.12172302864787272,
                "friends": 0.212299594348026,
                "fun": 0.16296992026700674,
                "good": 0.09283618163338092,
                "help": 0.11520940026084978,
                "light": 0.1932206654273305,
                "like": 0.07567795741269116,
                "needless": 0.212299594348026,
                "option": 0.18465262603800944,
                "php": 0.14982156523946769,
                "privileges": 0.212299594348026,
                "programmer": 0.21948570646076748,
                "programming": 0.2703810511283734,
                "projects": 0.12356633738539201,
                "questions": 0.13645571086606864,
                "say": 0.11059522029719177,
                "science": 0.17211581936878997,
                "sql": 0.15742917754494226,
                "start": 0.11831089261970477,
                "studied": 0.20469198204255143,
                "type": 0.14848441711998542,
                "university": 0.17211581936878997,
                "various": 0.16723709563873856,
                "want": 0.10025208074295328,
                "website": 0.16296992026700674,
                "years": 0.12485301487118082
            },
            "Max term": "degree",
            "Max score": 0.34423163873757995
        }
    },
    {
        "ID": "7859",
        "Question": "As a solo developer, I think I'm using an Agile-like process, but I'd like to compare what I'm doing to real Agile and see if I can improve my own process. Is there a book out there that's the de-facto standard for describing best practices, methodologies, and other helpful information on Agile? What about that book makes it special? ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "agile": 0.512808113462964,
                    "best": 0.1253097629338334,
                    "book": 0.3055750504992366,
                    "compare": 0.22919071086307677,
                    "describing": 0.2377088465265438,
                    "developer": 0.13127801534442005,
                    "facto": 0.2377088465265438,
                    "helpful": 0.17440873485273892,
                    "improve": 0.1957711411287762,
                    "information": 0.15832960813064612,
                    "like": 0.16947107241821244,
                    "makes": 0.1337025344631903,
                    "methodologies": 0.1957711411287762,
                    "practices": 0.1824751096871476,
                    "process": 0.29063060013508313,
                    "real": 0.14365532790763733,
                    "solo": 0.20675292799494036,
                    "special": 0.1957711411287762,
                    "standard": 0.1560153635551817,
                    "think": 0.1009139434670768,
                    "using": 0.11154389978252711
                },
                "Max term": "agile",
                "Max score": 0.512808113462964
            }
        ],
        "Best Answer": "Is there a canonical book? There is the agile manifesto, but for a canonical book? No. There are lots of books out there. Specific book recommendations: Agile Software Development, Principles, Patterns, and Practices by Robert C. Martin  Agile Software Development, Principles, Patterns, and Practices. This is focused on developer practices and coding and is a must read for any developer serious about agile software development. There is also a C# version of the book that he and his son Micah wrote, so if you are a .NET developer, that version might be the one for you.  The art of Agile Development by James Shore  For an insight into overall agile project practices look at The Art of Agile by James Shore & Shane Warden. It's focused on XP practices (but that's really because XP is where all the specific developer practices are defined), but has a big picture focus on how Agile projects work. A great thing about this book is that James Shore is publishing the whole text on his website for free, so you can try before you buy.  Practices of an Agile Developer: Working in the Real World by  Subramaniam and Hunt  Practices of an Agile Developer: Working in the Real World  Scrum and XP from the Trenches by Henrik Kniberg  It's a great book for getting a feel for how an agile team works, and it it's a very quick read (couple of hours). I give it to new staff in my organisation - technical and non-technical - and I've had consistently positive feedback. Amazon  Extreme Programming Explained by Kent Beck  Probably the oldest book I can remember which helped make Agile principles popular. Agile is fast becoming a buzz word in the world of Tech. I feel Extreme Programming (XP) is a good place to start before the term Agile just seems to lose meaning. Amazon  Agile Estimating and Planning by Mike Cohn  For \"the Agile process\" - look to Mike Cohn's \"Agile Estimating and Planning\" - bearing in mind that it's Scrum-centric. Cohn covers a lot of the basics as well as some of the things new Scrum teams often struggle with - estimation using Story Points vs. Ideal days, what do do if you fail a story in a sprint, when to re-estimate/size and when not to, etc. He also goes into some really interesting stuff that's mainly the domain of a Product Owner - things like how to assess and prioritize features, etc.  The Art of Unit Testing by Roy Osherove  Osherove presents a very pragmatic approach to unit testing. Presents a good approach on how to refactor code to become more testable, how to look for seams, etc. It is a .Net centric book, however. Amazon  The Agile Samurai by Jonathan Rasmusson  Just purchased this myself and found it to be a refreshing look on how to get started with agile. Amazon    Alistair Cockburns book on his Crystal methodologies is worth while reading - partly because it gives you an alternative the the usual Scrum methods, and partly because he was one of the original guys who came up with Agile in the first place, so I hope he know what he's talking about. Crystal is an interesting methodology as it scales from small teams to very large ones, he describes the changes required to make agile work in these different environments.  Unsorted books mentioned  Agile Adoption Patterns: A Roadmap to Organizational Success by Amr Elssamadisy  Agile and Iterative Development: A Managerâ€™s Guide by Craig Larman  Agile Estimating and Planning by Mike Cohn  Agile Project Management: Creating Innovative Products by Jim Highsmith  Agile Retrospectives: Making Good Teams Great by Esther Derby and Diana Larsen  Agile Software Development by Alistair Cockburn  Agile Software Development with Scrum by Ken Schwaber and Mike Beedle  Becoming Agile: ...in an imperfect world by Greg Smith and Dr. Ahmed Sidky  The Business Value of Agile Software Methods: Maximizing Roi with Just-In-Time Processes and Documentation by David F. Rico, Hasan H. Sayani, and Saya Sone  Collaboration Explained by Jean Tabaka  Continuous Delivery: Reliable Software Releases through Build, Test, and Deployment Automation by Humble and Farley  Crystal Clear: A Human-Powered Methodology for Small Teams by Alistair Cockburn  Encyclopedia of Software Engineering edited by Phillip A. Laplante  Fearless Change by Linda Rising and Mary Lynn Manns  Growing Object-Oriented Software, Guided by Tests Freeman and Pryce  Innovation Games: Creating Breakthrough Products Through Collaborative Play by Luke Hohmann  Lean Software Development â€“ An Agile Toolkit for Software Development Managers by Mary and Tom Poppendieck  Lean Solutions by Jim Womack and Dan Jones  Lean Thinking by Jim Womack and Dan Jones  Managing Agile Projects by Sanjiv Augustine  Managing the Design Factory by Donald G. Reinertsen  Planning Extreme Programming by Kent Beck and Martin Fowler  Scaling Lean & Agile Development: Thinking and Organizational Tools for Large-Scale Scrum by Craig Larman and Bas Vodde  Scrum Pocket Guide: A Quick Start Guide to Agile Software Development by Peter Saddington  The Software Project Manager's Bridge to Agility by Michele Sliger and Stacia Broderick  Today and Tomorrow by Henry Ford (From 1926)  User Stories Applied by Mike Cohn   Book lists  Agile Design Recommended Reading  ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "agile": 0.7621800750349798,
                "alternative": 0.02691229793023153,
                "applied": 0.030283164692417444,
                "approach": 0.042360684406497894,
                "art": 0.0826850364610988,
                "basics": 0.0291979879775478,
                "big": 0.018848114645188346,
                "book": 0.1946452501743311,
                "books": 0.04443796281474852,
                "build": 0.02002091774447778,
                "business": 0.0197347685811248,
                "buy": 0.024190812058180355,
                "came": 0.02691229793023153,
                "canonical": 0.06056632938483489,
                "centric": 0.06056632938483489,
                "change": 0.018733682712343075,
                "changes": 0.020170564405859705,
                "clear": 0.02494046727942543,
                "code": 0.010599986725491384,
                "coding": 0.017195292287891455,
                "collaboration": 0.028311334041611343,
                "consistently": 0.028311334041611343,
                "continuous": 0.028311334041611343,
                "couple": 0.022705700553547238,
                "covers": 0.0291979879775478,
                "creating": 0.046493211167097016,
                "david": 0.0291979879775478,
                "days": 0.020819945295994444,
                "defined": 0.02582712121536189,
                "delivery": 0.0291979879775478,
                "deployment": 0.02691229793023153,
                "describes": 0.028311334041611343,
                "design": 0.03472600628111045,
                "developer": 0.10034579235716033,
                "development": 0.16837253549589973,
                "different": 0.01629492005580238,
                "documentation": 0.021776573572427994,
                "domain": 0.02494046727942543,
                "donald": 0.030283164692417444,
                "edited": 0.0291979879775478,
                "engineering": 0.024190812058180355,
                "environments": 0.02691229793023153,
                "estimate": 0.024190812058180355,
                "estimating": 0.09084949407725232,
                "estimation": 0.027561678820366267,
                "explained": 0.0583959759550956,
                "extreme": 0.0875939639326434,
                "fail": 0.02296863662861933,
                "fast": 0.023246605583548508,
                "features": 0.019085387690990063,
                "feedback": 0.02691229793023153,
                "feel": 0.036397467510107216,
                "focus": 0.024551208965434855,
                "focused": 0.05662266808322269,
                "fowler": 0.0291979879775478,
                "free": 0.019334833791361323,
                "games": 0.023541431168045617,
                "getting": 0.018405706810242083,
                "gives": 0.024551208965434855,
                "goes": 0.021776573572427994,
                "good": 0.03972744347137271,
                "great": 0.056201048137029225,
                "guide": 0.0826850364610988,
                "guided": 0.030283164692417444,
                "guys": 0.028311334041611343,
                "helped": 0.027561678820366267,
                "hope": 0.025363615157469793,
                "hours": 0.021569600517239523,
                "human": 0.02582712121536189,
                "humble": 0.030283164692417444,
                "hunt": 0.0291979879775478,
                "ideal": 0.027561678820366267,
                "interesting": 0.042360684406497894,
                "jones": 0.06056632938483489,
                "know": 0.013206053026034002,
                "large": 0.040968847604739754,
                "like": 0.0107949713938565,
                "lists": 0.026339503390805246,
                "look": 0.06979631413523413,
                "lose": 0.02582712121536189,
                "lot": 0.01553548969003734,
                "lots": 0.022705700553547238,
                "mainly": 0.0291979879775478,
                "make": 0.027485380555996107,
                "making": 0.02032496254076207,
                "management": 0.019875738821362593,
                "manager": 0.04593727325723866,
                "managers": 0.02691229793023153,
                "managing": 0.05382459586046306,
                "manifesto": 0.030283164692417444,
                "meaning": 0.0291979879775478,
                "mentioned": 0.02691229793023153,
                "methodologies": 0.02494046727942543,
                "methodology": 0.050727230314939586,
                "methods": 0.041993611955626474,
                "mind": 0.020484423802369877,
                "net": 0.037025186303127566,
                "new": 0.02869194955574289,
                "non": 0.017903908170556496,
                "object": 0.021776573572427994,
                "ones": 0.020996805977813237,
                "organizational": 0.0583959759550956,
                "oriented": 0.022705700553547238,
                "original": 0.023541431168045617,
                "overall": 0.026339503390805246,
                "owner": 0.027561678820366267,
                "patterns": 0.07901851017241573,
                "peter": 0.030283164692417444,
                "place": 0.041993611955626474,
                "planning": 0.09082280221418895,
                "play": 0.025363615157469793,
                "points": 0.021992748395283878,
                "popular": 0.024190812058180355,
                "positive": 0.028311334041611343,
                "practices": 0.18597284466838807,
                "pragmatic": 0.025363615157469793,
                "principles": 0.07748136364608565,
                "probably": 0.017195292287891455,
                "process": 0.018512593151563783,
                "processes": 0.02582712121536189,
                "product": 0.019875738821362593,
                "products": 0.05165424243072378,
                "programming": 0.038568109026184794,
                "project": 0.04290093367186805,
                "projects": 0.03525187843125465,
                "publishing": 0.030283164692417444,
                "quick": 0.05267900678161049,
                "read": 0.036397467510107216,
                "reading": 0.04064992508152414,
                "real": 0.03660223855812141,
                "really": 0.028243655208882192,
                "recommendations": 0.030283164692417444,
                "recommended": 0.0291979879775478,
                "refactor": 0.02691229793023153,
                "releases": 0.028311334041611343,
                "reliable": 0.028311334041611343,
                "remember": 0.021180342203248947,
                "required": 0.02221898140737426,
                "robert": 0.030283164692417444,
                "roi": 0.0291979879775478,
                "scale": 0.027561678820366267,
                "scrum": 0.2043859158428346,
                "size": 0.02582712121536189,
                "small": 0.03619691884788653,
                "software": 0.1859040459114282,
                "solutions": 0.02385529056455579,
                "specific": 0.0394695371622496,
                "sprint": 0.028311334041611343,
                "staff": 0.030283164692417444,
                "start": 0.03375256798876449,
                "started": 0.0197347685811248,
                "stories": 0.027561678820366267,
                "story": 0.055123357640732534,
                "struggle": 0.027561678820366267,
                "stuff": 0.019085387690990063,
                "success": 0.027561678820366267,
                "talking": 0.022456254453175974,
                "team": 0.018098459423943267,
                "teams": 0.10330848486144756,
                "tech": 0.02494046727942543,
                "technical": 0.038669667582722646,
                "term": 0.02385529056455579,
                "test": 0.017113557040183965,
                "testable": 0.0291979879775478,
                "testing": 0.03561895088212606,
                "tests": 0.019208511552442843,
                "text": 0.02385529056455579,
                "thing": 0.017278424786796982,
                "things": 0.028784142336265583,
                "thinking": 0.038170775381980125,
                "time": 0.011935727373804971,
                "today": 0.02385529056455579,
                "tools": 0.02002091774447778,
                "try": 0.017363003140555226,
                "unit": 0.03919553973286684,
                "user": 0.018301119279060706,
                "using": 0.014210250636051025,
                "usual": 0.028311334041611343,
                "value": 0.02296863662861933,
                "version": 0.04355314714485599,
                "vs": 0.023541431168045617,
                "website": 0.023246605583548508,
                "word": 0.02494046727942543,
                "work": 0.025644762619482855,
                "working": 0.03231964869499708,
                "works": 0.02032496254076207,
                "world": 0.0749347308493723,
                "worth": 0.02032496254076207,
                "wrote": 0.023541431168045617
            },
            "Max term": "agile",
            "Max score": 0.7621800750349798
        }
    },
    {
        "ID": "7861",
        "Question": "I know we've covered what questions you should ask about a company before you would decide to work there.  But what do you do with the answers? In other words, what would you consider a dealbreaker?  I.e. what would scare you so much about a company that you wouldn't work there, even if everything else was great? For example, if they tell me they don't use version control, I wouldn't work there.  End of story. ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "answers": 0.20941916326826132,
                    "ask": 0.18357483916311343,
                    "company": 0.3508874483750647,
                    "consider": 0.19204218980477528,
                    "control": 0.19916808599295618,
                    "covered": 0.26371860994512014,
                    "decide": 0.23376242652451454,
                    "end": 0.16537384386779033,
                    "example": 0.158353122610625,
                    "great": 0.18357483916311343,
                    "know": 0.12940856837702497,
                    "questions": 0.19073649876152787,
                    "scare": 0.2861165115886851,
                    "story": 0.2700820139961314,
                    "tell": 0.21136452488094962,
                    "use": 0.11177543897542173,
                    "version": 0.21339269232142238,
                    "words": 0.24439627486894583,
                    "work": 0.3769466937335819
                },
                "Max term": "work",
                "Max score": 0.3769466937335819
            }
        ],
        "Best Answer": "Companies that feel the need to mention up-front that unpaid (for salaried employees) overtime is required 100% of the time. ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "100": 0.3526576878690705,
                "companies": 0.3219275852029918,
                "employees": 0.41853229901287015,
                "feel": 0.2690356401584883,
                "mention": 0.374955561879603,
                "need": 0.21073568054987712,
                "required": 0.32846779160899237,
                "time": 0.17644832316298445,
                "unpaid": 0.44768227881717576
            },
            "Max term": "unpaid",
            "Max score": 0.44768227881717576
        }
    },
    {
        "ID": "7912",
        "Question": "How do you endorse/support a code project that you find helpful, be it established, emergent or fledgling? I think there are some obvious answers, but hopefully there will be some novel suggestions too. ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "answers": 0.34765163081103007,
                    "code": 0.17243410542122692,
                    "helpful": 0.3614448094673294,
                    "hopefully": 0.4377928141427825,
                    "obvious": 0.3829576139029699,
                    "project": 0.23262872275282742,
                    "suggestions": 0.4201398225968126,
                    "support": 0.32568805323866634,
                    "think": 0.20913414170369246
                },
                "Max term": "hopefully",
                "Max score": 0.4377928141427825
            }
        ],
        "Best Answer": "It is really going to depend on what state the project is in.  If this is code that is avaialble as a completed app that's offered as free to try/purchase to continue then I'll probably pay for the app if I think I'll use it. ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "app": 0.4193839811839936,
                "code": 0.11263027015391248,
                "completed": 0.28595690398886253,
                "continue": 0.2744263474206573,
                "depend": 0.32177408413351444,
                "free": 0.20544247928773426,
                "going": 0.16633289477942784,
                "offered": 0.2928569074495058,
                "pay": 0.26950135893998145,
                "probably": 0.18270875859714084,
                "project": 0.15194810693166486,
                "purchase": 0.32177408413351444,
                "really": 0.15005162736007543,
                "state": 0.26950135893998145,
                "think": 0.13660194902251546,
                "try": 0.18449077202153855,
                "use": 0.12120099707054853
            },
            "Max term": "app",
            "Max score": 0.4193839811839936
        }
    },
    {
        "ID": "7915",
        "Question": "I have been offered an interesting job, but there's a big caveat for me: they use pair programming. I hate the idea of pair programming, and I'm probably not suited for it: I like to do frequent pauses, I hate to see someone programming (I would constantly poke the pair away to code myself), I have to be in full control of the machine I'm working on, I like to work listening music, and basically I don't like to being tied to someone else. I'm not even a social person. I have however never actually worked with true pair programming (besides few times for a short time to help someone else or to solve a complex task together)... so it is pair programming really that bad? And given my attitude, should I refuse the job or should I leave my current one and give a try?  For people that asked about it: I'm looking for a job where formal design and development are used, as I hate my current job where we are \"coding in the wild\". The company is very interested in my technical profile so they insisted even when I specified I never worked with pair programming and that I probably wouldn't like it (besides being an unsociable loner programmer, I don't like and believe the very concept of pair programming). ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "actually": 0.06105480464101993,
                    "asked": 0.07341558430800439,
                    "attitude": 0.10106713293224802,
                    "away": 0.07699411181528563,
                    "bad": 0.06565262874129771,
                    "basically": 0.08747601473549578,
                    "believe": 0.07909451731802608,
                    "big": 0.06911498101341661,
                    "code": 0.03886955778157005,
                    "coding": 0.06305417397814703,
                    "company": 0.06565262874129771,
                    "complex": 0.08147576068040109,
                    "concept": 0.08524400099314465,
                    "constantly": 0.09658548406713256,
                    "control": 0.07453049955114684,
                    "current": 0.16295152136080218,
                    "design": 0.0636691602839821,
                    "development": 0.0561284236118096,
                    "formal": 0.09658548406713256,
                    "frequent": 0.10706738698734272,
                    "given": 0.07699411181528563,
                    "hate": 0.3212021609620282,
                    "help": 0.06026210367020545,
                    "idea": 0.06430611497636762,
                    "interested": 0.08234582765337377,
                    "interesting": 0.07766712887694179,
                    "job": 0.2464142022756783,
                    "leave": 0.08747601473549578,
                    "like": 0.19792277821199336,
                    "looking": 0.06565262874129771,
                    "machine": 0.08524400099314465,
                    "offered": 0.10106713293224802,
                    "pair": 0.5967080069520124,
                    "people": 0.0496657038203753,
                    "person": 0.07571979586365653,
                    "probably": 0.12610834795629405,
                    "profile": 0.11104666923685748,
                    "programmer": 0.0574027395634387,
                    "programming": 0.32999655779436265,
                    "really": 0.05178395108100933,
                    "short": 0.07985347592205239,
                    "social": 0.09868588956987301,
                    "solve": 0.07909451731802608,
                    "suited": 0.09470660732035825,
                    "task": 0.07341558430800439,
                    "technical": 0.07089975286884456,
                    "time": 0.04376764394482512,
                    "times": 0.07341558430800439,
                    "true": 0.08632510990288852,
                    "try": 0.0636691602839821,
                    "use": 0.04182738044026559,
                    "used": 0.05418816010725007,
                    "work": 0.04701895428017283,
                    "worked": 0.14576644265232033,
                    "working": 0.05925717102122116
                },
                "Max term": "pair",
                "Max score": 0.5967080069520124
            }
        ],
        "Best Answer": "Guess what - nobody likes pair programming at first. When I first tried pair programming I was against the idea and I had tons of objections similar to yours.  I don't like to watch someone else coding, I like to listen to music, I feel I'll be quicker working on my own, I don't want to stop and explain myself constantly, etc etc etc. Then I tried it.  And guess what?  It still sucked.  We were having all kinds of problems - I wanted to work different hours to the other guy, we had different keyboard settings and shortcuts, our desks didn't work very well for pair programming etc etc. This went on for about a week.  During that week we were rewriting the entire legacy login system for a distributed application.  We had to learn how some seriously difficult threading issues work, figure out how remoting sinks worked, change tons and tons of legacy code to work with our new login module and pretty much do some of the most hectic coding I've had to do in my career.  After a week of this we deployed it.. and everything just worked.  Not a single bug.  Not one. That's when I figured there might be something to this pair programming nonsense.  We started to do more pair programming.  We even started to force everyone to work in pairs.  It rocked.  I probably learnt more in a month of doing that than I did in the previous 2 years.  The other issues didn't go away.  Sometimes you'll be stuck with a pair that you dislike.  It's gonna happen.  Sometimes you'll struggle to find overlapping working hours.  Sometimes you'll want to just work on your own.  But the advantages of pair programming are just incredible. Since then I've always tried to do as much pair programming as possible.  It's simply the best way of learning.  This company forces everyone to do pair programming? Where do I sign up?  It seems to me they are really enlightened and you will be in a really intense working environment.  Awesome. Having said that, make sure that the pairs are rotated often.  You don't want to be stuck developing with one other developer for months on end - you'll go out of your mind.  We're all human, after all.  Also, check that this has been an ongoing practice for a while.  If it's not, it's not the end of the world, but if it's an accepted practice it's a massive green light. Trust me, you want to work for a company like that. ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "accepted": 0.06799983135801022,
                "advantages": 0.062034021532195324,
                "application": 0.0438714407995631,
                "away": 0.053053041745063555,
                "awesome": 0.07651706656227254,
                "best": 0.04033646879961633,
                "bug": 0.053998721547716406,
                "career": 0.053998721547716406,
                "change": 0.04733476377440063,
                "check": 0.05175839564641659,
                "code": 0.026783194493431348,
                "coding": 0.08689536499332691,
                "company": 0.09047631230921564,
                "constantly": 0.06655254015364143,
                "deployed": 0.07377512925925679,
                "developer": 0.042257613820654946,
                "developing": 0.05502329583000667,
                "different": 0.0823453886144822,
                "difficult": 0.05556950899753909,
                "dislike": 0.07153480335795698,
                "distributed": 0.06799983135801022,
                "end": 0.0852832759612666,
                "entire": 0.062034021532195324,
                "environment": 0.05022041935892338,
                "explain": 0.04951806974511678,
                "feel": 0.04598309774517002,
                "figure": 0.0580353049493791,
                "figured": 0.07651706656227254,
                "force": 0.06964063479778905,
                "forces": 0.07153480335795698,
                "gonna": 0.07153480335795698,
                "green": 0.06964063479778905,
                "guess": 0.12406804306439065,
                "guy": 0.06301756815369466,
                "happen": 0.0580353049493791,
                "hours": 0.1090006658988647,
                "human": 0.06525789405499448,
                "idea": 0.044310336490261025,
                "issues": 0.1134813177014643,
                "keyboard": 0.06655254015364143,
                "learn": 0.04152379742142879,
                "learning": 0.04705227379327677,
                "legacy": 0.13310508030728285,
                "light": 0.06964063479778905,
                "like": 0.08182759824520915,
                "likes": 0.07153480335795698,
                "listen": 0.07377512925925679,
                "login": 0.15303413312454509,
                "make": 0.03472392523789196,
                "massive": 0.07651706656227254,
                "mind": 0.05175839564641659,
                "module": 0.07377512925925679,
                "month": 0.06027563085067891,
                "months": 0.06301756815369466,
                "new": 0.036248256023714946,
                "nonsense": 0.07377512925925679,
                "ongoing": 0.07651706656227254,
                "pair": 0.5286388910686713,
                "pairs": 0.14306960671591396,
                "possible": 0.04499955112367069,
                "practice": 0.11113901799507818,
                "pretty": 0.047920006428397874,
                "previous": 0.05556950899753909,
                "probably": 0.043447682496663455,
                "problems": 0.04624179725808539,
                "programming": 0.2598687946927372,
                "really": 0.07136379792304316,
                "rewriting": 0.07377512925925679,
                "said": 0.04853452312361745,
                "seriously": 0.06112339959352673,
                "settings": 0.06964063479778905,
                "shortcuts": 0.07377512925925679,
                "sign": 0.06655254015364143,
                "similar": 0.049864227086248665,
                "simply": 0.05135548174714359,
                "single": 0.05022041935892338,
                "started": 0.09972845417249733,
                "stop": 0.06301756815369466,
                "struggle": 0.06964063479778905,
                "stuck": 0.14306960671591396,
                "sure": 0.04499955112367069,
                "threading": 0.07377512925925679,
                "tons": 0.2295511996868176,
                "tried": 0.17211281762442293,
                "trust": 0.06525789405499448,
                "want": 0.1445315081033965,
                "wanted": 0.06525789405499448,
                "watch": 0.06799983135801022,
                "way": 0.03364621897563405,
                "week": 0.1762129636895571,
                "went": 0.0587376545631857,
                "work": 0.2267899375414326,
                "worked": 0.10044083871784676,
                "working": 0.12249403598909042,
                "world": 0.04733476377440063,
                "years": 0.04499955112367069
            },
            "Max term": "pair",
            "Max score": 0.5286388910686713
        }
    },
    {
        "ID": "7927",
        "Question": "No one's perfect, and no matter what we do, we are going to produce code that has bugs in it from time to time. What are some methods/techniques for reducing the number of bugs you produce, both when writing new software and changing/maintaining existing code? ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "bugs": 0.4046790946737687,
                    "changing": 0.2389502389126305,
                    "code": 0.2094075514650087,
                    "existing": 0.2151030500884126,
                    "going": 0.1546270117981998,
                    "maintaining": 0.2722467407510048,
                    "matter": 0.21723836598620372,
                    "methods": 0.20740071861721607,
                    "new": 0.14170562329046538,
                    "number": 0.18733409890331304,
                    "perfect": 0.26583233355914204,
                    "produce": 0.4592472501325728,
                    "software": 0.14125457116821957,
                    "techniques": 0.24635512857850003,
                    "time": 0.23579571456364362,
                    "writing": 0.16669932711297222
                },
                "Max term": "produce",
                "Max score": 0.4592472501325728
            }
        ],
        "Best Answer": "Avoid fancy coding.  The more complicated the code, the more likely there's bugs.  Usually on modern systems, clearly written code will be fast and small enough. Use available libraries.  The easiest way to not have bugs writing a utility routine is to not write it. Learn a few formal techniques for the more complicated stuff.  If there's complicated conditions, nail them down with pen and paper.  Ideally, know some proof techniques.  If I can prove code correct, it's almost always good except for big, dumb, obvious bugs that are easy to fix.  Obviously, this only goes so far, but sometimes you can formally reason about small but complicated things. For existing code, learn how to refactor:  how to make small changes in the code, often using an automated tool, that make the code more readable without changing the behavior. Don't do anything too quickly.  Taking a little time up front to do things right, to check what you've done, and to think about what you're doing can pay off big time later. Once you've written the code, use what you've got to make it good.  Unit tests are great.  You can often write tests ahead of time, which can be great feedback (if done consistently, this is test-driven development). Compile with warning options, and pay attention to the warnings.   Get somebody else to look at the code.  Formal code reviews are good, but they may not be at a convenient time. Pull requests, or similar if your scm doesn't support them allow for asynchronous reviews. Buddy checking can be a less formal review. Pair programming ensures two pairs of eyes look at everything.  ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "ahead": 0.08750994214970138,
                "allow": 0.07559031618433608,
                "asynchronous": 0.09494225448257373,
                "attention": 0.0896215152407891,
                "automated": 0.0839813043579144,
                "available": 0.06827470776409961,
                "avoid": 0.06827470776409961,
                "behavior": 0.0839813043579144,
                "big": 0.12257574039253967,
                "bugs": 0.19982582831416343,
                "changes": 0.06558804190038271,
                "changing": 0.07866056511612976,
                "check": 0.06660860943805448,
                "checking": 0.08750994214970138,
                "clearly": 0.0775695595627138,
                "code": 0.3102090370677744,
                "coding": 0.055913435458450345,
                "compile": 0.08564740268395953,
                "complicated": 0.3102782382508552,
                "conditions": 0.08750994214970138,
                "consistently": 0.09205914747916011,
                "convenient": 0.09205914747916011,
                "correct": 0.07224882032092918,
                "development": 0.04977201020968323,
                "driven": 0.07559031618433608,
                "easiest": 0.09494225448257373,
                "easy": 0.06287052079099677,
                "existing": 0.07081025553753205,
                "eyes": 0.08564740268395953,
                "far": 0.06660860943805448,
                "fast": 0.07559031618433608,
                "feedback": 0.08750994214970138,
                "fix": 0.07013724722984147,
                "formal": 0.25694220805187856,
                "goes": 0.07081025553753205,
                "good": 0.12918058089829745,
                "got": 0.06329223400628177,
                "great": 0.12183155036838576,
                "ideally": 0.08750994214970138,
                "know": 0.0429417413306773,
                "later": 0.0738314709156561,
                "learn": 0.10687512123534425,
                "libraries": 0.07224882032092918,
                "likely": 0.06660860943805448,
                "little": 0.0624597624139665,
                "look": 0.11347732973362219,
                "make": 0.13406012756620744,
                "modern": 0.07866056511612976,
                "obvious": 0.07654899202504205,
                "obviously": 0.0775695595627138,
                "options": 0.08247413509212646,
                "pair": 0.07559031618433608,
                "pairs": 0.09205914747916011,
                "paper": 0.08109819735450079,
                "pay": 0.16494827018425293,
                "pen": 0.0984708922743607,
                "programming": 0.041803602185322204,
                "proof": 0.09494225448257373,
                "prove": 0.0896215152407891,
                "pull": 0.09205914747916011,
                "quickly": 0.07081025553753205,
                "readable": 0.0839813043579144,
                "reason": 0.061287870196269835,
                "refactor": 0.08750994214970138,
                "requests": 0.0839813043579144,
                "review": 0.07654899202504205,
                "reviews": 0.16494827018425293,
                "right": 0.05645877599579618,
                "routine": 0.09494225448257373,
                "similar": 0.06417097719968345,
                "small": 0.17655071387369642,
                "somebody": 0.08564740268395953,
                "stuff": 0.062059404108595735,
                "support": 0.06510144017226653,
                "systems": 0.06827470776409961,
                "taking": 0.08109819735450079,
                "techniques": 0.16219639470900157,
                "test": 0.055647659313395145,
                "tests": 0.124919524827933,
                "things": 0.09359656455964706,
                "think": 0.041803602185322204,
                "time": 0.15524424034009557,
                "tool": 0.0688715072091671,
                "unit": 0.06372550243464085,
                "use": 0.07418105381741665,
                "using": 0.04620706170529839,
                "usually": 0.06417097719968345,
                "utility": 0.08750994214970138,
                "warning": 0.09205914747916011,
                "way": 0.04329979379819565,
                "write": 0.0970965420655854,
                "writing": 0.05487612540106924,
                "written": 0.13428941025908628
            },
            "Max term": "complicated",
            "Max score": 0.3102782382508552
        }
    },
    {
        "ID": "7951",
        "Question": "I'm a student of computer science but I am only taking entry level web development classes. I'm looking for some out-of-class reading, tutorials, and other ways of learning but I'm not sure what I should start in.  What is a good set of programming languages (different paradigms?), frameworks, suggested projects, and maybe even some open-source communities that I should start to look at and start learning? Also, maybe even some books or blogs on development processes in the professional world. I'm looking to start getting in to professional development around the end of college. I understand practicing it will be the best way to learn anything but if I don't know what I should practice, I'm lost at that. :) ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "best": 0.09129581807612652,
                    "blogs": 0.15762159937176726,
                    "books": 0.12706741881245645,
                    "class": 0.11535279264387703,
                    "classes": 0.1426312369171576,
                    "college": 0.15063213957957436,
                    "communities": 0.16190877852802138,
                    "computer": 0.10985093949392719,
                    "development": 0.26260916808158374,
                    "different": 0.09318849470565474,
                    "end": 0.0965132382531456,
                    "entry": 0.17318541747646843,
                    "frameworks": 0.13135459796871055,
                    "getting": 0.10525980525012273,
                    "good": 0.07573199997142536,
                    "know": 0.07552367230307143,
                    "languages": 0.09480121391393523,
                    "learn": 0.09398316630167569,
                    "learning": 0.21299216099650006,
                    "level": 0.10587107411294953,
                    "look": 0.09978897453917587,
                    "looking": 0.20478017026764442,
                    "lost": 0.13834405776090347,
                    "maybe": 0.23247155035265027,
                    "open": 0.10778987720159264,
                    "paradigms": 0.15063213957957436,
                    "practice": 0.12577362210911383,
                    "processes": 0.14770189362070738,
                    "professional": 0.26926066850948166,
                    "programming": 0.07352197313611918,
                    "projects": 0.10080041740939974,
                    "reading": 0.11623577517632513,
                    "science": 0.140405120053238,
                    "set": 0.10914681039897979,
                    "source": 0.10294082815408255,
                    "start": 0.3860529530125824,
                    "student": 0.16190877852802138,
                    "suggested": 0.1669794352315712,
                    "sure": 0.10185003683151042,
                    "taking": 0.1426312369171576,
                    "understand": 0.09480121391393523,
                    "way": 0.07615339611925127,
                    "ways": 0.11623577517632513,
                    "web": 0.10239008513382221,
                    "world": 0.1071354560978627
                },
                "Max term": "start",
                "Max score": 0.3860529530125824
            }
        ],
        "Best Answer": "These would be my baseline recommendations for topics to cover, not necessarily in-depth, but at least a general understanding: (in no particular order)  A compiled language - C#, Java, C, or if you're brave, C++. Understand about source code gets compiled into something else and then run by the runtime. A scripted language - JavaScript, Python. Know the differences to (1) and the strengths in terms of dynamic typing and rapid development. HTML + CSS. Whether for documentation or test harnesses, you'll use it somewhere. SQL. Data lives in databases. They all have their own flavours, but a basic understanding of SQL helps a lot. Version Control. Pick any system - Subversion, Git, Mercurial, CVS - it doesn't matter which, just understand about the check out, modify, build, merge, review, build, commit workflow. Testing - whether unit testing, automated or manual.  Security. Software systems get attacked - even the un-sexy ones - and users' information is becoming worth more than their bank details. Algorithms - understand Big O notation and that choice of good algorithm matters much more than micro-optimisation. Design Patterns - no point in re-inventing the wheel. The Software Development Lifecycle. Doesn't matter which methodology you prefer, but go find out what they are.  and when you've got the first job: 11.. How your employer measures success. All of the above are moot if your employer has their own unique systems which you have to use. Find out how to be successful in your employers' eyes first and then introduce the items you've learned along the way. ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "11": 0.10904013333976469,
                "algorithm": 0.08908778461098793,
                "algorithms": 0.09034079246999906,
                "automated": 0.09645160287314579,
                "bank": 0.11309273497031481,
                "baseline": 0.10904013333976469,
                "basic": 0.08132479840209074,
                "big": 0.0703884437412223,
                "build": 0.14953657369275106,
                "check": 0.07649925414436903,
                "choice": 0.08479463098057939,
                "code": 0.03958574018305998,
                "commit": 0.09472063557515227,
                "compiled": 0.21145783341631394,
                "control": 0.07590374471263651,
                "cover": 0.09472063557515227,
                "css": 0.10292932293661795,
                "data": 0.06913543588221119,
                "databases": 0.10572891670815697,
                "depth": 0.10904013333976469,
                "design": 0.06484228225180265,
                "details": 0.08681464539530008,
                "development": 0.1143252108227137,
                "differences": 0.10050420450369592,
                "documentation": 0.08132479840209074,
                "dynamic": 0.10904013333976469,
                "employer": 0.2058586458732359,
                "employers": 0.10292932293661795,
                "eyes": 0.09836509844599911,
                "general": 0.07981047077597675,
                "gets": 0.09034079246999906,
                "git": 0.10050420450369592,
                "good": 0.04945415801364473,
                "got": 0.07269043349590225,
                "helps": 0.08791567403707702,
                "html": 0.08577656797938021,
                "information": 0.07532714357045812,
                "introduce": 0.11309273497031481,
                "inventing": 0.11309273497031481,
                "items": 0.10572891670815697,
                "java": 0.06873626793547184,
                "javascript": 0.09168669777184683,
                "job": 0.06273861310383924,
                "know": 0.0493181168496285,
                "language": 0.10647137756796916,
                "learned": 0.08386307240652689,
                "lot": 0.05801741779614505,
                "manual": 0.10572891670815697,
                "matter": 0.16426421021706675,
                "matters": 0.11309273497031481,
                "measures": 0.11309273497031481,
                "mercurial": 0.10050420450369592,
                "merge": 0.10572891670815697,
                "methodology": 0.09472063557515227,
                "micro": 0.11309273497031481,
                "modify": 0.09645160287314579,
                "necessarily": 0.08479463098057939,
                "notation": 0.10904013333976469,
                "ones": 0.07841274971722237,
                "order": 0.08791567403707702,
                "particular": 0.07369966037283002,
                "patterns": 0.09836509844599911,
                "pick": 0.08577656797938021,
                "point": 0.06484228225180265,
                "prefer": 0.08213210510853337,
                "python": 0.07649925414436903,
                "rapid": 0.11309273497031481,
                "recommendations": 0.11309273497031481,
                "review": 0.08791567403707702,
                "run": 0.06996109671904495,
                "runtime": 0.10572891670815697,
                "security": 0.08297697420784121,
                "software": 0.10680926671107262,
                "source": 0.06722194030935785,
                "sql": 0.16772614481305378,
                "strengths": 0.11309273497031481,
                "success": 0.10292932293661795,
                "successful": 0.10904013333976469,
                "systems": 0.15682549943444474,
                "terms": 0.08577656797938021,
                "test": 0.06391072367775015,
                "testing": 0.13301927367721808,
                "topics": 0.10904013333976469,
                "typing": 0.10572891670815697,
                "understand": 0.1857199419487422,
                "understanding": 0.1806815849399981,
                "unique": 0.10050420450369592,
                "unit": 0.07318803751276132,
                "use": 0.08519612309206351,
                "users": 0.07318803751276132,
                "version": 0.08132479840209074,
                "way": 0.049729336164080304,
                "wheel": 0.10904013333976469,
                "workflow": 0.11309273497031481,
                "worth": 0.07590374471263651
            },
            "Max term": "compiled",
            "Max score": 0.21145783341631394
        }
    },
    {
        "ID": "7966",
        "Question": "I have been listening to Scott Hanselman and Rob Conery's podcast, This Developer's Life. In the latest episode, they discuss personality traits:  1.0.4 - Being Mean. What makes people mean in our   industry? What about aggressive?   Confident? What's the difference?   Would you rather have a drill sergeant   for a boss, or a zen master? We talk   to Cyra Richardson and Giles Bowkett.  It got me thinking, what traits did the best managers you've worked for have in common? EDIT: Just to clarify, as there have been a few close votes, I'm interested in whether there are traits common to managers of developers that are not necessarily those traits that a manager of some other profession requires.  As for whether this is programming related or not, well I don't want to ask this question on a site that isn't about programming because, frankly, I'm not as interested in what people who make cans of soup for a living want from their managers as I am interested in what developers want from their managers. ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "ask": 0.08149982048999996,
                    "best": 0.06945033003728857,
                    "boss": 0.0976946569937235,
                    "close": 0.11235942100367713,
                    "common": 0.1601459599866024,
                    "confident": 0.1145885104978317,
                    "developer": 0.07275810981403232,
                    "developers": 0.15033760740979193,
                    "difference": 0.10850208351562617,
                    "discuss": 0.11708042054337425,
                    "edit": 0.08775089252346699,
                    "frankly": 0.13174518455332787,
                    "got": 0.08467930834542793,
                    "industry": 0.09666241411137691,
                    "interested": 0.2930839709811705,
                    "latest": 0.11990551514907861,
                    "life": 0.10241565653342062,
                    "living": 0.1231668475255798,
                    "make": 0.059786791946068146,
                    "makes": 0.07410184911285472,
                    "manager": 0.09992374648787807,
                    "managers": 0.468321682173497,
                    "master": 0.10850208351562617,
                    "mean": 0.17550178504693398,
                    "necessarily": 0.09877985805719584,
                    "people": 0.11784625978884394,
                    "profession": 0.12702418501363075,
                    "programming": 0.11185890891603438,
                    "question": 0.0675862637583835,
                    "related": 0.09877985805719584,
                    "requires": 0.11034296427734727,
                    "site": 0.09473774400325483,
                    "talk": 0.10524075113912498,
                    "thinking": 0.08302989298376987,
                    "traits": 0.5269807382133115,
                    "want": 0.18663807041030714,
                    "worked": 0.08646827059689073
                },
                "Max term": "traits",
                "Max score": 0.5269807382133115
            }
        ],
        "Best Answer": "Joel Spolsky calls it the \"Abstraction Layer\". Do what it takes to keep me programming. Let me know what's going on in the company, but keep me out of the politics. Eventhough I still have to do it, at least acknowledge that the request is bull sh!t.  ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "abstraction": 0.3325872708341039,
                "calls": 0.322590433914127,
                "company": 0.23875302290835743,
                "going": 0.2087513913265624,
                "joel": 0.30629242369466636,
                "know": 0.17610596807231485,
                "layer": 0.3325872708341039,
                "let": 0.2631679971911948,
                "programming": 0.17143840942697952,
                "request": 0.35888211797354147,
                "spolsky": 0.3893623574290672,
                "takes": 0.26504787004779495
            },
            "Max term": "spolsky",
            "Max score": 0.3893623574290672
        }
    },
    {
        "ID": "7993",
        "Question": "During iteration retrospectives on agile projects, one of the topics that comes up most often for us is that the product owner is (or product owners are) not available or engaged in the project at a day to day level.  It seems to be a common theme that customers are unwilling to \"give up\" the necessary amount of their product owner's time to the project, but instead have them answer questions via email, or during product demos only. This has the effect of increasing the length of the feedback cycle and making the project less effective. Have you had to overcome this hurdle? How did you do it? ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "agile": 0.13381809288174074,
                    "answer": 0.11002037756514498,
                    "available": 0.1290263834764353,
                    "comes": 0.1428515103543741,
                    "common": 0.11310395436156062,
                    "customers": 0.14659190886349877,
                    "cycle": 0.17397451053471338,
                    "day": 0.23607445629548532,
                    "demos": 0.17942304165272788,
                    "effect": 0.1618575162656644,
                    "effective": 0.15586063609457873,
                    "email": 0.15870890313254776,
                    "feedback": 0.16537736628358227,
                    "instead": 0.12042923922530414,
                    "iteration": 0.17942304165272788,
                    "length": 0.17942304165272788,
                    "level": 0.11376077607426967,
                    "making": 0.12489787321460363,
                    "necessary": 0.1290263834764353,
                    "overcome": 0.17942304165272788,
                    "owner": 0.3387356862266239,
                    "product": 0.4885494873367759,
                    "project": 0.2636283025757642,
                    "projects": 0.10831224495625517,
                    "questions": 0.11961044321406605,
                    "time": 0.07334561927323842,
                    "topics": 0.17942304165272788,
                    "unwilling": 0.18609150480376238
                },
                "Max term": "product",
                "Max score": 0.4885494873367759
            }
        ],
        "Best Answer": "The product owner's presence in required meetings (Sprint Review and Planning) is (should be) non-negotiable.  Do what you need to negotiate a time that works, and then absolutely hold the product owner to it.  If something comes up, delay it but hold the product owner responsible for bringing the entire team to a halt.   If the product owner is actually (from) your customer and they are unwilling to participate in that capacity, then maybe it makes sense to find an internal Product Owner that communicates with the customer but is capable/authorized to make some calls on their own, on the customer's behalf.  That is the typical arrangement anyhow, since there are some things that a Product Owner is responsible for that shouldn't really pass by a customer's eyes. Otherwise, your only choice is basically to abandon agile.  You're not going to make it work without a PO at those meetings. ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "absolutely": 0.09012188807787447,
                "actually": 0.06016463181324887,
                "agile": 0.07868922038333064,
                "basically": 0.08620062335791166,
                "bringing": 0.10230244883736575,
                "calls": 0.08741302367733547,
                "capable": 0.10550635539946097,
                "capacity": 0.10942762011942377,
                "choice": 0.08204660245899201,
                "comes": 0.0840011521483937,
                "customer": 0.32115140958110994,
                "delay": 0.10550635539946097,
                "entire": 0.08871531081475395,
                "eyes": 0.09517727755530773,
                "going": 0.05656581347220915,
                "hold": 0.19449411871986494,
                "internal": 0.09517727755530773,
                "make": 0.09931788215887562,
                "makes": 0.06154903514963801,
                "maybe": 0.07344385246529145,
                "meetings": 0.1774306216295079,
                "need": 0.05151042399477587,
                "non": 0.06469542010684438,
                "owner": 0.5975615066209606,
                "pass": 0.09012188807787447,
                "planning": 0.08204660245899201,
                "presence": 0.10550635539946097,
                "product": 0.4309235483334144,
                "really": 0.05102894635307723,
                "required": 0.08028785239527748,
                "responsible": 0.2046048976747315,
                "review": 0.08506649860044119,
                "sense": 0.07868922038333064,
                "sprint": 0.10230244883736575,
                "team": 0.06539842723524719,
                "things": 0.0520054661563321,
                "time": 0.043129516157760416,
                "typical": 0.09517727755530773,
                "unwilling": 0.10942762011942377,
                "work": 0.04633342271985563,
                "works": 0.07344385246529145
            },
            "Max term": "owner",
            "Max score": 0.5975615066209606
        }
    },
    {
        "ID": "8020",
        "Question": "Console app (my favorite), quick & sloppy form, MS Paint (for GUI); what works best most of the time for your standard application? why? ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "app": 0.2508854816006869,
                    "application": 0.2207335437983715,
                    "best": 0.2029477842574166,
                    "console": 0.37119012799189516,
                    "favorite": 0.33485059458186256,
                    "form": 0.2768426762073536,
                    "gui": 0.3421324551869904,
                    "ms": 0.37119012799189516,
                    "quick": 0.33485059458186256,
                    "standard": 0.2526776174683074,
                    "time": 0.15173731063133084,
                    "works": 0.25838853871497375
                },
                "Max term": "console",
                "Max score": 0.37119012799189516
            }
        ],
        "Best Answer": "For me hands down it is Balsamiq I love it for a number of reasons.  Easy to use - The interface for Balsamiq is incredibly simple and fast for me to pull things together. Looks like a mockup - When showing it to clients/customers/vendors it looks like a mockup, so there isn't confusion that \"I'm almost done\" or something like that. Looks professional - In addition to the previous point, yes, it looks \"hand drawn\" but still looks professional. Common UI Controls - Are all available, to quickly build out mockups that resemble real apps.   ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "addition": 0.1469509092023197,
                "apps": 0.13025854004867704,
                "available": 0.11465017728264319,
                "build": 0.10932147352273884,
                "clients": 0.13025854004867704,
                "common": 0.10050183590001348,
                "confusion": 0.1653570645141875,
                "controls": 0.1504967644269943,
                "customers": 0.13025854004867704,
                "drawn": 0.1653570645141875,
                "easy": 0.10557520626005631,
                "fast": 0.12693489925038096,
                "hand": 0.11777784325055976,
                "hands": 0.159431606000437,
                "incredibly": 0.1545901538742953,
                "interface": 0.12693489925038096,
                "like": 0.17683337913983152,
                "looks": 0.6270854396126768,
                "love": 0.1410254506885692,
                "number": 0.10355744084951403,
                "point": 0.09480829562016416,
                "previous": 0.12008838416263103,
                "professional": 0.25708950778090384,
                "pull": 0.1545901538742953,
                "quickly": 0.11890799121188125,
                "real": 0.09993075004037515,
                "reasons": 0.11669383686295093,
                "showing": 0.159431606000437,
                "simple": 0.10229270329956211,
                "things": 0.0785859293377483,
                "ui": 0.1384945394744988,
                "use": 0.062284199007968284,
                "vendors": 0.159431606000437,
                "yes": 0.10775899528950825
            },
            "Max term": "looks",
            "Max score": 0.6270854396126768
        }
    },
    {
        "ID": "8034",
        "Question": "In an open source project, a number of other open source libraries have been included to implement needed functionality, some as libraries (LGPL), and some as source code (non-LGPL). The new BSD license was selected for the project. The included open source libraries are licensed under the new BSD, MIT, Apache, and LGPL licenses, but no GPL licensed code. How should these other open source libraries be credited? Do all the library licenses need to be included in the main project license file? Is it sufficient to just provide links to the project web sites in the Help->About dialog and documentation? Is any credit really needed? ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "apache": 0.11662626465354373,
                    "bsd": 0.24192162711215334,
                    "code": 0.08467959217750415,
                    "credit": 0.11308468032697479,
                    "dialog": 0.12096081355607667,
                    "documentation": 0.08698272068124374,
                    "file": 0.08056779749406251,
                    "functionality": 0.08874984152816376,
                    "gpl": 0.1052085470978729,
                    "help": 0.0656422487648038,
                    "implement": 0.08784619326439606,
                    "included": 0.31562564129361875,
                    "lgpl": 0.36288244066823,
                    "libraries": 0.35499936611265503,
                    "library": 0.08784619326439606,
                    "license": 0.1961310345472467,
                    "licenses": 0.20632385193241135,
                    "links": 0.11662626465354373,
                    "main": 0.09174420841053485,
                    "mit": 0.11662626465354373,
                    "need": 0.05693939780675688,
                    "needed": 0.167736150362866,
                    "new": 0.11460498253808894,
                    "non": 0.07151403494780918,
                    "number": 0.07575359620554797,
                    "open": 0.30114201136330276,
                    "project": 0.22848038470535817,
                    "provide": 0.08784619326439606,
                    "really": 0.05640717452359155,
                    "sites": 0.09174420841053485,
                    "source": 0.359493498444983,
                    "sufficient": 0.12096081355607667,
                    "web": 0.07151403494780918
                },
                "Max term": "lgpl",
                "Max score": 0.36288244066823
            }
        ],
        "Best Answer": "Each library that you use as a dependency should have a LICENSE file in their source code. I would just take these licenses and rename them to \"LIBRARY_NAME_LICENSE\" and include it with the source code. I know licenses (like the BSD license) require that the original license be included when any source code is reused. If you are just using these as linked libraries, I don't believe any of this is needed. But I may be wrong about this one. ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "believe": 0.14906762129959086,
                "bsd": 0.20928710860984254,
                "code": 0.21976969008489491,
                "dependency": 0.1956597767319823,
                "file": 0.13939887546125534,
                "include": 0.1587363671379263,
                "included": 0.182032444854122,
                "know": 0.09126710111175917,
                "libraries": 0.15355549600697949,
                "library": 0.151991998484399,
                "license": 0.5090205983529651,
                "licenses": 0.356982737952248,
                "like": 0.07460410341828899,
                "linked": 0.19047890560103545,
                "needed": 0.14510903526006605,
                "original": 0.16269495317745108,
                "require": 0.146377455068126,
                "reused": 0.20928710860984254,
                "source": 0.37319865487862913,
                "use": 0.07883110383432872,
                "using": 0.09820711601469301,
                "wrong": 0.13544028942173056
            },
            "Max term": "license",
            "Max score": 0.5090205983529651
        }
    },
    {
        "ID": "8055",
        "Question": "If I would start to focus on the .NET platform and be self-employed, then I probably would like to have some Windows 7, Windows Server 2008, Visual Studio 2010 licenses just for the development environment and for testing, and then a few licenses for the production environment (a Windows Server 2008 Web) and added to that upgrades when new versions is available. This will end up in a quite big amount of money. Is there any kind of bundle discount that I can get from Microsoft in such a case? And what is the requirement to be able to get that discount? ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "2008": 0.3542910021314145,
                    "2010": 0.16480765332810607,
                    "able": 0.1194182711625161,
                    "added": 0.15361820137329388,
                    "available": 0.1313781155721007,
                    "big": 0.11793364127802694,
                    "case": 0.12348148143004845,
                    "development": 0.09577416181958187,
                    "end": 0.10559579354042574,
                    "environment": 0.24872707922462944,
                    "focus": 0.15361820137329388,
                    "kind": 0.127174355971115,
                    "licenses": 0.32320330239864914,
                    "like": 0.06754470184075607,
                    "microsoft": 0.14050996118092032,
                    "money": 0.13371995359534067,
                    "net": 0.11583426570571798,
                    "new": 0.08976351614398867,
                    "platform": 0.15136317903403235,
                    "probably": 0.10759184515405676,
                    "production": 0.14926380346172338,
                    "quite": 0.12097906848750993,
                    "requirement": 0.16480765332810607,
                    "self": 0.15870146949995265,
                    "server": 0.2699242420577977,
                    "start": 0.10559579354042574,
                    "studio": 0.15605381104730304,
                    "testing": 0.11143482133648544,
                    "versions": 0.15870146949995265,
                    "visual": 0.15361820137329388,
                    "web": 0.11202569187471353,
                    "windows": 0.40877148685174836
                },
                "Max term": "windows",
                "Max score": 0.40877148685174836
            }
        ],
        "Best Answer": "How about a 100% discount? If you are making software you intend to sell, you qualify for BizSpark, which gives all your developers MSDN subscriptions. If you intend instead to offer your services, you don't qualify for BizSpark, but you still don't need to buy separate licenses for dev, staging etc. You can get an MSDN subscription, which covers one developer across any number of machines other than production. You don't install dev tools on production, and your clients are responsible for the Windows, SQL etc licenses they need. It is generally useful to join the partner program. The Registered level is free and lets you buy an MSDN subscription at a dramatically reduced price, 80-90% off or so. The program names vary over time - Empower, Action Pack, etc so you would need to check the partner program to be sure what they are and what they cost at the moment. Finally, back to the free angle, don't rule out Visual Studio Express, SQL Express etc - absolutely no cost ever and almost all the features of the full products. ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "100": 0.09258636968636755,
                "80": 0.09679812188557323,
                "90": 0.10023937400003954,
                "absolutely": 0.09679812188557323,
                "action": 0.11753402348622888,
                "buy": 0.1877771693596498,
                "check": 0.07950347239938389,
                "clients": 0.09258636968636755,
                "cost": 0.17071506447047433,
                "covers": 0.11332227128702319,
                "dev": 0.20890225239849045,
                "developer": 0.06490979853790854,
                "developers": 0.06706045439183987,
                "dramatically": 0.11332227128702319,
                "express": 0.21976203834511376,
                "features": 0.07407357942607223,
                "finally": 0.10023937400003954,
                "free": 0.15008344286455647,
                "generally": 0.08080568739284125,
                "gives": 0.09528734531108153,
                "install": 0.11753402348622888,
                "instead": 0.07606222028491759,
                "intend": 0.22664454257404637,
                "join": 0.10697148196680856,
                "lets": 0.10988101917255688,
                "level": 0.07185046808571191,
                "licenses": 0.2004787480000791,
                "machines": 0.10023937400003954,
                "making": 0.07888457659185132,
                "moment": 0.09679812188557323,
                "msdn": 0.3526020704586866,
                "names": 0.09258636968636755,
                "need": 0.16597895605278587,
                "number": 0.07360751547410443,
                "offer": 0.09679812188557323,
                "price": 0.1022280148588849,
                "production": 0.1851727393727351,
                "products": 0.10023937400003954,
                "program": 0.21555140425713576,
                "qualify": 0.22664454257404637,
                "responsible": 0.10988101917255688,
                "rule": 0.0938885846798249,
                "sell": 0.09844042952222082,
                "separate": 0.09679812188557323,
                "services": 0.09679812188557323,
                "software": 0.05550189791351876,
                "sql": 0.17431295342611178,
                "studio": 0.09679812188557323,
                "subscription": 0.23506804697245776,
                "sure": 0.06912155073711423,
                "time": 0.046324552791184234,
                "tools": 0.07770452792156518,
                "useful": 0.07606222028491759,
                "vary": 0.11753402348622888,
                "visual": 0.09528734531108153,
                "windows": 0.08451852161779543
            },
            "Max term": "msdn",
            "Max score": 0.3526020704586866
        }
    },
    {
        "ID": "8090",
        "Question": "Question first: What are some feasible alternatives to time tracking for employees in a web/software development company, and why are they better options Explanation: I work at a company where we work like this. Everybody is paid salary. We have 3 types of work, Contract, Adhoc and Internal (Non billable). Adhoc is just small changes that take a few hours and we just bill the client at the end of the month. Contracts are signed and we have this big long process, the usual. We figure out how much to charge by getting an estimation of the time involved (From the design and the developers), multiplying it by our hourly rate and that's it. So say we estimate 50 hours for a website. We have time tracking software and have to record the time in 15 we spend on it (7:00 to 7:15 for example), the project name, and give it some comments. Now if we go over the 50 hours, we are both losing money and are inefficient.  Now that I've explained how the system works, my question is how else can it be done if a better method exists (Which I'm sure one must). Nobody here likes the current system, we just can't find an alternative. I'd be more than willing to work after hours longer hours on a project to get it done in time, but I'm much inclined to do so with the current system. I'd love to be able to sum up (Or link) to this post for my manager to show them why we should use abc system instead of this system. ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "15": 0.19854018795049003,
                    "50": 0.1952278896556219,
                    "able": 0.07469787795926995,
                    "alternative": 0.10533144932366124,
                    "alternatives": 0.11852461040037295,
                    "better": 0.11852573793513872,
                    "big": 0.07376922021831726,
                    "billable": 0.11852461040037295,
                    "changes": 0.07894512717023784,
                    "charge": 0.10308960140867235,
                    "client": 0.08217893583611036,
                    "comments": 0.08789103903598165,
                    "company": 0.1401474226430899,
                    "contract": 0.09213828824694954,
                    "contracts": 0.10533144932366124,
                    "current": 0.17392476259005796,
                    "design": 0.06795667505417773,
                    "developers": 0.06762564570076239,
                    "development": 0.0599081412049121,
                    "employees": 0.11080710590452265,
                    "end": 0.06605171572246696,
                    "estimate": 0.09467988579087926,
                    "estimation": 0.10787304686759096,
                    "everybody": 0.10787304686759096,
                    "example": 0.06324758011190634,
                    "explained": 0.11427736118940506,
                    "explanation": 0.10787304686759096,
                    "figure": 0.08989644033196065,
                    "getting": 0.07203768995033943,
                    "hourly": 0.10308960140867235,
                    "hours": 0.42210391875549635,
                    "inclined": 0.11080710590452265,
                    "inefficient": 0.11852461040037295,
                    "instead": 0.07670327925524895,
                    "internal": 0.10308960140867235,
                    "involved": 0.08607693289853331,
                    "like": 0.042250200457430304,
                    "likes": 0.11080710590452265,
                    "link": 0.09761394482781095,
                    "long": 0.06575196609352615,
                    "longer": 0.08886734062673973,
                    "love": 0.10108420011269335,
                    "manager": 0.08989644033196065,
                    "method": 0.0828972742209876,
                    "money": 0.08364378982501375,
                    "month": 0.09336669561684305,
                    "non": 0.07007371132154495,
                    "options": 0.09927009397524501,
                    "paid": 0.09761394482781095,
                    "post": 0.08886734062673973,
                    "process": 0.07245603004428106,
                    "project": 0.11193934541774363,
                    "question": 0.12160802093129562,
                    "rate": 0.09927009397524501,
                    "record": 0.11080710590452265,
                    "salary": 0.11080710590452265,
                    "say": 0.06174413775082164,
                    "small": 0.07083516118138557,
                    "software": 0.11193934541774363,
                    "spend": 0.0828972742209876,
                    "sum": 0.11852461040037295,
                    "sure": 0.06970411314427588,
                    "time": 0.233574900641002,
                    "tracking": 0.21574609373518192,
                    "types": 0.08696238129502898,
                    "use": 0.04464405825785175,
                    "usual": 0.11080710590452265,
                    "web": 0.07007371132154495,
                    "website": 0.09098437689410696,
                    "willing": 0.09467988579087926,
                    "work": 0.2007409416523312,
                    "works": 0.07954942262521152
                },
                "Max term": "hours",
                "Max score": 0.42210391875549635
            }
        ],
        "Best Answer": "The problem with this method is that it takes no account of the inherent risk in estimates. A best practice for any estimates is to express it as a range of times, e.g. 50 hours Â± 15 hours, or something similar. The error term is tough to come up with, but nobody believes it will take exactly 50 hours anyway. There are other approaches aside from the fixed price model; you could use a lower rate, and bill straight hours, but these days, your clients will probably want to transfer the risk to you. That's fine, but it means you need to charge a reasonable risk premium based on the range of time estimates you come up with. ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "15": 0.12096792426428629,
                "50": 0.23789956898828876,
                "account": 0.12096792426428629,
                "approaches": 0.12317854626588277,
                "aside": 0.13145125627553675,
                "based": 0.09221456386303575,
                "believes": 0.14443097130482965,
                "best": 0.07613772494786183,
                "charge": 0.12562227551380697,
                "clients": 0.11377419837037143,
                "come": 0.19240090911861576,
                "days": 0.09929757844518891,
                "error": 0.10710170735070886,
                "estimates": 0.3512798276139347,
                "exactly": 0.11537441736036283,
                "express": 0.1350266234093183,
                "fine": 0.12096792426428629,
                "fixed": 0.11709327587131156,
                "hours": 0.41149178231588196,
                "lower": 0.12317854626588277,
                "means": 0.09346859768345912,
                "method": 0.10101643695613767,
                "model": 0.10829140277820969,
                "need": 0.06798741087277389,
                "practice": 0.10489108534911237,
                "price": 0.12562227551380697,
                "probably": 0.08201034443511968,
                "problem": 0.07523978149015968,
                "range": 0.25670826477931147,
                "rate": 0.12096792426428629,
                "reasonable": 0.1350266234093183,
                "risk": 0.34132259511111435,
                "similar": 0.09412199232141596,
                "straight": 0.12835413238965573,
                "takes": 0.09479432854946276,
                "term": 0.11377419837037143,
                "time": 0.05692564549767606,
                "times": 0.09548673745360103,
                "tough": 0.12835413238965573,
                "transfer": 0.1350266234093183,
                "use": 0.05440207460197346,
                "want": 0.06820317034284329
            },
            "Max term": "hours",
            "Max score": 0.41149178231588196
        }
    },
    {
        "ID": "8093",
        "Question": "What are some somewhat common math formulas you learned that helped you write better algorithms and become a better programmer? Example: I learned about the ecludian distance formula: sqrt((x1-x2)^2+(y1-y2)^2) which helped me understand how to find like objects by comparing 2 factors.  ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "algorithms": 0.2251327602880648,
                    "better": 0.2818341649191988,
                    "common": 0.17129344683744882,
                    "comparing": 0.2818314838321652,
                    "example": 0.15039205184070545,
                    "factors": 0.2251327602880648,
                    "helped": 0.5130077333558432,
                    "learned": 0.41798006107571256,
                    "like": 0.1004638331811512,
                    "math": 0.26348056298796513,
                    "objects": 0.23210945659810836,
                    "programmer": 0.1456855876756514,
                    "somewhat": 0.22848680852482292,
                    "understand": 0.1542737672476678,
                    "write": 0.13894899240413042
                },
                "Max term": "helped",
                "Max score": 0.5130077333558432
            }
        ],
        "Best Answer": "Knowing the powers of 2 is handy, especially when dealing with low-level bitwise operations.   ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "bitwise": 0.42108739229549724,
                "dealing": 0.35912610962352776,
                "especially": 0.30895492711288636,
                "handy": 0.42108739229549724,
                "knowing": 0.3526810580837255,
                "level": 0.2574175999766417,
                "low": 0.3317078052544281,
                "operations": 0.34679718701771084
            },
            "Max term": "bitwise",
            "Max score": 0.42108739229549724
        }
    },
    {
        "ID": "8098",
        "Question": "As I've implied through my other posts, I'm still fairly new to the workforce. During team meetings, I tend to be able to keep up with technical discussion, but when my project manager starts talking about how we've won a new contract, or we're involved in a new proposal bid, or... anything that's business rather than technical, really... I can get lost pretty quickly. What is the bare minimum all developers need to know about project management/business to function? ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "able": 0.13850970716427488,
                    "bid": 0.2197761104708613,
                    "business": 0.2864450082317955,
                    "contract": 0.17084886040084318,
                    "developers": 0.12539591001386927,
                    "discussion": 0.18100218215866865,
                    "fairly": 0.17312665395710938,
                    "function": 0.15238157560430152,
                    "implied": 0.21190058226930203,
                    "involved": 0.15960949755327306,
                    "know": 0.09584120412158978,
                    "lost": 0.17556165735246604,
                    "management": 0.1442455772129893,
                    "manager": 0.16669187888148507,
                    "meetings": 0.17817719081162112,
                    "minimum": 0.2197761104708613,
                    "need": 0.1034543255342834,
                    "new": 0.3123421118252329,
                    "posts": 0.20546580719367769,
                    "pretty": 0.1376382171943415,
                    "project": 0.20756527999933855,
                    "proposal": 0.20546580719367769,
                    "quickly": 0.15804063702526855,
                    "really": 0.10248731845457422,
                    "starts": 0.2000252823874751,
                    "talking": 0.16297333219928392,
                    "team": 0.1313472042340708,
                    "technical": 0.28064005928217617,
                    "tend": 0.16669187888148507
                },
                "Max term": "new",
                "Max score": 0.3123421118252329
            }
        ],
        "Best Answer": "I think you need to understand how your company makes money. You also need to be able to evaluate if you should do anything to help it make more money, i.e. do your job better. Most importantly this means that you need to be able the tell which task you're working on you should put the most effort into and how to prioritize the tasks you've been given. Also, programmers need to understand that even though something might technically be the best choice, that choice might not be the best choice for the business. And that is a good reason to not take the technically best way. ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "able": 0.23879988487217965,
                "best": 0.2996161422335194,
                "better": 0.0947280342713831,
                "business": 0.12346252906815432,
                "choice": 0.42614685899377647,
                "company": 0.11200849778674779,
                "effort": 0.14924089394048878,
                "evaluate": 0.1771183121657586,
                "given": 0.1313579512076757,
                "good": 0.08284618124986148,
                "help": 0.10281184219091412,
                "importantly": 0.18266530081621832,
                "job": 0.10510045507460734,
                "make": 0.0859755355603603,
                "makes": 0.10656109746175596,
                "means": 0.1226054524966529,
                "money": 0.26739885959514464,
                "need": 0.35672418248369353,
                "programmers": 0.10151699970327675,
                "reason": 0.11791554041769461,
                "task": 0.12525270457758925,
                "tasks": 0.1390039932110708,
                "technically": 0.3542366243315172,
                "tell": 0.1349414065790063,
                "think": 0.0804285469099006,
                "understand": 0.20741347260297233,
                "way": 0.08330716289109572,
                "working": 0.10109734882564264
            },
            "Max term": "choice",
            "Max score": 0.42614685899377647
        }
    },
    {
        "ID": "8104",
        "Question": "So I know everyone here is all about private offices, how many developers actually have them. I am sort of half skeptical. I can believe that lead developers have them, but that's normally just one person in your average office. That makes me wonder, how many developers have private offices. Which leads to the actual question: why should they have them? ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "actual": 0.2147156261128785,
                    "actually": 0.1477844610125528,
                    "average": 0.2147156261128785,
                    "believe": 0.19144997153981955,
                    "developers": 0.46008556315745985,
                    "half": 0.22923936943962062,
                    "know": 0.11721582298044012,
                    "lead": 0.20895177560320255,
                    "leads": 0.25128903487056764,
                    "makes": 0.1511850186944698,
                    "normally": 0.2388713072685766,
                    "office": 0.2388713072685766,
                    "person": 0.18328138605119398,
                    "private": 0.435828957883937,
                    "question": 0.13789170813050625,
                    "sort": 0.19721382204949553,
                    "wonder": 0.2147156261128785
                },
                "Max term": "developers",
                "Max score": 0.46008556315745985
            }
        ],
        "Best Answer": "In the management world, where concentration on a task is not an issue, offices are a means to represent status. They think \"private office == more status, big private office == even more status, etc.\" What most people fail to understand: Every time our concentration is broken, we create at least one bug and/or delay the deadline for another half-hour. Private offices is not a \"nice to have\" for developers but a must. This is not about status, this is about brain physics.  Working in an open space costs at least 30% productivity (I read that in a newspaper, start with this blog post if you want to know more). Worst part: This goes unnoticed. If you always work in such an environment, you'll never notice that it happens! Until you wonder why your neck is stiff, you feel tense/nervous all the time, etc. If you want another productivity increase, take the telephones away, too. Unless you're doing production support, the next day is always soon enough. To relax the team, supply free soft drinks. That costs $100-300/month for a team of 10 and makes sure they take regular breaks, drink enough (so they don't dehydrate). The funny thing is: These aren't a bunch of myths but hard facts. Still, most companies ignore these simple, cheap ways to boost productivity. Well, except for the successful ones, of course (Google, Microsoft, etc). See also:  Open Offices Reduce Productivity and Increase Stress The High Cost of Interruptions A study on unplanned interruptions in software development How to explain a layperson why a developer should not be interrupted while neck-deep in coding?  ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "10": 0.08055318798041779,
                "100": 0.08737515069222639,
                "30": 0.09289971507520925,
                "away": 0.07690533390914636,
                "big": 0.06903528812323888,
                "blog": 0.08992410204462144,
                "brain": 0.10369637173311928,
                "breaks": 0.09459740605681713,
                "broken": 0.10369637173311928,
                "bug": 0.07827618501592423,
                "bunch": 0.10095059767741255,
                "cheap": 0.10369637173311928,
                "coding": 0.06298146948936027,
                "companies": 0.07976140103186714,
                "cost": 0.08055318798041779,
                "costs": 0.18919481211363426,
                "course": 0.07827618501592423,
                "create": 0.07129302415950252,
                "day": 0.07035531958523925,
                "deadline": 0.09459740605681713,
                "deep": 0.10694393315160859,
                "delay": 0.10694393315160859,
                "developer": 0.06125635390893709,
                "developers": 0.06328596021017689,
                "development": 0.05606370484558616,
                "drink": 0.11091862709771001,
                "environment": 0.07279918347405084,
                "explain": 0.0717810621789456,
                "facts": 0.10694393315160859,
                "fail": 0.08412758927373708,
                "feel": 0.06665679044874487,
                "free": 0.07081800205106009,
                "funny": 0.10694393315160859,
                "goes": 0.07976140103186714,
                "google": 0.07976140103186714,
                "half": 0.09459740605681713,
                "happens": 0.08737515069222639,
                "hard": 0.07333093261582704,
                "high": 0.07444456230818547,
                "hour": 0.10369637173311928,
                "ignore": 0.09647411636852854,
                "increase": 0.19294823273705708,
                "interruptions": 0.21388786630321718,
                "issue": 0.07563248730496835,
                "know": 0.04837001964309295,
                "makes": 0.062387672056981355,
                "management": 0.07279918347405084,
                "means": 0.0717810621789456,
                "microsoft": 0.08225087896202565,
                "month": 0.08737515069222639,
                "nice": 0.08055318798041779,
                "notice": 0.08992410204462144,
                "office": 0.19714420000583707,
                "ones": 0.07690533390914636,
                "open": 0.13807057624647776,
                "people": 0.04960843688023988,
                "physics": 0.10694393315160859,
                "post": 0.08316452914585158,
                "private": 0.2697723061338643,
                "production": 0.08737515069222639,
                "productivity": 0.41478548693247713,
                "read": 0.06665679044874487,
                "reduce": 0.09289971507520925,
                "regular": 0.08992410204462144,
                "represent": 0.11091862709771001,
                "simple": 0.06861615646985152,
                "software": 0.052377976481049,
                "soon": 0.08860407058262108,
                "space": 0.08992410204462144,
                "start": 0.06181303275864815,
                "stress": 0.11091862709771001,
                "study": 0.09857210000291854,
                "successful": 0.10694393315160859,
                "support": 0.07333093261582704,
                "sure": 0.06523104785503851,
                "task": 0.07333093261582704,
                "team": 0.13257902813506428,
                "thing": 0.06328596021017689,
                "think": 0.047088007989362676,
                "time": 0.08743435550158939,
                "understand": 0.060716546737884416,
                "unless": 0.08225087896202565,
                "want": 0.104755952962098,
                "ways": 0.07444456230818547,
                "wonder": 0.08860407058262108,
                "work": 0.04696473916928401,
                "working": 0.05918884465907516,
                "world": 0.06861615646985152,
                "worst": 0.09857210000291854
            },
            "Max term": "productivity",
            "Max score": 0.41478548693247713
        }
    },
    {
        "ID": "8111",
        "Question": "I'm a self-taught programmer and have just started a computer science degree to supplement my knowledge and fill in the gaps. However, I'm already debating the direction of my education. I want a 4 year bachelor's degree for sure, but after that, I'm not sure: Is it worth it to get an M.Sc? What about a Ph.D.? What opportunities do these degrees open up? Currently my goal is to be a software developer, but there are a number of fascinating fields in the software industry and I'm certainly interested in investigating many of them. It is in this respect that I think a higher degree may be worth it -- even if it wouldn't necessarily help a career of software development. So will it be worth it? Will grad school open doors? ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "career": 0.12996634763435422,
                    "certainly": 0.14316516295817433,
                    "computer": 0.11681488975581916,
                    "currently": 0.13656575529626427,
                    "degree": 0.44791811601424475,
                    "developer": 0.10170736585236415,
                    "development": 0.09308571888306719,
                    "direction": 0.18416442811531505,
                    "education": 0.17217291177828964,
                    "fields": 0.15706538787483462,
                    "goal": 0.1471143162740635,
                    "help": 0.09994118631129222,
                    "higher": 0.14930603867141493,
                    "industry": 0.13512279993703813,
                    "interested": 0.13656575529626427,
                    "knowledge": 0.11533584565720197,
                    "necessarily": 0.1380827400264623,
                    "number": 0.11533584565720197,
                    "open": 0.22924633471693548,
                    "opportunities": 0.17217291177828964,
                    "programmer": 0.09519909761007274,
                    "school": 0.14316516295817433,
                    "science": 0.14930603867141493,
                    "self": 0.15424661615970225,
                    "software": 0.2608982910320109,
                    "started": 0.12001527603358307,
                    "sure": 0.2166135470285484,
                    "taught": 0.17217291177828964,
                    "think": 0.07818286512698282,
                    "want": 0.08696609701067029,
                    "worth": 0.3708134675622478,
                    "year": 0.13374698358113188
                },
                "Max term": "degree",
                "Max score": 0.44791811601424475
            }
        ],
        "Best Answer": "It might open up more technical positions and jobs at larger Oracle-type companies. The important thing it does though is gives you a very focused specialty. To employers, you are the best they can find in that specialty (on paper at least). ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "best": 0.17553822648509923,
                "companies": 0.2394530818586727,
                "employers": 0.3030655356677294,
                "focused": 0.3113086714604906,
                "gives": 0.2699627023772493,
                "important": 0.21260394906334537,
                "jobs": 0.2623104514270062,
                "larger": 0.295925006652652,
                "open": 0.20725203274082968,
                "oracle": 0.3030655356677294,
                "paper": 0.2742429488822445,
                "positions": 0.32105823177565984,
                "technical": 0.21260394906334537,
                "thing": 0.18999187595335357,
                "type": 0.23289697979900323
            },
            "Max term": "positions",
            "Max score": 0.32105823177565984
        }
    },
    {
        "ID": "8119",
        "Question": "In what circumstances should an IT Consultant encrypt their hard drive to protect their code/data of their clients? I am thinking that if it does not add much to your work load you might as well use full disc encryption with a 'weak' password to at least prevent someone from accessing your email files and other documents if your laptop is stolen, even if they will not get access to any database files or other very sensitive data.  ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "access": 0.1720969680735973,
                    "add": 0.1680054572548539,
                    "circumstances": 0.22245615018869697,
                    "clients": 0.19718703004779695,
                    "code": 0.0876191340151316,
                    "data": 0.30604894559229384,
                    "database": 0.1856226445717091,
                    "documents": 0.22782391080133524,
                    "drive": 0.21348611593557806,
                    "email": 0.21348611593557806,
                    "encrypt": 0.25031962155256593,
                    "files": 0.3565871858740939,
                    "hard": 0.16549223318749062,
                    "laptop": 0.22782391080133524,
                    "load": 0.2029394681601562,
                    "prevent": 0.20965479043914068,
                    "protect": 0.2340205356647848,
                    "sensitive": 0.25031962155256593,
                    "thinking": 0.15775917320784016,
                    "use": 0.0942866104341229,
                    "weak": 0.24134958729944703,
                    "work": 0.10598937295549032
                },
                "Max term": "files",
                "Max score": 0.3565871858740939
            }
        ],
        "Best Answer": "I agree that full-disc encryption is good, especially if you have sensitive data on your a laptop (you probably do). So, with the new laptop models being plenty fast, I'd say \"always\". That said, there are caveats:  if you forget your password, this means all your data are as good as gone (until you remember the password again). (corollary: any encryption solution that has a \"recover password\" option is likely snake oil, not encryption) weak passwords == no protection (your cow-orkers probably won't try to break into your computer, but a stolen laptop's data could be worth some money; plus, pass-phrases are quite strong and easy to remember) the full-disk encryption could make sleep mode/hibernation impractical, if not impossible (check the product you plan to use) some data may be accessible from additional locations (e.g. your e-mails may be stored on a server, with a copy stored locally in your computer) full-disc encryption is not magical pixie dust - it doesn't provide security against other attack vectors, you still need to address those separately (backups, antivirus, firewall, phishing protection, social engineering, rubber hose cryptanalysis)  Note that encryption should not be seen as a way of securing the data forever from anyone - its goal is just to delay an attacker long enough to make the attack uninteresting. With strong encryption, it should take years before the attacker gets to the data by brute force, at which point the data is so old that it's useless. Although the National Security Agency (or similarly powerful entity) can probably crack the encryption much faster (as it can throw enormous amounts of computing power at it), full-disk crypto is still good protection against anyone else cracking it (e.g. your competitors or a random thief). As a bonus, encryption eliminates casual snooping: if you forget your (powered-off) laptop somewhere, an almost-honest person might decide to browse through your files before returning it to you, just out of curiosity. There's a proverb that says \"most locks are made to keep honest people honest\"; strong locks will do that, and also keep the really malicious people out for long enough. ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "accessible": 0.09209371520148818,
                "additional": 0.07713294084409338,
                "address": 0.08609720815787754,
                "agree": 0.07159152220204637,
                "amounts": 0.09209371520148818,
                "bonus": 0.09209371520148818,
                "break": 0.07356634548623013,
                "casual": 0.09209371520148818,
                "caveats": 0.09209371520148818,
                "check": 0.06229489919177409,
                "computer": 0.11682948003106822,
                "computing": 0.08879359923482652,
                "copy": 0.07584611165815665,
                "crack": 0.09209371520148818,
                "data": 0.3940887450371443,
                "decide": 0.07254599569149499,
                "delay": 0.08879359923482652,
                "disk": 0.17758719846965304,
                "easy": 0.05879889683707943,
                "engineering": 0.07356634548623013,
                "especially": 0.06756983844261952,
                "fast": 0.07069493217624938,
                "faster": 0.06904999333680034,
                "files": 0.06559501515843576,
                "force": 0.08381744198595104,
                "forever": 0.09209371520148818,
                "forget": 0.16368523740353455,
                "gets": 0.07356634548623013,
                "goal": 0.07356634548623013,
                "gone": 0.08879359923482652,
                "good": 0.12081458136546418,
                "honest": 0.2663807977044796,
                "impossible": 0.07584611165815665,
                "laptop": 0.33526976794380414,
                "likely": 0.06229489919177409,
                "locations": 0.08609720815787754,
                "long": 0.10217865840520916,
                "magical": 0.08381744198595104,
                "make": 0.08358541238466459,
                "malicious": 0.08879359923482652,
                "means": 0.059598508114825116,
                "mode": 0.09209371520148818,
                "models": 0.08184261870176728,
                "money": 0.06499129026872306,
                "need": 0.04335090457149359,
                "new": 0.043627346378756524,
                "note": 0.06904999333680034,
                "old": 0.06499129026872306,
                "option": 0.08010070111426691,
                "pass": 0.07584611165815665,
                "people": 0.0823779626052392,
                "person": 0.06279627622606707,
                "phrases": 0.09209371520148818,
                "plan": 0.07584611165815665,
                "plus": 0.08010070111426691,
                "point": 0.05280238979346881,
                "power": 0.07466234355886563,
                "powerful": 0.08184261870176728,
                "probably": 0.156877099885528,
                "product": 0.06044383567652848,
                "provide": 0.06688184434437247,
                "quite": 0.05879889683707943,
                "random": 0.08381744198595104,
                "really": 0.04294569549574026,
                "recover": 0.08879359923482652,
                "remember": 0.1288224941182895,
                "said": 0.05841474001553411,
                "say": 0.04797524343828369,
                "says": 0.07069493217624938,
                "security": 0.13513967688523904,
                "seen": 0.06279627622606707,
                "sensitive": 0.09209371520148818,
                "separately": 0.08609720815787754,
                "server": 0.06559501515843576,
                "similarly": 0.08609720815787754,
                "sleep": 0.09209371520148818,
                "social": 0.08184261870176728,
                "solution": 0.06279627622606707,
                "stored": 0.17219441631575508,
                "strong": 0.22753833497446993,
                "throw": 0.08381744198595104,
                "try": 0.05280238979346881,
                "use": 0.0346884682662016,
                "useless": 0.07713294084409338,
                "way": 0.04049561028881296,
                "weak": 0.08879359923482652,
                "worth": 0.06180996374459289,
                "years": 0.05416015055942384
            },
            "Max term": "data",
            "Max score": 0.3940887450371443
        }
    },
    {
        "ID": "8145",
        "Question": "Looking at common Agile practices it seems to me that they (intentionally or unintentionally?)  force developers to spend more time actually working as opposed to reading blogs/articles, chatting, coffee breaks and just plain procrastinating. In particular: 1) Pair programming - the biggest work-forcer, just because it is inconvenient to do all that procrastination when there are two of you sitting together. 2) Short stories - when you have a HUGE chunk of work that must be done in e.g. a month, it is pretty common to slack off in the first three weeks and switch to OMG DEADLINE mode for the last one.  And with the little chunks (that must be done in a day or less) it is exact opposite - you feel that time is tight, there is no space for maneuvering, and you will be held accountable for the task pretty soon, so you start working immediately. 3) Team communication and cohesion - when you underperform in a slow, distanced and silent environment it may feel ok, but when at the end of the day at Scrum meeting everyone boasts what they have accomplished and you have nothing to say you may actually feel ashamed. 4) Testing and feedback - again, it prevents you from keeping tasks \"99% ready\" (when it's actually around 20%) until the deadline suddenly happens. Do you feel that under Agile you work more than under \"conventional\" methodologies? Is this pressure compensated by the more comfortable environment and by the feeling of actually getting right things done quickly? ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "20": 0.09954190572261407,
                    "accomplished": 0.11478718412682432,
                    "actually": 0.2700278927183429,
                    "agile": 0.17658451252319435,
                    "articles": 0.10471504147618838,
                    "biggest": 0.11838208744192501,
                    "blogs": 0.11174773668198762,
                    "breaks": 0.10471504147618838,
                    "coffee": 0.11478718412682432,
                    "cohesion": 0.12278189351241262,
                    "comfortable": 0.11174773668198762,
                    "common": 0.14925042059172108,
                    "communication": 0.10471504147618838,
                    "day": 0.1557603007425783,
                    "deadline": 0.20943008295237675,
                    "developers": 0.07005468991706573,
                    "end": 0.06842422597933778,
                    "environment": 0.1611707938870808,
                    "exact": 0.10679247474123603,
                    "feedback": 0.10911484754667598,
                    "feel": 0.29514418491845773,
                    "feeling": 0.10283577449664726,
                    "force": 0.11174773668198762,
                    "getting": 0.07462521029586054,
                    "happens": 0.09672033209060009,
                    "held": 0.11478718412682432,
                    "huge": 0.09008598133066271,
                    "immediately": 0.10679247474123603,
                    "intentionally": 0.11838208744192501,
                    "keeping": 0.10112013816108768,
                    "little": 0.07788015037128915,
                    "looking": 0.07259068755795212,
                    "meeting": 0.10283577449664726,
                    "methodologies": 0.10112013816108768,
                    "mode": 0.12278189351241262,
                    "month": 0.09672033209060009,
                    "ok": 0.09425244290927703,
                    "opposed": 0.12278189351241262,
                    "opposite": 0.12278189351241262,
                    "pair": 0.09425244290927703,
                    "particular": 0.08001383868002676,
                    "plain": 0.12278189351241262,
                    "practices": 0.09425244290927703,
                    "pressure": 0.11478718412682432,
                    "pretty": 0.1537881518658922,
                    "prevents": 0.11838208744192501,
                    "programming": 0.05212429087828952,
                    "quickly": 0.08829225626159717,
                    "reading": 0.08240675674654564,
                    "ready": 0.10679247474123603,
                    "right": 0.07039760950721016,
                    "say": 0.06396192420062377,
                    "scrum": 0.11838208744192501,
                    "short": 0.08829225626159717,
                    "sitting": 0.12278189351241262,
                    "slack": 0.12278189351241262,
                    "slow": 0.10283577449664726,
                    "soon": 0.09808069071625099,
                    "space": 0.09954190572261407,
                    "spend": 0.08587485975687745,
                    "start": 0.06842422597933778,
                    "stories": 0.11174773668198762,
                    "suddenly": 0.10911484754667598,
                    "switch": 0.10471504147618838,
                    "task": 0.08117401914532234,
                    "tasks": 0.09008598133066271,
                    "team": 0.07337948792008937,
                    "testing": 0.0722078137911408,
                    "things": 0.05835208332870184,
                    "time": 0.09678586913148164,
                    "weeks": 0.09425244290927703,
                    "work": 0.15596351364252453,
                    "working": 0.13103873735565444
                },
                "Max term": "feel",
                "Max score": 0.29514418491845773
            }
        ],
        "Best Answer": "The main idea behind the agile methods is to help you be productive - in a positive sense. No one cares if you spend an hour surfing every day if you meet the deadline. Everyone gets mad if you surf half an hour every day but miss your deadline. The solution: Make it easier for you to meet the deadline. As you noticed, pair programming makes sure you stay focused (among all the other advantages like improving skill/knowledge spreading, better code, less bugs, uniform design, etc.). I found that discipline is always a struggle for me. If I pair with someone, chances are that one of us wants some work done today and pulls the other along. So the \"work for a month\" often becomes turns into \"work together for one week\", being surprised how that huge amount of work resolved in the end, spend a day or so recovering (refactoring, fixing TODOs in the code, adding a couple of tests, surfing with a clear conscience) and then grabbing the next month of work. Net result: I'm much more relaxed (more because than despite the constant supervision), team cohesion is much better, work gets done more quickly, people don't hang around some minor issue for hours or even days (because someone else can spot the problem much faster). When you say \"you may actually feel ashamed\", isn't that a good thing? It means you feel that you did wrong and you should. You're not getting paid to get nothing done. Not getting anything done makes you feel helpless, unhappy, unworthy, miserable. Instead of feeling ashamed, stand back and think \"Why didn't I accomplish anything today?\" Do you need help? Is there something you don't understand? Is the current task too hard? You don't like it? Maybe you can switch the task with someone else. Maybe someone else can help you get through. Agile means: Assume responsibility instead of being micro-managed like a puppet on strings. You need a tool? Go to your boss and ask for it. Learn to argue. Learn to stand up and shout when you have to. As for tests, there is a sweet spot when your code suddenly collapses from \"nice\" to \"perfect\". That's the moment when you notice that you need to implement feature X and you thought that will be a nightmare and suddenly realize that the code is almost there. Just a small refactoring here and there. A new class and done. Four weeks of work suddenly became a day. Victory! Triumph! ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "accomplish": 0.07701818890908838,
                "actually": 0.04764947145073001,
                "adding": 0.07537895326455163,
                "advantages": 0.07026117409031292,
                "agile": 0.1246413265446108,
                "argue": 0.0866650073914954,
                "ask": 0.05361245323021545,
                "assume": 0.07258613547901592,
                "better": 0.0866658318431302,
                "boss": 0.06426578853091587,
                "bugs": 0.05862276146744399,
                "chances": 0.08355942549572991,
                "class": 0.05772455194427434,
                "clear": 0.07137516184561649,
                "code": 0.12134107346376288,
                "cohesion": 0.0866650073914954,
                "constant": 0.07701818890908838,
                "couple": 0.06497965870769656,
                "current": 0.06358675546164894,
                "day": 0.2198853141777361,
                "days": 0.05958296404271378,
                "deadline": 0.22173782103996864,
                "design": 0.04968981316181767,
                "despite": 0.07887660100752782,
                "discipline": 0.0866650073914954,
                "easier": 0.05608531629973759,
                "end": 0.04829690991577003,
                "faster": 0.06497965870769656,
                "feature": 0.05427531265770293,
                "feel": 0.15624457464240737,
                "feeling": 0.07258613547901592,
                "fixing": 0.07391260701332289,
                "focused": 0.0810219803280235,
                "gets": 0.1384595650502416,
                "getting": 0.10534768957979676,
                "good": 0.037897615358914956,
                "half": 0.07391260701332289,
                "hang": 0.08355942549572991,
                "hard": 0.057296289933137026,
                "help": 0.1410924531792795,
                "hour": 0.162043960656047,
                "hours": 0.06172834336320949,
                "huge": 0.06358675546164894,
                "idea": 0.0501869166184364,
                "implement": 0.0629393169966089,
                "improving": 0.0866650073914954,
                "instead": 0.11217063259947518,
                "issue": 0.05909458350533072,
                "knowledge": 0.05427531265770293,
                "learn": 0.094061635452853,
                "like": 0.09267983896086708,
                "main": 0.06573213478214461,
                "make": 0.03932912450262995,
                "makes": 0.09749179558801278,
                "managed": 0.068269579949851,
                "maybe": 0.11633282364759333,
                "means": 0.11217063259947518,
                "meet": 0.14782521402664578,
                "methods": 0.06008910771867274,
                "micro": 0.0866650073914954,
                "minor": 0.07258613547901592,
                "miss": 0.08355942549572991,
                "moment": 0.07137516184561649,
                "month": 0.136539159899702,
                "need": 0.12238641226157611,
                "net": 0.05297973440397212,
                "new": 0.04105561696706493,
                "nice": 0.0629393169966089,
                "notice": 0.07026117409031292,
                "noticed": 0.07537895326455163,
                "paid": 0.07137516184561649,
                "pair": 0.1330552645463675,
                "people": 0.038760987774570856,
                "perfect": 0.07701818890908838,
                "positive": 0.0810219803280235,
                "problem": 0.04514721572575302,
                "productive": 0.07137516184561649,
                "programming": 0.03679167933492357,
                "quickly": 0.0623206632723054,
                "realize": 0.07026117409031292,
                "refactoring": 0.14275032369123297,
                "relaxed": 0.0866650073914954,
                "responsibility": 0.08355942549572991,
                "result": 0.07137516184561649,
                "say": 0.04514721572575302,
                "sense": 0.0623206632723054,
                "skill": 0.07258613547901592,
                "small": 0.05179455765874621,
                "solution": 0.05909458350533072,
                "spend": 0.12122871121581183,
                "spot": 0.15775320201505563,
                "stand": 0.15775320201505563,
                "stay": 0.068269579949851,
                "strings": 0.0866650073914954,
                "struggle": 0.07887660100752782,
                "suddenly": 0.23105456672726513,
                "sure": 0.05096753712549889,
                "surprised": 0.0810219803280235,
                "switch": 0.07391260701332289,
                "task": 0.11459257986627405,
                "team": 0.05179455765874621,
                "tests": 0.10994265708886805,
                "thing": 0.04944776502292371,
                "think": 0.03679167933492357,
                "thought": 0.06008910771867274,
                "today": 0.136539159899702,
                "tool": 0.060614355607905915,
                "turns": 0.07537895326455163,
                "understand": 0.047440183037871966,
                "wants": 0.06737137042668136,
                "week": 0.06652763227318376,
                "weeks": 0.06652763227318376,
                "work": 0.25686755251325843,
                "wrong": 0.05608531629973759
            },
            "Max term": "work",
            "Max score": 0.25686755251325843
        }
    },
    {
        "ID": "8187",
        "Question": "A recent question on stackoverflow provoked a discussion about the immutability of primary keys. I had thought that it was a kind of rule that primary keys should be immutable. If there is a chance that some day a primary key would be updated, I thought you should use a surrogate key. However it is not in the SQL standard and some RDBMS' \"cascade update\" feature allows a primary key to change.  So my question is: is it still a bad practice to have a primary key that may change ? What are the cons, if any, of having a mutable primary key ? ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "allows": 0.10281865259617874,
                    "bad": 0.07819642319796821,
                    "chance": 0.10281865259617874,
                    "change": 0.16364102937479572,
                    "cons": 0.12365149759076725,
                    "day": 0.08389435893265058,
                    "discussion": 0.10892902910127089,
                    "feature": 0.08283213598533638,
                    "immutable": 0.13226358957517148,
                    "key": 0.507654918359344,
                    "keys": 0.2473029951815345,
                    "kind": 0.08877052748371429,
                    "mutable": 0.12365149759076725,
                    "practice": 0.09605468506771282,
                    "primary": 0.6339291821150534,
                    "question": 0.13570441881372455,
                    "recent": 0.12752401334230867,
                    "rule": 0.10565486368584225,
                    "sql": 0.09807907636331596,
                    "stackoverflow": 0.10892902910127089,
                    "standard": 0.08680851518237244,
                    "thought": 0.18340969026492493,
                    "update": 0.10031693711686666,
                    "updated": 0.11503940560636303,
                    "use": 0.049819049212145465
                },
                "Max term": "primary",
                "Max score": 0.6339291821150534
            }
        ],
        "Best Answer": "You only need the primary key to be immutable if it's linked to a foreign key, or if it's used as an identifier outside the database (for example in an URL pointing to a page for the item). On the other hand, you only need to have a mutable key if it carries some information that might change. I always use a surrogate key if the record doesn't have a simple, immutable identifier that can be used as key. ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "change": 0.10678230335978975,
                "database": 0.12800102426010132,
                "example": 0.09211126782768501,
                "foreign": 0.16137507539613768,
                "hand": 0.12294708206325089,
                "identifier": 0.34522908586997675,
                "immutable": 0.34522908586997675,
                "information": 0.11497255293565815,
                "key": 0.6625301943093994,
                "linked": 0.1571020281539369,
                "mutable": 0.16137507539613768,
                "need": 0.16250830063821217,
                "outside": 0.1325060388618799,
                "page": 0.13597555338769401,
                "pointing": 0.17261454293498837,
                "primary": 0.13788803148749348,
                "record": 0.16137507539613768,
                "simple": 0.10678230335978975,
                "use": 0.0650178362528313,
                "used": 0.1684636658385494
            },
            "Max term": "key",
            "Max score": 0.6625301943093994
        }
    },
    {
        "ID": "8228",
        "Question": "I am rereading Refactoring by Martin Fowler. In Chapter 4, Building Tests, I came across the following passage. In fact, one of the most usefull times to write tests is before you start programming. When you need to add a feature, begin by writing the test. This isn't as backward as it sounds. By writing the test you are asking yourself what needs to be done to add the function. Writing the test also concentrates on the interface rather than the implementation (always a good thing). It also means you have a clear point at which you are done coding--when the test works. While I am an advocate of test-driven development now, I did not remember having been introduced to the concept when I originally read this book nearly 5 years ago. According to Amazon.com, this book was originally published on July 8, 1999. Is this the first published reference to test-first programming or is there something even earlier? ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "add": 0.1963506454897601,
                    "advocate": 0.14103454741665689,
                    "ago": 0.1062312005458182,
                    "asking": 0.10322835528756052,
                    "begin": 0.13675175790848415,
                    "book": 0.1880383318621003,
                    "building": 0.12251344124583882,
                    "came": 0.12999401744569136,
                    "chapter": 0.12999401744569136,
                    "clear": 0.12046951720846351,
                    "coding": 0.08305812946374043,
                    "com": 0.11371177674567075,
                    "concept": 0.11228768571212502,
                    "development": 0.07393518272971192,
                    "driven": 0.11228768571212502,
                    "earlier": 0.1331307109744237,
                    "fact": 0.09894556577938778,
                    "feature": 0.0916077882436836,
                    "following": 0.10518701495577684,
                    "fowler": 0.14103454741665689,
                    "function": 0.10142051673400782,
                    "good": 0.06396493272429514,
                    "implementation": 0.1185892893590635,
                    "interface": 0.11228768571212502,
                    "means": 0.09466277627121503,
                    "nearly": 0.14103454741665689,
                    "need": 0.06885603533396656,
                    "needs": 0.10518701495577684,
                    "originally": 0.24502688249167764,
                    "point": 0.08386822035837621,
                    "programming": 0.12419658974234758,
                    "published": 0.2662614219488474,
                    "read": 0.08790503580842227,
                    "refactoring": 0.12046951720846351,
                    "reference": 0.12251344124583882,
                    "remember": 0.10230704865904289,
                    "sounds": 0.11228768571212502,
                    "start": 0.08151722909992673,
                    "test": 0.49597995047620297,
                    "tests": 0.18556509684363004,
                    "thing": 0.08345968296693977,
                    "times": 0.09670670030859033,
                    "works": 0.09817532274488006,
                    "write": 0.07211734617306616,
                    "writing": 0.24455168729978022,
                    "years": 0.08602480795902226
                },
                "Max term": "test",
                "Max score": 0.49597995047620297
            }
        ],
        "Best Answer": "Jon Bently in Programming Pearls (originaly published 1986) does not specifically mention Test-First programming.   But in the chapter \"Writing Correct Programs\", he describes writing an algorithm by first defining the preconditions, invariants and postconditions, and in the next chapter describes an automated testing framework. It's not quite test-first, but he was definitely laying some of the groundwork. Also, CIO Magazine, March 1993, Bug Busters, by Lucie Juneau,  pg 84:  Test cases ... can be developed even   before any code has been written.    Ideally these cases are based on an   application's requirements ... If developers are given requirements-based tests before they begin to write code, they will design a product that can pass those tests ... \"  ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "algorithm": 0.13480535121594642,
                "application": 0.0981176787678215,
                "automated": 0.14594809218155974,
                "based": 0.2185208394668696,
                "begin": 0.15998628558069147,
                "bug": 0.12076715781681469,
                "cases": 0.23730432430428905,
                "chapter": 0.3041607700979689,
                "code": 0.11980025391410228,
                "correct": 0.12555862961199885,
                "defining": 0.1649967336788801,
                "definitely": 0.12555862961199885,
                "describes": 0.31997257116138295,
                "design": 0.0981176787678215,
                "developed": 0.14332883685302897,
                "developers": 0.09763972966664444,
                "framework": 0.11231705374702897,
                "given": 0.11865216215214452,
                "ideally": 0.15208038504898444,
                "jon": 0.1649967336788801,
                "magazine": 0.1711290265463048,
                "mention": 0.14332883685302897,
                "pass": 0.14093764408337112,
                "product": 0.11231705374702897,
                "programming": 0.14529795725159356,
                "programs": 0.11865216215214452,
                "published": 0.15575001207493247,
                "quite": 0.1092604197334348,
                "requirements": 0.22796620410868745,
                "specifically": 0.13303174355166408,
                "test": 0.2901242046639172,
                "testing": 0.10064067697298995,
                "tests": 0.217093155009394,
                "write": 0.08437029634300548,
                "writing": 0.1907344942981303,
                "written": 0.11668837116396479
            },
            "Max term": "describes",
            "Max score": 0.31997257116138295
        }
    },
    {
        "ID": "8236",
        "Question": "I just sent out emails to five local web design companies to my area asking to take drawings to HTML/CSS/jQuery. None of the ones who accepted the deal seem suitable to myself. Others rejected the offer because they wanted to 'provide an end-to-end solution' or are 'booked till June'. The local companies did not seem suitable to myself because my review process is this: goto their website, do a view-source. I'll see really weird things (contact us forms that go nowhere), really old things (mm_menu.js), and portfolios that are non-existent (aren't on the site, don't link anywhere, or otherwise). The company would like to hire as locally as they can rather than out-source to another country. Answers I'm looking for  Processes you use when searching for someone How you qualify their aptitude for the project Anything that you think I'm doing wrong, or should be doing also.  Answers I'm not looking for:  \"Hello sir please contact me we do everything for 10 dolla.\" My bud's great at this stuff, call him. example.com is the best for this.  ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "10": 0.10993599489921516,
                    "accepted": 0.13452753584079288,
                    "answers": 0.2136568518860509,
                    "area": 0.14152095130847725,
                    "asking": 0.10682842594302545,
                    "best": 0.0797996942604505,
                    "com": 0.11767745487260105,
                    "companies": 0.217710787042351,
                    "company": 0.08949695244712542,
                    "contact": 0.253572151734814,
                    "country": 0.14595310234419692,
                    "css": 0.13777362100224588,
                    "deal": 0.11924635587549762,
                    "design": 0.08679310972813488,
                    "emails": 0.13777362100224588,
                    "end": 0.1687202561296946,
                    "example": 0.08077873374933779,
                    "forms": 0.14595310234419692,
                    "goto": 0.13777362100224588,
                    "great": 0.09364477827379245,
                    "hello": 0.14595310234419692,
                    "hire": 0.1316642858079698,
                    "html": 0.11481420483977796,
                    "jquery": 0.12910302137600507,
                    "js": 0.14595310234419692,
                    "like": 0.05396123752985186,
                    "link": 0.12467087034028541,
                    "local": 0.253572151734814,
                    "looking": 0.17899390489425085,
                    "non": 0.08949695244712542,
                    "offer": 0.12467087034028541,
                    "old": 0.10682842594302545,
                    "ones": 0.10495753933927052,
                    "process": 0.09253960940679835,
                    "processes": 0.12910302137600507,
                    "project": 0.07148351418011686,
                    "provide": 0.10993599489921516,
                    "qualify": 0.14595310234419692,
                    "really": 0.14118264253160367,
                    "review": 0.11767745487260105,
                    "searching": 0.14152095130847725,
                    "sent": 0.1513776168089847,
                    "site": 0.1088553935211755,
                    "solution": 0.10322040563553164,
                    "source": 0.17995668994966724,
                    "stuff": 0.09540285943962142,
                    "things": 0.14388439626475025,
                    "think": 0.06426396193520248,
                    "till": 0.14595310234419692,
                    "use": 0.05701863200331436,
                    "view": 0.12467087034028541,
                    "wanted": 0.12910302137600507,
                    "web": 0.08949695244712542,
                    "website": 0.11620369891582473,
                    "weird": 0.14152095130847725,
                    "wrong": 0.09796412387158612
                },
                "Max term": "contact",
                "Max score": 0.253572151734814
            }
        ],
        "Best Answer": "I might start out by searching for people on google, because if their own site isn't findable, I won't trust that mine would be.  Then I would want to see some portfolio sites, ideally ones where they use the technology I'm wanting to use. If they don't have any, they don't get to do the job unless they can show they clearly understand what I'm talking about and how to implement it.  Be ready to widen the net- there are a lot of decent designers and developers around so no point settling for someone weak just because they are very local rather than somewhat local. If I can't find anyone convincing that way, I might look the other way- find some sites that do something like what I am looking for and then find out who developed them.  ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "clearly": 0.1635498985654578,
                "convincing": 0.2001789900282575,
                "decent": 0.18896058981826816,
                "designers": 0.2001789900282575,
                "developed": 0.17389084719097556,
                "developers": 0.11845945089640783,
                "google": 0.14929838683942045,
                "ideally": 0.18450848815870236,
                "implement": 0.15078046354080496,
                "job": 0.11517733720819058,
                "like": 0.0740094308096777,
                "local": 0.3477816943819511,
                "look": 0.11962943886775637,
                "looking": 0.12274771322930274,
                "lot": 0.10651003206582133,
                "net": 0.12692080710265807,
                "ones": 0.14395236472081502,
                "people": 0.09285769186634417,
                "point": 0.11903931309261798,
                "ready": 0.1805814561836147,
                "searching": 0.19410016399624383,
                "site": 0.14929838683942045,
                "sites": 0.3149421450668882,
                "somewhat": 0.16832105754864435,
                "start": 0.11570240689266872,
                "talking": 0.1539582227279163,
                "technology": 0.1539582227279163,
                "trust": 0.17706860637808688,
                "understand": 0.11364999066158227,
                "unless": 0.1539582227279163,
                "use": 0.15640547523682244,
                "want": 0.09804175068852425,
                "wanting": 0.19410016399624383,
                "way": 0.18258907033949853,
                "weak": 0.2001789900282575
            },
            "Max term": "local",
            "Max score": 0.3477816943819511
        }
    },
    {
        "ID": "8254",
        "Question": "I'm developing a statically- and strongly-typed, compiled language, and I'm revisiting the idea of whether to include function overloading as a language feature. I realized that I'm a little bit biased, coming mainly from a C[++|#] background. What are the most convincing arguments for and against including function overloading in a language?  EDIT: Is there nobody who has an opposing opinion? Bertrand Meyer (creator of Eiffel back in 1985/1986) calls method overloading this: (source)  a vanity mechanism that brings nothing to the semantic power of an O-O language, but hampers readability and complicates everyone's task  Now those are some sweeping generalizations, but he's a smart guy, so I think it's safe to say he could back them up if he needed to. In fact, he almost had Brad Abrams (one of the CLSv1 developers) convinced that .NET shouldn't support method overloading. (source) That's some powerful stuff. Can anyone shed some light on his thoughts, and whether his viewpoint is still justified 25 years later? ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "25": 0.12747496663110439,
                    "arguments": 0.11420253072817108,
                    "background": 0.10892185282980568,
                    "biased": 0.13146722572884645,
                    "bit": 0.09014643455692609,
                    "calls": 0.10892185282980568,
                    "coming": 0.11420253072817108,
                    "compiled": 0.12747496663110439,
                    "convinced": 0.13146722572884645,
                    "convincing": 0.13146722572884645,
                    "creator": 0.1363533559731345,
                    "developers": 0.07779805147640555,
                    "developing": 0.09805147243874113,
                    "edit": 0.09082023548548987,
                    "fact": 0.09223342272838658,
                    "feature": 0.08539341598319852,
                    "function": 0.18908096223565862,
                    "guy": 0.11229725980188951,
                    "idea": 0.07896098682545327,
                    "include": 0.10341887045985941,
                    "including": 0.10467045695175693,
                    "justified": 0.13146722572884645,
                    "language": 0.25674026983759823,
                    "later": 0.10223497120076179,
                    "light": 0.12409955965902056,
                    "little": 0.08648848427919124,
                    "mainly": 0.13146722572884645,
                    "mechanism": 0.1363533559731345,
                    "method": 0.1907337472424427,
                    "needed": 0.09454048111782931,
                    "net": 0.0833550333863565,
                    "opinion": 0.09805147243874113,
                    "overloading": 0.545413423892538,
                    "power": 0.11054458045043622,
                    "powerful": 0.12117564914391962,
                    "readability": 0.11420253072817108,
                    "realized": 0.12747496663110439,
                    "safe": 0.1363533559731345,
                    "say": 0.07103183352008338,
                    "smart": 0.11859657728907429,
                    "source": 0.16209594999382754,
                    "statically": 0.12747496663110439,
                    "strongly": 0.11859657728907429,
                    "stuff": 0.08593410524120182,
                    "support": 0.09014643455692609,
                    "task": 0.09014643455692609,
                    "think": 0.057885749972214795,
                    "thoughts": 0.10599794231470475,
                    "typed": 0.12747496663110439,
                    "years": 0.08018916679200648
                },
                "Max term": "overloading",
                "Max score": 0.545413423892538
            }
        ],
        "Best Answer": "Function overloading is absolutely critical for C++-style template code.  If I have to use different function names for different types, I can't write generic code.  That would eliminate a large and heavily used part of the C++ library, and much of C++'s functionality. It's usually present in member function names.  A.foo() can call an entirely different function from B.foo(), but both functions are named foo.  It's present in operators, as + does different things when applied to integers and floating-point numbers, and it's often used as a string concatenation operator.  It seems odd not to allow it in regular functions as well. It enables the use of Common Lisp-style \"multimethods\", in which the exact function called depends on two data types.  If you haven't programmed in the Common Lisp Object System, try it before you call this useless.  It's vital for C++ streams. I/O without function overloading (or variadic functions, which are worse) would require a number of different functions, either to print values of different types or to convert values of different types to a common type (like String). Without function overloading, if I change the type of some variable or value I need to change every function that uses it.  It makes it much harder to refactor code. It makes it easier to use APIs when the user doesn't have to remember which type naming convention is in use, and the user can just remember standard function names. Without operator overloading, we'd have to label each function with the types it uses, if that base operation can be used on more than one type.  This is essentially Hungarian notation, the bad way of doing it. Overall, it makes a language far more usable. ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "absolutely": 0.0592221135308207,
                "allow": 0.05519997278522667,
                "apis": 0.06722636829681412,
                "applied": 0.07190855718113888,
                "bad": 0.042513529134908495,
                "base": 0.055900047649152025,
                "called": 0.05664531904301135,
                "change": 0.08896772237751864,
                "code": 0.07551024729197116,
                "common": 0.13111520880328925,
                "convention": 0.05829780446292352,
                "convert": 0.06722636829681412,
                "critical": 0.06390430241514546,
                "data": 0.043958875392693185,
                "depends": 0.05519997278522667,
                "different": 0.2708504681552323,
                "easier": 0.04653566988050253,
                "entirely": 0.0613275079273361,
                "essentially": 0.06390430241514546,
                "exact": 0.06254417941248938,
                "far": 0.04864106427701792,
                "foo": 0.19633884809523314,
                "function": 0.49857735762171207,
                "functionality": 0.05275983904809289,
                "functions": 0.2265812761720454,
                "generic": 0.07190855718113888,
                "harder": 0.06254417941248938,
                "language": 0.03384922623018436,
                "large": 0.04864106427701792,
                "library": 0.05222263992602637,
                "like": 0.025633081140236734,
                "lisp": 0.1184442270616414,
                "makes": 0.12133780233924853,
                "member": 0.06390430241514546,
                "named": 0.06544628269841105,
                "names": 0.16993595712903403,
                "naming": 0.06390430241514546,
                "need": 0.03384922623018436,
                "notation": 0.06933176269332952,
                "number": 0.045033855546103806,
                "numbers": 0.06022689469201979,
                "object": 0.051709324367089846,
                "odd": 0.07190855718113888,
                "operation": 0.06933176269332952,
                "operator": 0.1278086048302909,
                "operators": 0.06544628269841105,
                "overall": 0.06254417941248938,
                "overloading": 0.2876342287245555,
                "point": 0.04122912901773214,
                "present": 0.13445273659362825,
                "print": 0.06722636829681412,
                "programmed": 0.07190855718113888,
                "refactor": 0.06390430241514546,
                "regular": 0.05829780446292352,
                "remember": 0.10058709939386021,
                "require": 0.050293549696930104,
                "standard": 0.047195718019233245,
                "string": 0.1308925653968221,
                "style": 0.10664650632268534,
                "template": 0.06390430241514546,
                "things": 0.034174535028296676,
                "try": 0.04122912901773214,
                "type": 0.20117419878772042,
                "types": 0.2637991952404644,
                "use": 0.1083417124996591,
                "used": 0.1052690486727246,
                "useless": 0.06022689469201979,
                "user": 0.0869134448479021,
                "uses": 0.1132906380860227,
                "usually": 0.04686097867861484,
                "value": 0.05453992464649595,
                "values": 0.1226550158546722,
                "variable": 0.0613275079273361,
                "vital": 0.07190855718113888,
                "way": 0.03161975713182181,
                "worse": 0.0613275079273361,
                "write": 0.03545246765795763
            },
            "Max term": "function",
            "Max score": 0.49857735762171207
        }
    },
    {
        "ID": "8257",
        "Question": "I'm currently writing a load test for a cache which should test how a cache will react to persistent requests. A colleague and I had differing opinions on how this load testing should be performed. I believe that a load test should be as random as possible. It should model real-world load as much as possible, and the way towards that is randomality. So I have created this random test as follows:  Test data is held in spreadsheets and is loaded into TestRunner objects at startup  The test data is not random  The load test will run 10 random TestRunners in individual Threads at the same time The object returned by the cache will be tested to make sure it is sensible, it is not thoroughly tested  Any tests that fail will be output at the end and each test has a unique ID to easily find failed tests  At random intervals, the cache will be cleared to model the real-world requirement of the cache being cleared at any time. The load test will run for a configurable amount of time  My colleague's idea of what a load test should do is:  Test data is held in spreadsheets and is loaded into TestRunner objects at startup All TestRunner objects are run in a sequential manner Each time the load test is run, it will run the TestRunner objects in the same order  Which methodology do you feel would produce the most reliable load test?  I personally think the random test will produce a more reliable load test as it will model real-world usage. It is not known what order requests will come in when this is released to production, so it should be tested with that unknown element taken into account. However, running all tests in the same sequence each time will make any failures reproducable, which is important during testing. ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "10": 0.04272533445538742,
                    "account": 0.04927392070892842,
                    "believe": 0.04190328464657819,
                    "cache": 0.29415567272359866,
                    "come": 0.03918537578409671,
                    "created": 0.04634369700331116,
                    "currently": 0.043625788140829694,
                    "data": 0.10789330007613189,
                    "easily": 0.04411038733122646,
                    "element": 0.05883113454471973,
                    "end": 0.032785573911203555,
                    "fail": 0.04462119350905965,
                    "failed": 0.05228254829117872,
                    "failures": 0.05500045715366019,
                    "feel": 0.03535469839303718,
                    "follows": 0.05883113454471973,
                    "held": 0.11000091430732038,
                    "idea": 0.03406857430503839,
                    "important": 0.03756180107768545,
                    "individual": 0.05500045715366019,
                    "known": 0.04516120407773011,
                    "load": 0.47695658381525824,
                    "make": 0.053395876485376303,
                    "manner": 0.05228254829117872,
                    "methodology": 0.04927392070892842,
                    "model": 0.13233116199367936,
                    "object": 0.04230537140932573,
                    "objects": 0.19380748360047675,
                    "opinions": 0.05500045715366019,
                    "order": 0.09146792407527543,
                    "output": 0.04769565838152583,
                    "personally": 0.043625788140829694,
                    "possible": 0.06919697174888764,
                    "produce": 0.09032240815546022,
                    "production": 0.04634369700331116,
                    "random": 0.3212646072024278,
                    "real": 0.10666080856090035,
                    "released": 0.051169779762600655,
                    "reliable": 0.11000091430732038,
                    "requests": 0.1003487487887414,
                    "requirement": 0.051169779762600655,
                    "run": 0.18196972135542766,
                    "running": 0.0431648375558041,
                    "sequence": 0.0567229606479117,
                    "sequential": 0.05883113454471973,
                    "startup": 0.11000091430732038,
                    "sure": 0.03459848587444382,
                    "taken": 0.04845187090011919,
                    "test": 0.49869786744343736,
                    "tested": 0.1430869751445775,
                    "testing": 0.06919697174888764,
                    "tests": 0.11194918421077588,
                    "think": 0.024975434748436644,
                    "thoroughly": 0.0567229606479117,
                    "threads": 0.05228254829117872,
                    "time": 0.11593774794502164,
                    "unique": 0.05228254829117872,
                    "unknown": 0.05883113454471973,
                    "usage": 0.053544101200404634,
                    "way": 0.02586932986859448,
                    "world": 0.10918183281325658,
                    "writing": 0.032785573911203555
                },
                "Max term": "test",
                "Max score": 0.49869786744343736
            }
        ],
        "Best Answer": "Do you have a way to reset the data once the test is run (if this is even necessary)? If so, what about running the non-random test first - to look for failures when run that way (and possible anomalies caused by the data itself)?  Then, after resetting (if necessary), run the random tests to reflect the real world load. ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "data": 0.30123418813729946,
                "failures": 0.2303389280822682,
                "load": 0.19974682746882585,
                "look": 0.14196441748712524,
                "necessary": 0.3416569332248675,
                "non": 0.1456648779046595,
                "possible": 0.14489658017430748,
                "random": 0.44847957685780554,
                "real": 0.14889655822112763,
                "run": 0.457247587342814,
                "running": 0.18077199587035597,
                "test": 0.27846927866535637,
                "tests": 0.15627903491027903,
                "way": 0.2166786976148657,
                "world": 0.1524158624476047
            },
            "Max term": "run",
            "Max score": 0.457247587342814
        }
    },
    {
        "ID": "8283",
        "Question": "What was a project or spec that got put on your desk that could not possibly be done? How did you explain the dilemma to the \"requester\"? More importantly, did they understand after you explained the fundamental issue?  ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "desk": 0.3518647665402324,
                    "explain": 0.24356904936470183,
                    "explained": 0.36288446203433083,
                    "fundamental": 0.3763714793140991,
                    "got": 0.24191302822428956,
                    "importantly": 0.36288446203433083,
                    "issue": 0.2566377882237911,
                    "possibly": 0.30997026433940045,
                    "project": 0.17773008021714418,
                    "spec": 0.3425477467551043,
                    "understand": 0.2060246967756869
                },
                "Max term": "fundamental",
                "Max score": 0.3763714793140991
            }
        ],
        "Best Answer": "I was told to make the printer print faster. Serious, and I was written up for failing. The boss wasn't very tech savvy and didn't understand why I couldn't speed it up.  ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "boss": 0.3005269872086209,
                "failing": 0.37888419643281157,
                "faster": 0.303865268094769,
                "make": 0.18391532363509755,
                "print": 0.37888419643281157,
                "speed": 0.3601612117772126,
                "tech": 0.3337726470231041,
                "told": 0.3601612117772126,
                "understand": 0.2218451777673069,
                "written": 0.27634481031321767
            },
            "Max term": "failing",
            "Max score": 0.37888419643281157
        }
    },
    {
        "ID": "8297",
        "Question": "My management just asked an unprecedented question in my (admittedly brief) history with the organization: \"What can we do to help you?\" Simultaneously, we're working several big projects for a fairly new client whose ability to push requirements around mid-project is legend. Developing for these guys is like tap dancing on quicksand. Seems like a prime opportunity to propose a shift to a more agile approach. The thing I know I'm going to get asked, and that I don't have any idea about, is how to quote/bid/bill for that sort of project. Do you go hourly? Do you bid a range of prices? Do you charge by the sprint? More generally, the aspect of the Agile Manifesto that reads \"We value customer collaboration over contract negotiation\" is GOING to scare my management. How do you value that in the real world of customers who want a lot for a little? ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "ability": 0.1169994610216774,
                    "admittedly": 0.14750504500115877,
                    "agile": 0.22691650347884604,
                    "approach": 0.1103518232393532,
                    "asked": 0.2086221983410014,
                    "aspect": 0.15212460579361511,
                    "bid": 0.3155569825263029,
                    "big": 0.09820067096941616,
                    "charge": 0.1372315987391661,
                    "client": 0.1093955800912046,
                    "collaboration": 0.14750504500115877,
                    "contract": 0.12265334649121373,
                    "customer": 0.11576324335538503,
                    "customers": 0.12428858714565358,
                    "developing": 0.11345825173942302,
                    "fairly": 0.12428858714565358,
                    "generally": 0.10847411723140883,
                    "going": 0.1631191228864862,
                    "guys": 0.14750504500115877,
                    "help": 0.0856222330914615,
                    "history": 0.12791439562532203,
                    "hourly": 0.1372315987391661,
                    "idea": 0.09136808757698817,
                    "know": 0.06880493314196247,
                    "like": 0.11248588561010091,
                    "little": 0.10007837697736052,
                    "lot": 0.08094154455865307,
                    "management": 0.2071094032494066,
                    "manifesto": 0.15777849126315144,
                    "mid": 0.15212460579361511,
                    "negotiation": 0.15777849126315144,
                    "new": 0.07474404604478249,
                    "opportunity": 0.13214711781846222,
                    "organization": 0.12603668961737768,
                    "project": 0.1490122681975994,
                    "projects": 0.09183300770523575,
                    "propose": 0.14750504500115877,
                    "push": 0.12994247261518993,
                    "question": 0.08094154455865307,
                    "quote": 0.12603668961737768,
                    "range": 0.1402159188771826,
                    "real": 0.09535076725320503,
                    "requirements": 0.10509077410524488,
                    "scare": 0.15212460579361511,
                    "shift": 0.15212460579361511,
                    "sort": 0.11576324335538503,
                    "sprint": 0.14750504500115877,
                    "thing": 0.09002242077253131,
                    "value": 0.23933805270639452,
                    "want": 0.0745061340987997,
                    "working": 0.08419439416331112,
                    "world": 0.09760446849520205
                },
                "Max term": "bid",
                "Max score": 0.3155569825263029
            }
        ],
        "Best Answer": "We have the same problem in my company.  There's a history of fixed-price, fixed-timeline projects, and our clients aren't generally very progressive. Regarding development with no up-front commitments, I've heard so many fundamentalist agilists say, \"I know it's hard, but you just need to push the benefits\", or, \"They might be skeptical but they'll see how well it went and come back to you next time\".  In some industries, maybe. In ours, that's a load of crap. I can't see any of our customers agreeing to just let us do our thing with no commitment on scope or price. What we've found is that it's not always necessary to change the way you quote/bid/bill customers for an agile project.  You can keep the agile process while sticking to your quote if you manage it properly. Quote the way you normally would (with padding), and set some boundaries around the scope of the project.  From that point on, follow your agile methodology:  Prioritise the work with the customer - develop the important stuff first Develop in small iterations, showing your progress Collaborate with the customer to make sure you're actually developing what they want Grow the spec as you write the software  But more importantly:  If a function turns out to be more complicated than what was originally requested, tell the customer immediately and make sure they're aware it will affect the timeline and/or price. Treat major (or even minor) changes as chargeable change requests.  You're still using Agile internally and getting the benefits, but the customer is seeing a more familiar fixed-price, fixed-timeline, fixed-scope project. Any changes cost money and blow out the time. The hardest part about this is setting the boundaries up front.  It's definitely not something that can be done by just your sales guy, BA, or project manager. You need an experienced developer in those meetings.  You need to nail down the areas that could cause problems and decide on expectations. ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "actually": 0.04937448563058882,
                "affect": 0.07810783480899265,
                "agile": 0.2583072256244358,
                "areas": 0.07521391096424719,
                "aware": 0.07658840364414492,
                "benefits": 0.1479181949193836,
                "bid": 0.0898024685656971,
                "blow": 0.0898024685656971,
                "cause": 0.06981036011039096,
                "change": 0.11110668055879698,
                "changes": 0.11962861176547578,
                "clients": 0.07074108676579269,
                "collaborate": 0.0898024685656971,
                "come": 0.05981430588273789,
                "company": 0.05309270570034266,
                "complicated": 0.07074108676579269,
                "cost": 0.06521785673659411,
                "customer": 0.26355493551136555,
                "customers": 0.14148217353158538,
                "decide": 0.07074108676579269,
                "definitely": 0.06588873387784139,
                "develop": 0.1331846988329837,
                "developer": 0.04959466178309839,
                "developing": 0.06457680640610895,
                "development": 0.045390564450794715,
                "expectations": 0.07980641433804403,
                "experienced": 0.07658840364414492,
                "familiar": 0.07074108676579269,
                "fixed": 0.3640239046615182,
                "follow": 0.06521785673659411,
                "function": 0.06226446370298736,
                "generally": 0.061739996528540536,
                "getting": 0.05458075217845588,
                "grow": 0.0898024685656971,
                "guy": 0.0739590974596918,
                "hard": 0.05937053985824189,
                "heard": 0.07074108676579269,
                "history": 0.07280478093230364,
                "immediately": 0.07810783480899265,
                "important": 0.057336009013828626,
                "importantly": 0.08658445787179798,
                "internally": 0.08395515168734487,
                "iterations": 0.08658445787179798,
                "know": 0.039161566295754166,
                "let": 0.05852198583464142,
                "load": 0.07280478093230364,
                "major": 0.06981036011039096,
                "make": 0.08150584816566696,
                "manage": 0.07980641433804403,
                "manager": 0.06811178058133957,
                "maybe": 0.06027216204793728,
                "meetings": 0.07280478093230364,
                "methodology": 0.07521391096424719,
                "minor": 0.07521391096424719,
                "money": 0.06337433872259272,
                "necessary": 0.06226446370298736,
                "need": 0.12681706574304366,
                "normally": 0.07980641433804403,
                "originally": 0.07521391096424719,
                "point": 0.051488692135476403,
                "price": 0.3124313392359706,
                "problem": 0.04678164282298949,
                "problems": 0.05427060564731638,
                "process": 0.0548977156597874,
                "progress": 0.07810783480899265,
                "project": 0.16962602980401784,
                "projects": 0.05226840947533429,
                "properly": 0.08173210498384667,
                "push": 0.0739590974596918,
                "quote": 0.2152081522685808,
                "regarding": 0.08658445787179798,
                "requested": 0.08658445787179798,
                "requests": 0.07658840364414492,
                "sales": 0.07521391096424719,
                "say": 0.04678164282298949,
                "scope": 0.22976521093243474,
                "seeing": 0.0739590974596918,
                "set": 0.056596295188838776,
                "setting": 0.0739590974596918,
                "showing": 0.08658445787179798,
                "small": 0.0536696329466901,
                "software": 0.04240650745100446,
                "spec": 0.08173210498384667,
                "sticking": 0.0898024685656971,
                "stuff": 0.056596295188838776,
                "sure": 0.105625344953995,
                "tell": 0.06396304323203875,
                "thing": 0.05123788132914694,
                "time": 0.0707890204462833,
                "turns": 0.07810783480899265,
                "using": 0.04213943948778161,
                "want": 0.04240650745100446,
                "way": 0.07897619858322494,
                "went": 0.06893607680634796,
                "work": 0.03802381640759476,
                "write": 0.04427455141966331
            },
            "Max term": "fixed",
            "Max score": 0.3640239046615182
        }
    },
    {
        "ID": "8301",
        "Question": "In my experience, software developers tend to wear multiple hats and fill multiple roles with different responsibilities.  From not only coding, but sometimes also writing SQL, designing the user-interface, designing the database, graphics manipulation, to even QA testing. If the primary role is to write software/code, what roles should the developer not take on?  Are there any? The intention of this question is not because a developer is incapable of filling another role-- but having the additional role actually works against the primary role, or should really be a dedicated role of someone who does not primarily program. ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "actually": 0.08301903523691402,
                    "additional": 0.1264658506291053,
                    "code": 0.05285273134660748,
                    "coding": 0.08573766998526014,
                    "database": 0.11196942169847365,
                    "dedicated": 0.13742564437850943,
                    "designing": 0.26266347922294253,
                    "developer": 0.166778485752289,
                    "developers": 0.08615217801669564,
                    "different": 0.08124831231652747,
                    "experience": 0.08657389524377222,
                    "graphics": 0.1341877578965034,
                    "incapable": 0.15099528039637347,
                    "interface": 0.11591020172441567,
                    "multiple": 0.213117216000628,
                    "primary": 0.2412362437572787,
                    "program": 0.09230588091357146,
                    "qa": 0.13742564437850943,
                    "question": 0.07746170671619122,
                    "really": 0.07041302784895996,
                    "responsibilities": 0.14116351000392235,
                    "role": 0.6566586980573563,
                    "roles": 0.29116893339642763,
                    "software": 0.14260593468009003,
                    "sql": 0.11196942169847365,
                    "tend": 0.11452421711160117,
                    "testing": 0.08880005657430416,
                    "user": 0.09125144829401423,
                    "works": 0.10134255944051289,
                    "write": 0.07444392579414415,
                    "writing": 0.08414705859386706
                },
                "Max term": "role",
                "Max score": 0.6566586980573563
            }
        ],
        "Best Answer": "Sysadmin.  Developing software and handling the IT infrastructure are two different skillsets that look similar to an outsider.  (It's all just banging on computers, right?)  For a smallish company, the temptation will be very strong to make The Computer Guy responsible for all the machines in the office.   If you have the skills to actually wear both hats, awesome; but it's one of those things that can be a much greater time sink than people realize, and if you're self-teaching as you go, chances are you're not doing it very well. ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "actually": 0.13743508386245326,
                "awesome": 0.24996735947231208,
                "chances": 0.24100994829247188,
                "company": 0.14778484002860334,
                "computer": 0.15855347223204122,
                "computers": 0.21318568777561864,
                "developing": 0.17975111417656203,
                "different": 0.13450371454015253,
                "greater": 0.24100994829247188,
                "guy": 0.20586694994280344,
                "handling": 0.24996735947231208,
                "infrastructure": 0.23369121045965668,
                "look": 0.14403052424085788,
                "machines": 0.21318568777561864,
                "make": 0.11343675721240352,
                "office": 0.22214309895545883,
                "people": 0.11179808386537847,
                "realize": 0.20265388176154983,
                "responsible": 0.23369121045965668,
                "right": 0.14332002918574702,
                "self": 0.20935975390881512,
                "similar": 0.16289737357787087,
                "skills": 0.17331465191749265,
                "software": 0.11803954681062756,
                "strong": 0.20586694994280344,
                "teaching": 0.24996735947231208,
                "things": 0.11879696404836225,
                "time": 0.0985214816653052
            },
            "Max term": "awesome",
            "Max score": 0.24996735947231208
        }
    },
    {
        "ID": "8311",
        "Question": "This might be slightly off topic, but I'll risk it, as the site is about Programmers ! Programmers are good at constantly learning new programming languages, but how good are they at learning a new spoken language ? Have you taken up a foreign language (French/Spanish/etc) as an adult and mastered it? Was it easy? I ask because I have been trying to learn French for quite some time now, and I'm still at the annoying \"Je parle un peu de FranÃ§aise\" stage. I've attended two French courses, one where the majority of the class were programmers, and one where they weren't and the difference in ability was quite apparent. Does a mathematical / logical inclination hinder learning a spoken language where grammar is not in ones and zeros? Or am I just transferring blame instead of simply accepting that I am not good with languages. [It is important that you have not been taught the language in school, as early exposure really gives you the upper hand. I've picked up and got quite good at languages I've been exposed to under the age of 10.] ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "10": 0.10359700590322547,
                    "ability": 0.10578035465766879,
                    "age": 0.12982949434680843,
                    "annoying": 0.11748225776683274,
                    "apparent": 0.14264907391390289,
                    "ask": 0.08824515261384672,
                    "blame": 0.13753734087736705,
                    "class": 0.09501359458435549,
                    "constantly": 0.12407242783946087,
                    "courses": 0.14264907391390289,
                    "difference": 0.11748225776683274,
                    "early": 0.10950330957204328,
                    "easy": 0.0910768792703995,
                    "exposed": 0.13753734087736705,
                    "exposure": 0.13336075087668187,
                    "foreign": 0.13336075087668187,
                    "gives": 0.11564865356568575,
                    "good": 0.24951522637382376,
                    "got": 0.09168779076138153,
                    "grammar": 0.13753734087736705,
                    "hand": 0.10160376465698365,
                    "important": 0.0910768792703995,
                    "instead": 0.09231544161976263,
                    "language": 0.2685945018907701,
                    "languages": 0.2342571141575614,
                    "learn": 0.0774118966353041,
                    "learning": 0.263155538380129,
                    "logical": 0.11395100123695931,
                    "majority": 0.13753734087736705,
                    "mathematical": 0.13753734087736705,
                    "new": 0.13515364310441275,
                    "ones": 0.09890561169239077,
                    "picked": 0.14264907391390289,
                    "programmers": 0.22931084552974054,
                    "programming": 0.060558455400064395,
                    "quite": 0.2732306378111985,
                    "really": 0.06652097461431139,
                    "risk": 0.1123705247302969,
                    "school": 0.11089208769420462,
                    "simply": 0.09574088815428318,
                    "site": 0.10257871278237422,
                    "slightly": 0.14264907391390289,
                    "spanish": 0.14264907391390289,
                    "stage": 0.13336075087668187,
                    "taken": 0.11748225776683274,
                    "taught": 0.13336075087668187,
                    "time": 0.05622333311777074,
                    "topic": 0.13336075087668187,
                    "transferring": 0.13753734087736705,
                    "trying": 0.08824515261384672,
                    "upper": 0.13336075087668187
                },
                "Max term": "quite",
                "Max score": 0.2732306378111985
            }
        ],
        "Best Answer": "I find it easy and fun to learn new languages! The only reason I'm any good at programming is that I've got a strong inclination toward language. All human languages are fundamentally the same, and not even vast differences in phonology, grammar, and vocabulary can get in the way of the fact that all people work in basically the same way. I find it immensely rewarding to draw parallels between etymologies, to discover the underlying nature of what makes a language tick, and to learn how native speakers understand their own language. Not to mention that studying a wide variety of orthographies has given me great clerical accuracy, which is a big help in programming. However, your mileage may varyâ€”I'm a programmer because I'm a linguist, not the other way round, and you can become proficient at programming in many different ways. Edit: Here are a few tips that I think can help programmers with language learning: Natural languages are not programming languages. Natural languages do not have rules, but they do have patterns. If you notice a pattern, don't claim it's a rule and then complain about all of the exceptions. Linguistics is not a black-and-white field. I've noticed that people of a technical mindset get caught up in whether they're \"correct\" and lose sight of the fact that it's more important to be understood. Natural speech has inherent meaning that transcends literalism. Learning a language is not about rote memorisation. No native speaker of Spanish says to himself \"voy, vas, va, vamos, vais, van\" to remember how to conjugate \"to go\". He just does it in running speech because he has developed a sense over time of what sounds right. Do not take a \"phrasebook\" approach to language learning: you will find yourself lost for the appropriate phrase because you won't be able to produce your own. Learning vocabulary is not the same as learning an API. Natural languages are redundant and compressible, and you can use this to your advantage as a student. If you pronounce or spell something wrong, chances are you will still be understood. Look up the etymologies of words to get a sense of their deeper meaning. Having a sense of the language as it was is just as important as knowing the language as it is. It's okay to make some mistakes. Step outside your comfort zone and experiment. Try to talk the way native speakers do. If you notice that you pronounce or articulate something differently, try to discern exactly how. If you don't understand everything someone says, it's okay to ask them to repeat themselves or explain. If you make a mistake, the worst that can happen is a misunderstanding, and if you're confident and outgoing then it turns into a funny situation rather than an awkward, embarrassing one. Have fun. ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "able": 0.05039063226130884,
                "accuracy": 0.07995581962658563,
                "advantage": 0.06696686621780214,
                "api": 0.07709065693443104,
                "approach": 0.05592188392570354,
                "appropriate": 0.07105581140221157,
                "ask": 0.04946203513085398,
                "awkward": 0.07474964855921692,
                "basically": 0.06298447764268826,
                "big": 0.04976416666416724,
                "black": 0.07995581962658563,
                "caught": 0.07474964855921692,
                "chances": 0.07709065693443104,
                "claim": 0.07277035418028407,
                "confident": 0.06954347749184821,
                "correct": 0.05866417488854131,
                "deeper": 0.07474964855921692,
                "developed": 0.06696686621780214,
                "differences": 0.07105581140221157,
                "different": 0.04302303613392138,
                "differently": 0.07277035418028407,
                "draw": 0.07474964855921692,
                "easy": 0.051049238044766916,
                "edit": 0.053255794953463435,
                "exactly": 0.06387034595591001,
                "exceptions": 0.07474964855921692,
                "experiment": 0.07995581962658563,
                "explain": 0.05174346104310008,
                "fact": 0.10816893883662838,
                "field": 0.06696686621780214,
                "fun": 0.12275476634276472,
                "fundamentally": 0.07709065693443104,
                "funny": 0.07709065693443104,
                "given": 0.05543729820010544,
                "good": 0.0349637643740913,
                "got": 0.05139165827674297,
                "grammar": 0.07709065693443104,
                "great": 0.04946203513085398,
                "happen": 0.060643469267474145,
                "help": 0.08677983634243588,
                "human": 0.06819064871005696,
                "important": 0.10209847608953383,
                "knowing": 0.06696686621780214,
                "language": 0.3010982540108585,
                "languages": 0.2626055543428379,
                "learn": 0.08677983634243588,
                "learning": 0.24583424884527003,
                "look": 0.04607032950716189,
                "lose": 0.06819064871005696,
                "lost": 0.06387034595591001,
                "make": 0.07256890593913214,
                "makes": 0.04497222499442174,
                "meaning": 0.15418131386886208,
                "mention": 0.06696686621780214,
                "mistake": 0.06696686621780214,
                "mistakes": 0.07277035418028407,
                "misunderstanding": 0.07709065693443104,
                "native": 0.22424894567765077,
                "natural": 0.27817390996739283,
                "new": 0.0378772886967868,
                "notice": 0.1296437843001552,
                "noticed": 0.06954347749184821,
                "okay": 0.15991163925317126,
                "outside": 0.06137738317138236,
                "pattern": 0.06387034595591001,
                "patterns": 0.06954347749184821,
                "people": 0.07152059730525115,
                "phrase": 0.07995581962658563,
                "produce": 0.06137738317138236,
                "programmer": 0.04133111890836267,
                "programmers": 0.04284345281872602,
                "programming": 0.13577377837740784,
                "reason": 0.04976416666416724,
                "redundant": 0.07709065693443104,
                "remember": 0.05592188392570354,
                "repeat": 0.07105581140221157,
                "rewarding": 0.07474964855921692,
                "right": 0.04584306697739821,
                "rule": 0.06387034595591001,
                "rules": 0.06584964033484286,
                "running": 0.05866417488854131,
                "says": 0.12275476634276472,
                "sense": 0.17248829238888216,
                "situation": 0.05866417488854131,
                "sounds": 0.06137738317138236,
                "spanish": 0.07995581962658563,
                "speaker": 0.07709065693443104,
                "speakers": 0.15418131386886208,
                "step": 0.06696686621780214,
                "strong": 0.06584964033484286,
                "student": 0.07474964855921692,
                "talk": 0.06387034595591001,
                "technical": 0.051049238044766916,
                "think": 0.03394344459435196,
                "time": 0.031513577748728636,
                "tips": 0.0648218921500776,
                "try": 0.09168613395479643,
                "turns": 0.06954347749184821,
                "underlying": 0.07474964855921692,
                "understand": 0.08753518478094596,
                "understood": 0.15991163925317126,
                "use": 0.03011654927534226,
                "variety": 0.07709065693443104,
                "vary": 0.07995581962658563,
                "vast": 0.07474964855921692,
                "way": 0.14063325406459495,
                "ways": 0.05366344816772693,
                "white": 0.07709065693443104,
                "wide": 0.06954347749184821,
                "words": 0.06584964033484286,
                "work": 0.033854586123942744,
                "worst": 0.07105581140221157,
                "wrong": 0.05174346104310008
            },
            "Max term": "language",
            "Max score": 0.3010982540108585
        }
    },
    {
        "ID": "8352",
        "Question": "I really like using ClassNames and memberNames as convention but I am not sure how I would name the file containing a class. I like making my classes defined in a file with the exact same name as the class. But I also like making php files all lowercase. So I am conflicted. If I have a class called ProductGroup should that be defined in ProductGroup.php, productgroup.php, or product_group.php? I know there is no right answer, so I am looking for what is most common or your opinion of which to use.. which do you use? ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "answer": 0.11535836611568019,
                    "called": 0.1537042815751005,
                    "class": 0.38988862062825486,
                    "classes": 0.16069628642575162,
                    "common": 0.11859155244805854,
                    "convention": 0.15818821932268506,
                    "defined": 0.3328183407213222,
                    "exact": 0.16971054847447134,
                    "file": 0.25992574708550326,
                    "files": 0.13897713559147135,
                    "know": 0.0850891707781232,
                    "like": 0.2086623072009567,
                    "looking": 0.11535836611568019,
                    "making": 0.2619153815724513,
                    "opinion": 0.14031070328233883,
                    "php": 0.5507920587029187,
                    "really": 0.09098968468206792,
                    "right": 0.11187320969674175,
                    "sure": 0.11474991765412447,
                    "use": 0.14698994873461402,
                    "using": 0.0915594114901115
                },
                "Max term": "php",
                "Max score": 0.5507920587029187
            }
        ],
        "Best Answer": "At work we use underscores as folder delimiters and name the files exactly the same as the path. The autoloader is very simple, it just has to replace _ with / and add '.php' to the end. ProjectName_Models_ProductGroup() will always reside in ProjectName/Models/ProductGroup.php. It can make for some very long class names, but it doesn't really matter with an IDE. You could use the same convention, but just run strtolower() before including the file. ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "add": 0.18555058784829967,
                "class": 0.18414105685229615,
                "convention": 0.22413282419521138,
                "end": 0.15406692187365117,
                "exactly": 0.22084268981657879,
                "file": 0.18414105685229615,
                "files": 0.19691313317799208,
                "folder": 0.25845974690753837,
                "ide": 0.20284145927750158,
                "including": 0.21222284286400767,
                "long": 0.153367749987523,
                "make": 0.12545972739608516,
                "matter": 0.20077613353336432,
                "models": 0.24568767058184243,
                "names": 0.2177796479904046,
                "path": 0.23154944039813746,
                "php": 0.3902015592246961,
                "really": 0.12892094675408658,
                "replace": 0.24045851636846113,
                "run": 0.17102348075021123,
                "simple": 0.17102348075021123,
                "use": 0.2082662822760143,
                "work": 0.11705804548795819
            },
            "Max term": "php",
            "Max score": 0.3902015592246961
        }
    },
    {
        "ID": "8355",
        "Question": "The article \"Promiscuous Pairing and Beginnerâ€™s Mind\" (PDF) suggests that you put someone in the pair that knows the least about the particular area of the code base. It also suggests that you swap out the senior member of the pair every 90 minutes or so.  Not only will the newbies learn about that area of the code but they will also think differently compared to someone who already knows the area. Does anybody have experience with this strategy? Does it have any connection with reality? I found other questions about when to use pair programming and whether to accept a job where pair programming is required, but I didn't find any that are specifically about promiscuous pairing and this \"beginner's mind\" strategy. If you are unfamiliar with pair programming, there are interesting articles on Wikipedia and c2.com. ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "90": 0.1135337923992066,
                    "accept": 0.11149625983358734,
                    "anybody": 0.12115875769785159,
                    "area": 0.37336253175360196,
                    "article": 0.10486579530079769,
                    "articles": 0.1135337923992066,
                    "base": 0.1034860965233462,
                    "beginner": 0.24890835450240129,
                    "code": 0.09319325079176632,
                    "com": 0.1034860965233462,
                    "compared": 0.12835183131233827,
                    "connection": 0.11578618015279173,
                    "differently": 0.12115875769785159,
                    "experience": 0.0763262609699626,
                    "interesting": 0.09310695352362854,
                    "job": 0.07385001869708287,
                    "knows": 0.19743150697214984,
                    "learn": 0.07224189907351747,
                    "member": 0.11830413543647789,
                    "mind": 0.18009551277533203,
                    "minutes": 0.10634071878471991,
                    "pair": 0.510950343691228,
                    "particular": 0.08675233683431696,
                    "pdf": 0.12835183131233827,
                    "programming": 0.16954207350079514,
                    "questions": 0.08556436948783838,
                    "reality": 0.11578618015279173,
                    "required": 0.09767272168631103,
                    "senior": 0.11149625983358734,
                    "specifically": 0.1034860965233462,
                    "strategy": 0.25670366262467653,
                    "suggests": 0.2662443486992191,
                    "think": 0.05651402450026505,
                    "unfamiliar": 0.12835183131233827,
                    "use": 0.05014244794393491,
                    "wikipedia": 0.10963613833806897
                },
                "Max term": "pair",
                "Max score": 0.510950343691228
            }
        ],
        "Best Answer": "I think your question understates (perhaps, confuses) Pair Programming and Promiscuous Pairing. When you do pair programming and one of the programmers knows way more about the task at hand, the other programmer learns very quickly (the languages, the tools, the design or requirements of the product they're working on.  I do have experience with that and highly recommend it for bringing your co-workers or yourself up to speed. The idea of Promiscuous Pairing is when you have N programmers on the team and make all possible pairs out of them and rotate those pairs frequently, then such knowledge spreads throughout the team very quickly. ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "bringing": 0.19915971898523288,
                "design": 0.12214227775809469,
                "experience": 0.12214227775809469,
                "frequently": 0.17017337736366075,
                "hand": 0.15173412779925158,
                "highly": 0.17544692339224222,
                "idea": 0.12336420524401831,
                "knowledge": 0.13341387081605363,
                "knows": 0.15797140889871206,
                "languages": 0.11661247335820427,
                "make": 0.09667472150356529,
                "pair": 0.327062471063731,
                "pairs": 0.39831943797046576,
                "possible": 0.1252830445539346,
                "product": 0.13981843993887483,
                "programmer": 0.11012083917175526,
                "programmers": 0.2283004719941909,
                "programming": 0.18087488080820957,
                "question": 0.10928639944759456,
                "quickly": 0.3063802127283414,
                "recommend": 0.16560522400841698,
                "requirements": 0.14189242841542632,
                "speed": 0.18931801960140765,
                "task": 0.14083971973754847,
                "team": 0.25463187906584644,
                "think": 0.09043744040410479,
                "tools": 0.14083971973754847,
                "way": 0.09367428442588321,
                "workers": 0.21303081519439832,
                "working": 0.11367836185918417
            },
            "Max term": "pairs",
            "Max score": 0.39831943797046576
        }
    },
    {
        "ID": "8364",
        "Question": "Many developers recommend Firefox for web development for a variety of reasons. But, after looking at Opera, it seems to me that Opera has all of the same web development functionality that Firefox has built into it. So what is wrong with Opera for web development? ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "built": 0.21544609192027764,
                    "developers": 0.15388359373388805,
                    "development": 0.4089667448051514,
                    "firefox": 0.5394105388664032,
                    "functionality": 0.1978847464547734,
                    "looking": 0.1594542190716385,
                    "reasons": 0.19033322104974779,
                    "recommend": 0.20966263270399516,
                    "variety": 0.2600405636060779,
                    "web": 0.4783626572149155,
                    "wrong": 0.17453994177298662
                },
                "Max term": "firefox",
                "Max score": 0.5394105388664032
            }
        ],
        "Best Answer": "I think any browser you like to work in is the right browser to work in. I like Chrome--I think its developer interface is very nice indeed. Problem is, a very compliant browser is going to fool you when you switch to a less-compliant one (lookin at you, Internet Explorer). Things will be building nicely, and then your boss will look at it on IE6 and it'll be a calamity. So you've got to at least be looking very frequently at your work the browser that's simultaneously most popular and most breakage-prone. ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "boss": 0.14692573746334903,
                "browser": 0.7213170824821251,
                "building": 0.16594788189268936,
                "developer": 0.10942296405782789,
                "frequently": 0.1582745203077599,
                "going": 0.10242097363179818,
                "got": 0.1273515892208685,
                "interface": 0.15209681008933418,
                "internet": 0.1582745203077599,
                "like": 0.14125767378039372,
                "look": 0.11416501968221714,
                "looking": 0.11714085788082333,
                "nice": 0.14389313157991798,
                "nicely": 0.19813528184029874,
                "popular": 0.1582745203077599,
                "problem": 0.10321647203834032,
                "prone": 0.1852340799445593,
                "right": 0.1136018496015806,
                "switch": 0.1689804877761204,
                "things": 0.09416377403507073,
                "think": 0.1682277535954686,
                "work": 0.2516810406514936
            },
            "Max term": "browser",
            "Max score": 0.7213170824821251
        }
    },
    {
        "ID": "8391",
        "Question": "In a book I'm reading there is a chapter on documentation for your code. The book is about PHP and described some easy methods but also going for some complicated and time consuming methods (xml, xsl) like DocBook. At my current small company (5 people) we even rarely write comments, but I'm wondering if in a big company how detailed documentation do they write? Do they use such tools like DocBook? Is it complex or simple? ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "big": 0.13941452342012214,
                    "book": 0.2879478961146106,
                    "chapter": 0.19906315622084736,
                    "code": 0.07840530076419402,
                    "comments": 0.16610298012962027,
                    "company": 0.2648609552672659,
                    "complex": 0.1643479341091775,
                    "complicated": 0.1764512805504982,
                    "consuming": 0.2239965669099027,
                    "current": 0.1643479341091775,
                    "described": 0.20386645506641018,
                    "detailed": 0.1910363908186756,
                    "documentation": 0.32215112052051487,
                    "easy": 0.1430146563289315,
                    "going": 0.11578930445908243,
                    "like": 0.15969510166286627,
                    "methods": 0.3106156508326303,
                    "people": 0.10018262794716608,
                    "php": 0.15807621472744848,
                    "rarely": 0.16989293568449254,
                    "reading": 0.15033837704693478,
                    "simple": 0.1385681006514799,
                    "small": 0.13386952184480708,
                    "time": 0.08828542137058389,
                    "tools": 0.14808943803259347,
                    "use": 0.084371640192736,
                    "wondering": 0.17412974553179203,
                    "write": 0.22087026510246258,
                    "xml": 0.20386645506641018
                },
                "Max term": "documentation",
                "Max score": 0.32215112052051487
            }
        ],
        "Best Answer": "Working on PHP and NetBeans, the documentation style is pretty much PHPDoc way. Thus I write a little more than what the IDE generates. e.g. IDE generates: /**    * Description for ClassA    *    *    * @author Sam-Mauris Yong    */    class ClassA{      function __construct(){         echo \"5\";     }  }  I'll probably write: /**    * Class A Helper Class  * Some example class used here  *    * @author Sam-Mauris Yong  * @license GNU Public License v3  */    class ClassA{      /**      * Constructor for example class      * echos 5      */     function __construct(){         echo \"5\";     }  }  ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "author": 0.267180754141639,
                "class": 0.6138141478363697,
                "description": 0.13978908454298633,
                "documentation": 0.11044781792912008,
                "example": 0.16392086031008055,
                "function": 0.21298588559100046,
                "generates": 0.2961764438574419,
                "gnu": 0.15359209056196615,
                "ide": 0.22538330053533412,
                "license": 0.2490407821722152,
                "little": 0.09742295681078832,
                "netbeans": 0.14808822192872095,
                "php": 0.10839119823598382,
                "pretty": 0.09618944240485913,
                "probably": 0.08721218264822217,
                "public": 0.12864080474457096,
                "sam": 0.3071841811239323,
                "style": 0.11389506686922903,
                "used": 0.07494932402543984,
                "way": 0.06753778397617452,
                "working": 0.08196043015504027,
                "write": 0.1514484182862856
            },
            "Max term": "class",
            "Max score": 0.6138141478363697
        }
    },
    {
        "ID": "8402",
        "Question": "I've had an argument recently with a fellow programmer. He was interviewing for a new position and was asked this question:  Give a sequence of numbers starting at   X and ending in Y but with one element   missing so N is Y-X-1, find the   missing element in O(N) or better.  Now, the answer is irrelevant here (but interesting). This started a discussion on whether this was even a good question to ask during an interview. One side: Algorithms are an inherit part of programming and a candidates ability to answer this question supports that this candidate will be a good programmer and be able to solve larger problems and can handle most programming tasks which are ultimately easy to understand and answer. Other side: Writing algorithms from scratch is rarely used in modern programming and therefore is irrelevant in the bigger question of whether the person will be a good programmer. A person could successfully answer this question yet still not be able to do more common programmings tasks. Your thoughts? Good interview question or not? ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "ability": 0.09356992821920054,
                    "able": 0.15904863921142348,
                    "algorithms": 0.20159484321553692,
                    "answer": 0.2984054898122509,
                    "argument": 0.1179666671299551,
                    "ask": 0.07805884771791524,
                    "asked": 0.08342245320293637,
                    "better": 0.0630920109283177,
                    "bigger": 0.10975051279125808,
                    "candidate": 0.10975051279125808,
                    "common": 0.0766922493084963,
                    "discussion": 0.1039210585164663,
                    "easy": 0.08056370280984163,
                    "element": 0.25236564293730424,
                    "fellow": 0.11213721285516332,
                    "good": 0.2207132117958319,
                    "handle": 0.09809160424167451,
                    "interesting": 0.08825350210332233,
                    "interview": 0.19879876498798463,
                    "interviewing": 0.11213721285516332,
                    "irrelevant": 0.22968606044251452,
                    "larger": 0.11213721285516332,
                    "missing": 0.2152310736653787,
                    "modern": 0.10079742160776846,
                    "new": 0.05977630120814936,
                    "numbers": 0.1056842161551222,
                    "person": 0.17208147797260198,
                    "position": 0.09809160424167451,
                    "problems": 0.07625645767611743,
                    "programmer": 0.19568096066065932,
                    "programming": 0.16070423501190864,
                    "question": 0.3883963796842356,
                    "rarely": 0.09570490417776926,
                    "recently": 0.09939938249399231,
                    "scratch": 0.11213721285516332,
                    "sequence": 0.12166114544617815,
                    "solve": 0.08987544990297751,
                    "started": 0.08223013697180567,
                    "starting": 0.09356992821920054,
                    "successfully": 0.11484303022125726,
                    "supports": 0.11484303022125726,
                    "tasks": 0.1851625345381429,
                    "thoughts": 0.09809160424167451,
                    "ultimately": 0.11484303022125726,
                    "understand": 0.06907212411194473,
                    "used": 0.061574246031130854,
                    "writing": 0.07031950431688562
                },
                "Max term": "question",
                "Max score": 0.3883963796842356
            }
        ],
        "Best Answer": "I agree with asking a algorithm question, but I disagree with insisting on a specific big-O quality level. Asking this sort of question is interesting to see how the person approaches the problem and what pitfalls they consider in their attempt, but unless they are writing something insanely incorrect or inefficient the actual detail of what they write is not as telling as the fact that they get through the problem solving / design steps in a coherent manner. I ask a similar question, but the people that I have had the best luck with after hire are the folks that gave flawed answers but had the correct idea in their approach. ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "actual": 0.1631116567977789,
                "agree": 0.15873306906670373,
                "algorithm": 0.16084933230099285,
                "answers": 0.14409900292166894,
                "approach": 0.14281292831373113,
                "approaches": 0.17414481670242962,
                "ask": 0.12631581022518337,
                "asking": 0.2881980058433379,
                "attempt": 0.19089514608175354,
                "best": 0.10764041756561787,
                "big": 0.12708739168809885,
                "consider": 0.1321421002638302,
                "correct": 0.14981617239634215,
                "design": 0.1170737138724244,
                "disagree": 0.18584043750602217,
                "fact": 0.13812055159274958,
                "folks": 0.19089514608175354,
                "hire": 0.17759966168031677,
                "idea": 0.11824493477550267,
                "inefficient": 0.2041906304831903,
                "interesting": 0.14281292831373113,
                "level": 0.12482506719131282,
                "manner": 0.18146184977494703,
                "people": 0.09132440843266498,
                "person": 0.13923220717660878,
                "problem": 0.21274188328302746,
                "quality": 0.145437584665267,
                "question": 0.31425395597456596,
                "similar": 0.1330658430170182,
                "solving": 0.16816636537351026,
                "sort": 0.14981617239634215,
                "specific": 0.1330658430170182,
                "steps": 0.16816636537351026,
                "telling": 0.18584043750602217,
                "unless": 0.15141603599418635,
                "write": 0.10067037925719968,
                "writing": 0.11379190728666208
            },
            "Max term": "question",
            "Max score": 0.31425395597456596
        }
    },
    {
        "ID": "8415",
        "Question": "I'm looking for something that allows me to work out an algorithm on a computer similar to how I would do it on a whiteboard. At work, I have a huge whiteboard that I can use for this, but at home, I don't (and can't). This makes it difficult to design algorithms when I'm working on hobby projects. I think better when I use drawings as opposed to text, so pseudocode is no good. I guess what I'm looking for is something like a flowchart program, but that allows a less rigid approach to designing algorithms.  I'd like the program to be cross-platform (Mac, Linux), but I'll be happy even if it just runs on Macs. Free is preferred, but reasonably priced programs are good too. I would prefer programs that people have used and had experiences with, rather than whatever turned up on Google, as I know of some flowchart and mind-mapping software, but haven't really been satisfied with either. I realise that a computer isn't the best platform for doing this kind of stuff, but assume for a moment that it's the only medium I possess. ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "algorithm": 0.12526087577134323,
                    "algorithms": 0.25404530670692055,
                    "allows": 0.2472256858108909,
                    "approach": 0.11121508691483455,
                    "assume": 0.1331808824023495,
                    "best": 0.08382461263458504,
                    "better": 0.07950713922728733,
                    "computer": 0.2017225464357079,
                    "cross": 0.14472261477699794,
                    "design": 0.09117076036114212,
                    "designing": 0.1383051383585596,
                    "difficult": 0.11548092097881182,
                    "experiences": 0.1289150483383722,
                    "free": 0.10152457405812271,
                    "good": 0.1390689233181244,
                    "google": 0.11434581648040441,
                    "guess": 0.1289150483383722,
                    "happy": 0.1331808824023495,
                    "home": 0.1289150483383722,
                    "huge": 0.1166688396564797,
                    "kind": 0.1067236050211158,
                    "know": 0.06934318251321706,
                    "like": 0.11336584369507907,
                    "linux": 0.13561468946832383,
                    "looking": 0.18802195773760638,
                    "mac": 0.14472261477699794,
                    "makes": 0.08943886651159855,
                    "medium": 0.1383051383585596,
                    "mind": 0.10756091434780557,
                    "moment": 0.13095899063200253,
                    "opposed": 0.1590127657525208,
                    "people": 0.07111857547639226,
                    "platform": 0.25404530670692055,
                    "prefer": 0.11548092097881182,
                    "preferred": 0.14472261477699794,
                    "program": 0.19441420130165,
                    "programs": 0.2205027264760827,
                    "projects": 0.09255140181450369,
                    "realise": 0.1590127657525208,
                    "really": 0.074151789869727,
                    "reasonably": 0.14472261477699794,
                    "runs": 0.1383051383585596,
                    "satisfied": 0.1533146508918615,
                    "similar": 0.10362457706926331,
                    "software": 0.07508898300224309,
                    "stuff": 0.1002147666212485,
                    "text": 0.12526087577134323,
                    "think": 0.06750529266440895,
                    "turned": 0.13561468946832383,
                    "use": 0.11978904894127092,
                    "used": 0.07759448589417313,
                    "work": 0.13465714936364873,
                    "working": 0.08485303268895376
                },
                "Max term": "algorithms",
                "Max score": 0.25404530670692055
            }
        ],
        "Best Answer": "If I have to brainstorm some design stuff that takes more complexity than Notepad can cope with, I usually just use a pencil/pen and paper. ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "complexity": 0.34100168303375017,
                "cope": 0.40714267519002767,
                "design": 0.23343727842779122,
                "notepad": 0.39255299292816753,
                "paper": 0.33531266206061844,
                "pen": 0.40714267519002767,
                "stuff": 0.2565939154798494,
                "takes": 0.26721980867257455,
                "use": 0.1533563472517773,
                "usually": 0.2653245311705185
            },
            "Max term": "cope",
            "Max score": 0.40714267519002767
        }
    },
    {
        "ID": "8429",
        "Question": "Which way is more beneficial and productive? ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "beneficial": 0.7309536211995338,
                    "productive": 0.6019953679698862,
                    "way": 0.32141621085142846
                },
                "Max term": "beneficial",
                "Max score": 0.7309536211995338
            }
        ],
        "Best Answer": "I think you need both. You have to focus on your core competencies and improve your understanding of them, but at the same time it's beneficial to look outside and see what else is out there. Exposure to other approaches and other languages is very important to make one a better developer overall. There are many ways to skin a cat, as it were, and knowing as many of them as possible will make you  a psychopath better at picking the right tool for a particular task. So, spend most of your time getting better at your chosen proficiency and spend some of your time on learning something new. ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "approaches": 0.19095990665956225,
                "beneficial": 0.223906886671541,
                "better": 0.33586352507538425,
                "core": 0.1875328474525698,
                "developer": 0.12365569112677338,
                "exposure": 0.20932761576145476,
                "focus": 0.1815260993792163,
                "getting": 0.13608764310892435,
                "important": 0.14295739836000046,
                "improve": 0.18440418752099055,
                "knowing": 0.1875328474525698,
                "languages": 0.12256600451383952,
                "learning": 0.1376859909716414,
                "look": 0.12901454948566013,
                "make": 0.20322070205616685,
                "need": 0.10539878921988971,
                "new": 0.1060709004956122,
                "outside": 0.17188015634300263,
                "overall": 0.19474834485136852,
                "particular": 0.1459144259546098,
                "picking": 0.223906886671541,
                "possible": 0.1316792428982879,
                "right": 0.12837812744991423,
                "spend": 0.31320534227750424,
                "task": 0.14803014830201935,
                "think": 0.09505463188951173,
                "time": 0.2647502251075615,
                "tool": 0.15660267113875212,
                "understanding": 0.17886140596658853,
                "ways": 0.1502781869213696
            },
            "Max term": "better",
            "Max score": 0.33586352507538425
        }
    },
    {
        "ID": "8445",
        "Question": "After 15 years of C++, I've still haven't learn to love using const. I understand it's use, but I've never actually been in situation where being const correct would have avoided the problem I was facing. So how did you come to love benefits of consts? ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "15": 0.22745319868116629,
                    "actually": 0.14931260116566808,
                    "avoided": 0.25388744651406703,
                    "benefits": 0.22365853700621208,
                    "come": 0.1808834964902906,
                    "const": 0.5431404500277107,
                    "correct": 0.19925307812661153,
                    "facing": 0.27157022501385536,
                    "learn": 0.14737401099909928,
                    "love": 0.46321956051522845,
                    "problem": 0.14147162623556156,
                    "situation": 0.19925307812661153,
                    "understand": 0.1486567828246403,
                    "use": 0.102290966455506,
                    "using": 0.12743321254340131,
                    "years": 0.15970996763489612
                },
                "Max term": "const",
                "Max score": 0.5431404500277107
            }
        ],
        "Best Answer": "Well I wasn't convinced until I tried to embrace the philosophy. I first started by putting const to really read-only members of my most basic class members and member functions arguments. From there, I couldn't compile anymore. Then I persevered in going in the code using those basic classes, see if the previously const additions were really legitimate compared to the use I made of them. It helped me fix some bugs on the way as I added constness to other parts of the code. It's contagious. Most of the code got even more constness and I found easier to debug it because it makes you confident that the compiler will stop you if you start modifying something you shouldn't.  Once I got the application running again, it was faster (had to change some algorithms that I've discovered weren't right for the job), with a lot less bugs and easier to understand when reading the code. I was convinced.  Now, I think that it's even better when you're using a lot of assertions in addition to constness because it makes you feel confident when you have to write new code or modify the current code. You know the compiler will stop you if necessary. It lets you forget about having to check everything you shouldn't modify and then you have more thinking time for more business-specific thinking, or architectural thinking. ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "added": 0.10024202768266585,
                "addition": 0.10988230021277233,
                "algorithms": 0.09877053530912877,
                "anymore": 0.11559453282842187,
                "application": 0.07089274682644628,
                "arguments": 0.10355906368305953,
                "basic": 0.17782650898815094,
                "better": 0.0618233243839153,
                "bugs": 0.1672748727569026,
                "business": 0.08057661116425097,
                "change": 0.07648920033603371,
                "check": 0.0836374363784513,
                "class": 0.08235595560258677,
                "classes": 0.1018313605233291,
                "code": 0.2596770279464185,
                "compared": 0.11921472067808007,
                "compile": 0.10754359313897864,
                "compiler": 0.2036627210466582,
                "confident": 0.21508718627795728,
                "const": 0.2472909450357302,
                "convinced": 0.23842944135616015,
                "current": 0.09071959561968555,
                "debug": 0.09740060868354407,
                "easier": 0.16003449705758616,
                "embrace": 0.1236454725178651,
                "faster": 0.09270685882098229,
                "feel": 0.07430501591314355,
                "fix": 0.08806818821823634,
                "forget": 0.10988230021277233,
                "functions": 0.09740060868354407,
                "going": 0.06391536914990664,
                "got": 0.1589464256831079,
                "helped": 0.11253370761422155,
                "job": 0.068592783297494,
                "know": 0.05392001407662681,
                "lets": 0.11559453282842187,
                "lot": 0.12686210196532452,
                "makes": 0.13909211450985096,
                "member": 0.10988230021277233,
                "members": 0.19754107061825754,
                "modify": 0.2109030967459746,
                "necessary": 0.08572948114444265,
                "new": 0.058574288656939234,
                "parts": 0.1018313605233291,
                "previously": 0.1236454725178651,
                "putting": 0.11921472067808007,
                "read": 0.07430501591314355,
                "reading": 0.08298635967494121,
                "really": 0.11531820169403588,
                "right": 0.07089274682644628,
                "running": 0.09071959561968555,
                "specific": 0.08057661116425097,
                "start": 0.06890548362514953,
                "started": 0.08057661116425097,
                "stop": 0.2036627210466582,
                "think": 0.05249090391860754,
                "thinking": 0.23377561128840524,
                "time": 0.04873330333761503,
                "tried": 0.09270685882098229,
                "understand": 0.06768318638171959,
                "use": 0.04657290717734186,
                "using": 0.11604026014703563,
                "way": 0.05436960446328792,
                "write": 0.06095988137337113
            },
            "Max term": "code",
            "Max score": 0.2596770279464185
        }
    },
    {
        "ID": "8454",
        "Question": "I was having a chat with a coworker who is working on a polling app and framework. He was asking technical questions and I suggested he open source the application to get more quality opinions from developers who are interested in this problem and are willing to give it heavy though.  He has a different point of view which I think is still valid so I want to open this question for discussion here. He says he believes something like a polling framework should not be open sourced because it will reduce its security and validity as people reveal loopholes through which they can cheat. Can't say I completely disagree. I see a somewhat valid point there, but I always believed that solutions by a group of people are almost always better than a solution thought by a single person asking a small number of coworkers, no matter how smart that person is. Again I'm willing to accept that maybe some types of applications are different.  Does anyone have an argument in his favor? I'd really like to present your responses to him.  ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "accept": 0.12313137653030325,
                    "app": 0.09580531820146429,
                    "application": 0.08429123625016464,
                    "applications": 0.10282306661244431,
                    "argument": 0.13744150864574914,
                    "asking": 0.2074980402845921,
                    "believes": 0.14701404871194287,
                    "better": 0.07350772363458716,
                    "completely": 0.10901716909704705,
                    "coworker": 0.14174589975719187,
                    "coworkers": 0.14174589975719187,
                    "developers": 0.08388063827119899,
                    "different": 0.15821214164190525,
                    "disagree": 0.13380219781636013,
                    "discussion": 0.12107714331567672,
                    "favor": 0.14174589975719187,
                    "framework": 0.19297935766939797,
                    "group": 0.11918743194251669,
                    "heavy": 0.14174589975719187,
                    "interested": 0.10901716909704705,
                    "like": 0.10481153251052518,
                    "matter": 0.10676701120023083,
                    "maybe": 0.09867050103202007,
                    "number": 0.0920698410936556,
                    "open": 0.27450278127006467,
                    "opinions": 0.13744150864574914,
                    "people": 0.13150428105480041,
                    "person": 0.20049000720254279,
                    "point": 0.1685824725003293,
                    "present": 0.13744150864574914,
                    "problem": 0.07658540824824042,
                    "quality": 0.10471277798560434,
                    "question": 0.07541930512390956,
                    "questions": 0.09449338132696031,
                    "really": 0.06855647593069414,
                    "reduce": 0.12313137653030325,
                    "responses": 0.14701404871194287,
                    "reveal": 0.14174589975719187,
                    "say": 0.07658540824824042,
                    "says": 0.11285404416477139,
                    "security": 0.10786529242009398,
                    "single": 0.09648967883469899,
                    "small": 0.08786161626063253,
                    "smart": 0.12786896857955538,
                    "solution": 0.10024500360127139,
                    "solutions": 0.11580899436092572,
                    "somewhat": 0.11918743194251669,
                    "source": 0.08738465481222363,
                    "suggested": 0.14174589975719187,
                    "technical": 0.09386377631635838,
                    "think": 0.06241150725926577,
                    "thought": 0.10193206318328925,
                    "types": 0.10786529242009398,
                    "valid": 0.26760439563272026,
                    "view": 0.12107714331567672,
                    "want": 0.06942295074599705,
                    "willing": 0.23487566497257542,
                    "working": 0.0784502289615208
                },
                "Max term": "open",
                "Max score": 0.27450278127006467
            }
        ],
        "Best Answer": "In fact, being open source helps you to be more secure.  I personally believe that when a program began as closed source and is then first made open source, it often starts less secure for any users (through exposure of vulnerabilities), and over time (say a few years) it has the potential to be much more secure than a closed program. If the program began as open source software, the public scrutiny is more likely to improve its security before it's ready for use by significant numbers of users, but there are several caveats to this statement (it's not an ironclad rule). Just making a program open source doesn't suddenly make a program secure, and just because a program is open source does not guarantee security:  First, people have to actually review the code. This is one of the key points of debate - will people really review code in an open source project? All sorts of factors can reduce the amount of review: being a niche or rarely-used product (where there are few potential reviewers), having few developers, and use of a rarely-used computer language. Clearly, a program that has a single developer and no other contributors of any kind doesn't have this kind of review. On the other hand, a program that has a primary author and many other people who occasionally examine the code and contribute suggests that there are others reviewing the code (at least to create contributions). In general, if there are more reviewers, there's generally a higher likelihood that someone will identify a flaw - this is the basis of the \"many eyeballs\" theory. Note that, for example, the OpenBSD project continuously examines programs for security flaws, so the components in its innermost parts have certainly undergone a lengthy review. Since OSS/FS discussions are often held publicly, this level of review is something that potential users can judge for themselves.   Â    One factor that can particularly reduce review likelihood is not actually being open source. Some vendors like to posture their \"disclosed source\" (also called \"source available\") programs as being open source, but since the program owner has extensive exclusive rights, others will have far less incentive to work \"for free\" for the owner on the code. Even open source licenses which have unusually asymmetric rights (such as the MPL) have this problem. After all, people are less likely to voluntarily participate if someone else will have rights to their results that they don't have (as Bruce Perens says, \"who wants to be someone else's unpaid employee?\"). In particular, since the reviewers with the most incentive tend to be people trying to modify the program, this disincentive to participate reduces the number of \"eyeballs\". Elias Levy made this mistake in his article about open source security; his examples of software that had been broken into (e.g., TIS's Gauntlet) were not, at the time, open source. Second, at least some of the people developing and reviewing the code must know how to write secure programs. Hopefully the existence of this book will help. Clearly, it doesn't matter if there are \"many eyeballs\" if none of the eyeballs know what to look for. Note that it's not necessary for everyone to know how to write secure programs, as long as those who do know how are examining the code changes. Third, once found, these problems need to be fixed quickly and their fixes distributed. Open source systems tend to fix the problems quickly, but the distribution is not always smooth. For example, the OpenBSD developers do an excellent job of reviewing code for security flaws - but they don't always report the identified problems back to the original developer. Thus, it's quite possible for there to be a fixed version in one system, but for the flaw to remain in another. I believe this problem is lessening over time, since no one \"downstream\" likes to repeatedly fix the same problem. Of course, ensuring that security patches are actually installed on end-user systems is a problem for both open source and closed source software.  Another advantage of open source is that, if you find a problem, you can fix it immediately. This really doesn't have any counterpart in closed source. In short, the effect on security of open source software is still a major debate in the security community, though a large number of prominent experts believe that it has great potential to be more secure.  Look at Linux... ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "actually": 0.06903870512088142,
                "advantage": 0.03505637208995984,
                "article": 0.03297163819720253,
                "author": 0.03640519798932876,
                "available": 0.02902077793283876,
                "basis": 0.039130567719309395,
                "believe": 0.08943740119887202,
                "book": 0.0269029326982399,
                "broken": 0.039130567719309395,
                "called": 0.03297163819720253,
                "caveats": 0.04185593744929003,
                "certainly": 0.032537836796271306,
                "changes": 0.027878786469761937,
                "clearly": 0.06594327639440506,
                "closed": 0.15237772094427446,
                "code": 0.11720634507041797,
                "community": 0.037196887122780666,
                "components": 0.039130567719309395,
                "computer": 0.026549083168785282,
                "continuously": 0.04185593744929003,
                "contribute": 0.04035605825369253,
                "course": 0.029538078405076298,
                "create": 0.0269029326982399,
                "debate": 0.07826113543861879,
                "developer": 0.04623104675331811,
                "developers": 0.047762819668547986,
                "developing": 0.030098535293955998,
                "discussions": 0.04035605825369253,
                "distributed": 0.037196887122780666,
                "effect": 0.03640519798932876,
                "employee": 0.04035605825369253,
                "end": 0.023325590123088605,
                "example": 0.04467066794044627,
                "examples": 0.030710010179578612,
                "excellent": 0.038094430236068615,
                "exposure": 0.039130567719309395,
                "fact": 0.02831258787069316,
                "factor": 0.037196887122780666,
                "factors": 0.03343537990955925,
                "far": 0.02831258787069316,
                "fix": 0.08943740119887202,
                "fixed": 0.06786700645055056,
                "fixes": 0.039130567719309395,
                "flaws": 0.08371187489858006,
                "free": 0.026723679707301946,
                "general": 0.029538078405076298,
                "generally": 0.02877632958304988,
                "great": 0.025892797525187698,
                "hand": 0.02981246706629067,
                "held": 0.039130567719309395,
                "help": 0.022714115237465995,
                "helps": 0.032537836796271306,
                "higher": 0.03393350322527528,
                "hopefully": 0.037196887122780666,
                "identify": 0.039130567719309395,
                "immediately": 0.03640519798932876,
                "improve": 0.03447151739280003,
                "installed": 0.04035605825369253,
                "job": 0.023219736143252574,
                "judge": 0.04185593744929003,
                "key": 0.03213034301718647,
                "kind": 0.056184376329618604,
                "know": 0.07301109180944874,
                "language": 0.019702677279820027,
                "large": 0.02831258787069316,
                "lengthy": 0.04185593744929003,
                "level": 0.025587218140712527,
                "licenses": 0.035697007927183166,
                "like": 0.014920291588324877,
                "likely": 0.05662517574138632,
                "likes": 0.039130567719309395,
                "linux": 0.035697007927183166,
                "long": 0.023219736143252574,
                "look": 0.04823455851308103,
                "major": 0.032537836796271306,
                "make": 0.01899448721767443,
                "making": 0.028092188164809302,
                "matter": 0.030397321763450478,
                "mistake": 0.03505637208995984,
                "modify": 0.035697007927183166,
                "necessary": 0.02902077793283876,
                "need": 0.019702677279820027,
                "niche": 0.039130567719309395,
                "note": 0.06276546006762262,
                "number": 0.05242586737180396,
                "numbers": 0.03505637208995984,
                "occasionally": 0.035697007927183166,
                "open": 0.39076439779603866,
                "original": 0.032537836796271306,
                "oss": 0.04185593744929003,
                "owner": 0.07618886047213723,
                "particular": 0.027276450387452376,
                "particularly": 0.03393350322527528,
                "parts": 0.03447151739280003,
                "people": 0.11232059133876036,
                "personally": 0.0310379576006738,
                "points": 0.030397321763450478,
                "possible": 0.024615402572256556,
                "potential": 0.13573401290110113,
                "primary": 0.03343537990955925,
                "problem": 0.10902203174635393,
                "problems": 0.07588478729782437,
                "product": 0.027471292690677107,
                "program": 0.25587218140712525,
                "programs": 0.11608311173135503,
                "project": 0.03953040827632879,
                "public": 0.03505637208995984,
                "quickly": 0.060197070587911995,
                "quite": 0.026723679707301946,
                "rarely": 0.06349229532563878,
                "ready": 0.03640519798932876,
                "really": 0.03903702528349978,
                "reduce": 0.07011274417991968,
                "reduces": 0.04185593744929003,
                "repeatedly": 0.04185593744929003,
                "report": 0.035697007927183166,
                "results": 0.03343537990955925,
                "review": 0.22776485757389914,
                "rights": 0.111590661368342,
                "rule": 0.03343537990955925,
                "say": 0.021804406349270784,
                "says": 0.03213034301718647,
                "second": 0.0310379576006738,
                "secure": 0.2666610116524803,
                "security": 0.2456800814366289,
                "short": 0.030098535293955998,
                "significant": 0.039130567719309395,
                "single": 0.027471292690677107,
                "software": 0.07906081655265758,
                "sorts": 0.039130567719309395,
                "source": 0.49758056157133856,
                "starts": 0.038094430236068615,
                "statement": 0.037196887122780666,
                "suddenly": 0.037196887122780666,
                "suggests": 0.04185593744929003,
                "systems": 0.05804155586567752,
                "tend": 0.06349229532563878,
                "theory": 0.03640519798932876,
                "time": 0.049490969333351974,
                "trying": 0.025892797525187698,
                "unpaid": 0.04185593744929003,
                "unusually": 0.04185593744929003,
                "use": 0.03153132338694822,
                "used": 0.040849424039966956,
                "user": 0.025294929099274787,
                "users": 0.08126129200893008,
                "vendors": 0.04035605825369253,
                "version": 0.030098535293955998,
                "wants": 0.032537836796271306,
                "work": 0.017722480312167128,
                "write": 0.04127175754553084,
                "years": 0.024615402572256556
            },
            "Max term": "source",
            "Max score": 0.49758056157133856
        }
    },
    {
        "ID": "8544",
        "Question": "For someone with .Net experience and wanting to develop for iPhone/iPod/iPad, is it worth learning Objective-C? Is MonoTouch a good alternative? What are some of the trade-offs when using MonoTouch vs coding in Objective-C? ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "alternative": 0.2950799849993581,
                    "coding": 0.188537842570136,
                    "develop": 0.24622168067414554,
                    "experience": 0.19037670880209245,
                    "good": 0.14519723106992538,
                    "iphone": 0.3022001240457,
                    "learning": 0.20417968644668227,
                    "net": 0.2029813925077807,
                    "objective": 0.5901599699987162,
                    "using": 0.15580834291421583,
                    "vs": 0.25812010456851237,
                    "wanting": 0.3104197213470214,
                    "worth": 0.22285312302905935
                },
                "Max term": "objective",
                "Max score": 0.5901599699987162
            }
        ],
        "Best Answer": "MonoTouch is a fantastic alternative. I've been using it for pretty much one year now, and I can't ever imagine going back to objective-c. Highlights: LINQ, LINQ to XML, LINQ, C#, LINQ, Garbage collector, LINQ, MonoTouch.Dialog, and a lot of other things. Seriously, though.. nowadays most apps are always downloading data from the web, and you'll need to be converting that to objects, keeping them in lists, sorting and filtering them, and pushing them to databases. That stuff is so simple to do with C# and LINQ that I can't imagine people doing that in other languages.  The $400 dollar cost is not low, but you can probably make that money back in 1 month or so with no advertisement. And the amount of time MT will save you will offset that easily. Also remember, you don't have to pay until the app is ready for testing in a device, so its free for learning. With that said, yes, its still totally worthy to learn Objective-C. It'll make you a better developer for the platform, you'll understand why some things are the way they are, and so on. You'll also be able to read Obj-C examples in the web and translate them to C#.  Finally, here's my suggestion: if you're thinking of getting in iOS development, go to MonoTouch. Spend a few weeks using it, and then make the decision of jumping to Obj-C. The hardest part of going to iOS development is not the Obj-C language, is all the new frameworks you'll have to learn. Being able to learn them in C# is a HUGE deal, you'll be a lot more productive from the start up. Just after you know those things look into Obj-C: everything will be already familiar, so it'll be easy to understand everything. ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "able": 0.13183909620762224,
                "alternative": 0.09295312973042176,
                "app": 0.06816246271042092,
                "apps": 0.08239444748837854,
                "better": 0.05229842732356683,
                "cost": 0.07596136160557733,
                "data": 0.06394115721091162,
                "databases": 0.0977852992276444,
                "deal": 0.08239444748837854,
                "decision": 0.0977852992276444,
                "developer": 0.05776451766312648,
                "development": 0.10573573718172888,
                "dialog": 0.10459585961776655,
                "easily": 0.07842384677241228,
                "easy": 0.06678111688506748,
                "examples": 0.07674275405956463,
                "familiar": 0.08239444748837854,
                "finally": 0.08920500787850069,
                "frameworks": 0.07933200895017745,
                "free": 0.06678111688506748,
                "getting": 0.06357197952207051,
                "going": 0.10813631656517675,
                "huge": 0.07674275405956463,
                "imagine": 0.19039208867406313,
                "ios": 0.2091917192355331,
                "keeping": 0.08614256934029961,
                "know": 0.04561275158806949,
                "language": 0.04923598878536574,
                "languages": 0.057255481475414274,
                "learn": 0.17028425739584505,
                "learning": 0.06431863171823253,
                "linq": 0.605086426595073,
                "lists": 0.09097473883752223,
                "look": 0.06026785467499721,
                "lot": 0.10731691454422354,
                "low": 0.08239444748837854,
                "make": 0.14239877347903257,
                "money": 0.07381415613923485,
                "month": 0.08239444748837854,
                "need": 0.04923598878536574,
                "new": 0.04954995883643484,
                "nowadays": 0.09519604433703156,
                "objective": 0.18590625946084352,
                "objects": 0.08614256934029961,
                "pay": 0.08760409149292211,
                "people": 0.04678057451262422,
                "platform": 0.08355331444968678,
                "pretty": 0.06550478854528519,
                "probably": 0.05939129534506994,
                "productive": 0.08614256934029961,
                "read": 0.06285710956561004,
                "ready": 0.09097473883752223,
                "remember": 0.07315536940239234,
                "said": 0.06634480901227018,
                "save": 0.09097473883752223,
                "seriously": 0.08355331444968678,
                "simple": 0.06470478455624039,
                "sorting": 0.10084773776584549,
                "spend": 0.07315536940239234,
                "start": 0.058289463782097685,
                "stuff": 0.06591954810381112,
                "suggestion": 0.0977852992276444,
                "testing": 0.06151263951504754,
                "things": 0.14912751729886198,
                "thinking": 0.06591954810381112,
                "time": 0.041225138703519654,
                "totally": 0.09097473883752223,
                "translate": 0.09519604433703156,
                "understand": 0.11451096295082855,
                "using": 0.09816235494263462,
                "way": 0.045993075202117775,
                "web": 0.12367760665950524,
                "weeks": 0.08029209360721956,
                "xml": 0.09519604433703156,
                "year": 0.07596136160557733,
                "yes": 0.06816246271042092
            },
            "Max term": "linq",
            "Max score": 0.605086426595073
        }
    },
    {
        "ID": "8560",
        "Question": "I'm currently working on throwing together some basic prototypes, partly to gather requirements and partly to design the final UI.  At the moment I'm trying building up the screen using Post-it notes, with yellow notes for information and pink for actions (buttons or menus). The idea being that you can easily move, remove and add information. But I'm sure there are more efficient methods out there.  What is the recommended way for developers to efficiently create non-interactive UI prototypes? And why?  I tried some pen, paper and Post-it note versions and they went down like a lead balloon (likely my drawing skills). In the end I used Balsamiq, which thus far is liked by most users and they get it is prototype. Alas, some people are still having problems with the idea that first one should get an idea of what the application should do via some lo-fi prototypes and really want to \"see something on the screen\" before committing to anything. ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "add": 0.10790468210596488,
                    "application": 0.09217971893079976,
                    "basic": 0.11561124621890176,
                    "building": 0.1346547539822523,
                    "create": 0.10333664232529358,
                    "currently": 0.11921965382228734,
                    "design": 0.09217971893079976,
                    "developers": 0.09173069471454223,
                    "easily": 0.12054395649242276,
                    "efficient": 0.15030411463879192,
                    "end": 0.08959574001141167,
                    "far": 0.10875125767566142,
                    "final": 0.14632421513465765,
                    "idea": 0.27930569105736536,
                    "information": 0.21416997308085328,
                    "interactive": 0.16077251078541785,
                    "lead": 0.12498082795542372,
                    "like": 0.05731021418912764,
                    "liked": 0.1550113366522815,
                    "likely": 0.10875125767566142,
                    "methods": 0.11147148093054303,
                    "moment": 0.13240827322379486,
                    "non": 0.09505136925707958,
                    "note": 0.12054395649242276,
                    "notes": 0.2926484302693153,
                    "paper": 0.13240827322379486,
                    "pen": 0.16077251078541785,
                    "people": 0.07190562272602047,
                    "post": 0.24108791298484553,
                    "problems": 0.09716015240027831,
                    "prototype": 0.1550113366522815,
                    "really": 0.07497240476367056,
                    "recommended": 0.1550113366522815,
                    "remove": 0.13711549523728442,
                    "requirements": 0.10708498654042664,
                    "screen": 0.26068342250760507,
                    "skills": 0.11147148093054303,
                    "sure": 0.09455002842380841,
                    "throwing": 0.1550113366522815,
                    "tried": 0.12054395649242276,
                    "trying": 0.09945662008947527,
                    "ui": 0.2693095079645046,
                    "used": 0.07845320003882858,
                    "users": 0.10404403566217185,
                    "using": 0.07544184027173509,
                    "versions": 0.1346547539822523,
                    "want": 0.07591996952233886,
                    "way": 0.07069517097530509,
                    "went": 0.12341560681870258,
                    "working": 0.085792074923041
                },
                "Max term": "notes",
                "Max score": 0.2926484302693153
            }
        ],
        "Best Answer": "I prefer a whiteboard. It makes it easy to change as you make decisions without redrawing the whole thing.  It's easy to share with other (nearby) developers.  It's easy to annotate using sticky-notes or other colors. ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "change": 0.2165377856501839,
                "decisions": 0.304451496641,
                "developers": 0.1997168362625865,
                "easy": 0.6704590057464603,
                "make": 0.1588481969812232,
                "makes": 0.19688203265981957,
                "notes": 0.31857830583580066,
                "prefer": 0.25420848164246385,
                "share": 0.272109304638012,
                "thing": 0.1997168362625865,
                "using": 0.1642526060419089
            },
            "Max term": "easy",
            "Max score": 0.6704590057464603
        }
    },
    {
        "ID": "8564",
        "Question": "Obviously the size of the project you're working on will be a huge factor in how long you spend writing the design document/specification.  But do you go through everything, picking out every tiny detail? Or do you take a more agile approach and start writing the software quite early on and solve the problems as they come to you? I've always found that there's only so far you can go with designing.  There will inevitably be some things that are missed, and at that point how well you can adapt to the situation means more than the specification itself. Am I taking the right viewpoint on this? Is it actually an opinion, or is a perfect design spec always the best route to go? ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "actually": 0.11070205533849198,
                    "adapt": 0.20134524375751822,
                    "agile": 0.1447870312986773,
                    "approach": 0.14082283694902623,
                    "best": 0.10614045346558917,
                    "come": 0.13410907506775316,
                    "design": 0.2308845944739054,
                    "designing": 0.17512481884040187,
                    "document": 0.16863638025689348,
                    "early": 0.15456090918154353,
                    "factor": 0.17893318752759652,
                    "far": 0.13619584827450956,
                    "huge": 0.14772849115837933,
                    "inevitably": 0.18823503129896005,
                    "long": 0.1116970188378315,
                    "means": 0.13030070638055852,
                    "missed": 0.17512481884040187,
                    "obviously": 0.15860790450443124,
                    "opinion": 0.1447870312986773,
                    "perfect": 0.17893318752759652,
                    "picking": 0.20134524375751822,
                    "point": 0.1154422972369527,
                    "problems": 0.12167959853946626,
                    "project": 0.09507921904597841,
                    "quite": 0.12855250969551085,
                    "right": 0.1154422972369527,
                    "situation": 0.14772849115837933,
                    "size": 0.17171811696298941,
                    "software": 0.09507921904597841,
                    "solve": 0.14341091883911672,
                    "spec": 0.18325075984685915,
                    "specification": 0.3764700625979201,
                    "spend": 0.14082283694902623,
                    "start": 0.11220622246989947,
                    "taking": 0.16582297506903837,
                    "things": 0.09568930813392883,
                    "working": 0.10744266015039246,
                    "writing": 0.22441244493979895
                },
                "Max term": "specification",
                "Max score": 0.3764700625979201
            }
        ],
        "Best Answer": "It depends a bit on your target audience, but my experience ( more in small/medium scale development than very large scale work ) is that detailed design documents are arduous and boring to write, rarely read and tend to end up out of date by the time a project is delivered. This does not mean that they are worthless - if you are delivering something for someone, there needs to be an authoritative and agreed statement of what will be delivered sufficiently detailed that everyone can point to it in case anyone is dissatisfied with the deal and say \"this is what we promised\" and evaluate it against what was delivered. If I were setting up a company to build a product, however, I wouldn't worry so much about a detailed specification. I would want to document what we were going to do, but I wouldn't want to go into too much depth regarding how - that is the part that is most likely to change and leave the documents out of date and useless or even inaccurate enough to be actually obstructive. I would prefer to document the \"how\" stuff in code using whatever documentation format the language or IDE supports best, so that as the code changes it is easier to update the documentation at the same time. It won't stop it going out of date, but it will reduce it somewhat. Ideally you would want a design document that could double as your manual when your code is complete, but I don't know of anyone who has managed that successfully.  ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "actually": 0.06332381557992939,
                "agreed": 0.10767424661819254,
                "audience": 0.1151735534142676,
                "best": 0.06071448700996273,
                "bit": 0.07614396522512838,
                "boring": 0.10767424661819254,
                "build": 0.07614396522512838,
                "case": 0.07505567685485333,
                "change": 0.07124832653491565,
                "changes": 0.0767131044786706,
                "code": 0.12094226112615568,
                "company": 0.0680925109693719,
                "complete": 0.07985548338084344,
                "date": 0.2801209852951764,
                "deal": 0.09072693062154373,
                "delivered": 0.3144694274901034,
                "depends": 0.08841196741064596,
                "depth": 0.11104638706281779,
                "design": 0.1320706597181734,
                "detailed": 0.29467871225285636,
                "development": 0.05821435293232331,
                "document": 0.28939026499920734,
                "documentation": 0.1656422229973712,
                "documents": 0.20964628499340227,
                "double": 0.10767424661819254,
                "easier": 0.07453464053171947,
                "end": 0.06418422961415303,
                "evaluate": 0.10767424661819254,
                "experience": 0.0660353298590867,
                "format": 0.10017493982211749,
                "going": 0.11907205387913879,
                "ide": 0.0845036860554271,
                "ideally": 0.1023534037690686,
                "know": 0.05022553187667389,
                "language": 0.054215184090445435,
                "large": 0.07790678097634472,
                "leave": 0.09072693062154373,
                "likely": 0.07790678097634472,
                "managed": 0.09072693062154373,
                "manual": 0.10767424661819254,
                "mean": 0.0767131044786706,
                "medium": 0.10017493982211749,
                "needs": 0.0828211114986856,
                "point": 0.0660353298590867,
                "prefer": 0.08364327202120345,
                "product": 0.07559181776544696,
                "project": 0.05438723711083415,
                "promised": 0.1151735534142676,
                "rarely": 0.08735479017691848,
                "read": 0.06921379768259554,
                "reduce": 0.09646342166640245,
                "regarding": 0.11104638706281779,
                "say": 0.05999844018251062,
                "scale": 0.20964628499340227,
                "setting": 0.09485409697299355,
                "small": 0.06883243228873667,
                "somewhat": 0.09337366176505878,
                "specification": 0.10767424661819254,
                "statement": 0.1023534037690686,
                "stop": 0.09485409697299355,
                "stuff": 0.07258593812722078,
                "successfully": 0.10482314249670113,
                "sufficiently": 0.11104638706281779,
                "supports": 0.10482314249670113,
                "tend": 0.08735479017691848,
                "time": 0.09078840657424862,
                "update": 0.08735479017691848,
                "useless": 0.09646342166640245,
                "using": 0.054044716834735246,
                "want": 0.16316171133250248,
                "work": 0.04876634373174956,
                "worry": 0.10017493982211749,
                "write": 0.0567830427634052
            },
            "Max term": "delivered",
            "Max score": 0.3144694274901034
        }
    },
    {
        "ID": "8565",
        "Question": "Loose coupling is, to some developers, the holy grail of well-engineered software.  It's certainly a good thing when it makes code more flexible in the face of changes that are likely to occur in the foreseeable future, or avoids code duplication.   On the other hand, efforts to loosely couple components increase the amount of indirection in a program, thus increasing its complexity, often making it more difficult to understand and often making it less efficient.   Do you consider a focus on loose coupling without any use cases for the loose coupling (such as avoiding code duplication or planning for changes that are likely to occur in the foreseeable future) to be an anti-pattern?  Can loose coupling fall under the umbrella of YAGNI? ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "avoiding": 0.13989505032834743,
                    "avoids": 0.14963847491328786,
                    "cases": 0.10375170681407951,
                    "certainly": 0.11632548622451377,
                    "changes": 0.19933798376025347,
                    "code": 0.15713343012338316,
                    "complexity": 0.12532946041143608,
                    "components": 0.13989505032834743,
                    "consider": 0.09683863705463289,
                    "couple": 0.11219588299902276,
                    "coupling": 0.5985538996531514,
                    "developers": 0.08537803628719276,
                    "difficult": 0.10867296606704906,
                    "efficient": 0.13989505032834743,
                    "engineered": 0.14963847491328786,
                    "face": 0.13298198056890081,
                    "fall": 0.14963847491328786,
                    "focus": 0.12131511036509966,
                    "future": 0.24263022073019933,
                    "good": 0.06543519161708315,
                    "hand": 0.10658206163957334,
                    "holy": 0.14963847491328786,
                    "increase": 0.13015162574340697,
                    "likely": 0.20243973629556536,
                    "makes": 0.08416617068090067,
                    "making": 0.2008638415542396,
                    "occur": 0.27979010065669485,
                    "pattern": 0.1195342778757353,
                    "planning": 0.11219588299902276,
                    "program": 0.09147644356284226,
                    "software": 0.0706622568701993,
                    "thing": 0.08537803628719276,
                    "understand": 0.08191168330865468,
                    "use": 0.05636355832833761
                },
                "Max term": "coupling",
                "Max score": 0.5985538996531514
            }
        ],
        "Best Answer": "Is programming practice X good or bad?  Clearly, the answer is always \"it depends.\" If you're looking at your code, wondering what \"patterns\" you can inject, then you're doing it wrong. If you are building your software so that unrelated objects don't fiddle around with each other, then you're doing it right. If you're \"engineering\" your solution so that it can be infinitely extended and changed, then you're actually making it more complicated. I think at the end of the day, you're left with the single truth: is it more or less complicated to have the objects decoupled?  If it is less complicated to couple them, then that is the correct solution.  If it is less complicated to decouple them, then that is the right solution. (I am presently working in a fairly small codebase that does a simple job in a very complicated way, and part of what makes it so complicated is the lack of understanding of the terms \"coupling\" and \"cohesion\" on the part of the original developers.) ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "actually": 0.07716684260815165,
                "answer": 0.08297800801556217,
                "bad": 0.08297800801556217,
                "building": 0.1175509973460027,
                "changed": 0.1121154877328806,
                "clearly": 0.11056046941385471,
                "code": 0.04912702718835145,
                "codebase": 0.12207387921495529,
                "cohesion": 0.14035129417813022,
                "complicated": 0.6633628164831282,
                "correct": 0.10297678025129316,
                "couple": 0.10523254389952759,
                "coupling": 0.14035129417813022,
                "day": 0.08902436330559436,
                "depends": 0.10773943912528143,
                "developers": 0.08007912332866732,
                "end": 0.07821534914157388,
                "engineering": 0.1121154877328806,
                "fairly": 0.11056046941385471,
                "good": 0.061374013826146184,
                "job": 0.07786039966560307,
                "lack": 0.11378579441531361,
                "left": 0.12207387921495529,
                "looking": 0.08297800801556217,
                "makes": 0.07894247109860668,
                "making": 0.09419870167770944,
                "objects": 0.23117972613682192,
                "original": 0.10910584692186664,
                "patterns": 0.12207387921495529,
                "practice": 0.1019282737178709,
                "programming": 0.05958298470242814,
                "right": 0.16094222557961665,
                "simple": 0.0868237068386106,
                "single": 0.09211671549714964,
                "small": 0.08387968128763099,
                "software": 0.06627666585767421,
                "solution": 0.28710554087039725,
                "terms": 0.10645115558682348,
                "think": 0.05958298470242814,
                "understanding": 0.1121154877328806,
                "unrelated": 0.14035129417813022,
                "way": 0.06171551772162907,
                "wondering": 0.10910584692186664,
                "working": 0.07489482304438853,
                "wrong": 0.0908284319586917
            },
            "Max term": "complicated",
            "Max score": 0.6633628164831282
        }
    },
    {
        "ID": "8588",
        "Question": "SQL is officially pronounced as /ËŒÉ›skjuËËˆÉ›l/ like \"S-Q-L\", as stated in   Beaulieu, Alan (April 2009). Mary E. Treseler. ed. Learning SQL (2nd ed.). Sebastapol, CA, USA: O'Reilly. ISBN 978-0-596-52083-0.  But often it is pronounced  /ËˆsiËkwÉ™l/ like \"sequel\", what is the history behind this second pronunciation? ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "2009": 0.31604502498699294,
                    "ed": 0.6094395307531758,
                    "history": 0.25622445770618485,
                    "learning": 0.19434405570930627,
                    "like": 0.22531971400991002,
                    "second": 0.23436082628264168,
                    "sequel": 0.31604502498699294,
                    "sql": 0.46872165256528336
                },
                "Max term": "ed",
                "Max score": 0.6094395307531758
            }
        ],
        "Best Answer": "SEQUEL = Structured English QUEry Language.  For a good historical perspective read   Don Chamberlin: ...A bunch of things were happening at about this time that I think we ought to mention just in passing. One was that we had to change the name of our language from SEQUEL to SQL. And the reason that we had to do that was because of a legal challenge that came from a lawyer. Mike, you probably can help me out with this. I believe it was from the Hawker Siddeley Aircraft Company in Great Britain, that said SEQUEL was their registered trademark. We never found out what kind of an aircraft a SEQUEL was, but they said we couldn't use their name anymore, so we had to figure out what to do about that. I think I was the one who condensed all the vowels out of SEQUEL to turn it into SQL, based on the pattern of APL and languages that had three-lettered names that end in L. So that was how that happened. ...  ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "anymore": 0.1341888476442291,
                "based": 0.09164241649800439,
                "believe": 0.10223466804145001,
                "bunch": 0.1306356639573882,
                "came": 0.12755775624730686,
                "challenge": 0.1341888476442291,
                "change": 0.08879310637948508,
                "company": 0.0848601765711191,
                "end": 0.0799894875456745,
                "english": 0.12484284923976177,
                "figure": 0.10886575943837223,
                "good": 0.06276614460530666,
                "great": 0.08879310637948508,
                "happened": 0.11821175784283953,
                "happening": 0.1341888476442291,
                "help": 0.0778925818515464,
                "kind": 0.09633538630671164,
                "language": 0.13513116286225169,
                "languages": 0.07857057391229326,
                "legal": 0.12755775624730686,
                "mention": 0.12021737601874101,
                "names": 0.1130682837612339,
                "passing": 0.1435348460486964,
                "pattern": 0.11465857415599866,
                "perspective": 0.12484284923976177,
                "probably": 0.08150150938230133,
                "query": 0.12241428216570122,
                "read": 0.08625757824006046,
                "reason": 0.08933548595014182,
                "said": 0.18208735952849958,
                "sequel": 0.717674230243482,
                "sql": 0.21287438472862333,
                "structured": 0.12755775624730686,
                "things": 0.06821492206714663,
                "think": 0.12186898006840724,
                "time": 0.056572449031632145,
                "turn": 0.11821175784283953,
                "use": 0.05406453568911812
            },
            "Max term": "sequel",
            "Max score": 0.717674230243482
        }
    },
    {
        "ID": "8631",
        "Question": "When you are defining a function/variable/etc and are not sure what to name it, what do you name it? How do you come up with a name? If you use a temporary name as a place-card until you give it it's real name, what temporary name do you use?  update I have been using things like WILL_NAME_LATER, NEEDS_NAME, or TO_BE_NAMED. I was hoping there was an adopted convention, I was actually hoping that if I used this adopted convention my IDE would highlight the name until I changed it. ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "actually": 0.14274822081152763,
                    "card": 0.2596309095379131,
                    "changed": 0.20739848694541138,
                    "come": 0.1729311330495677,
                    "convention": 0.42097665674600104,
                    "defining": 0.2503272115805621,
                    "function": 0.18001486597521016,
                    "hoping": 0.5192618190758262,
                    "ide": 0.1904931142565488,
                    "like": 0.09255004455080888,
                    "place": 0.18001486597521016,
                    "real": 0.15690355655510793,
                    "sure": 0.15268847738077027,
                    "things": 0.12338956530696744,
                    "update": 0.19692023866407274,
                    "use": 0.1955876912279335,
                    "used": 0.1266937711100819,
                    "using": 0.12183073780011588,
                    "variable": 0.22142728608444695
                },
                "Max term": "hoping",
                "Max score": 0.5192618190758262
            }
        ],
        "Best Answer": "I always try to give my variables and functions great names. If I can't think of a great name, I'll settle for a good name. If I can't come up with a good name, I'll use an okay name. I have never, in 15 years of professional programming, been unable to come up with a decent name. ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "15": 0.24064309795103458,
                "come": 0.3827456832089201,
                "decent": 0.2614977295186968,
                "functions": 0.22633252351197786,
                "good": 0.25128213548612094,
                "great": 0.35548019601632347,
                "names": 0.22633252351197786,
                "okay": 0.2873184489711244,
                "professional": 0.2233547107266815,
                "programming": 0.12197458420329582,
                "settle": 0.2873184489711244,
                "think": 0.12197458420329582,
                "try": 0.16473546217823812,
                "unable": 0.25533657984890296,
                "use": 0.10822276935644855,
                "variables": 0.24064309795103458,
                "years": 0.16897147021086598
            },
            "Max term": "come",
            "Max score": 0.3827456832089201
        }
    },
    {
        "ID": "8660",
        "Question": "We're integrating Mercurial slowly in our office and doing web-development we started using named branches.   We haven't quite found a good convention as far as naming our branches though.   We tried:   FeatureName (Can see this causing problem down the line) DEVInitial_FeatureName (Could get confusing when developer come and go down the line) {uniqueID (int)}_Feature  So far the uniqueID_featureName is winning, we are thinking of maintaining it in a small DB just for reference. It would have: branchID(int), featureName(varchar), featureDescription(varchar), date, who etc... This would give us branches like: 1_NewWhizBangFeature, 2_NowWithMoreFoo, ... and we would have an easy reference as to what that branch does without having to check the log. Any better solution out there? ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "better": 0.09686612472995378,
                    "branch": 0.1811160196680049,
                    "causing": 0.19373040648596518,
                    "check": 0.13104494824669208,
                    "come": 0.12903709638963107,
                    "confusing": 0.1811160196680049,
                    "convention": 0.15706138182402363,
                    "date": 0.15706138182402363,
                    "db": 0.17216596978718715,
                    "developer": 0.10699031040271081,
                    "development": 0.09792083271348767,
                    "easy": 0.12369067922009142,
                    "far": 0.26208989649338416,
                    "good": 0.08471608841115531,
                    "int": 0.3304475435268608,
                    "integrating": 0.19373040648596518,
                    "like": 0.06905864091079711,
                    "line": 0.2641993124604519,
                    "log": 0.15955158296922686,
                    "maintaining": 0.1763202523758071,
                    "mercurial": 0.17216596978718715,
                    "named": 0.1763202523758071,
                    "naming": 0.17216596978718715,
                    "office": 0.17216596978718715,
                    "problem": 0.10092179897648046,
                    "quite": 0.12369067922009142,
                    "reference": 0.324517171459332,
                    "slowly": 0.17216596978718715,
                    "small": 0.11578122486809293,
                    "solution": 0.13209965623022596,
                    "started": 0.12624918095449428,
                    "thinking": 0.12209489836587432,
                    "tried": 0.14525511591886947,
                    "using": 0.09090719744620744,
                    "web": 0.11453662266803256
                },
                "Max term": "int",
                "Max score": 0.3304475435268608
            }
        ],
        "Best Answer": "If you don't have an issue tracker, I recommend setting one up and then using {issue tracker name}_{ticket number}. When someone years from now files a bug and you don't know exactly how the feature was supposed to work, it'll be easy to annotate the file and get back to where the user may have requested that exact functionality. ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "bug": 0.1865980032369046,
                "easy": 0.16881887860613695,
                "exact": 0.22997898370685746,
                "exactly": 0.21121804347025044,
                "feature": 0.1655923929002134,
                "file": 0.1761159211708096,
                "files": 0.18833137179227585,
                "functionality": 0.19400133279860124,
                "issue": 0.3605916948578053,
                "know": 0.11530645087129411,
                "number": 0.1655923929002134,
                "recommend": 0.20554808246392506,
                "requested": 0.25493736543664575,
                "setting": 0.21776353308539126,
                "supposed": 0.21121804347025044,
                "tracker": 0.5098747308732915,
                "user": 0.1597931726368697,
                "using": 0.12407443492801667,
                "work": 0.11195648522916155,
                "years": 0.15550046641037665
            },
            "Max term": "tracker",
            "Max score": 0.5098747308732915
        }
    },
    {
        "ID": "8677",
        "Question": "I'm not sure if I'm using the correct term, but would you program using High-level abstractions like Powerbuilder, or some CMS like MODx or DotNetNuke? I haven't dabbled in any of these yet. The reason I'm asking is that I kind of feel intimidated by the whole notion of using any abstraction over the languages I'm using. I'm thinking that my job might be over-simplified. While it may provide business solutions faster, I'd rather be coding straight from, in my case, .NET.  Do/Would you use abstractions like these or prefer them over programming in lower level languages? ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "abstraction": 0.17806684073690834,
                    "asking": 0.15258255803179765,
                    "business": 0.1408998417930143,
                    "case": 0.1408998417930143,
                    "cms": 0.21621196603412202,
                    "coding": 0.12276880536951573,
                    "correct": 0.1586363150006862,
                    "faster": 0.16211133171605804,
                    "feel": 0.1299330517294616,
                    "high": 0.14511363508875225,
                    "intimidated": 0.21621196603412202,
                    "job": 0.11994438801922849,
                    "kind": 0.14511363508875225,
                    "languages": 0.2367076528892896,
                    "level": 0.26434781188451184,
                    "like": 0.2312177751619428,
                    "lower": 0.18439726203295984,
                    "net": 0.13217390594225592,
                    "notion": 0.21621196603412202,
                    "prefer": 0.15702108472925655,
                    "program": 0.13217390594225592,
                    "programming": 0.09178792643224794,
                    "provide": 0.15702108472925655,
                    "reason": 0.1345694204969628,
                    "solutions": 0.17031903123946954,
                    "straight": 0.19214507153039864,
                    "sure": 0.12715387372023246,
                    "term": 0.17031903123946954,
                    "thinking": 0.13626347302551306,
                    "use": 0.08143945443115866,
                    "using": 0.4058263076616329
                },
                "Max term": "using",
                "Max score": 0.4058263076616329
            }
        ],
        "Best Answer": "I've got no problem with using high-level abstractions, with two caveats:  Any abstraction that you can't get underneath when necessary is evil, because it will occasionally be necessary.  Avoid these. Don't ever use any abstraction without a solid understanding of what's really going on under the hood.  Not doing this will frequently cause performance problems, and occasionally cause correctness problems, both of which are very difficult to debug since you don't know what's really happening.  ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "abstraction": 0.33975057931594627,
                "avoid": 0.1430141006345835,
                "cause": 0.32069226240472554,
                "caveats": 0.20626563713697316,
                "correctness": 0.20626563713697316,
                "debug": 0.16248390012612413,
                "difficult": 0.14979769473308127,
                "evil": 0.1794044481135835,
                "frequently": 0.16476921460228744,
                "going": 0.10662375315558349,
                "got": 0.1325773807020463,
                "happening": 0.1928350426252783,
                "high": 0.13843801963356608,
                "hood": 0.19887424760512412,
                "know": 0.0899494808137276,
                "level": 0.12609355264712413,
                "necessary": 0.286028201269167,
                "occasionally": 0.3518289892756379,
                "performance": 0.15833800597343636,
                "problem": 0.107451894333383,
                "problems": 0.24930631040423518,
                "really": 0.1923740664460925,
                "solid": 0.18772896756959265,
                "understanding": 0.16476921460228744,
                "use": 0.07769302164191685,
                "using": 0.09678930293751806
            },
            "Max term": "occasionally",
            "Max score": 0.3518289892756379
        }
    },
    {
        "ID": "8721",
        "Question": "Here's a bit information about me, before starting with the question. I am a Computer Science Undergraduate, Java being my primary coding language. The basic problem in my University are the teaching standards. No one is concerned about teaching coding knowledge to students, rather than just theoretical knowledge. The effect being, most of my fellow college mates don't understand programming at all. Even I haven't been able to come out of the traditional programming environment, which limits my coding to an extent. What are the possible ways by which I can develop and expand my programming/coding skills. Also, can you suggest the sources for the same? Edited: Sources suggesting development of coding skills. ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "able": 0.09836276021664152,
                    "basic": 0.11223266298415288,
                    "bit": 0.10318431898278155,
                    "coding": 0.44310769043675413,
                    "college": 0.13574920762433787,
                    "come": 0.10395557178147005,
                    "computer": 0.09899731912930873,
                    "concerned": 0.15607415031173508,
                    "develop": 0.11573561972672987,
                    "development": 0.07888751714709437,
                    "edited": 0.15048133874690656,
                    "effect": 0.13574920762433787,
                    "environment": 0.10243609212807475,
                    "expand": 0.15048133874690656,
                    "extent": 0.1331084792368182,
                    "fellow": 0.13870129080164675,
                    "information": 0.10395557178147005,
                    "java": 0.09485980347406453,
                    "knowledge": 0.19548774207537928,
                    "language": 0.07346815775037428,
                    "limits": 0.15048133874690656,
                    "possible": 0.091786930962919,
                    "primary": 0.12467522716596166,
                    "problem": 0.08130517201143139,
                    "programming": 0.1987733087519536,
                    "question": 0.08006720491984817,
                    "science": 0.12653264998309566,
                    "skills": 0.2164277535411019,
                    "sources": 0.29182335793607295,
                    "standards": 0.1229460078931196,
                    "starting": 0.11573561972672987,
                    "students": 0.13870129080164675,
                    "suggest": 0.14591167896803647,
                    "suggesting": 0.14591167896803647,
                    "teaching": 0.31214830062347015,
                    "theoretical": 0.14591167896803647,
                    "traditional": 0.15048133874690656,
                    "understand": 0.08543455405042337,
                    "university": 0.12653264998309566,
                    "ways": 0.10475131284616258
                },
                "Max term": "coding",
                "Max score": 0.44310769043675413
            }
        ],
        "Best Answer": "My favorite quote is from Confucius:  I hear, I know. I see, I remember. I   do, I understand.  All knowledge I got, was from applying one and single strategy:  Take the most challenging path, always.  You want to learn C#? Get a job as a C# developer. You want to learn Italian? Go there with a dictionnary english/italian, and talk Italian You want to learn coding ? Code! ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "applying": 0.24938873899501923,
                "code": 0.09337311053406593,
                "coding": 0.15146980548585834,
                "developer": 0.14732091973381242,
                "english": 0.23201928693057414,
                "favorite": 0.23201928693057414,
                "got": 0.17145901150754705,
                "hear": 0.2427851797974004,
                "job": 0.14798509334443744,
                "know": 0.11632941444664369,
                "knowledge": 0.1670614779775173,
                "learn": 0.43428794060127446,
                "path": 0.22342288749726244,
                "quote": 0.21309190536864367,
                "remember": 0.18657329343038645,
                "single": 0.17508130962562904,
                "strategy": 0.25719909179164707,
                "talk": 0.21309190536864367,
                "understand": 0.14602268887540043,
                "want": 0.37790553191209486
            },
            "Max term": "learn",
            "Max score": 0.43428794060127446
        }
    },
    {
        "ID": "8748",
        "Question": "Quote from Wikipedia of the article \"High-level programming language\":  A high-level programming language is a programming language with strong abstraction from the details of the computer. In comparison to low-level programming languages, it may use natural language elements, be easier to use, or be more portable across platforms. Such languages hide the details of CPU operations such as memory access models and management of scope.  I.e., as the level of programming language increases, the further away the programmer goes from the hardware on which the program runs. Now I do not know the statistics of language usages across levels, but I would suspect that the higher level languages more and more are replacing the lower level languages. If so, can this lead to a deficit of programmers with computer architecture knowledge? Would this be a problem for the industry? ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "abstraction": 0.10682840904482156,
                    "access": 0.08917882762389616,
                    "architecture": 0.10682840904482156,
                    "article": 0.10218023222105997,
                    "away": 0.08993638140384762,
                    "computer": 0.16455302992332854,
                    "details": 0.1991460594831457,
                    "easier": 0.08394383923130164,
                    "elements": 0.1250648020345799,
                    "goes": 0.09327638825392459,
                    "hardware": 0.09957302974157285,
                    "hide": 0.1250648020345799,
                    "high": 0.17411730003281858,
                    "higher": 0.10516108477518418,
                    "increases": 0.1250648020345799,
                    "industry": 0.09517136979644213,
                    "know": 0.05656596641621805,
                    "knowledge": 0.08123477624014332,
                    "language": 0.3663556165066904,
                    "languages": 0.2840180896370039,
                    "lead": 0.10083586687227562,
                    "level": 0.4757739744452404,
                    "levels": 0.11805593960996204,
                    "low": 0.10218023222105997,
                    "lower": 0.11062624604154696,
                    "management": 0.08513447374853991,
                    "memory": 0.1086408937146442,
                    "models": 0.11527442286530855,
                    "natural": 0.11282095121736752,
                    "operations": 0.10682840904482156,
                    "platforms": 0.1086408937146442,
                    "portable": 0.1297129788583415,
                    "problem": 0.06757259954404922,
                    "program": 0.07929566240754006,
                    "programmer": 0.06705181159032769,
                    "programmers": 0.06950528323826871,
                    "programming": 0.2753336362261789,
                    "quote": 0.1036173836169291,
                    "runs": 0.11282095121736752,
                    "scope": 0.11062624604154696,
                    "strong": 0.10682840904482156,
                    "suspect": 0.11805593960996204,
                    "use": 0.09771664746063688,
                    "wikipedia": 0.10682840904482156
                },
                "Max term": "level",
                "Max score": 0.4757739744452404
            }
        ],
        "Best Answer": "It can, but likely won't lead to a problem. It's just economics.  If the vast majority of people lose the ability to understand the underlying architecture, and there is still a huge NEED to understand the underlying architecture, then the ones who do will have jobs and get paid more, while those who don't will only have jobs where that is not needed (and may still get paid more...who knows?). Is it helpful to know? Absolutely. You'll likely be better.  Is it necessary in most cases?  No.  That's why abstraction is so great, we stand on the shoulders of giants without having to be giants ourselves (but there will always be giants around). ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "ability": 0.14722706255272294,
                "absolutely": 0.1635139886706615,
                "abstraction": 0.1635139886706615,
                "architecture": 0.327027977341323,
                "better": 0.09927175980898573,
                "cases": 0.13765866759074313,
                "great": 0.12282124262013433,
                "helpful": 0.14567145969699455,
                "huge": 0.14567145969699455,
                "jobs": 0.31279876735316525,
                "know": 0.08658115265805179,
                "knows": 0.14722706255272294,
                "lead": 0.15434166754680181,
                "likely": 0.26859880402552755,
                "lose": 0.16932704421654182,
                "majority": 0.1914270258803607,
                "necessary": 0.13765866759074313,
                "need": 0.09345870426310537,
                "needed": 0.13765866759074313,
                "ones": 0.13765866759074313,
                "paid": 0.327027977341323,
                "people": 0.08879788923692751,
                "problem": 0.10342815525462891,
                "stand": 0.1806991019007726,
                "underlying": 0.3712279406689607,
                "understand": 0.21736226864374134,
                "vast": 0.18561397033448035
            },
            "Max term": "underlying",
            "Max score": 0.3712279406689607
        }
    },
    {
        "ID": "8758",
        "Question": "Disclaimer: I by no means condone the use of pirated software. Have you ever witnessed the use of pirated software for development purposes? May be a company didn't have enough money to buy a piece of software and there were no free alternatives? May be a company wanted to try something out before buying and there were no trial licenses for that product. Whatever the circumstances, have you worked at a company where using pirated/cracked software was accepted? Were there any consequences to doing this? ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "accepted": 0.2012910976458355,
                    "alternatives": 0.22650356639663863,
                    "buy": 0.18093568690265108,
                    "buying": 0.21838696436428542,
                    "circumstances": 0.2012910976458355,
                    "company": 0.4017379716675745,
                    "consequences": 0.22650356639663863,
                    "development": 0.11448599234596861,
                    "disclaimer": 0.22650356639663863,
                    "free": 0.14461529545906854,
                    "licenses": 0.1931744956134823,
                    "means": 0.14658193135538478,
                    "money": 0.159845424830326,
                    "piece": 0.2012910976458355,
                    "product": 0.14866100599234863,
                    "purposes": 0.20614815565345418,
                    "software": 0.42783791267614035,
                    "try": 0.12986694668924476,
                    "use": 0.17063187771154922,
                    "using": 0.10628586811013112,
                    "wanted": 0.1931744956134823,
                    "worked": 0.14866100599234863
                },
                "Max term": "software",
                "Max score": 0.42783791267614035
            }
        ],
        "Best Answer": "While I don't have any problem when some companies or individuals use unlicensed software when they can't afford them (yet), I'm always amazed to see how commercial software development factories do it without shame. They are unrespectful to their own profession! Thanks to programs like Microsoft Bizspark (3 years of free Microsoft softwares for any startup that generate less than 1.000.000 a year in revenues), you can now get them legally. ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "000": 0.4839913310076083,
                "afford": 0.2588502040395468,
                "commercial": 0.23558786734434736,
                "companies": 0.18613875299223917,
                "development": 0.13083556674127386,
                "free": 0.16526759084785328,
                "generate": 0.2251411269680615,
                "like": 0.09227174822321267,
                "microsoft": 0.38389686852140936,
                "problem": 0.13484526632112664,
                "profession": 0.24957448213544522,
                "programs": 0.1794735644949486,
                "software": 0.2444684045242394,
                "startup": 0.24199566550380416,
                "thanks": 0.24199566550380416,
                "use": 0.09749978127042194,
                "year": 0.18798654193942507,
                "years": 0.15222934586195183
            },
            "Max term": "000",
            "Max score": 0.4839913310076083
        }
    },
    {
        "ID": "8805",
        "Question": "Assuming I've found an open source project I'm interested in, how do I evaluate the project(the members, the activity level, etc) to determine if joining the project will be a good use of my time and energy? ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "activity": 0.3296616012292595,
                    "assuming": 0.2761075360088706,
                    "determine": 0.300035589568469,
                    "energy": 0.3296616012292595,
                    "evaluate": 0.3081963132945268,
                    "good": 0.14415724336759803,
                    "interested": 0.2444580966301484,
                    "level": 0.20152752076068303,
                    "members": 0.2633404374719333,
                    "open": 0.20517999744066495,
                    "project": 0.4670182470077002,
                    "source": 0.195949744127573,
                    "time": 0.12993196179624078,
                    "use": 0.12417194775785943
                },
                "Max term": "project",
                "Max score": 0.4670182470077002
            }
        ],
        "Best Answer": "Look at the source control history. From that, you can see checkins, review code, gauge the activity level, and generally see the quality of commits.  You can learn the most from just looking at the source code activity. ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "activity": 0.6341992413088596,
                "code": 0.22198814448457752,
                "control": 0.2128257722385571,
                "generally": 0.21800881190792068,
                "history": 0.2570794409573828,
                "learn": 0.17208161527925933,
                "level": 0.19384817687698722,
                "look": 0.18271195365606765,
                "looking": 0.18747454391834906,
                "quality": 0.2258585656801197,
                "review": 0.24650590415072376,
                "source": 0.3769658904676282
            },
            "Max term": "activity",
            "Max score": 0.6341992413088596
        }
    },
    {
        "ID": "8886",
        "Question": "Interested in knowing from the more experienced ones if someone can find a job as a programmer without even a highschool degree. Consider the said person to be an average programmer. Would someone even consider giving him/her a chance on an interview ? The languages of interest would be python/php/java/c# Please answer for your region/city/country only. No \"go back to school\" answers please. ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "answer": 0.16041525584021427,
                    "answers": 0.19148036676201072,
                    "average": 0.2167445938801933,
                    "chance": 0.21092627753069249,
                    "consider": 0.3511838015558636,
                    "country": 0.26160783817806227,
                    "degree": 0.21997367445469754,
                    "experienced": 0.23140558016220694,
                    "giving": 0.22346134717016747,
                    "interested": 0.2012033221463516,
                    "interview": 0.2137383917858266,
                    "java": 0.16491126623071733,
                    "job": 0.1505217614989818,
                    "knowing": 0.2272526632598221,
                    "languages": 0.14852571871671716,
                    "ones": 0.18812697041740686,
                    "person": 0.1850133141431492,
                    "php": 0.19148036676201072,
                    "programmer": 0.2805150480503424,
                    "python": 0.18353613376997127,
                    "said": 0.1721042280624619,
                    "school": 0.21092627753069249
                },
                "Max term": "consider",
                "Max score": 0.3511838015558636
            }
        ],
        "Best Answer": "Your biggest difficulty is going to be getting through the HR filter. If you can do that, experience will trump education (most of the time).   In the meantime, try to find some small shop that just needs someone who can code. You should also try to join an opensource project (or two) to get some experience and show that you have some skills. You are going to have to start small and build on that. ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "biggest": 0.2748622523548429,
                "build": 0.18847170393007245,
                "code": 0.09978551359567658,
                "education": 0.26651552318712823,
                "experience": 0.3269015765419898,
                "filter": 0.28507782324559955,
                "getting": 0.17326652897919625,
                "going": 0.29472739984978685,
                "join": 0.25945846422952346,
                "needs": 0.2049989905226067,
                "project": 0.13461940444027487,
                "shop": 0.2748622523548429,
                "skills": 0.1976584615267752,
                "small": 0.34074836425325294,
                "start": 0.15886894102575994,
                "time": 0.1123598280806237,
                "try": 0.3269015765419898
            },
            "Max term": "small",
            "Max score": 0.34074836425325294
        }
    },
    {
        "ID": "8890",
        "Question": "So the other day my boss (let's call him Colfax) asked me to work on a project, but that I should not discuss it with anyone (including the other programmers on my team) and that it would have to be done outside of normal work hours. In exchange, Colfax offered me \"off-the-book\" vacation days equal to the hours spent on the project. When I asked Colfax if his boss (let's call him Schuyler) knew what he was offering, Colfax said that Schuyler does not know and implied that he (Colfax) would get into trouble if Schuyler found out. My boss also said that if I were to go along with this, my efforts would be remembered for \"future consideration\".  The work is for our employer so everything there is on the up-and-up. However, I have an uneasy feeling about the whole thing. Part of me wants to work on the project -- as it's you know -- coding and coding something cool and fairly simple. On the other hand, the whole thing seems seedy and underhanded.  Would I be a \"bad employee\" for refusing extra work? Or am I morally justified to not do the work?  UPDATE I know it's been a while since I posted this question, but I thought the folks who participated in the discussion might be interested to know that Colfax quit a couple of months after this conversation. So, if I had followed along, it would have probably been for nothing. Regardless, thanks for the comments everyone. ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "asked": 0.1753855519205809,
                    "bad": 0.07842015176588384,
                    "book": 0.08525574368328001,
                    "boss": 0.29507907416673734,
                    "coding": 0.15063274655225922,
                    "comments": 0.09835969138891244,
                    "conversation": 0.12072174496349017,
                    "cool": 0.12400527812631128,
                    "couple": 0.09945227971444305,
                    "day": 0.08413438992144252,
                    "days": 0.0911925627810308,
                    "discuss": 0.11787741916193262,
                    "discussion": 0.1092406870350816,
                    "employee": 0.1278888735713718,
                    "employer": 0.12072174496349017,
                    "equal": 0.12400527812631128,
                    "extra": 0.11312428248014213,
                    "fairly": 0.1044875503532911,
                    "feeling": 0.11109409917837115,
                    "folks": 0.12400527812631128,
                    "followed": 0.1326420102531623,
                    "future": 0.10753571313952322,
                    "hand": 0.09447609594385192,
                    "hours": 0.18895219188770385,
                    "implied": 0.1278888735713718,
                    "including": 0.10182147498396454,
                    "interested": 0.09835969138891244,
                    "justified": 0.1278888735713718,
                    "knew": 0.1326420102531623,
                    "know": 0.23137309969741796,
                    "let": 0.17287885219848062,
                    "months": 0.1092406870350816,
                    "normal": 0.11109409917837115,
                    "offered": 0.12072174496349017,
                    "offering": 0.1326420102531623,
                    "outside": 0.10182147498396454,
                    "posted": 0.1278888735713718,
                    "probably": 0.07531637327612961,
                    "programmers": 0.07107477272577122,
                    "project": 0.18790856707915288,
                    "question": 0.06804634204131893,
                    "quit": 0.1278888735713718,
                    "regardless": 0.11787741916193262,
                    "said": 0.16826877984288505,
                    "simple": 0.08205461217969347,
                    "spent": 0.11536854599946025,
                    "team": 0.07927229749135867,
                    "thanks": 0.12400527812631128,
                    "thing": 0.15136099684473667,
                    "thought": 0.09196722278137956,
                    "trouble": 0.11787741916193262,
                    "update": 0.10060395490823057,
                    "vacation": 0.1278888735713718,
                    "wants": 0.10311282807070293,
                    "work": 0.336976623896089
                },
                "Max term": "work",
                "Max score": 0.336976623896089
            }
        ],
        "Best Answer": "If you have serious doubts about whether something is ethical, it's probably not.  That inner voice is there for a reason; listen to it. A real red flag should be the boss offering you vacation days \"off the book.\"  That could easily be interpreted as a confession of intent to commit accounting fraud, which is a pretty serious no-no.  Plus, if the boss is willing to hide things from his boss, how do you know he's not willing to hide things from you?  You could be getting set up for something here. Time to take this to someone with authority.  If what he's asking you to do is flat-out illegal, go to the police or the FBI.  Otherwise, go to Schuyler and explain what's going on.  You won't regret it. ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "accounting": 0.1816681830691196,
                "asking": 0.12820472702838556,
                "authority": 0.1816681830691196,
                "book": 0.11676735011469563,
                "boss": 0.40414405031464107,
                "commit": 0.15215589019583708,
                "days": 0.12489849300554852,
                "easily": 0.13621110629521685,
                "ethical": 0.1816681830691196,
                "explain": 0.11756668366741599,
                "flag": 0.17515822665929148,
                "getting": 0.11041551793815102,
                "going": 0.09390872748679019,
                "hide": 0.35031645331858297,
                "inner": 0.17515822665929148,
                "intent": 0.17515822665929148,
                "interpreted": 0.17515822665929148,
                "know": 0.07922288450106267,
                "listen": 0.17515822665929148,
                "offering": 0.1816681830691196,
                "plus": 0.15801022688849378,
                "pretty": 0.1137725332612257,
                "probably": 0.10315426207967818,
                "real": 0.10978809914112672,
                "reason": 0.11306951491523562,
                "red": 0.17515822665929148,
                "set": 0.11449291182767479,
                "things": 0.1726755737897372,
                "time": 0.07160222280699849,
                "vacation": 0.17515822665929148,
                "voice": 0.1816681830691196,
                "willing": 0.2902405292321748
            },
            "Max term": "boss",
            "Max score": 0.40414405031464107
        }
    },
    {
        "ID": "8917",
        "Question": "I've been using SVN for sometime and have been making an awkward, but soon to be rewarding transition over to git. Theres quite a few side / small projects that I'm working on which 90% will never see the light of day. As well - I also have my weekly school assignments / projects, and finally client projects that I have on the go. I've been rolling the idea or question of how or what the best way would be to back up my projects. The solutions I've sought out so far: github which offers an outstanding service - I'm ok with my work being open source, however It's the school work and client work I might not want the public to be open to. github, of course has a payment plan - but let's face it, im a poor colleage student doing what I can to at least put KD on the table! Theres the USB thumbstick that I can take around with me, work off of or back up, but that requires it to be around constently. Theres Dropbox, but thats a little overkill since it already is a form of a version control system, as well - I have quite a few things on the go - putting everything within dropbox would eat a lot of space Finally, theres a private server. I have a mac mini setup as a media server and I was thinking that I could backup to that. Anyways - what are your guys thoughts, how do you handle backing up projects, not only for version control but for the everyday backups. ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "90": 0.09675652002738198,
                    "assignments": 0.10938484722906339,
                    "awkward": 0.10606316268689438,
                    "backup": 0.10606316268689438,
                    "best": 0.05980604197792445,
                    "client": 0.15732127953114372,
                    "control": 0.15228740584229902,
                    "course": 0.08006277950804902,
                    "day": 0.07196112633779235,
                    "eat": 0.11345026054671493,
                    "everyday": 0.11345026054671493,
                    "face": 0.10082193334503353,
                    "far": 0.07674109496588001,
                    "finally": 0.19351304005476397,
                    "form": 0.08158189445191183,
                    "git": 0.10082193334503353,
                    "guys": 0.10606316268689438,
                    "handle": 0.08819360614335212,
                    "idea": 0.06569801281706927,
                    "im": 0.10938484722906339,
                    "let": 0.07393265070206916,
                    "light": 0.10325471842308352,
                    "little": 0.07196112633779235,
                    "lot": 0.05820083108740781,
                    "mac": 0.10325471842308352,
                    "making": 0.07614370292114951,
                    "ok": 0.08708909676605413,
                    "open": 0.14122193231980032,
                    "plan": 0.09343483548521296,
                    "poor": 0.09675652002738198,
                    "private": 0.09197655139929431,
                    "projects": 0.3301615628194523,
                    "public": 0.09502008053808363,
                    "putting": 0.10938484722906339,
                    "question": 0.05820083108740781,
                    "quite": 0.1448687383592117,
                    "requires": 0.09502008053808363,
                    "rewarding": 0.10606316268689438,
                    "rolling": 0.11345026054671493,
                    "school": 0.17638721228670423,
                    "server": 0.16161301656706314,
                    "service": 0.09867606482707382,
                    "setup": 0.10082193334503353,
                    "small": 0.06780252189608929,
                    "solutions": 0.08936942216756141,
                    "soon": 0.09062639122140212,
                    "source": 0.06743445230636762,
                    "space": 0.09197655139929431,
                    "student": 0.10606316268689438,
                    "svn": 0.10606316268689438,
                    "table": 0.10325471842308352,
                    "thats": 0.11345026054671493,
                    "theres": 0.45380104218685974,
                    "things": 0.0539172256405672,
                    "thinking": 0.07149986562401917,
                    "thoughts": 0.08819360614335212,
                    "transition": 0.10938484722906339,
                    "using": 0.05323606873550359,
                    "version": 0.16316378890382366,
                    "want": 0.05357346402647097,
                    "way": 0.04988654793883068,
                    "weekly": 0.11345026054671493,
                    "work": 0.19214669473217028,
                    "working": 0.06053978509953761
                },
                "Max term": "theres",
                "Max score": 0.45380104218685974
            }
        ],
        "Best Answer": "If you have a private server with ssh access all you need to do is this: ssh my.server mkdir ~/repo.git && cd ~/repo.git git init --bare # bare repository that will serve as backup location exit # back on your box cd $my_local_git_repo git remote add --mirror backup ssh://my_server:repo.git git config remote.backup.fetch \":\" # don't replace our data when                                    # accidentally fetching from backup git push backup # copy everything new to backup repo  ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "access": 0.07437480860083842,
                "add": 0.07260658840824234,
                "backup": 0.6068171709320539,
                "box": 0.10818013908324424,
                "config": 0.09845821196162813,
                "copy": 0.08909449347494747,
                "data": 0.06613228578547924,
                "exit": 0.10818013908324424,
                "git": 0.6729690618199456,
                "location": 0.09226187532167793,
                "need": 0.05092320225835392,
                "new": 0.051247931400757375,
                "private": 0.0877039512718945,
                "push": 0.08909449347494747,
                "remote": 0.19691642392325626,
                "replace": 0.09409225122744039,
                "repository": 0.1011361951553423,
                "serve": 0.10818013908324424,
                "server": 0.15410558358910526
            },
            "Max term": "git",
            "Max score": 0.6729690618199456
        }
    },
    {
        "ID": "8955",
        "Question": "After working out a project, it might require too much tweaks and changes to get it working right... What can I do to prevent this? ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "changes": 0.32291191713953155,
                    "prevent": 0.40604781459206624,
                    "project": 0.22893464060322022,
                    "require": 0.3390775175599723,
                    "right": 0.2779654807174161,
                    "tweaks": 0.4674325459979661,
                    "working": 0.5174074215962847
                },
                "Max term": "working",
                "Max score": 0.5174074215962847
            }
        ],
        "Best Answer": "There is simple rule, that I apply all the time because I tend to be a perfectionist too. And perfectionism leads you to mediocrity.  Set a deadline. Ship at that deadline.  To prevent your software from having an unfishined state of missing feature that will make it unusable, use this definition of done for each feature you produce. Don't start the next feature until ALL steps are completed:  Develop the feature Test is (80% code coverage) Commit/Integrate Document (both technical & end user documentation) Update Release Note (both in file and maybe for your website including screenshots) Update Installer (if necessary)  I assume you can create a release with one mouse click (using build scripts) ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "80": 0.13467081748975507,
                "apply": 0.13695568529182306,
                "assume": 0.13695568529182306,
                "build": 0.10810676998695273,
                "click": 0.1453180937705197,
                "code": 0.057236653255494374,
                "commit": 0.13695568529182306,
                "completed": 0.1453180937705197,
                "coverage": 0.1453180937705197,
                "create": 0.10510242116874621,
                "deadline": 0.2789169495913238,
                "definition": 0.13062291091489223,
                "develop": 0.12125683577155623,
                "document": 0.13695568529182306,
                "documentation": 0.11758676901550962,
                "end": 0.09112671932925728,
                "feature": 0.4096271328076186,
                "file": 0.10891481572230836,
                "including": 0.1255244876819527,
                "integrate": 0.1635197327946254,
                "leads": 0.15287245651386075,
                "make": 0.07420628144258025,
                "maybe": 0.10974851794661865,
                "missing": 0.1394584747956619,
                "mouse": 0.15766011381976758,
                "necessary": 0.11337626492822579,
                "note": 0.1226037676425698,
                "prevent": 0.13695568529182306,
                "produce": 0.1255244876819527,
                "release": 0.2576223970297945,
                "rule": 0.13062291091489223,
                "scripts": 0.15766011381976758,
                "set": 0.10305519674745055,
                "simple": 0.10115609852852184,
                "software": 0.07721726226343756,
                "start": 0.09112671932925728,
                "state": 0.13695568529182306,
                "steps": 0.13467081748975507,
                "technical": 0.10440212861846411,
                "tend": 0.12402354120899042,
                "test": 0.09240792046668592,
                "time": 0.06444924005458302,
                "update": 0.24804708241798085,
                "use": 0.061592140674681654,
                "user": 0.09882038963727872,
                "using": 0.07673096291463673,
                "website": 0.1255244876819527
            },
            "Max term": "feature",
            "Max score": 0.4096271328076186
        }
    },
    {
        "ID": "8966",
        "Question": "Are there ways to unit test your multi-threaded code for race conditions and deadlocks? To see if they are performing the way they should be... ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "code": 0.17896051439833327,
                    "conditions": 0.4543627087431251,
                    "multi": 0.4145002347020877,
                    "test": 0.2889296987260675,
                    "threaded": 0.47798275928076095,
                    "unit": 0.3308708838212715,
                    "way": 0.22481801627192688,
                    "ways": 0.3431481421268494
                },
                "Max term": "threaded",
                "Max score": 0.47798275928076095
            }
        ],
        "Best Answer": "CHESS, a project of Microsoft Research.  Quoting their site:  CHESS is a tool for finding and reproducing Heisenbugs in concurrent programs. CHESS repeatedly runs a concurrent test ensuring that every run takes a different interleaving. If an interleaving results in an error, CHESS can reproduce the interleaving for improved debugging. CHESS is available for both managed and native programs.  Update (9/23/2015): For C, C++, and Go, you can use ThreadSanitizer. ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "available": 0.15805511560768307,
                "concurrent": 0.41494542902363035,
                "debugging": 0.2131158034075737,
                "different": 0.12266129791165646,
                "error": 0.169041229292815,
                "finding": 0.20258444856450297,
                "improved": 0.2131158034075737,
                "managed": 0.17957258413588575,
                "microsoft": 0.169041229292815,
                "native": 0.2131158034075737,
                "programs": 0.31611023121536613,
                "project": 0.10764672236894259,
                "repeatedly": 0.22795891439318033,
                "reproduce": 0.21979016095016976,
                "reproducing": 0.22795891439318033,
                "research": 0.19092661665677693,
                "results": 0.18209824868313781,
                "run": 0.14101927645499032,
                "runs": 0.19827269242196705,
                "site": 0.16392487777266146,
                "takes": 0.14961619403056248,
                "test": 0.12882365247853103,
                "tool": 0.15943669904280608,
                "update": 0.17289822659328968,
                "use": 0.08586411733553152
            },
            "Max term": "concurrent",
            "Max score": 0.41494542902363035
        }
    }
]