[
    {
        "ID:": "1",
        "Question": "A coworker of mine believes that any use of in-code comments (ie, not javadoc style method or class comments) is a code smell.  What do you think? ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "class": 0.33022024164560737,
                    "code": 0.33879160957188237,
                    "comments": 0.6753479120269171,
                    "method": 0.3551248547310851,
                    "style": 0.33767395601345856,
                    "think": 0.2133881209999066,
                    "use": 0.18549442528191792
                },
                "Max term": "comments",
                "Max score": 0.6753479120269171
            }
        ],
        "Best Answer": "Only if the comment describes what the code is doing. If I wanted to know what was happening in a method or block, I would read the code. I would hope, anyway, that any developers working on a given project were at least familiar enough with the development language to read what is written and understand what it is doing. In some cases of extreme optimization, you might be using techniques that makes it difficult for someone to follow what your code is doing. In these cases, comments can and should be used to not only explain why you have such optimizations, but what the code is doing. A good rule of thumb would be to have someone else (or multiple other people) familiar with the implementation language and project look at your code - if they can't understand both the why and the how, then you should comment both the why and the how. However, what's not clear in the code is why you have done something. If you take an approach that might not be obvious to others, you should have a comment that explains why you made the decisions that you did. I would suspect that you might not even realize that a comment is needed until after something like a code review, where people want to know why you did X instead of Y - you can capture your answer in the code for everyone else who looks at it in the future. The most important thing, though, is to change your comments when you change your code. If you change an algorithm, be sure to update the comments with why you went with algorithm X over Y. Stale comments are an even bigger code smell. ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "algorithm": 0.20092519928275482,
                "answer": 0.07169121907844199,
                "approach": 0.08656599566678204,
                "bigger": 0.10046259964137741,
                "cases": 0.17313199133356408,
                "change": 0.21800817507656006,
                "clear": 0.09680731467181217,
                "code": 0.4342625850151851,
                "comment": 0.41974522753729215,
                "comments": 0.34626398266712816,
                "developers": 0.07369774846640065,
                "development": 0.06203105849318809,
                "difficult": 0.09103970290972767,
                "explain": 0.07369774846640065,
                "familiar": 0.20987261376864608,
                "follow": 0.08867832245930131,
                "given": 0.09103970290972767,
                "good": 0.057322862476113866,
                "implementation": 0.10046259964137741,
                "important": 0.07478171848470595,
                "instead": 0.07843700345427118,
                "know": 0.11107918664009445,
                "language": 0.1119415236020963,
                "like": 0.0436607472756471,
                "look": 0.07478171848470595,
                "looks": 0.09371681526554819,
                "makes": 0.07592766246778344,
                "method": 0.09103970290972767,
                "multiple": 0.09371681526554819,
                "needed": 0.09103970290972767,
                "obvious": 0.09680731467181217,
                "people": 0.1085981609492914,
                "project": 0.11960228898361057,
                "read": 0.15428619787026462,
                "realize": 0.10046259964137741,
                "review": 0.10046259964137741,
                "rule": 0.10046259964137741,
                "sure": 0.07843700345427118,
                "suspect": 0.10493630688432304,
                "techniques": 0.09680731467181217,
                "thing": 0.07843700345427118,
                "understand": 0.1380282134452429,
                "update": 0.10493630688432304,
                "used": 0.05877278771759133,
                "using": 0.06144990007341186,
                "want": 0.05827773635203676,
                "went": 0.09103970290972767,
                "working": 0.06901410672262145,
                "written": 0.09371681526554819
            },
            "Max term": "code",
            "Max score": 0.4342625850151851
        }
    },
    {
        "ID:": "4",
        "Question": "When starting a project for a company that's not primarily a programming company, one of the expectations is that there's a finished product at the end free of all bugs and does everything needed right away. However, that's rarely the case.  What are some ways to manage expectations and explain to non-programmers how software development differs from other types of product development? ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "away": 0.19871907838576003,
                    "bugs": 0.17950456440370313,
                    "case": 0.17580559018543732,
                    "company": 0.3219971798407811,
                    "development": 0.26306388538986175,
                    "end": 0.16099858992039054,
                    "expectations": 0.4450182421195399,
                    "explain": 0.15627023403272314,
                    "free": 0.19871907838576003,
                    "needed": 0.1930424738343103,
                    "non": 0.15627023403272314,
                    "product": 0.35900912880740626,
                    "programmers": 0.13829400329927768,
                    "programming": 0.10810064802184169,
                    "project": 0.1268035868072635,
                    "rarely": 0.22250912105976994,
                    "right": 0.16099858992039054,
                    "software": 0.13029964233083058,
                    "starting": 0.1930424738343103,
                    "types": 0.1930424738343103,
                    "ways": 0.17950456440370313
                },
                "Max term": "expectations",
                "Max score": 0.4450182421195399
            }
        ],
        "Best Answer": "Pretty much everybody with a computer has encountered the concept of \"bugs\" these days, so you might start there.  \"What's the most annoying way an application has ever failed on you?  Multiply that by ten, and you'll have our users' experience if we don't devote enough resources to testing and maintenance.\" And don't underestimate the value of establishing a good working relationship with the non-programmers.  If you can establish that your judgment may be trusted, they'll take you seriously when you sound the alarm that X is going to fail spectacularly if you don't do Y pronto, even if they don't completely understand your reasoning. ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "annoying": 0.219264210552331,
                "application": 0.17472564697115073,
                "bugs": 0.19174013544623955,
                "completely": 0.2008524090670324,
                "computer": 0.1841543615223685,
                "concept": 0.21226436849675717,
                "days": 0.2008524090670324,
                "encountered": 0.2376760120376296,
                "experience": 0.15824643883679634,
                "fail": 0.22754326648847184,
                "failed": 0.219264210552331,
                "going": 0.16937722653379297,
                "good": 0.12983370347617623,
                "non": 0.1669220832305017,
                "pretty": 0.17197273807792055,
                "programmers": 0.14772053853945996,
                "reasoning": 0.2376760120376296,
                "resources": 0.22754326648847184,
                "seriously": 0.2376760120376296,
                "sound": 0.2376760120376296,
                "start": 0.16237738447821917,
                "testing": 0.1776562824699338,
                "understand": 0.15631384548585212,
                "users": 0.18078918596351778,
                "value": 0.2008524090670324,
                "way": 0.13311771888875354,
                "working": 0.15631384548585212
            },
            "Max term": "encountered",
            "Max score": 0.2376760120376296
        }
    },
    {
        "ID:": "9",
        "Question": "Sometimes, the things I have to do for my job are interesting and engaging.  Sometimes, they aren't.  Occasionally, they really aren't. Do you have any particular strategies or tricks for dealing with those dull stretches when your brain would rather be doing anything other than what you're supposed to be doing, particularly when the Internet and its boundless opportunities for interesting Slack beckon? ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "dealing": 0.3444747504409596,
                    "interesting": 0.5338067328223992,
                    "internet": 0.3177896816894165,
                    "job": 0.2353409943050311,
                    "particular": 0.2721712553481638,
                    "particularly": 0.3177896816894165,
                    "really": 0.19806453848532965,
                    "supposed": 0.29885632409970686,
                    "things": 0.18817394410295155,
                    "tricks": 0.3177896816894165
                },
                "Max term": "interesting",
                "Max score": 0.5338067328223992
            }
        ],
        "Best Answer": "Increments. I will pick something that I can do, even if it's a small task (i.e. modify comments in code). Pretty soon, the perfectionist in me wants to do more and more stuff and I'm back rolling. ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "code": 0.1612896048975701,
                "comments": 0.3215150399883475,
                "modify": 0.3897442713419761,
                "pick": 0.34807392181645763,
                "pretty": 0.2820031727991632,
                "small": 0.28651742925047463,
                "soon": 0.3731284610340983,
                "stuff": 0.3019787602066422,
                "task": 0.3019787602066422,
                "wants": 0.33813085029622536
            },
            "Max term": "modify",
            "Max score": 0.3897442713419761
        }
    },
    {
        "ID:": "16",
        "Question": "I have read a few articles on Internet about programming language choice in the enterprise. Recently many dynamic typed languages have been popular, i.e. Ruby, Python, PHP and Erlang. But many enterprises still stay with static typed languages like C, C++, C# and Java. And yes, one of the benefits of static typed languages is that programming errors are caught earlier, at compile time, rather than at run time. But there are also advantages with dynamic typed languages. (more on Wikipedia) The main reason why enterprises don't start to use languages like Erlang, Ruby and Python, seem to be the fact that they are dynamic typed. That also seem to be the main reason why people on StackOverflow decide against Erlang. See Why did you decide \"against\" Erlang. However, there seem to be a strong criticism against dynamic typing in the enterprises, but I don't really get it why it is that strong. Really, why is there so much criticism against dynamic typing in the enterprises? Does it really affect the cost of projects that much, or what? But maybe I'm wrong. ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "advantages": 0.09473073227059611,
                    "articles": 0.09069211517350612,
                    "benefits": 0.09069211517350612,
                    "caught": 0.09473073227059611,
                    "choice": 0.07814702463549936,
                    "compile": 0.09069211517350612,
                    "cost": 0.08218564173258935,
                    "decide": 0.17478464947542072,
                    "earlier": 0.08739232473771036,
                    "enterprise": 0.09069211517350612,
                    "enterprises": 0.37892292908238445,
                    "erlang": 0.36276846069402446,
                    "errors": 0.07814702463549936,
                    "fact": 0.0748472341997036,
                    "internet": 0.08739232473771036,
                    "java": 0.06471889360618556,
                    "language": 0.05052732851558468,
                    "languages": 0.30781658500201303,
                    "like": 0.07882904751856451,
                    "main": 0.15629404927099871,
                    "maybe": 0.0800539172048246,
                    "people": 0.04901822646239584,
                    "php": 0.0748472341997036,
                    "popular": 0.08739232473771036,
                    "programming": 0.09204524737917832,
                    "projects": 0.06964055119458258,
                    "python": 0.1528440609615229,
                    "read": 0.06964055119458258,
                    "really": 0.16340354766381127,
                    "reason": 0.1416172342052272,
                    "recently": 0.08460239167707806,
                    "ruby": 0.17478464947542072,
                    "run": 0.0800539172048246,
                    "stackoverflow": 0.09473073227059611,
                    "start": 0.06471889360618556,
                    "static": 0.18946146454119223,
                    "stay": 0.08739232473771036,
                    "strong": 0.17478464947542072,
                    "time": 0.09731964772298651,
                    "typed": 0.4230119583853903,
                    "typing": 0.16920478335415612,
                    "use": 0.0429285029659678,
                    "wrong": 0.07642203048076145,
                    "yes": 0.0708086171026136
                },
                "Max term": "typed",
                "Max score": 0.4230119583853903
            }
        ],
        "Best Answer": " The main reason why enterprises don't start to use languages like Erlang, Ruby and Python, seem to be the fact that they are dynamic typed.  I think this is only their primary excuse. The real reason is that businesses don’t really take them all that seriously and feel that they are perhaps a bit too amateur. Java and .NET are “big business names”, have good commercial marketing, commercial customer support, and are thus widely taken very seriously indeed. It is unfortunate that there is practically no statically-typed language that is anywhere near as popular as the big business names. Why are open-source/free-software programming environments almost always dynamically typed? This might indicate that a statically-typed language is actually not that easy to make, and that dynamic typing is a “lazy man’s hack”. If that is the case, the businesses who decide against dynamically-typed languages might actually have a point. ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "actually": 0.1605086784263286,
                "big": 0.17958473870398703,
                "bit": 0.08979236935199351,
                "business": 0.19120283296149293,
                "case": 0.09156460713038266,
                "commercial": 0.23177829819034101,
                "customer": 0.09793421970075915,
                "decide": 0.10691168439796483,
                "dynamically": 0.23177829819034101,
                "easy": 0.08662395178354079,
                "enterprises": 0.11588914909517051,
                "environments": 0.11588914909517051,
                "erlang": 0.11094849374832864,
                "fact": 0.09156460713038266,
                "feel": 0.08815153345640751,
                "free": 0.10349861072398966,
                "good": 0.06330599916556394,
                "java": 0.07917406875920183,
                "language": 0.12362554299690111,
                "languages": 0.15062736773264482,
                "like": 0.048217885695288724,
                "main": 0.09560141648074647,
                "make": 0.06490726194558212,
                "man": 0.11094849374832864,
                "names": 0.23177829819034101,
                "net": 0.08519499456000616,
                "open": 0.08815153345640751,
                "point": 0.082587142433177,
                "popular": 0.10691168439796483,
                "practically": 0.11588914909517051,
                "primary": 0.11588914909517051,
                "programming": 0.05630192621417348,
                "python": 0.09349113927719138,
                "real": 0.08519499456000616,
                "really": 0.06663342030616136,
                "reason": 0.17324790356708158,
                "ruby": 0.10691168439796483,
                "seriously": 0.23177829819034101,
                "software": 0.06786380084198346,
                "source": 0.08815153345640751,
                "start": 0.07917406875920183,
                "statically": 0.23177829819034101,
                "support": 0.10054207182758834,
                "taken": 0.10349861072398966,
                "think": 0.060413917817644505,
                "typed": 0.5174930536199484,
                "typing": 0.10349861072398966,
                "use": 0.05251672357440129
            },
            "Max term": "typed",
            "Max score": 0.5174930536199484
        }
    },
    {
        "ID:": "18",
        "Question": "At first glance, I'd say a good programming team needs to understand the following matters:  The details of the core language / framework HTML, (asynchronous) javascript SQL / data model Usability / UI design Security Project management.  If this team is not complete: what is needed? ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "complete": 0.21432814642761508,
                    "core": 0.25362234561663516,
                    "data": 0.17563588926207815,
                    "design": 0.1629228426128013,
                    "details": 0.21432814642761508,
                    "following": 0.22003540701751367,
                    "framework": 0.19291882682266637,
                    "good": 0.13854460167612168,
                    "html": 0.23397524602212513,
                    "javascript": 0.22003540701751367,
                    "language": 0.1352766865483478,
                    "management": 0.19291882682266637,
                    "model": 0.21432814642761508,
                    "needed": 0.22003540701751367,
                    "needs": 0.22003540701751367,
                    "programming": 0.1232162519154131,
                    "project": 0.14453440364820805,
                    "say": 0.14992392074049077,
                    "security": 0.22650576542178785,
                    "sql": 0.25362234561663516,
                    "team": 0.3512717785241563,
                    "ui": 0.23397524602212513,
                    "understand": 0.16680136882388208
                },
                "Max term": "team",
                "Max score": 0.3512717785241563
            }
        ],
        "Best Answer": "Customer (or an advocate of some sort).   Basically, someone that can say, \"Yes, you're building what I want and it's going to solve my problem.\" or that the team can go to when they have questions about how something is supposed to work.  That may or may not be the same person that is doing Project Management. Also, you're missing out on a QA person there.  You can't really depend on the developers to adequately test - they're usually too close to the code and the normal response for developers is to test happy path stuff, not doing weird crap like copy pasting War & Peace into a textbox and seeing what the application does. ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "adequately": 0.19824297399731597,
                "advocate": 0.19824297399731597,
                "application": 0.14573675985308113,
                "building": 0.18979136125271526,
                "close": 0.18288589083270987,
                "code": 0.08203977146258222,
                "copy": 0.18288589083270987,
                "customer": 0.1675288076681038,
                "developers": 0.27845578459304565,
                "going": 0.14127570059598638,
                "like": 0.08248276162806881,
                "management": 0.15079429171121925,
                "normal": 0.18979136125271526,
                "path": 0.18979136125271526,
                "person": 0.3132655675211849,
                "problem": 0.12454118463910183,
                "project": 0.11297478522440542,
                "qa": 0.19824297399731597,
                "questions": 0.14573675985308113,
                "really": 0.11398485114649153,
                "say": 0.11718748144478691,
                "seeing": 0.19824297399731597,
                "solve": 0.15992835944879732,
                "sort": 0.19824297399731597,
                "stuff": 0.1536011480072767,
                "supposed": 0.17198986692519855,
                "team": 0.13728514710848042,
                "test": 0.26735050475335986,
                "usually": 0.14573675985308113,
                "want": 0.11009680171987492,
                "war": 0.18979136125271526,
                "work": 0.10334560942512253,
                "yes": 0.14818117101599176
            },
            "Max term": "person",
            "Max score": 0.3132655675211849
        }
    },
    {
        "ID:": "38",
        "Question": "Where waterfall commonly includes:  Requirements Functional design Technical design Build Test Review (Deploy)  And iterations across this list. If I forgot a step, let me know. ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "build": 0.29601601904817615,
                    "commonly": 0.31732340375424206,
                    "design": 0.4258414455141715,
                    "functional": 0.2673936845289276,
                    "know": 0.1754285958989356,
                    "let": 0.2875600323624442,
                    "list": 0.23278334898622569,
                    "requirements": 0.2801013235020038,
                    "review": 0.31732340375424206,
                    "step": 0.30577773927437896,
                    "technical": 0.26188361659006903,
                    "test": 0.2234995618446177
                },
                "Max term": "design",
                "Max score": 0.4258414455141715
            }
        ],
        "Best Answer": "It depends on many factors, including:  The domain (eg, I'd spend more time on a defense contract's requirements than I would on a Twitter clone) The developers (if they have experience building similar systems with similar technology, for example, I might spend less time on the design). The customers (How likely the requirements are to change affects how long that phase will take) The criticality of the system (I'll spend more time testing the space shuttle's launch system than I will the StackExchange rep system).  I'd give you a rough breakdown of what percent of the total effort I'd give to each section, but it'd have a margin of error +/- 10% on each based on the above factors so it'd be kinda meaningless. ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "10": 0.14183457998297433,
                "based": 0.13004303328938838,
                "building": 0.16068268127954324,
                "change": 0.11622945002156451,
                "contract": 0.16068268127954324,
                "customers": 0.1548363166438759,
                "depends": 0.1456114376757881,
                "design": 0.10781641766039902,
                "developers": 0.11787423250163707,
                "domain": 0.16068268127954324,
                "effort": 0.1498932857760304,
                "error": 0.14183457998297433,
                "example": 0.10217626742122983,
                "experience": 0.11174781169155769,
                "factors": 0.3356761066095549,
                "including": 0.16783805330477744,
                "likely": 0.13539982768053244,
                "long": 0.10907407799633029,
                "phase": 0.1548363166438759,
                "requirements": 0.28366915996594866,
                "rough": 0.16783805330477744,
                "section": 0.16068268127954324,
                "similar": 0.26521940202977307,
                "space": 0.1498932857760304,
                "spend": 0.42550373994892304,
                "systems": 0.1548363166438759,
                "testing": 0.1254543289896523,
                "time": 0.2586374004078516,
                "twitter": 0.16068268127954324
            },
            "Max term": "spend",
            "Max score": 0.42550373994892304
        }
    },
    {
        "ID:": "39",
        "Question": "What's your favourite quote about programming? One quote per answer, and please check for duplicates before posting! ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "answer": 0.37933870912174267,
                    "check": 0.43870424261910873,
                    "favourite": 0.5552479607013989,
                    "posting": 0.5315762983647503,
                    "programming": 0.26975372550460147
                },
                "Max term": "favourite",
                "Max score": 0.5552479607013989
            }
        ],
        "Best Answer": " Debugging is twice as hard as writing the code in the first place. Therefore, if you write the code as cleverly as possible, you are, by definition, not smart enough to debug it.    — Brian W. Kernighan ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "code": 0.40851829847944604,
                "definition": 0.47253449505536155,
                "hard": 0.38242963449161704,
                "place": 0.38242963449161704,
                "possible": 0.34180674630984414,
                "write": 0.29458356784772927,
                "writing": 0.33720582712436786
            },
            "Max term": "definition",
            "Max score": 0.47253449505536155
        }
    },
    {
        "ID:": "42",
        "Question": "We've all had them, managers who have either come from sales or last looked at code 10 or more years ago but think they know how to write code. What can I do to give the impression that I'm grateful for their intervention, but keep it as short as possible so I can get on with my work? Or, should I be engaging more with the manager to educate them with modern coding techniques and practices? After all, a manager who understands these will be able to talk sensibly to clients and more senior management when discussing the project and its timescales. ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "10": 0.2020235274204182,
                    "able": 0.2020235274204182,
                    "ago": 0.21350202702856716,
                    "clients": 0.23906183927838687,
                    "code": 0.19786404798476195,
                    "coding": 0.15722527101560865,
                    "come": 0.197211306148582,
                    "know": 0.1265281552789969,
                    "management": 0.18184332086167024,
                    "manager": 0.44108536669880505,
                    "modern": 0.23906183927838687,
                    "possible": 0.16555259998168506,
                    "practices": 0.197211306148582,
                    "project": 0.13623665647889618,
                    "sales": 0.22887001231547893,
                    "senior": 0.22887001231547893,
                    "short": 0.21350202702856716,
                    "talk": 0.22054268334940252,
                    "techniques": 0.22054268334940252,
                    "think": 0.12462480244495364,
                    "work": 0.12462480244495364,
                    "write": 0.1426802603973886,
                    "years": 0.1678953626457931
                },
                "Max term": "manager",
                "Max score": 0.44108536669880505
            }
        ],
        "Best Answer": "I say, go ahead and try to engage and educate. If they're honestly trying to help you, the chance to learn something could be valuable to them.  If they're just shoving their nose in for ego or political reasons (\"See, I'm helping, I'm helping!\"), they'll likely get the notion you'll embarrass them if they keep this nonsense up -- or bore them to death with a wall of jargon they're only pretending to understand. And if you've got the dreaded egomaniac who truly thinks they're an expert at your job no matter what evidence you can bring to the contrary, then smile, nod, and make whatever trivial cosmetic changes will make them go the hell away.  And update your resume. ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "away": 0.23802235019608947,
                "bring": 0.266517660835266,
                "chance": 0.2458716132112081,
                "changes": 0.2198606693717489,
                "evidence": 0.2458716132112081,
                "expert": 0.2551553209068557,
                "got": 0.2198606693717489,
                "help": 0.1797128788810388,
                "job": 0.18208165103692475,
                "learn": 0.1752823101409944,
                "likely": 0.21500753041614562,
                "make": 0.2985427326030704,
                "matter": 0.23802235019608947,
                "reasons": 0.2198606693717489,
                "say": 0.15754673572574435,
                "trivial": 0.2458716132112081,
                "try": 0.17320367790823177,
                "trying": 0.18993091405204338,
                "understand": 0.1752823101409944,
                "update": 0.266517660835266
            },
            "Max term": "make",
            "Max score": 0.2985427326030704
        }
    },
    {
        "ID:": "44",
        "Question": "I am finishing my college degree in programming soon and I'm exploring the next steps to take to further my career. One option I've been considering is getting a certification or a series of certifications in the area of development I want to work in. Are these certifications worth the time and money? Do employers place a lot of value in them? ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "career": 0.2284825910617892,
                    "college": 0.287570712976386,
                    "considering": 0.287570712976386,
                    "degree": 0.287570712976386,
                    "development": 0.17756175712398103,
                    "getting": 0.2327355226017275,
                    "lot": 0.1907911211170828,
                    "money": 0.2682611387719853,
                    "option": 0.30037654505811545,
                    "place": 0.2327355226017275,
                    "programming": 0.14593064327741398,
                    "soon": 0.287570712976386,
                    "steps": 0.2605979973479193,
                    "time": 0.15429279838036888,
                    "value": 0.2538386275708911,
                    "want": 0.16681800245295025,
                    "work": 0.15658863706546294,
                    "worth": 0.22081944963772315
                },
                "Max term": "option",
                "Max score": 0.30037654505811545
            }
        ],
        "Best Answer": "The main purpose of certifications is to make money for the certifying body. Having said that, I think certifications are more important the earlier on in your career you are. As a hiring manager, I never use certifications or the lack thereof to filter potential employees, but I do think some companies may look for these as proof that you know what you are doing. Personally, I want the job candidate to show me they can do something (which is a whole other question, I realize!) The more experience you have, the more you can prove by examples that you know what you are doing and the less important certifications become. ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "body": 0.2202998335589359,
                "candidate": 0.2202998335589359,
                "career": 0.1675719280021949,
                "companies": 0.19674600162394498,
                "earlier": 0.2032340944969338,
                "examples": 0.18173380599603212,
                "experience": 0.14667725126388084,
                "hiring": 0.2202998335589359,
                "important": 0.31398856362636324,
                "job": 0.15050618894019283,
                "know": 0.23319599341008052,
                "lack": 0.2032340944969338,
                "look": 0.15699428181318162,
                "main": 0.18173380599603212,
                "make": 0.12338565875253185,
                "manager": 0.2032340944969338,
                "money": 0.19674600162394498,
                "personally": 0.1777222680709014,
                "potential": 0.19674600162394498,
                "prove": 0.2202998335589359,
                "purpose": 0.19112575993718578,
                "question": 0.13148245538714923,
                "realize": 0.21090787961778223,
                "said": 0.16466806693403002,
                "think": 0.2296880448909078,
                "use": 0.09983182681754099,
                "want": 0.1223463641873532
            },
            "Max term": "important",
            "Max score": 0.31398856362636324
        }
    },
    {
        "ID:": "49",
        "Question": "During my four years at university we have been using much functional programming in several functional programming languages. But I have also used much object oriented programming to, and in fact I use object oriented languages more when doing my own small project to prepare for my first job. But I often wish that I was coding in a functional programming language when doing these projects. However, when looking for a job, it is very rare to see a job where knowledge of a functional programming language is required. Why isn't functional programming languages used more in the industry? There is quite much news about functional programming languages these days, so I wonder if functional programming is catching on in the industry now? ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "coding": 0.07348273758717556,
                    "days": 0.09442020201953659,
                    "fact": 0.08827914011575275,
                    "functional": 0.6309558190378302,
                    "industry": 0.21393501118382377,
                    "job": 0.22899957511668115,
                    "knowledge": 0.08498853233035374,
                    "language": 0.11918968446584587,
                    "languages": 0.29044529143018444,
                    "looking": 0.08657049272392736,
                    "object": 0.21393501118382377,
                    "oriented": 0.18884040403907318,
                    "prepare": 0.10696750559191189,
                    "programming": 0.4342538706878649,
                    "project": 0.06367324039657121,
                    "projects": 0.08213807821196892,
                    "quite": 0.08827914011575275,
                    "required": 0.0997849348589309,
                    "small": 0.08213807821196892,
                    "university": 0.10696750559191189,
                    "use": 0.05063234959598797,
                    "used": 0.12515659601236068,
                    "using": 0.06542875212456516,
                    "wonder": 0.10696750559191189,
                    "years": 0.0784696429251484
                },
                "Max term": "functional",
                "Max score": 0.6309558190378302
            }
        ],
        "Best Answer": "I would say that one of the reasons that functional programming is not more prevalent is the lack of knowledge base.  My experience is that corporations are very risk averse in terms of implementing technologies that are not main stream and would rather invest in tried and true frameworks (java, c++, c#).  It's only when there is a business need (like in Ericsson) that new paradigms are considered.  But even in Ericsson's case I heard that management demanded that c++ be used and Joe Armstrong was compelled to code erlang calls in c++!! This should show how reluctant corporations are to implement new technologies! ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "base": 0.19464546770762092,
                "business": 0.17405377652772425,
                "calls": 0.1884315601695211,
                "case": 0.16670428382753238,
                "code": 0.08731493509014085,
                "considered": 0.1884315601695211,
                "erlang": 0.2019949604078128,
                "experience": 0.14047870385624225,
                "frameworks": 0.17830092291201466,
                "functional": 0.17021176528646717,
                "heard": 0.17830092291201466,
                "implement": 0.1884315601695211,
                "java": 0.14414583149382632,
                "knowledge": 0.16049037628943258,
                "lack": 0.19464546770762092,
                "like": 0.08778640955740791,
                "main": 0.17405377652772425,
                "management": 0.16049037628943258,
                "need": 0.12023907262090121,
                "new": 0.2426281717192393,
                "paradigms": 0.2019949604078128,
                "programming": 0.10250436912026029,
                "reasons": 0.17405377652772425,
                "risk": 0.2019949604078128,
                "say": 0.12472264553291082,
                "technologies": 0.38929093541524185,
                "terms": 0.2109900125032272,
                "tried": 0.1884315601695211,
                "true": 0.17830092291201466,
                "used": 0.11817140876754717
            },
            "Max term": "technologies",
            "Max score": 0.38929093541524185
        }
    },
    {
        "ID:": "57",
        "Question": "The coding standards for the code hosted in drupal.org suggest to use two spaces to indent the code; other sites suggest to use tabs to indent the code. What is the proper indentation character for everything, and in every situation? Please explain the answer you give. ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "answer": 0.18477875382324319,
                    "character": 0.2495136112340296,
                    "code": 0.3357837974691194,
                    "coding": 0.1778786970057957,
                    "explain": 0.18995043320856705,
                    "indent": 0.5409309610339524,
                    "org": 0.2704654805169762,
                    "proper": 0.2589348347845188,
                    "sites": 0.23464802340285928,
                    "situation": 0.22856174195108298,
                    "spaces": 0.2704654805169762,
                    "standards": 0.22311737767040182,
                    "use": 0.2451301262909969
                },
                "Max term": "indent",
                "Max score": 0.5409309610339524
            }
        ],
        "Best Answer": "Tabs Now, of course, consistency matters more than either one, and a good IDE makes the differences negligible.  That said, the point of this thread is to be a holy war, so: I prefer tabs:  They're a character specifically meant for indentation They allow developers with different preferences in indentation size to change how it's the code looks without changing the code (separation of data and presentation for the proverbial win!) It's impossible to half-indent something with tabs.  So when you copy code from some website that used 3 spaces into your 4-space indented file, you don't have to deal with misalignment.  ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "allow": 0.1926690289873356,
                "change": 0.13936670148307936,
                "changing": 0.1926690289873356,
                "character": 0.1856588559650154,
                "code": 0.24985104171825162,
                "consistency": 0.20124878736058932,
                "copy": 0.1856588559650154,
                "course": 0.17006892456944153,
                "data": 0.13936670148307936,
                "deal": 0.1856588559650154,
                "developers": 0.14133890309689015,
                "different": 0.13936670148307936,
                "file": 0.1559300899817885,
                "good": 0.10993484432487866,
                "half": 0.20124878736058932,
                "ide": 0.1745976236084612,
                "impossible": 0.20124878736058932,
                "indent": 0.20124878736058932,
                "looks": 0.17973183912674545,
                "makes": 0.1456154733519439,
                "meant": 0.20124878736058932,
                "point": 0.14341776081731344,
                "prefer": 0.17973183912674545,
                "said": 0.1504279338396336,
                "size": 0.17973183912674545,
                "space": 0.17973183912674545,
                "spaces": 0.20124878736058932,
                "specifically": 0.1856588559650154,
                "used": 0.11271553773095126,
                "war": 0.1926690289873356,
                "website": 0.1745976236084612,
                "win": 0.1856588559650154
            },
            "Max term": "code",
            "Max score": 0.24985104171825162
        }
    },
    {
        "ID:": "73",
        "Question": "We often receive last minute requests from the business asking for an extra feature to be implemented.  The project manager is usually responsible for filtering out these requests as \"must haves\" or \"nice to have\", but there are cases where the business wants to squeeze all these features into a release.   Is there a good way to say NO to the business?  What steps can be taken to stop or minimize scope creep? ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "asking": 0.181659201066823,
                    "business": 0.5572788097252098,
                    "cases": 0.18575960324173663,
                    "extra": 0.20773616967978048,
                    "feature": 0.17128400899071147,
                    "features": 0.17791582716717255,
                    "good": 0.12300756328422391,
                    "implemented": 0.18575960324173663,
                    "manager": 0.20773616967978048,
                    "minute": 0.22517995180831704,
                    "nice": 0.1953596092957091,
                    "project": 0.12832564090130633,
                    "release": 0.20110435150331937,
                    "say": 0.1331107523872823,
                    "scope": 0.22517995180831704,
                    "steps": 0.1953596092957091,
                    "stop": 0.22517995180831704,
                    "taken": 0.20110435150331937,
                    "usually": 0.16553926678310119,
                    "wants": 0.1953596092957091,
                    "way": 0.12611891821652077
                },
                "Max term": "business",
                "Max score": 0.5572788097252098
            }
        ],
        "Best Answer": "Ask them what they want you to drop so you'll have the time to squeeze this latest request in. I've not had to do this for a while, and when I did, I used it sparingly otherwise it loses it's potency. I found it most effective towards the end of the phase when you were tidying stuff up or doing the little improvements and tweaks you'd agreed on in the planning stage. ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "ask": 0.25343169383266817,
                "drop": 0.3245968825006288,
                "effective": 0.30280110391006804,
                "end": 0.2453239575780561,
                "little": 0.28652162216016536,
                "phase": 0.3127865758789833,
                "planning": 0.3127865758789833,
                "request": 0.33905152959780127,
                "stage": 0.33905152959780127,
                "stuff": 0.2627013867364123,
                "time": 0.17415876891009552,
                "used": 0.1898961776532008,
                "want": 0.18829665573648435
            },
            "Max term": "request",
            "Max score": 0.33905152959780127
        }
    },
    {
        "ID:": "94",
        "Question": "I realize there have been lots of discussions about this type of thing and they often devolve into dogma around whether you ask the \"100 logical pirates\" type of questions or whether you get them to write \"fizz buzz\".  I'm interested in what techniques and questions have been effective for you when interviewing potential developers for jobs.  One technique per answer so we can vote on them, please. ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "100": 0.22828579800685514,
                    "answer": 0.17463341142176908,
                    "ask": 0.19106554011772212,
                    "developers": 0.17952113793334998,
                    "effective": 0.22828579800685514,
                    "interested": 0.21086703965615927,
                    "interviewing": 0.23581397874154603,
                    "jobs": 0.2447179267028082,
                    "logical": 0.23581397874154603,
                    "lots": 0.22176459123333425,
                    "potential": 0.22828579800685514,
                    "questions": 0.37582740837337064,
                    "realize": 0.2447179267028082,
                    "techniques": 0.23581397874154603,
                    "thing": 0.19106554011772212,
                    "type": 0.4039261833897942,
                    "write": 0.15256003682009792
                },
                "Max term": "type",
                "Max score": 0.4039261833897942
            }
        ],
        "Best Answer": "Besides real technical questions, and typically at the end of the interview I try to get a grasp of their level of interest in the industry and it's culture with questions like:  Have you seen anything recently programming-related that you found interesting and would like to recommend to other fellow programmers? A new language, tool, platform, technique, website? Can you name any well known person in our industry whose work you like or find inspiring and why? (developer, web site founder, author, speaker, etc) What are you reading now or what was the last software related book you read? What programming related sites do you frequent?  Although failing to answer these questions at all (sadly it happens very frequently) does not mean a 'no-hire' to me, they say a lot about the way a person approaches the software development profession. ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "answer": 0.10333566219124407,
                "approaches": 0.13953798101301934,
                "author": 0.14480670565856393,
                "book": 0.11505278465094393,
                "developer": 0.10199132772418115,
                "development": 0.08941151494165231,
                "end": 0.10944206808865696,
                "frequently": 0.12782085855331948,
                "happens": 0.14480670565856393,
                "hire": 0.1512551034727192,
                "industry": 0.28961341131712787,
                "interesting": 0.11719435532521646,
                "interview": 0.13122455032571456,
                "known": 0.1512551034727192,
                "language": 0.08067620844515556,
                "level": 0.11719435532521646,
                "like": 0.18879769194147725,
                "lot": 0.09607318294661497,
                "mean": 0.1247761525115593,
                "new": 0.0869679772596556,
                "person": 0.2390148557320294,
                "platform": 0.14480670565856393,
                "programmers": 0.09400816325668715,
                "programming": 0.14696723104325735,
                "questions": 0.3335819915361297,
                "read": 0.11119399717870992,
                "reading": 0.11719435532521646,
                "real": 0.11119399717870992,
                "recently": 0.13508333779794857,
                "recommend": 0.14480670565856393,
                "related": 0.39367365097714374,
                "say": 0.08941151494165231,
                "seen": 0.10944206808865696,
                "site": 0.12782085855331948,
                "sites": 0.13122455032571456,
                "software": 0.17714766737956805,
                "technical": 0.1195074278660147,
                "tool": 0.1247761525115593,
                "try": 0.09829720155039938,
                "way": 0.08471504621755001,
                "web": 0.10779030540631485,
                "website": 0.13122455032571456,
                "work": 0.07885046582916866
            },
            "Max term": "related",
            "Max score": 0.39367365097714374
        }
    },
    {
        "ID:": "104",
        "Question": "We've often run across scenarios where the business will promise a client a new feature.  The business will promise that the feature be implemented in a specific way.  These technical details promised by the business are usually poor.  Unfortunately, client is now set and want this feature to be implemented in the way described by the business. In the end, the business just wants this feature to be completed without regard to quality and maintainability.  Is there a good way to push back?  How can we explain to the business that providing technical details before the requirements have been gathered is a bad idea? ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "bad": 0.09483290996366835,
                    "business": 0.6170847062576285,
                    "client": 0.2300299437352412,
                    "completed": 0.1246728764774494,
                    "details": 0.21071413451558355,
                    "end": 0.09020824503098296,
                    "explain": 0.0875589256380659,
                    "feature": 0.3793316398546734,
                    "good": 0.06810422784076492,
                    "idea": 0.09850467488632296,
                    "implemented": 0.20569490208587615,
                    "new": 0.07168384826329026,
                    "poor": 0.1246728764774494,
                    "promise": 0.2387154960484714,
                    "push": 0.1246728764774494,
                    "quality": 0.10057722702985171,
                    "requirements": 0.10535706725779177,
                    "run": 0.10535706725779177,
                    "scenarios": 0.1193577480242357,
                    "set": 0.09165228251485416,
                    "specific": 0.09850467488632296,
                    "technical": 0.19700934977264592,
                    "unfortunately": 0.1246728764774494,
                    "usually": 0.09165228251485416,
                    "want": 0.06923869575105367,
                    "wants": 0.10816257949615178,
                    "way": 0.20948057124102848
                },
                "Max term": "business",
                "Max score": 0.6170847062576285
            }
        ],
        "Best Answer": "That's an organizational issue.  If the higher-ups don't understand this, there's not much you can do.  Try to explain the issue to your non-technical bosses, but don't be surprised when you get nowhere. It's is a common problem for developers working in non-development companies that, for whatever reason, sell software. It's not a pleasant tactic, but you can just bludgeon them with evidence.  At the start of a project, write down exactly why it's going to fail (because technical details were poor) and email it to relevant people.  Keep emailing them throughout, and when the project eventually ends up a disaster with pissed off customers, cite those emails you sent at every opportunity.  It may generate some ill will, but there's really no good way to try to fix a systemic issue like that. ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "common": 0.11830835828278385,
                "companies": 0.1504453363675392,
                "customers": 0.1554065722076776,
                "details": 0.1423569507040552,
                "developers": 0.11830835828278385,
                "development": 0.09957960515195696,
                "email": 0.1554065722076776,
                "emails": 0.1612744687554555,
                "ends": 0.16845619371129997,
                "eventually": 0.16845619371129997,
                "evidence": 0.1554065722076776,
                "exactly": 0.1554065722076776,
                "explain": 0.11830835828278385,
                "fail": 0.1612744687554555,
                "fix": 0.1358984994827699,
                "generate": 0.16845619371129997,
                "going": 0.12004847539575003,
                "good": 0.09202145103131186,
                "higher": 0.1504453363675392,
                "issue": 0.3915659287376639,
                "like": 0.07008940488780734,
                "non": 0.2366167165655677,
                "opportunity": 0.1554065722076776,
                "organizational": 0.16845619371129997,
                "people": 0.08716731787469548,
                "poor": 0.16845619371129997,
                "problem": 0.10582838575092886,
                "project": 0.19199976594895732,
                "really": 0.09685818255100954,
                "reason": 0.12591637194352795,
                "relevant": 0.13309809689937238,
                "sell": 0.16845619371129997,
                "software": 0.0986466607950844,
                "start": 0.11508723955561166,
                "technical": 0.26619619379874476,
                "try": 0.21895158636600132,
                "understand": 0.1107896215910672,
                "way": 0.09434904283053992,
                "working": 0.1107896215910672,
                "write": 0.10054040267084237
            },
            "Max term": "issue",
            "Max score": 0.3915659287376639
        }
    },
    {
        "ID:": "134",
        "Question": "How do you bill your programming projects? Do you do it per hour? Per job?  Please include what kind of project you are doing in the answer. (Mobile, Web, Desktop, etc... You can be more specific if you want.) BONUS: If you'd like to give specific amounts in your answer, you may. ;-) ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "answer": 0.4300267031586935,
                    "desktop": 0.2730425273978192,
                    "include": 0.2730425273978192,
                    "job": 0.21501335157934676,
                    "kind": 0.2730425273978192,
                    "like": 0.13094551501382745,
                    "mobile": 0.30130329118314764,
                    "programming": 0.1528993778569144,
                    "project": 0.17935312958474078,
                    "projects": 0.2313644051039396,
                    "specific": 0.4973247775108584,
                    "want": 0.1747841866351657,
                    "web": 0.22428225011303923
                },
                "Max term": "specific",
                "Max score": 0.4973247775108584
            }
        ],
        "Best Answer": "There's always going to be a struggle between you and the client over costs: you want to charge as much as you can from a client, and a client is going to want to get as much work for as little cost as possible. So, when you charge hourly, it leaves open to negotiation how many hours a project should take to complete. You may think it'll take 10 hours, but your client thinks you should do it in 5. By charging by project, there's very little open to negotiation: it costs $X, and the client can take it or leave it. ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "10": 0.1244357079981822,
                "charge": 0.2944986616736714,
                "client": 0.6792125970875448,
                "complete": 0.1244357079981822,
                "cost": 0.12774925791717992,
                "costs": 0.2944986616736714,
                "going": 0.2098712701570528,
                "hours": 0.26301170196933876,
                "leave": 0.1244357079981822,
                "little": 0.2488714159963644,
                "open": 0.2240115561300272,
                "possible": 0.10197156367233468,
                "project": 0.1678290149738589,
                "think": 0.0767622252931915,
                "want": 0.16355364383049315,
                "work": 0.0767622252931915
            },
            "Max term": "client",
            "Max score": 0.6792125970875448
        }
    },
    {
        "ID:": "135",
        "Question": "Who in the software engineering and software development fields uses Twitter to tweet about relevant happenings in the field? ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "development": 0.24583051829171562,
                    "engineering": 0.39813560398110887,
                    "field": 0.3836496251763007,
                    "relevant": 0.32857706248668217,
                    "software": 0.48705474808816485,
                    "twitter": 0.39813560398110887,
                    "uses": 0.36079244647872405
                },
                "Max term": "software",
                "Max score": 0.48705474808816485
            }
        ],
        "Best Answer": "I'll probably get flamed for this but... 140 characters is hardly the format to get any real pearls of programming wisdom.  Most (but not all) programming concepts/thoughts/ideas require more space to be articulated. I would follow the blogs of the list of programmers that everyone is suggesting. ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "characters": 0.31012050598113455,
                "concepts": 0.31012050598113455,
                "follow": 0.27374332665894846,
                "format": 0.2988369155871635,
                "hardly": 0.3239305045153786,
                "list": 0.22749941894453243,
                "probably": 0.2381349572887476,
                "programmers": 0.20132948279523785,
                "programming": 0.3147475239250828,
                "real": 0.2381349572887476,
                "require": 0.24639900223004002,
                "space": 0.28929677584335545,
                "wisdom": 0.2988369155871635
            },
            "Max term": "hardly",
            "Max score": 0.3239305045153786
        }
    },
    {
        "ID:": "163",
        "Question": "Are there any great programming or software development books that are language agnostic?  Why should I read it? ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "agnostic": 0.4860681199705606,
                    "books": 0.4095870143622821,
                    "development": 0.3001248234586737,
                    "great": 0.37950169457330235,
                    "language": 0.27080329455012836,
                    "programming": 0.24666014382963883,
                    "read": 0.3732413973155734,
                    "software": 0.29731300511518993
                },
                "Max term": "agnostic",
                "Max score": 0.4860681199705606
            }
        ],
        "Best Answer": "The Pragmatic Programmer: From Journeyman to Master - Andrew Hunt and David Thomas This book is all about how to write code that works and is maintainable. A key concept is being practical. Everything in the book is boiled down to 70 tips that are easy to remember that help you deliver better, higher-quality software. ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "better": 0.17020129987810437,
                "book": 0.4030746649100853,
                "code": 0.10964656889966348,
                "concept": 0.23662474264762293,
                "deliver": 0.253657112851028,
                "easy": 0.19804488344836696,
                "help": 0.17865764992512823,
                "higher": 0.23662474264762293,
                "key": 0.253657112851028,
                "maintainable": 0.253657112851028,
                "master": 0.253657112851028,
                "pragmatic": 0.2649527359688568,
                "programmer": 0.17020129987810437,
                "quality": 0.2137450601177085,
                "remember": 0.22390309754869528,
                "software": 0.15515429914463358,
                "tips": 0.23662474264762293,
                "works": 0.23662474264762293,
                "write": 0.1581328307150475
            },
            "Max term": "book",
            "Max score": 0.4030746649100853
        }
    },
    {
        "ID:": "188",
        "Question": "For the longest time in places like Java's IRC channel, SO, and other places I've been told something along the lines of \"Worry about how the code looks and its readability/understandability now, and performance later if absolutely necessary\". So for the longest time, I haven't really been OCD about performance for my small desktop or web apps, just removing the obviously inefficient. Most responses are \"What about scalability?\". Thats a legitimate point, but if my app was only built to parse, say, files 10,000 lines long, should I make my code a mess for the small percentage of people that are going to shove in a 1,000,000 line file? My main question is when should I trade the easy but somewhat inefficient ways of doing tasks for big giant complicated beasts that do things extremely quickly but destroy any possible ways of upgrading and make the code excessively difficult and prone to rewriting anyway by the next developer?  ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "000": 0.4193199738376897,
                    "10": 0.11811797383783487,
                    "absolutely": 0.13381442484511552,
                    "app": 0.1127591967032037,
                    "apps": 0.11530439151132822,
                    "big": 0.10829812874767573,
                    "built": 0.12894564922519905,
                    "code": 0.17352904937657856,
                    "complicated": 0.12894564922519905,
                    "desktop": 0.12126329127877594,
                    "developer": 0.0942491633694164,
                    "difficult": 0.12126329127877594,
                    "easy": 0.10447671612396404,
                    "extremely": 0.12482915809307972,
                    "file": 0.10829812874767573,
                    "files": 0.11811797383783487,
                    "going": 0.09960794050404759,
                    "java": 0.09549144937192826,
                    "later": 0.12126329127877594,
                    "like": 0.05815535140295478,
                    "line": 0.10631912475929244,
                    "lines": 0.24965831618615944,
                    "long": 0.09083545841009319,
                    "looks": 0.12482915809307972,
                    "main": 0.11530439151132822,
                    "make": 0.15656864968750722,
                    "necessary": 0.12894564922519905,
                    "obviously": 0.12126329127877594,
                    "parse": 0.13977332461256325,
                    "people": 0.07232542507630589,
                    "performance": 0.24965831618615944,
                    "places": 0.24965831618615944,
                    "point": 0.09960794050404759,
                    "possible": 0.09679435817754092,
                    "question": 0.08342148798205222,
                    "quickly": 0.12126329127877594,
                    "readability": 0.12894564922519905,
                    "really": 0.08036623583153553,
                    "say": 0.0826242845041898,
                    "small": 0.20550651588997726,
                    "somewhat": 0.12894564922519905,
                    "tasks": 0.1127591967032037,
                    "things": 0.07635304979264683,
                    "time": 0.14359321823365123,
                    "told": 0.13381442484511552,
                    "ways": 0.2255183934064074,
                    "web": 0.09960794050404759
                },
                "Max term": "000",
                "Max score": 0.4193199738376897
            }
        ],
        "Best Answer": "Worry about performance when it becomes a problem. If you write a small app to process 10,000 line files and you get a 1,000,000 line file every 100th file, it probably doesn't matter that it takes longer to process that one file. However, if you are regularly getting files that are 5-10 times larger than initially and your application is taking too long to do its job, then you start profiling and optimizing. Now, I said \"too long to do its job\". That is up to the user or sponsoring organization to decide. If I'm doing a task and it takes me 5 minutes to do something when it took me 3 without the software or with a different tool, I'd probably file a bug report or maintenance request to have that improved. If you are the user, how long you want your software to take to do its job is up to you - only you can decide if you want it done faster or if you are willing to wait longer to have more readable code. ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "000": 0.35864739818273433,
                "10": 0.20205431001936247,
                "app": 0.09644375427351565,
                "application": 0.08788560268067337,
                "bug": 0.09862067775142135,
                "code": 0.049473549199545434,
                "decide": 0.22057628773725935,
                "different": 0.08278891272796897,
                "faster": 0.1067672793110344,
                "file": 0.37051268269369103,
                "files": 0.20205431001936247,
                "getting": 0.09262817067342276,
                "initially": 0.11445244277487372,
                "job": 0.24502357628590082,
                "line": 0.1818710285751641,
                "long": 0.23307666832579368,
                "longer": 0.22890488554974744,
                "matter": 0.1067672793110344,
                "organization": 0.1067672793110344,
                "performance": 0.1067672793110344,
                "probably": 0.17577120536134674,
                "problem": 0.07510374926412967,
                "process": 0.17300182305942893,
                "readable": 0.11954913272757811,
                "report": 0.11028814386862967,
                "request": 0.11954913272757811,
                "said": 0.08935968889247291,
                "small": 0.08788560268067337,
                "software": 0.14001411862285054,
                "start": 0.08167452542863361,
                "takes": 0.18525634134684552,
                "task": 0.09262817067342276,
                "times": 0.09262817067342276,
                "took": 0.11445244277487372,
                "tool": 0.09862067775142135,
                "user": 0.16792094508997138,
                "wait": 0.11445244277487372,
                "want": 0.13278631667288626,
                "willing": 0.11445244277487372,
                "write": 0.07135100039111486
            },
            "Max term": "file",
            "Max score": 0.37051268269369103
        }
    },
    {
        "ID:": "192",
        "Question": "If I have some code that has 80% test coverage (all tests pass), is it fair to say that it's of higher quality than code with no test coverage?   Or is it fair to say it's more maintainable? ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "80": 0.2944616694240278,
                    "code": 0.24371676409944043,
                    "coverage": 0.5638160076986126,
                    "higher": 0.26297866482586535,
                    "maintainable": 0.2819080038493063,
                    "quality": 0.23755077298313962,
                    "say": 0.3481305866839592,
                    "test": 0.397111051976534,
                    "tests": 0.22815260261522433
                },
                "Max term": "coverage",
                "Max score": 0.5638160076986126
            }
        ],
        "Best Answer": "By one definition it's more maintainable, as any breaking change is more likely to be caught by the tests. However, the fact that code passes the unit tests doesn't mean it's intrinsically of higher quality. The code might still be badly formatted with irrelevant comments and inappropriate data structures, but it can still pass the tests. I know which code I'd prefer to maintain and extend. ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "caught": 0.22189078183013447,
                "change": 0.15366147920066098,
                "code": 0.275478146800467,
                "comments": 0.18304624041687054,
                "data": 0.15366147920066098,
                "definition": 0.21243100163308007,
                "fact": 0.17531703720979694,
                "higher": 0.19816685022874025,
                "irrelevant": 0.21243100163308007,
                "know": 0.11744003720178658,
                "likely": 0.17900573220509125,
                "maintain": 0.22189078183013447,
                "maintainable": 0.21243100163308007,
                "mean": 0.18304624041687054,
                "passes": 0.22189078183013447,
                "prefer": 0.19816685022874025,
                "quality": 0.17900573220509125,
                "structures": 0.21243100163308007,
                "tests": 0.5157713002499994,
                "unit": 0.16878208901253075
            },
            "Max term": "tests",
            "Max score": 0.5157713002499994
        }
    },
    {
        "ID:": "206",
        "Question": "Test driven development. I get it, like it. But writing tests does require overhead. So should TDD be used universally throughout the code base, or are there areas where TDD provides a high ROI and other areas where the ROI is so low that it is not worth following. ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "areas": 0.4495088323131978,
                    "base": 0.2247544161565989,
                    "code": 0.10082134194572662,
                    "development": 0.14401550525883772,
                    "driven": 0.2058815974562946,
                    "following": 0.21136393818910415,
                    "high": 0.2175793034903509,
                    "like": 0.10136574695998836,
                    "low": 0.21136393818910415,
                    "overhead": 0.24362723485690319,
                    "provides": 0.24362723485690319,
                    "require": 0.1853160068225519,
                    "tdd": 0.4227278763782083,
                    "test": 0.16427786291064284,
                    "tests": 0.18876544376480853,
                    "universally": 0.23324077322585285,
                    "used": 0.13645088322245572,
                    "worth": 0.1791006415213051,
                    "writing": 0.1664431881222476
                },
                "Max term": "areas",
                "Max score": 0.4495088323131978
            }
        ],
        "Best Answer": "I'd say avoid TDD in places where the code is likely to change structurally a lot.  Ie, it's great to have a pile of tests for a method whose signature changes rarely but gets refactored internally more frequently, but it sucks to have to fix your tests every time a highly volatile interface changes dramatically. The apps I've been working on recently have been data-driven webapps built on a Gui->Presenter->BusinessLogic->Data Access Layer-based architecture.  My data access layer is tested like nobody's business.  The business logic layer is pretty well tested.  The Presenters are only tested in the more stable areas, and the GUI, which is changing hourly, has almost no tests. ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "access": 0.23090592462209195,
                "apps": 0.1180589606583925,
                "architecture": 0.14311244537382706,
                "areas": 0.13202610177647078,
                "avoid": 0.11545296231104597,
                "based": 0.11088532148355548,
                "built": 0.13202610177647078,
                "business": 0.236117921316785,
                "change": 0.09910673109891008,
                "changes": 0.236117921316785,
                "changing": 0.13701119021787492,
                "code": 0.059224859651666725,
                "data": 0.2973201932967302,
                "driven": 0.12093975817911454,
                "fix": 0.11545296231104597,
                "frequently": 0.12093975817911454,
                "gets": 0.12416021581434462,
                "great": 0.10697261706103624,
                "gui": 0.26405220355294157,
                "interface": 0.14311244537382706,
                "like": 0.05954465613464423,
                "likely": 0.11545296231104597,
                "logic": 0.13701119021787492,
                "lot": 0.09090118502227586,
                "method": 0.12416021581434462,
                "places": 0.1278112695550133,
                "pretty": 0.1035503704095612,
                "rarely": 0.14311244537382706,
                "recently": 0.1278112695550133,
                "say": 0.08459814085007877,
                "stable": 0.14311244537382706,
                "tdd": 0.12416021581434462,
                "tested": 0.4110335706536248,
                "tests": 0.3326559644506664,
                "time": 0.07351179725272253,
                "working": 0.09412164265750594
            },
            "Max term": "tested",
            "Max score": 0.4110335706536248
        }
    },
    {
        "ID:": "215",
        "Question": "Having taken a course in Operating Systems I'm interested in expanding my knowledge of the Linux kernel and practice working with a big system. What are some interesting but not overly difficult projects I can try my hand at?  EDIT: a bit of background on what I did do with the kernel.   Implemented a new scheduling policy Implemented User Threads and a corresponding mutex library (not really kernel hacking but contained kernel related theory)  ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "background": 0.1493678217413022,
                    "big": 0.133397794329294,
                    "bit": 0.133397794329294,
                    "course": 0.14549353126242814,
                    "difficult": 0.1493678217413022,
                    "edit": 0.13889277963053628,
                    "hand": 0.15883067781417745,
                    "implemented": 0.28405572066585993,
                    "interested": 0.14202786033292997,
                    "interesting": 0.133397794329294,
                    "kernel": 0.688671297463707,
                    "knowledge": 0.13096012739938528,
                    "library": 0.13889277963053628,
                    "new": 0.09899227920597659,
                    "practice": 0.14549353126242814,
                    "projects": 0.12656781911667764,
                    "really": 0.09899227920597659,
                    "related": 0.1493678217413022,
                    "systems": 0.15883067781417745,
                    "taken": 0.1537601300240098,
                    "theory": 0.16482786295755453,
                    "threads": 0.17216782436592676,
                    "try": 0.11188789629993313,
                    "user": 0.12091507115944725,
                    "working": 0.11323067256492833
                },
                "Max term": "kernel",
                "Max score": 0.688671297463707
            }
        ],
        "Best Answer": "I've not done much work on kernels before (they scare me), but I've heard that http://kernelnewbies.org/ is a fantastic resource if you want to get involved in kernel work. As already mentioned SourceForge is a great place to look if you want to get involved in an open-source kernel-related project. Also, a similar question has been asked on Stack Overflow before, so you may want to look here. What are some interesting, small Linux kernel projects to help learn the source? ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "asked": 0.12751445391450023,
                "great": 0.12965322627979284,
                "heard": 0.1465817165571762,
                "help": 0.11696106614336099,
                "http": 0.15491014343669468,
                "interesting": 0.13439551235071678,
                "involved": 0.30982028687338936,
                "kernel": 0.5203665416427146,
                "learn": 0.11407755525263588,
                "look": 0.24722237314794776,
                "mentioned": 0.16606065492485952,
                "open": 0.13193961345349237,
                "org": 0.17345551388090488,
                "overflow": 0.15048498389770254,
                "place": 0.13439551235071678,
                "project": 0.09884889755008122,
                "projects": 0.12751445391450023,
                "question": 0.10352416748149668,
                "related": 0.15048498389770254,
                "resource": 0.17345551388090488,
                "similar": 0.1370480852358382,
                "small": 0.12751445391450023,
                "source": 0.26387922690698473,
                "stack": 0.15048498389770254,
                "want": 0.2889922946659923,
                "work": 0.18084742605215975
            },
            "Max term": "kernel",
            "Max score": 0.5203665416427146
        }
    },
    {
        "ID:": "220",
        "Question": "How would someone implement Agile process concepts as a solo developer?  Agile seems useful for getting applications developed at a faster pace, but it also seems very team oriented... ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "agile": 0.5630821488217543,
                    "applications": 0.24112610342512322,
                    "concepts": 0.292171602290905,
                    "developer": 0.2057844593966045,
                    "faster": 0.272553091155113,
                    "getting": 0.2364590950335809,
                    "implement": 0.272553091155113,
                    "oriented": 0.2578998319164776,
                    "process": 0.2208175667423048,
                    "solo": 0.292171602290905,
                    "team": 0.21134166031939708,
                    "useful": 0.2174848609307236
                },
                "Max term": "agile",
                "Max score": 0.5630821488217543
            }
        ],
        "Best Answer": " By doing test-driven development By developing in small sprints By having a lot of contact with the customer  I remember reading a thesis about Cowboy Development, that is essentially Agile for solo developers. The thesis can be read here: Cowboy: An Agile Programming Methodology For a Solo Programmer (PDF) ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "agile": 0.4618283556552689,
                "customer": 0.21152411872225826,
                "developers": 0.1757910035265329,
                "developing": 0.21715671195239797,
                "development": 0.2959249705519033,
                "driven": 0.21152411872225826,
                "essentially": 0.23963311736577075,
                "lot": 0.15898653463626944,
                "programmer": 0.16079134391729016,
                "programming": 0.12160422946348691,
                "read": 0.1840091869717853,
                "reading": 0.19393886889790282,
                "remember": 0.21152411872225826,
                "small": 0.1840091869717853,
                "solo": 0.4792662347315415,
                "test": 0.1687801659161222
            },
            "Max term": "solo",
            "Max score": 0.4792662347315415
        }
    },
    {
        "ID:": "221",
        "Question": " Possible Duplicate: Using “Foo” and “Bar” in examples   I know AT&T labs used them in their Unix days, but do they have even deeper histories? ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "days": 0.4328865060951509,
                    "examples": 0.4225751048463902,
                    "know": 0.27111857594391225,
                    "possible": 0.3547383193240723,
                    "unix": 0.5122504574951906,
                    "used": 0.28690153380175437,
                    "using": 0.2999699566360629
                },
                "Max term": "unix",
                "Max score": 0.5122504574951906
            }
        ],
        "Best Answer": "From the Jargon file:  When ‘foo’ is used in connection with ‘bar’ it has generally traced to the WWII-era Army slang acronym FUBAR (‘Fucked Up Beyond All Repair’ or ‘Fucked Up Beyond All Recognition’), later modified to foobar. Early versions of the Jargon File interpreted this change as a post-war bowdlerization, but it it now seems more likely that FUBAR was itself a derivative of ‘foo’ perhaps influenced by German furchtbar (terrible) — ‘foobar’ may actually have been the original form. For, it seems, the word ‘foo’ itself had an immediate prewar history in comic strips and cartoons. The earliest documented uses were in the Smokey Stover comic strip published from about 1930 to about 1952. Bill Holman, the author of the strip, filled it with odd jokes and personal contrivances, including other nonsense phrases such as “Notary Sojac” and “1506 nix nix”. The word “foo” frequently appeared on license plates of cars, in nonsense sayings in the background of some frames (such as “He who foos last foos best” or “Many smoke but foo men chew”), and Holman had Smokey say “Where there's foo, there's fire”.  ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "actually": 0.13402437216613217,
                "author": 0.185283467077113,
                "background": 0.16790479100679384,
                "best": 0.12292781849104818,
                "change": 0.13402437216613217,
                "connection": 0.1728421971739851,
                "documented": 0.17854201429036903,
                "early": 0.1728421971739851,
                "file": 0.29990567602197277,
                "filled": 0.19353433846228427,
                "form": 0.17854201429036903,
                "frequently": 0.16354969011845383,
                "generally": 0.15965391962162256,
                "history": 0.185283467077113,
                "including": 0.19353433846228427,
                "interpreted": 0.19353433846228427,
                "later": 0.16790479100679384,
                "license": 0.19353433846228427,
                "likely": 0.15612976653437644,
                "original": 0.16790479100679384,
                "personal": 0.15612976653437644,
                "post": 0.17854201429036903,
                "published": 0.19353433846228427,
                "say": 0.11440406305539541,
                "terrible": 0.19353433846228427,
                "used": 0.10839482471064174,
                "uses": 0.16790479100679384,
                "war": 0.185283467077113,
                "word": 0.370566934154226
            },
            "Max term": "word",
            "Max score": 0.370566934154226
        }
    },
    {
        "ID:": "247",
        "Question": "Does learning COBOL still make sense? ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "cobol": 0.6174630875738565,
                    "learning": 0.4529609972044048,
                    "make": 0.36122922459673285,
                    "sense": 0.5320517999148152
                },
                "Max term": "cobol",
                "Max score": 0.6174630875738565
            }
        ],
        "Best Answer": "I don't think so, unless you are already in the niche market where COBOL is still maintained. ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "cobol": 0.5433218484225307,
                "market": 0.5433218484225307,
                "think": 0.2958508077954321,
                "unless": 0.5675165526927293
            },
            "Max term": "unless",
            "Max score": 0.5675165526927293
        }
    },
    {
        "ID:": "252",
        "Question": "There is a widely accepted opinion that Singleton is an anti-pattern. As usual, there are always exceptions to the rule. Can you explain why Singleton is a bad choice in general and give an example of some valid use cases for it? ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "accepted": 0.3265077707540052,
                    "bad": 0.24835940985089322,
                    "cases": 0.2693488184162926,
                    "choice": 0.2693488184162926,
                    "example": 0.1987710453188462,
                    "explain": 0.22930945709648143,
                    "general": 0.2832686925024889,
                    "opinion": 0.3012145314111204,
                    "pattern": 0.3012145314111204,
                    "rule": 0.312587896667809,
                    "use": 0.14796137926166425,
                    "usual": 0.3265077707540052,
                    "valid": 0.3265077707540052
                },
                "Max term": "accepted",
                "Max score": 0.3265077707540052
            }
        ],
        "Best Answer": "The two main criticisms of Singletons fall into two camps from what I've observed:  Singletons are misused and abused by less capable programmers and so everything becomes a singleton and you see code littered with Class::get_instance() references. Generally speaking there are only one or two resources (like a database connection for example) that qualify for use of the Singleton pattern. Singletons are essentially static classes, relying on one or more static methods and properties. All things static present real, tangible problems when you try to do Unit Testing because they represent dead ends in your code that cannot be mocked or stubbed. As a result, when you test a class that relies on a Singleton (or any other static method or class) you are not only testing that class but also the static method or class.  As a result of both of these, a common approach is to use create a broad container object to hold a single instance of these classes and only the container object modifies these types of classes while many other classes can be granted access to them to use from the container object. ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "access": 0.0840562394670774,
                "approach": 0.08595355259573681,
                "class": 0.420281197335387,
                "classes": 0.3844896624455342,
                "code": 0.08623804683109905,
                "common": 0.07317634655734594,
                "connection": 0.09305378108327243,
                "create": 0.0840562394670774,
                "ends": 0.10419389626965438,
                "essentially": 0.09975183991897565,
                "example": 0.06343104676968418,
                "generally": 0.08595355259573681,
                "granted": 0.09975183991897565,
                "like": 0.04335185321234127,
                "main": 0.08595355259573681,
                "method": 0.18079121789283106,
                "methods": 0.08595355259573681,
                "object": 0.29925551975692694,
                "pattern": 0.09612241561138354,
                "problems": 0.0823241282881447,
                "programmers": 0.06475865333452806,
                "real": 0.07659732162317669,
                "references": 0.10419389626965438,
                "represent": 0.10419389626965438,
                "resources": 0.09975183991897565,
                "result": 0.18079121789283106,
                "single": 0.09039560894641553,
                "speaking": 0.09975183991897565,
                "static": 0.5209694813482719,
                "test": 0.07025795214383856,
                "testing": 0.15576414387493195,
                "things": 0.05691731073878837,
                "try": 0.06771320892181923,
                "types": 0.09039560894641553,
                "unit": 0.0792554937600336,
                "use": 0.1416505882886316
            },
            "Max term": "static",
            "Max score": 0.5209694813482719
        }
    },
    {
        "ID:": "262",
        "Question": "Will Java have the same importance it had in the past, or it will be less relevant than nowadays? ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "importance": 0.6039211659258445,
                    "java": 0.41259165581484764,
                    "past": 0.4872007282549792,
                    "relevant": 0.47716119004645485
                },
                "Max term": "importance",
                "Max score": 0.6039211659258445
            }
        ],
        "Best Answer": "Java is relevant and will continue to be relevant for many years in the Enterprise computing world.   Whether it continues to be relevant in other areas depends a lot on what Oracle does.  If they inject some life (and resources) into ME, desktop applications and other areas, and if they press on with the evolution of the Java language, then Java will do well.   But if Oracle cuts back on R&D and/or tries to stomp other players in the Java space, there's a good chance that someone / some company will develop a better (and more open) Java-like language.  If Oracle win their lawsuit against Google, I predict that the next generation of the Android platform will have a new language, just like happened with C#.  If Google get the openness right ... then, the game is on! ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "android": 0.15183627977634553,
                "applications": 0.11996661822447813,
                "areas": 0.28014827186760716,
                "better": 0.09753714032085768,
                "chance": 0.14007413593380358,
                "company": 0.1098625837283455,
                "computing": 0.1453631049072685,
                "depends": 0.13172876206702008,
                "desktop": 0.13172876206702008,
                "develop": 0.13560237638336117,
                "enterprise": 0.1453631049072685,
                "game": 0.12525558719794305,
                "good": 0.08294260054433546,
                "google": 0.26345752413404017,
                "happened": 0.14007413593380358,
                "java": 0.5186635741574689,
                "language": 0.24295858603507112,
                "life": 0.13172876206702008,
                "like": 0.1263487468812351,
                "lot": 0.09644233053939422,
                "new": 0.08730213938970724,
                "open": 0.11549485867403574,
                "platform": 0.1453631049072685,
                "relevant": 0.3598998546734344,
                "resources": 0.1453631049072685,
                "right": 0.1098625837283455,
                "space": 0.13560237638336117,
                "win": 0.14007413593380358,
                "world": 0.10514806948861759,
                "years": 0.10663603749049871
            },
            "Max term": "java",
            "Max score": 0.5186635741574689
        }
    },
    {
        "ID:": "294",
        "Question": "I just started working a year ago, and I want to join an open source project for the same reasons as anyone else: help create something useful and develop my skills further. My problem is, I don't know how to find a project where I'll fit in. How can I find a beginner-friendly project?  What attributes should I be searching for?  What are warning signs that a project might not be the right fit?  Are there any tools out there to help match people with open source projects? There's a similar question here, but that question has to do with employment and is limited to PHP/Drupal. ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "ago": 0.17844374038083288,
                    "create": 0.16118968620339694,
                    "develop": 0.17844374038083288,
                    "help": 0.2694590510153446,
                    "know": 0.10575148913433977,
                    "limited": 0.19980648135696136,
                    "match": 0.19128821223377326,
                    "open": 0.30396715937021657,
                    "people": 0.10338946102341127,
                    "php": 0.157868118891182,
                    "problem": 0.12552341898938366,
                    "project": 0.45546318969271504,
                    "projects": 0.1468861599655121,
                    "question": 0.2385026474752352,
                    "reasons": 0.16482805153804864,
                    "right": 0.14457187913112346,
                    "similar": 0.157868118891182,
                    "skills": 0.16482805153804864,
                    "source": 0.30396715937021657,
                    "started": 0.16118968620339694,
                    "tools": 0.16118968620339694,
                    "useful": 0.14238991712112728,
                    "want": 0.11096511577051447,
                    "working": 0.13140795819545736,
                    "year": 0.16118968620339694
                },
                "Max term": "project",
                "Max score": 0.45546318969271504
            }
        ],
        "Best Answer": "I suggest to start a project on your own on a topic that you're interested in.  A lot can be learned by working on a project in general.  It is not needed to see how someone else codes to learn how to code better.  And sometimes you'll actually see what not to do as the other people are often no more experienced than you are.   It usually helps to see other's code, but you will encounter other people's code in your own project just via the libraries and components you use.   Experience will teach you what is good and bad practice. ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "actually": 0.15649937810528503,
                "bad": 0.1718992430840683,
                "better": 0.14517148889770676,
                "code": 0.280565818317881,
                "components": 0.2163542861802466,
                "encounter": 0.2259887744433619,
                "experience": 0.15046498999273053,
                "experienced": 0.2163542861802466,
                "general": 0.19606132040588112,
                "good": 0.12344939347677446,
                "helps": 0.2163542861802466,
                "interested": 0.1864268321427658,
                "learn": 0.14862742801441808,
                "learned": 0.20848233608937966,
                "libraries": 0.20848233608937966,
                "lot": 0.1435420053439344,
                "needed": 0.19606132040588112,
                "people": 0.2338748716093779,
                "practice": 0.19097589773539744,
                "project": 0.38635971920312917,
                "start": 0.15439280473008604,
                "teach": 0.2259887744433619,
                "use": 0.10240984674599139,
                "usually": 0.1661338663684003,
                "working": 0.14862742801441808
            },
            "Max term": "project",
            "Max score": 0.38635971920312917
        }
    },
    {
        "ID:": "348",
        "Question": "Elite developers can be 10x more productive than an average developer.  Clearly it's easier to find an elite developer around the whole world than in a company's backyard.  If a company is not located in a programming hot spot, should they consider hiring people who work from home? ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "clearly": 0.2814606715728337,
                    "company": 0.4415090107929698,
                    "consider": 0.2516847343441284,
                    "developer": 0.41145138244725776,
                    "developers": 0.21427118236963907,
                    "easier": 0.26469173334300017,
                    "hiring": 0.30509516257281855,
                    "home": 0.30509516257281855,
                    "people": 0.15787087688561988,
                    "productive": 0.2724752551161186,
                    "programming": 0.14822306890328124,
                    "work": 0.15904848919978198,
                    "world": 0.21128130511431004
                },
                "Max term": "company",
                "Max score": 0.4415090107929698
            }
        ],
        "Best Answer": "Maybe. Your benefits are:  Access to a wider pool of candidates (as you point out) Access to people who want to work at home  Your costs are:  More difficult communication- you can't just pull someone into a free conference room. No guarantee of instant communication- if you're blocked and waiting for Joe Remote, you can't just go over to his desk and ask him what's up.  If he's incommunicado, you're SOL. Not all developers work well remotely.  Some need the structured environment to be productive. There's often no guarantee of matching schedules- eg, a work-from-home person might sleep in, or a person in another time-zone might be awake and working at different times than you.  Atwood had a decent article about it. Edit, from Atwood's article:  The minimum remote team size is two. Always have a buddy, even if your buddy is on another continent halfway across the world. Only grizzled veterans who absolutely love to code need apply for remote development positions. Mentoring of newbies or casual programmers simply doesn't work at all remotely. To be effective, remote teams need full autonomy and a leader (PM, if you will) who has a strong vision and the power to fully execute on that vision.  ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "absolutely": 0.13768541428558753,
                "access": 0.23204219919579705,
                "apply": 0.1438166933619425,
                "article": 0.27537082857117506,
                "ask": 0.10749902306403544,
                "benefits": 0.13768541428558753,
                "code": 0.05951630172819024,
                "communication": 0.2568804427005561,
                "costs": 0.1438166933619425,
                "developers": 0.1010038070459419,
                "development": 0.08501444336196969,
                "different": 0.0995944295363366,
                "difficult": 0.12477120098731703,
                "edit": 0.11602109959789852,
                "effective": 0.12844022135027805,
                "environment": 0.11863992191096207,
                "free": 0.12844022135027805,
                "home": 0.287633386723885,
                "love": 0.1438166933619425,
                "maybe": 0.12153489566808924,
                "minimum": 0.1438166933619425,
                "need": 0.24587494401394935,
                "people": 0.07441765808535618,
                "person": 0.2272606042807808,
                "point": 0.10248940329346379,
                "power": 0.13768541428558753,
                "productive": 0.12844022135027805,
                "programmers": 0.08938503811241581,
                "room": 0.1438166933619425,
                "simply": 0.12477120098731703,
                "size": 0.12844022135027805,
                "sleep": 0.1438166933619425,
                "strong": 0.13267579451501588,
                "team": 0.0995944295363366,
                "teams": 0.1438166933619425,
                "time": 0.07387354451504306,
                "times": 0.11143098167657604,
                "waiting": 0.1438166933619425,
                "want": 0.07987046226058034,
                "wider": 0.1438166933619425,
                "work": 0.2998910583574508,
                "working": 0.09458480976576494,
                "world": 0.0995944295363366
            },
            "Max term": "work",
            "Max score": 0.2998910583574508
        }
    },
    {
        "ID:": "368",
        "Question": "For a long time in SO and in other places Java has the reputation of being slow. From jokes to many comments in questions and answers, people still believe Java is slow based solely on experience with it in the 90s. This is my issue: we have disproved (most) of the reasons that people believe Java is slow. Outside of small things, Java is pretty fast. So why is it that people still refuse to believe Java is fast now? Is it part of their mindset that anything thats not C/C++ is slow? Is it because people don't check over time? Is it because people are just biased? ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "answers": 0.11810223326840688,
                    "based": 0.10547504301599449,
                    "believe": 0.36472543815214903,
                    "check": 0.1075568107347791,
                    "comments": 0.11229866845553807,
                    "experience": 0.09063619132046265,
                    "fast": 0.23620446653681376,
                    "issue": 0.10547504301599449,
                    "java": 0.46501102311889925,
                    "long": 0.08846758474936049,
                    "outside": 0.12558432962808785,
                    "people": 0.3522003292802588,
                    "places": 0.12157514605071634,
                    "pretty": 0.09849797635199517,
                    "questions": 0.10007471437509814,
                    "reasons": 0.11229866845553807,
                    "slow": 0.5445190086468625,
                    "small": 0.10007471437509814,
                    "things": 0.07436269956284569,
                    "time": 0.1398500698501173
                },
                "Max term": "slow",
                "Max score": 0.5445190086468625
            }
        ],
        "Best Answer": "It's the applications. As you note, we have proved, time and time again, that in contrived scenarios Java code can meet or even beat the performance of so-called \"performant\" languages like C, C++, Lisp, VB6, or JavaScript. And when presented with such evidence, most sane, open-minded opponents will hang their heads in shame and promise never again to spread such slander. ...but then, they fire up Eclipse, or NetBeans, or Guiffy, or enable the Java support in their browser, or try to run an app on their favorite feature phone. And they wait for it to become responsive... ...and wait...   ...and wait...     ...and wait...         ...and wait...             ...and...      ...what did I promise never to do again? Sorry, must have dozed off... ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "app": 0.12218593309813698,
                "applications": 0.11966809953849387,
                "called": 0.14500139092624828,
                "code": 0.06267872728678141,
                "evidence": 0.139725582747774,
                "favorite": 0.15145845828404708,
                "feature": 0.11520746728166693,
                "hang": 0.15145845828404708,
                "java": 0.20694918349078767,
                "javascript": 0.13140097507476697,
                "languages": 0.09842935714988925,
                "like": 0.06301717361931324,
                "lisp": 0.14500139092624828,
                "meet": 0.15145845828404708,
                "note": 0.139725582747774,
                "open": 0.11520746728166693,
                "performance": 0.13526495049094703,
                "promise": 0.29000278185249656,
                "run": 0.12799270721150088,
                "scenarios": 0.14500139092624828,
                "support": 0.13140097507476697,
                "time": 0.1555976973002381,
                "try": 0.09842935714988925,
                "wait": 0.7250069546312413
            },
            "Max term": "wait",
            "Max score": 0.7250069546312413
        }
    },
    {
        "ID:": "370",
        "Question": "I've been told that to be taken seriously as a job applicant, I should drop years of relevant experience off my résumé, remove the year I got my degree, or both. Or not even bother applying, because no one wants to hire programmers older than them.1 Or that I should found a company, not because I want to, or because I have a product I care about, but because that way I can get a job if/when my company is acquired. Or that I should focus more on management jobs (which I've successfully done in the past) because… well, they couldn't really explain this one, except the implication was that over a certain age you're a loser if you're still writing code. But I like writing code. Have you seen this? Is this only a local (Northern California) issue? If you've ever hired programmers:2  Of the résumés you've received, how old was the eldest applicant? What was the age of the oldest person you've interviewed? How old (when hired) was the oldest person you hired?  How old is \"too old\" to employed as a programmer? 1 I'm assuming all applicants have equivalent applicable experience. This isn't about someone with three decades of COBOL applying for a Java guru job. 2 Yes, I know that (at least in the US) you aren't supposed to ask how old an applicant is. In my experience, though, you can get a general idea from a résumé. ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "applicable": 0.12479258124414948,
                    "applying": 0.24958516248829896,
                    "ask": 0.09327902245411594,
                    "assuming": 0.12479258124414948,
                    "care": 0.11947234946590268,
                    "certain": 0.11145011321830757,
                    "cobol": 0.11947234946590268,
                    "code": 0.10328693763073148,
                    "company": 0.18058971710590616,
                    "decades": 0.12479258124414948,
                    "degree": 0.11947234946590268,
                    "drop": 0.11947234946590268,
                    "experience": 0.2492634583419173,
                    "explain": 0.08764299541380345,
                    "focus": 0.12479258124414948,
                    "general": 0.10826643188738626,
                    "got": 0.10294620010913948,
                    "hire": 0.12479258124414948,
                    "idea": 0.09859925423236272,
                    "issue": 0.09669086048997745,
                    "java": 0.08525678620652084,
                    "job": 0.25577035861956254,
                    "jobs": 0.11947234946590268,
                    "know": 0.0660489149794394,
                    "like": 0.05192232806117988,
                    "local": 0.12479258124414948,
                    "management": 0.09492396386154438,
                    "old": 0.4834543024498873,
                    "past": 0.1006737963385668,
                    "person": 0.19719850846472545,
                    "product": 0.1006737963385668,
                    "programmer": 0.08016471113321424,
                    "programmers": 0.15512232091976094,
                    "really": 0.0717526755701991,
                    "relevant": 0.09859925423236272,
                    "remove": 0.12479258124414948,
                    "seen": 0.09029485855295308,
                    "seriously": 0.12479258124414948,
                    "successfully": 0.12479258124414948,
                    "supposed": 0.10826643188738626,
                    "taken": 0.11145011321830757,
                    "told": 0.11947234946590268,
                    "want": 0.0693051753427313,
                    "wants": 0.10826643188738626,
                    "way": 0.06989390139561306,
                    "writing": 0.1705135724130417,
                    "year": 0.1006737963385668,
                    "years": 0.08764299541380345,
                    "yes": 0.09327902245411594
                },
                "Max term": "old",
                "Max score": 0.4834543024498873
            }
        ],
        "Best Answer": "Having just got a new job at nearly 50 in the UK I can say that it's possible and you're never too old. There are two approaches - both rely on your skills being relevant to the job.  Stick with what you know and become a guru. This is risky as the number of jobs requiring \"old\" technologies are becoming fewer and further between as each year passes. However, as people retire from such jobs there will be openings. Keep refreshing your skills. I moved into Silverlight last year, which is what got me this job. That and my previous team leadership roles which my new employer saw as relevant.  ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "50": 0.17377355670520664,
                "approaches": 0.16031202054923988,
                "fewer": 0.17377355670520664,
                "got": 0.2867049814003232,
                "job": 0.35615999343848265,
                "jobs": 0.3327302775154453,
                "know": 0.0919730544722191,
                "new": 0.19983107188966565,
                "number": 0.1372993724916788,
                "old": 0.26928387185705477,
                "passes": 0.17377355670520664,
                "people": 0.08991877663755551,
                "possible": 0.12033984264260056,
                "previous": 0.15519418202635535,
                "relevant": 0.2745987449833576,
                "rely": 0.17377355670520664,
                "saw": 0.17377355670520664,
                "say": 0.10272286094871509,
                "skills": 0.2867049814003232,
                "stick": 0.17377355670520664,
                "team": 0.12033984264260056,
                "technologies": 0.16031202054923988,
                "year": 0.2803763410028597
            },
            "Max term": "job",
            "Max score": 0.35615999343848265
        }
    },
    {
        "ID:": "404",
        "Question": "Joel Spolsky wrote a famous blog post \"Human Task Switches considered harmful\". While I agree with the premise and it seems like common sense, I'm wondering if there are any studies or white papers on this to calculate the overhead on task switches, or is the evidence merely anecdotal?  ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "agree": 0.2918627444039251,
                    "blog": 0.27226497221691387,
                    "common": 0.21410581848943827,
                    "considered": 0.27226497221691387,
                    "evidence": 0.28124345417448604,
                    "joel": 0.27226497221691387,
                    "like": 0.12684268143652674,
                    "overhead": 0.3048597052455401,
                    "post": 0.28124345417448604,
                    "sense": 0.2514904965385673,
                    "task": 0.47241826292929756,
                    "wrote": 0.3048597052455401
                },
                "Max term": "task",
                "Max score": 0.47241826292929756
            }
        ],
        "Best Answer": "The abstract of a study that says 'maybe' Another study [PDF] that says interruptions make things seem like they took longer. A study[PDF] that says interruptions increase resumption lag time, but that cues seen in the task before the interruption can speed recovery time. Task switching[PDF] takes a significant portion of our work week. More reading on the psychology of interruptions than you can shake a stick at. ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "like": 0.09373749646808825,
                "longer": 0.21568830509484233,
                "make": 0.12618231076796807,
                "maybe": 0.19038803632573753,
                "reading": 0.17455995391801613,
                "seen": 0.16301299076422096,
                "stick": 0.2252931365063922,
                "study": 0.6758794095191766,
                "takes": 0.17455995391801613,
                "task": 0.34911990783603225,
                "things": 0.12306939194081382,
                "time": 0.23145021846320446,
                "took": 0.21568830509484233,
                "week": 0.21568830509484233,
                "work": 0.11744707023950143
            },
            "Max term": "study",
            "Max score": 0.6758794095191766
        }
    },
    {
        "ID:": "408",
        "Question": "\"Regular\" golf vs. code golf: Both are competitions.  Both have a well-defined set of rules, which I'll leave out for simplicity.  Both have well-defined goals; in short, \"use fewer hits/characters than your competitors.\" To win matches, athletic golfers rely on  equipment  Some situations call for a sand wedge; others, a 9-iron.   techniques  The drive works better when your feet are about shoulder width apart and your arms are relaxed.   and strategies  Sure, you could take that direct shortcut to the hole... but do you really want to risk the water hazard or sand bunker when those trees are in the way and the wind is so strong?  It might be better to go around the long way.    What do code golfers have that's analagous to athletic golfers' equipment, techniques and strategies? Sample answer to get this started: use the right club!  Choose GolfScript instead of C#. ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "answer": 0.11633920878568678,
                    "apart": 0.16302888282653916,
                    "better": 0.21878138927685645,
                    "characters": 0.16302888282653916,
                    "code": 0.14094268780843175,
                    "defined": 0.3405774674428781,
                    "drive": 0.17028873372143905,
                    "fewer": 0.17028873372143905,
                    "golf": 0.3405774674428781,
                    "instead": 0.1272861452028806,
                    "leave": 0.14390557175585023,
                    "long": 0.11066671864991094,
                    "really": 0.09791184814159194,
                    "regular": 0.17028873372143905,
                    "rely": 0.17028873372143905,
                    "right": 0.12321403220641929,
                    "risk": 0.16302888282653916,
                    "rules": 0.16302888282653916,
                    "sample": 0.16302888282653916,
                    "set": 0.12518642043971073,
                    "short": 0.1520819464093453,
                    "situations": 0.16302888282653916,
                    "started": 0.1373768626829194,
                    "strong": 0.15709715273864464,
                    "sure": 0.1272861452028806,
                    "techniques": 0.31419430547728927,
                    "use": 0.15433725118370598,
                    "vs": 0.1520819464093453,
                    "want": 0.09457205253544917,
                    "way": 0.19075082580789338,
                    "win": 0.15709715273864464,
                    "works": 0.1520819464093453
                },
                "Max term": "defined",
                "Max score": 0.3405774674428781
            }
        ],
        "Best Answer": "I'd say that thorough knowledge of the syntactical oddities of your language help. Here is one I found in Ruby when doing a bit of code golf: Instead of require \"sequel\" require \"nokogiri\" require \"chronic\"  You can do something like this:  body_of_your_program if %w{sequel nokogiri chronic}.each{|i| require i}  With this kind of thing, you too can write incredibly elaborate Ruby one-liners! In Ruby and Perl, you also get the magic variables like \"$_\" which can be used to do all sorts of magic with strings and regexes. Is your data not strings? Well, you might want to turn it into strings. Obviously, in C, the preprocessor is your friend. ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "bit": 0.13719043855256038,
                "code": 0.07327466214751394,
                "data": 0.12261763523846153,
                "golf": 0.1770627426649648,
                "help": 0.1193934207855798,
                "incredibly": 0.16951409817922664,
                "instead": 0.13234953059044058,
                "kind": 0.15361451119458222,
                "knowledge": 0.13468346610342288,
                "language": 0.09444144631910603,
                "like": 0.1473406467020023,
                "magic": 0.3541254853299296,
                "obviously": 0.15361451119458222,
                "require": 0.5387338644136915,
                "ruby": 0.4900392196396839,
                "say": 0.10466719930712183,
                "thing": 0.13234953059044058,
                "turn": 0.1633464065465613,
                "used": 0.09916940376807898,
                "variables": 0.1770627426649648,
                "want": 0.098334086086833,
                "write": 0.10567708466717632
            },
            "Max term": "require",
            "Max score": 0.5387338644136915
        }
    },
    {
        "ID:": "487",
        "Question": "If you were to design a programming language, how would you do it? What features would you put in? What would you leave out? Statically or dynamically typed? Strongly or weakly typed? Compiled or interpreted? Justify your answers. ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "answers": 0.28580225353282407,
                    "design": 0.2116191943917735,
                    "dynamically": 0.32942806299236016,
                    "features": 0.26028279093538914,
                    "interpreted": 0.32942806299236016,
                    "language": 0.17570982047854664,
                    "leave": 0.27838913779749036,
                    "programming": 0.1600446171215083,
                    "statically": 0.32942806299236016,
                    "typed": 0.588413101992913
                },
                "Max term": "typed",
                "Max score": 0.588413101992913
            }
        ],
        "Best Answer": " I definitely think that functional programming languages will catch on, so my language will be functional. See Taming Effects with Functional Programming I think the CPUs soon will have hundreads of cores, and threads will he a hell to manage. So the Actor Model is a must instead of threads. See Erlang - software for a concurrent world I also think that OOP has failed, the communication between objects was assumed to be asynchronous. So I think we need message passing, with immutable messages. Send and Forget. As in the Actor model. See Object Oriented Programming: The Wrong Path? I think that it would be good to have static typing, so errors are catched earlier in the development cycle. But I would use type inference as in Haskell, so that the developer don't need to write the type everywhere in the code as in C, C# and Java. See Learn You A Haskell for Great Good I would also design a great UI library, with declarative layout, as in WPF and Android. But I would like to have it as in Functional Reactive Programming.  So my language would be like the concurrency in Erlang but with the typing as in Haskell and a GUI framework as in WPF.NET. ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "android": 0.11206341058809022,
                "code": 0.04637569951956488,
                "communication": 0.1000819093022637,
                "concurrency": 0.11206341058809022,
                "concurrent": 0.11206341058809022,
                "cycle": 0.11206341058809022,
                "definitely": 0.11206341058809022,
                "design": 0.07198770030104013,
                "developer": 0.07556436624461295,
                "development": 0.06624410734026398,
                "earlier": 0.10338231041384646,
                "effects": 0.10338231041384646,
                "erlang": 0.21457171281564355,
                "errors": 0.092445417638599,
                "failed": 0.10338231041384646,
                "framework": 0.08524147053304094,
                "functional": 0.3616192200553428,
                "good": 0.1224322765775753,
                "great": 0.1675286349287105,
                "gui": 0.10338231041384646,
                "haskell": 0.29166891545660234,
                "instead": 0.08376431746435525,
                "java": 0.07656037035879719,
                "language": 0.11954441025932658,
                "languages": 0.07282742468910779,
                "learn": 0.07370143287540092,
                "library": 0.0904048050138357,
                "like": 0.09325222878154556,
                "message": 0.11206341058809022,
                "model": 0.1894024204792054,
                "need": 0.12772548239591341,
                "net": 0.08238253304964467,
                "object": 0.10728585640782178,
                "objects": 0.10728585640782178,
                "oop": 0.10728585640782178,
                "oriented": 0.0947012102396027,
                "path": 0.10728585640782178,
                "programming": 0.2177731366051497,
                "software": 0.06562347758354974,
                "soon": 0.10728585640782178,
                "static": 0.11206341058809022,
                "think": 0.2920976523899584,
                "threads": 0.22412682117618044,
                "type": 0.17708374328924736,
                "typing": 0.2001638186045274,
                "ui": 0.10338231041384646,
                "use": 0.05078303881432696,
                "world": 0.07760497886937623,
                "wpf": 0.22412682117618044,
                "write": 0.0668832660703692,
                "wrong": 0.0904048050138357
            },
            "Max term": "functional",
            "Max score": 0.3616192200553428
        }
    },
    {
        "ID:": "492",
        "Question": "Did you learn to touch-type when you were already working as a programmer?  If so how did it affect your productivity?  Or are you still unable to touch type and do you think it holds you back? According to Steve Yegge it is essential, Personally I did not notice much difference, possibly because I was spending less than 25% of my work time actually typing (I was working on a large legacy project at the time and I was spending more time on reading and debugging existing code.) ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "actually": 0.14583306066147586,
                    "code": 0.0871478905063381,
                    "difference": 0.194273086154468,
                    "existing": 0.18807106661236128,
                    "large": 0.194273086154468,
                    "learn": 0.13849762847622335,
                    "legacy": 0.21058636175563453,
                    "notice": 0.20160851833972052,
                    "personally": 0.16988612851583615,
                    "possibly": 0.1779598105533015,
                    "productivity": 0.21058636175563453,
                    "programmer": 0.13527723114971982,
                    "project": 0.12000903997159497,
                    "reading": 0.16316495998884215,
                    "steve": 0.21058636175563453,
                    "think": 0.10978031379084345,
                    "time": 0.32451227891043705,
                    "touch": 0.388546172308936,
                    "type": 0.33277071463069136,
                    "typing": 0.18807106661236128,
                    "unable": 0.21058636175563453,
                    "work": 0.10978031379084345,
                    "working": 0.2769952569524467
                },
                "Max term": "touch",
                "Max score": 0.388546172308936
            }
        ],
        "Best Answer": "The main benefit for me is the ability to work more ergonomically (no looking down and straining your neck and top back). I don't think it actually affects your speed though, except for comments, because of the excessive use of punctuation marks in programming languages. Touch Typing is really more suited for words... at least on a QWERTY keyboard.  I think Steve Yegge is overreacting about this. We're not typists, we're problem solvers. At the end what's important is for your typing to not get in your way. If it's not causing you physical strain, and your typing speed is not disruptively behind your though speed, then you can type in whatever way you want, and trust me- it is possible to type fast without touch typing.  ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "ability": 0.15295432615228804,
                "actually": 0.11481671478913079,
                "benefit": 0.16579803047749264,
                "causing": 0.16579803047749264,
                "comments": 0.13677317235584754,
                "end": 0.11996474118148155,
                "fast": 0.14384157291077587,
                "important": 0.1181541642603667,
                "keyboard": 0.1480713763900549,
                "languages": 0.10774831423420243,
                "looking": 0.12846239796136794,
                "main": 0.13677317235584754,
                "physical": 0.16579803047749264,
                "possible": 0.11481671478913079,
                "problem": 0.10415846125662143,
                "programming": 0.08054894311747161,
                "really": 0.09532980384270431,
                "steve": 0.16579803047749264,
                "suited": 0.16579803047749264,
                "think": 0.17286361433836744,
                "touch": 0.3059086523045761,
                "trust": 0.16579803047749264,
                "type": 0.26199573717114255,
                "typing": 0.5922855055602196,
                "use": 0.07513360313497633,
                "want": 0.09207808236005088,
                "way": 0.18572051444482804,
                "words": 0.15295432615228804,
                "work": 0.08643180716918372
            },
            "Max term": "typing",
            "Max score": 0.5922855055602196
        }
    },
    {
        "ID:": "500",
        "Question": "Rather than slavishly pair program all the time, we use pair programming selectively on our team. I think it works best in the following circumstances:  Ramping up brand new team members on a project (instead of letting them wade through documentation or code on their own). Having junior and senior people work together (helps to show some of the skills and tricks of the more experienced developers, plus it allows the old dogs to learn new tricks sometimes). When someone is trying to track down a defect, it often helps to pair with a fresh set of eyes.  When to use pair program and why? When to avoid pair programming? Why? ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "allows": 0.13414958121099535,
                    "avoid": 0.11304161739611715,
                    "best": 0.08900262732503869,
                    "code": 0.0579878921343356,
                    "developers": 0.09840997673017583,
                    "documentation": 0.12156701162930364,
                    "experienced": 0.13414958121099535,
                    "eyes": 0.13414958121099535,
                    "following": 0.12156701162930364,
                    "helps": 0.2682991624219907,
                    "instead": 0.10473839222155737,
                    "learn": 0.09215582263986566,
                    "members": 0.13414958121099535,
                    "new": 0.16113504792601005,
                    "old": 0.10856937609118648,
                    "pair": 0.646343055412825,
                    "people": 0.07250657390728839,
                    "plus": 0.1401234058506533,
                    "program": 0.21713875218237297,
                    "programming": 0.1361511016118236,
                    "project": 0.07985358250882617,
                    "senior": 0.13414958121099535,
                    "set": 0.10301061740795397,
                    "skills": 0.11559318698964569,
                    "team": 0.19407358553659204,
                    "think": 0.0730474249874581,
                    "time": 0.07197643345655537,
                    "track": 0.129268611082565,
                    "tricks": 0.25853722216513,
                    "trying": 0.09985742209312702,
                    "use": 0.12699760467339682,
                    "work": 0.0730474249874581,
                    "works": 0.12514180964040536
                },
                "Max term": "pair",
                "Max score": 0.646343055412825
            }
        ],
        "Best Answer": "I have never worked in a \"Pair Programming\" setup and yet I can claim to have been a part of the three circumstances you've listed. The scenario you mention seems more \"regular programming\" with phases of helping / training thrown in. Did we not do all of this before \"pair programming\" came into being? Pair Programming, I'd assume would require a more committed approach where the process of sharing within a team doesn't stop the minute you tackle the immediate task or problem at hand. But then this is what I \"think\" not what I \"know\". Personally for Pair Programming I'd like to work in a team where I get a chance to learn and share my knowledge. An unbalanced team where everyone you work with is miles ahead of you, or then way below par can get quite uninteresting quite quickly. Also, I'd be afraid to work with people who are set in their beliefs and hard to convince. ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "approach": 0.11720799244041173,
                "assume": 0.1420808918015148,
                "chance": 0.13107445849645954,
                "claim": 0.1420808918015148,
                "convince": 0.1420808918015148,
                "hand": 0.13107445849645954,
                "hard": 0.11008606080993225,
                "know": 0.0751990915585067,
                "knowledge": 0.10807438474564994,
                "learn": 0.09344321447146221,
                "like": 0.05911545864181018,
                "mention": 0.1360236144529104,
                "minute": 0.1420808918015148,
                "pair": 0.5242978339858382,
                "people": 0.07351947106680999,
                "personally": 0.1146207781121463,
                "problem": 0.08925876273315128,
                "process": 0.10280398001541191,
                "programming": 0.34513273887633605,
                "quickly": 0.12326526978901614,
                "quite": 0.22451767296792177,
                "regular": 0.1420808918015148,
                "require": 0.10807438474564994,
                "set": 0.10444964777651748,
                "share": 0.13107445849645954,
                "sharing": 0.1420808918015148,
                "stop": 0.1420808918015148,
                "task": 0.11008606080993225,
                "team": 0.2951771112837392,
                "think": 0.07406787768978508,
                "thrown": 0.1420808918015148,
                "training": 0.1420808918015148,
                "way": 0.0795767484154144,
                "work": 0.22220363306935523,
                "worked": 0.1146207781121463
            },
            "Max term": "pair",
            "Max score": 0.5242978339858382
        }
    },
    {
        "ID:": "501",
        "Question": "No matter how much you love a programming language, there are always a few details in it that aren’t quite as nice as they could be. In this question, I would like to specifically focus on syntax elements. In a programming language that you use frequently (perhaps your favourite programming language, or perhaps the one you are forced to use at work), which syntax element do you find most unreadable, unclear, inconvenient or unpleasant? ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "details": 0.19303375627445155,
                    "elements": 0.22842391382342644,
                    "favourite": 0.22842391382342644,
                    "focus": 0.22842391382342644,
                    "forced": 0.22842391382342644,
                    "frequently": 0.19303375627445155,
                    "language": 0.3655091602671271,
                    "like": 0.09504011594531117,
                    "love": 0.22842391382342644,
                    "matter": 0.20400147832171975,
                    "nice": 0.1981739768570867,
                    "programming": 0.33292261895230085,
                    "question": 0.13633118361213784,
                    "quite": 0.18047889808259926,
                    "specifically": 0.210728835048939,
                    "syntax": 0.421457670097878,
                    "use": 0.20702672568932798,
                    "work": 0.11907916888733364
                },
                "Max term": "syntax",
                "Max score": 0.421457670097878
            }
        ],
        "Best Answer": "Semicolon insertion in JavaScript. I haven't really been bitten by it often, but it's just such a phenomenally bad idea it makes my head spin.  Here's the rules (from ECMA-262 Section 7.9)  When the program contains a token that is not allowed by the formal grammar, then a semicolon is inserted if (a) there is a line break at that point, or (b) the unexpected token was a closing brace. When the end of a file is reached, if the program cannot be parsed otherwise, then a semicolon is inserted. When a \"restricted production\" is encountered and contains a line terminator in a place where the grammar contains the annotation \"[no LineTerminator here]\", then a semicolon is inserted.    Example: return 1; // returns 1  return 1; // returns undefined  ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "bad": 0.1396097381462379,
                "break": 0.1693210733645856,
                "contains": 0.5271430757668044,
                "encountered": 0.18353910731647116,
                "end": 0.13280146599141684,
                "example": 0.11173473799393592,
                "file": 0.1422084072872233,
                "formal": 0.1693210733645856,
                "head": 0.1757143585889348,
                "idea": 0.14501518378301884,
                "javascript": 0.15923321773490443,
                "line": 0.2792194762924758,
                "makes": 0.13280146599141684,
                "place": 0.1422084072872233,
                "point": 0.13079714983113327,
                "production": 0.18353910731647116,
                "program": 0.2844168145744466,
                "reached": 0.18353910731647116,
                "really": 0.10553048819430617,
                "return": 0.3102060788254,
                "rules": 0.1757143585889348,
                "section": 0.1757143585889348,
                "unexpected": 0.18353910731647116
            },
            "Max term": "contains",
            "Max score": 0.5271430757668044
        }
    },
    {
        "ID:": "502",
        "Question": "I think everyone has their own program or set of features beyond \"Hello World!\", that they use when trying out a new language. Mine is a guessing game: I'm thinking of a number 1-10, guess what it is! Guess: 3 Nope, too low! Guess: 7 Nope, too high! Guess: 5 Yes, You win! Play again (Y/N)? N  What do you write? ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "10": 0.16460699933785242,
                    "features": 0.15390100897658737,
                    "game": 0.16068604362630157,
                    "guess": 0.7459251196474397,
                    "hello": 0.1947854911864391,
                    "high": 0.1739595802056546,
                    "language": 0.10389437796314419,
                    "low": 0.1689902549008807,
                    "new": 0.11199688327255976,
                    "number": 0.15390100897658737,
                    "play": 0.1739595802056546,
                    "program": 0.15092224686764133,
                    "set": 0.14319501861532236,
                    "think": 0.10154319665375343,
                    "thinking": 0.16460699933785242,
                    "trying": 0.13881176305229406,
                    "use": 0.08826966007440035,
                    "win": 0.17969624526214575,
                    "world": 0.13489080734074319,
                    "write": 0.11625462553122339,
                    "yes": 0.1455967977020082
                },
                "Max term": "guess",
                "Max score": 0.7459251196474397
            }
        ],
        "Best Answer": "It usually goes like this:  Hello World Hello [user inputted name] A few problems from Project Euler A linked list A simple blog engine (either terminal or web-based, depending on what language) And from there I dive into a project that I want to work on (but don't care if the design gets mangled as I learn my way through a new language).  ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "based": 0.17671560371881995,
                "blog": 0.20369013102273045,
                "care": 0.21835185100830984,
                "depending": 0.2280752929743102,
                "design": 0.14651183424227757,
                "engine": 0.21835185100830984,
                "euler": 0.2280752929743102,
                "gets": 0.19787152349776782,
                "goes": 0.20369013102273045,
                "hello": 0.4561505859486204,
                "language": 0.24330087983449886,
                "learn": 0.14999968149702186,
                "like": 0.09489506560725167,
                "list": 0.16017940855828303,
                "new": 0.13113770337314032,
                "problems": 0.18020345097356424,
                "project": 0.2599512781634813,
                "simple": 0.18020345097356424,
                "user": 0.16017940855828303,
                "usually": 0.16766775402122544,
                "want": 0.12666456622132283,
                "way": 0.1277405425786827,
                "web": 0.1625353784493607,
                "work": 0.11889743011806601,
                "world": 0.15794431205522508
            },
            "Max term": "hello",
            "Max score": 0.4561505859486204
        }
    },
    {
        "ID:": "507",
        "Question": "I have seen this on the SO on many times. Whenever a question is vague and the question is asking some magical answer somebody or the other leaves a comment saying answer is 42. Even a book I am reading right now uses '42' as the number whenever it wants demonstrate some basic concept using an integer. So is there any history behind it or it is just a coincidence? ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "answer": 0.35509164308629615,
                    "asking": 0.20965148551929946,
                    "basic": 0.2397467142522257,
                    "book": 0.19767755621359526,
                    "comment": 0.25987844892267287,
                    "concept": 0.23209298394721617,
                    "history": 0.2487991558376546,
                    "number": 0.20533128651860474,
                    "question": 0.31020864623046274,
                    "reading": 0.2013570886876093,
                    "right": 0.1880375223630027,
                    "saying": 0.25987844892267287,
                    "seen": 0.1880375223630027,
                    "times": 0.2013570886876093,
                    "uses": 0.2254630211890519,
                    "using": 0.15218283539495597,
                    "vague": 0.25987844892267287,
                    "wants": 0.2254630211890519
                },
                "Max term": "answer",
                "Max score": 0.35509164308629615
            }
        ],
        "Best Answer": "It's the answer to Life, The Universe, and Everything from Douglas Adams' Hitchhiker's Guide to the Galaxy. ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "answer": 0.458585082770779,
                "guide": 0.6712429443493423,
                "life": 0.5823509521940732
            },
            "Max term": "guide",
            "Max score": 0.6712429443493423
        }
    },
    {
        "ID:": "558",
        "Question": "I am a moderately capable web developer. I can put stuff where I want it to go and put some JQuery stuff in there if I need to. However, if I am making my own website (which I am starting to do) I have no idea how to design it. If someone was to sit next to me a point to the screen and say \"put this picture there, text there\" I can do that quite easily. But designing my own site with my choice of colours and text will look like a toddler has invented it. Does anyone know any websites/books I can look at or has anyone got any tips on the basics of non-toddler web design? ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "books": 0.16122344931814966,
                    "choice": 0.16486257675209692,
                    "design": 0.25675859483881797,
                    "developer": 0.1347577462241303,
                    "easily": 0.17338263012900915,
                    "got": 0.16486257675209692,
                    "idea": 0.15790118626378793,
                    "know": 0.10577364005321686,
                    "like": 0.08315070188174793,
                    "look": 0.28483948479713345,
                    "making": 0.16486257675209692,
                    "need": 0.11388964798133396,
                    "non": 0.14035535107535335,
                    "point": 0.14241974239856672,
                    "quite": 0.15790118626378793,
                    "say": 0.11813645835267954,
                    "screen": 0.1913282798461163,
                    "sit": 0.19984833322302856,
                    "site": 0.16888544549258608,
                    "starting": 0.17338263012900915,
                    "stuff": 0.3096900010268568,
                    "text": 0.36873377871561464,
                    "tips": 0.1784811175643568,
                    "want": 0.11098835874607672,
                    "web": 0.28483948479713345,
                    "website": 0.17338263012900915,
                    "websites": 0.19984833322302856
                },
                "Max term": "text",
                "Max score": 0.36873377871561464
            }
        ],
        "Best Answer": "You have a few things to do. Tips: Learn to use Photoshop. (In particular, layer styles are excellent. Just note that they can be difficult effects to reimplement in CSS2) It goes a long way towards making good mockups.  Look at professionally designed sites. What sites have you been to that look nice to you?   Find sites that bother you and consider what could make it better. Look at product advertisements as well. Food packaging. Newspaper ads. You name it.  Also, once you start getting the hang of it, practice, practice, practice. Graphics takes time to develop as a skill, especially from a programmer who has coding to consider. (Gradients vs \"tileability\")  Tools: (Photoshop is a personal favorite. Paint.NET is a good Windows alternative, but is not quite as powerful.) Nathan Smith's 960 grid system. It has templates for many of the mainstream graphics programs. Check it out. References: Look at some of these sites: (I've seen more, I'll try to add as I come across them)  A List Apart John McCain BarackObama.com  Hayon2010.com (Okay, I made this one, but I think that it's nice. edit: I'd appreciate comments on it too. ;-D)  ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "add": 0.10277775054929038,
                "apart": 0.11341557227743815,
                "better": 0.07610067626755627,
                "check": 0.09360066069583377,
                "coding": 0.07791232196960285,
                "com": 0.21160006357198363,
                "come": 0.09772723355120723,
                "comments": 0.09772723355120723,
                "consider": 0.19545446710241446,
                "designed": 0.1092889994220647,
                "develop": 0.10580003178599182,
                "difficult": 0.10277775054929038,
                "edit": 0.09557003169456789,
                "effects": 0.1092889994220647,
                "especially": 0.09772723355120723,
                "excellent": 0.1184660892755213,
                "favorite": 0.1184660892755213,
                "getting": 0.09178901499378721,
                "goes": 0.10580003178599182,
                "good": 0.12942737447601654,
                "graphics": 0.2268311445548763,
                "hang": 0.1184660892755213,
                "learn": 0.07791232196960285,
                "list": 0.08319984101260432,
                "long": 0.07698837782689315,
                "look": 0.3376942833695087,
                "mainstream": 0.11341557227743815,
                "make": 0.06635055609874538,
                "making": 0.09772723355120723,
                "net": 0.08708941182305945,
                "nice": 0.20555550109858076,
                "note": 0.1092889994220647,
                "particular": 0.09360066069583377,
                "personal": 0.09557003169456789,
                "powerful": 0.1092889994220647,
                "practice": 0.3003357287058243,
                "product": 0.09557003169456789,
                "programmer": 0.07610067626755627,
                "programs": 0.10011190956860809,
                "quite": 0.09360066069583377,
                "references": 0.1184660892755213,
                "seen": 0.08571726514356556,
                "sites": 0.4111110021971615,
                "start": 0.08093460320630431,
                "styles": 0.1092889994220647,
                "takes": 0.09178901499378721,
                "things": 0.06471368723800827,
                "think": 0.06175729684400053,
                "time": 0.06085183656387804,
                "tips": 0.10580003178599182,
                "tools": 0.09557003169456789,
                "try": 0.07698837782689315,
                "use": 0.05368449860921592,
                "vs": 0.10580003178599182,
                "way": 0.06635055609874538,
                "windows": 0.10277775054929038
            },
            "Max term": "sites",
            "Max score": 0.4111110021971615
        }
    },
    {
        "ID:": "566",
        "Question": "goto is almost universally discouraged. Is using this statement ever worthwhile? ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "goto": 0.665268004669777,
                    "universally": 0.6369059021777195,
                    "using": 0.38957586390057397
                },
                "Max term": "goto",
                "Max score": 0.665268004669777
            }
        ],
        "Best Answer": "This has been discussed several times on Stack Overflow, and Chris Gillum summarized the possible uses of goto:  Cleanly exiting a function Often in a function, you may allocate resources and need to exit in multiple places.  Programmers can simplify their code by putting the resource cleanup code at the end of the function all all \"exit points\" of the function would goto the cleanup label.  This way, you don't have to write cleanup code at every \"exit point\" of the function. Exiting nested loops If you're in a nested loop and need to break out of all loops, a goto can make this much cleaner and simpler than break statements and if-checks. Low-level performance improvements This is only valid in perf-critical code, but goto statements execute very quickly and can give you a boost when moving through a function.  This is a double-edged sword, however, because a compiler typically cannot optimize code that contains gotos.  I'd argue, as many others would argue, that in all of these cases, the usage of goto is used as a means to get out of a corner one coded oneself into, and is generally a symptom of code that could be refactored. ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "break": 0.20200084633356935,
                "cases": 0.09031551204410004,
                "code": 0.27184333126517324,
                "compiler": 0.10481403301613187,
                "contains": 0.10481403301613187,
                "critical": 0.10948151425134255,
                "end": 0.07921639046913735,
                "function": 0.5551159924933609,
                "generally": 0.09031551204410004,
                "goto": 0.5474075712567127,
                "level": 0.08482765333619803,
                "low": 0.09498299327931072,
                "make": 0.06131847010003639,
                "means": 0.08650190219475284,
                "moving": 0.10100042316678468,
                "multiple": 0.09777606198201723,
                "need": 0.12478273816408308,
                "overflow": 0.09498299327931072,
                "performance": 0.09777606198201723,
                "places": 0.09777606198201723,
                "point": 0.07802081111019499,
                "points": 0.0925193320822268,
                "possible": 0.07581699107206821,
                "programmers": 0.06804501685581704,
                "quickly": 0.09498299327931072,
                "resource": 0.10948151425134255,
                "resources": 0.10481403301613187,
                "simpler": 0.10948151425134255,
                "stack": 0.09498299327931072,
                "times": 0.08482765333619803,
                "usage": 0.10948151425134255,
                "used": 0.06131847010003639,
                "uses": 0.09498299327931072,
                "valid": 0.10948151425134255,
                "way": 0.06131847010003639,
                "write": 0.06534230226469365
            },
            "Max term": "function",
            "Max score": 0.5551159924933609
        }
    },
    {
        "ID:": "568",
        "Question": "Managed OSes like Microsoft Singularity and JNode are quite an interesting concept. Essentially, the OS is bootstrapped with code written in a low-level language (C/C++/Assembly), which essentially implements a virtual machine. The rest of the OS (and all userland apps) run on the virtual machine. There are some great things about this. For example, you suddenly make arbitrary pointers obsolete. And if well written, you get rid of a ton of legacy crud that most modern OSes currently have.  However, as a disadvantage, you're that much farther away from the hardware, and as a developer, you lose the ability to drop down to a lower level of abstraction and get your hands dirty.  What are your opinions on this? ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "ability": 0.16699643702603656,
                    "apps": 0.14932975770448886,
                    "assembly": 0.1810192692955178,
                    "away": 0.16166520362464729,
                    "code": 0.0749120091566472,
                    "concept": 0.16166520362464729,
                    "currently": 0.16699643702603656,
                    "developer": 0.12206130699213655,
                    "drop": 0.17330194780589456,
                    "essentially": 0.3466038956117891,
                    "example": 0.11020071374605228,
                    "great": 0.13530692543500764,
                    "hands": 0.1810192692955178,
                    "hardware": 0.16699643702603656,
                    "interesting": 0.14025600511625877,
                    "language": 0.09655177225083814,
                    "legacy": 0.1810192692955178,
                    "level": 0.28051201023251754,
                    "like": 0.07531651154300954,
                    "low": 0.15704707919411207,
                    "lower": 0.1810192692955178,
                    "machine": 0.3466038956117891,
                    "make": 0.10138537750167745,
                    "managed": 0.16699643702603656,
                    "microsoft": 0.14932975770448886,
                    "modern": 0.1810192692955178,
                    "quite": 0.14302424692463084,
                    "run": 0.1529736047565553,
                    "things": 0.0988841992580529,
                    "written": 0.32333040724929457
                },
                "Max term": "essentially",
                "Max score": 0.3466038956117891
            }
        ],
        "Best Answer": "I think that this is another case where \"it depends\". If you're writing applications such as web browsers, word processors etc. where lightning fast performance is not necessarily an issue then this approach has it's merits. By using this approach you can offer your customers a safer, more controlled experience. Not only are you limiting the damage that can be done by malware, but you are also running in a more consistent environment. It's like the difference between console games and PC games. The former know exactly what hardware they need to work with so can make use of that knowledge whereas the latter have to be able to cope with a wider variety of graphics cards, sound cards, hard disk speeds etc. However, there will be applications (such as games!) that require the low level access and will still need to be run \"natively\". Like managed languages you will have to use the appropriate tool for the job. ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "able": 0.12623779262947607,
                "access": 0.12051063549420475,
                "applications": 0.23605464815961755,
                "approach": 0.24646159076278623,
                "browsers": 0.14938180358391284,
                "cards": 0.2987636071678257,
                "case": 0.11802732407980877,
                "consistent": 0.14938180358391284,
                "customers": 0.13780979810669447,
                "depends": 0.12959932955702716,
                "difference": 0.13780979810669447,
                "environment": 0.12323079538139312,
                "exactly": 0.13780979810669447,
                "experience": 0.09945950473297814,
                "fast": 0.12959932955702716,
                "games": 0.40023097742348984,
                "graphics": 0.1430132694082788,
                "hard": 0.11574289902550186,
                "hardware": 0.13780979810669447,
                "issue": 0.11574289902550186,
                "job": 0.1020558463037259,
                "know": 0.07906324194934254,
                "knowledge": 0.11362785178094428,
                "languages": 0.09707978717887338,
                "level": 0.11574289902550186,
                "like": 0.12430628383076718,
                "low": 0.12959932955702716,
                "make": 0.08366584732762174,
                "managed": 0.13780979810669447,
                "necessarily": 0.13341032580782994,
                "need": 0.1702595238160154,
                "performance": 0.13341032580782994,
                "require": 0.11362785178094428,
                "run": 0.12623779262947607,
                "running": 0.13780979810669447,
                "sound": 0.14938180358391284,
                "think": 0.07787389997797572,
                "tool": 0.12323079538139312,
                "use": 0.13538873910307772,
                "using": 0.08747684357842456,
                "web": 0.1064553186025904,
                "wider": 0.14938180358391284,
                "word": 0.1430132694082788,
                "work": 0.07787389997797572,
                "writing": 0.1020558463037259
            },
            "Max term": "games",
            "Max score": 0.40023097742348984
        }
    },
    {
        "ID:": "570",
        "Question": "All but the most trivial programs are filled with bugs and so anything that promises to remove them is extremely alluring. At the moment, correctness proofs are code are extremely esoteric, mainly because of the difficultly of learning this and the extra effort it takes to prove a program correct. Do you think that code proving will ever take off? ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "bugs": 0.21216154529005793,
                    "code": 0.21766852043920634,
                    "correct": 0.22816238512572293,
                    "effort": 0.23487172534577197,
                    "extra": 0.24261709020556302,
                    "extremely": 0.46974345069154394,
                    "filled": 0.26298985277613074,
                    "learning": 0.1847002300212126,
                    "moment": 0.26298985277613074,
                    "program": 0.20376784350110327,
                    "programs": 0.2222443276349953,
                    "prove": 0.26298985277613074,
                    "remove": 0.26298985277613074,
                    "takes": 0.20376784350110327,
                    "think": 0.1370986626145977,
                    "trivial": 0.24261709020556302
                },
                "Max term": "extremely",
                "Max score": 0.46974345069154394
            }
        ],
        "Best Answer": "Not really in that sense, but pure functional programming is good in this domain. If you use Haskell, it's likely that your program is correct if the code compiles. Except from IO, a good type system is a good help. Also programming to contract can be helpful. See Microsoft Code Contracts ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "code": 0.2267055015767761,
                "contract": 0.2622310190573856,
                "correct": 0.23763504183567635,
                "domain": 0.2622310190573856,
                "functional": 0.22096989239985232,
                "good": 0.44887846908372964,
                "haskell": 0.23763504183567635,
                "help": 0.18469648682699716,
                "helpful": 0.24462293487949513,
                "likely": 0.22096989239985232,
                "microsoft": 0.22595761348453047,
                "program": 0.21222770786020814,
                "programming": 0.2661435227688047,
                "really": 0.15749064380990763,
                "sense": 0.22595761348453047,
                "type": 0.21641645980210628,
                "use": 0.1241252898097838
            },
            "Max term": "good",
            "Max score": 0.44887846908372964
        }
    },
    {
        "ID:": "604",
        "Question": "on a widescreen monitor one can easily see more than 80 characters at a time, without scrollbars. even linus torvalds sees the 80 character limit as outdated. so, is the 80 character limit still relevant in times of widescreen monitors? ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "80": 0.7405031085612683,
                    "character": 0.455426214080949,
                    "characters": 0.23631117941093358,
                    "easily": 0.21414635540605628,
                    "monitor": 0.2277131070404745,
                    "relevant": 0.19502509292610798,
                    "time": 0.1267900781081013,
                    "times": 0.19125037201319736
                },
                "Max term": "80",
                "Max score": 0.7405031085612683
            }
        ],
        "Best Answer": "If I keep my lines to less than about 100 characters, I can have two editor windows side-by-side on a widescreen monitor.  It's very useful to have both the class header file and implementation both visible at the same time, or have code on one side that calls into the code on the other.  And, if I keep the lines short, I don't need a horizontal scrollbar on my editor windows, which gives me more vertical space. 80 characters may be outdated, but there's some merit in keeping things within reason. ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "100": 0.19622226352492836,
                "80": 0.21971339513025379,
                "calls": 0.19622226352492836,
                "characters": 0.4206928851641536,
                "class": 0.1772491711740695,
                "code": 0.1818499426264468,
                "file": 0.17023670016693906,
                "gives": 0.21971339513025379,
                "implementation": 0.2103464425820768,
                "lines": 0.3924445270498567,
                "monitor": 0.202693085086686,
                "need": 0.12521035739759137,
                "reason": 0.1642297203367273,
                "short": 0.19622226352492836,
                "space": 0.19622226352492836,
                "things": 0.12002138351500509,
                "time": 0.11285899359998204,
                "useful": 0.15657636284133652,
                "windows": 0.3812339658569442
            },
            "Max term": "characters",
            "Max score": 0.4206928851641536
        }
    },
    {
        "ID:": "616",
        "Question": "When I am in a code or design rut, I tend to find a non-dev coworker to discuss the problem with. It forces me to explain the problem in great detail and I'll usually find something I missed in the process. What are your \"unsticking\" methods? ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "code": 0.12926100481070776,
                    "design": 0.20064823973164822,
                    "dev": 0.31234955386538954,
                    "discuss": 0.31234955386538954,
                    "explain": 0.2193660091329451,
                    "forces": 0.31234955386538954,
                    "great": 0.23347270132621528,
                    "methods": 0.2576691607437548,
                    "missed": 0.31234955386538954,
                    "non": 0.2193660091329451,
                    "problem": 0.3924515726889492,
                    "process": 0.22600348918318078,
                    "tend": 0.27895402751449655,
                    "usually": 0.2296213126953675
                },
                "Max term": "problem",
                "Max score": 0.3924515726889492
            }
        ],
        "Best Answer": "Some of my tactics:  Explain the problem to someone, or even no one.  My girlfriend used to explain problems to a potato she kept. Work on something else for a bit (if opportunity allows)- some other functionality or even another project.  Get your ming off the current project.  A lot of times problems that seem impossible at 4:30pm seem trivial at 9:30 am the next day. Go to the pub (if possible).  Same principle as above. Beat your head against it.  This isn't often that productive for solving the problem, but at least for me, I tend to learn a lot.  If my gridview isn't auto-sorting, I'll try and read everything I can about the problem.  It'll still take me 3 hours to solve a stupid error on my part, but by the end, I'll have learned everything there is to know about gridviews and how they bind to data- I'll be able to solve any number of similar problems in the future. Get another input- preferably someone who knows at least something about the context of the project.  Most of my errors are stupid ones that only require a few minutes from a second set of eyes to solve where it would take me hours. Isolate the problem.  I keep a folder labeled \"proof of bugs\" where I keep a pile of project that each reproduce a specific issue outside the overall context of the large, complex project.  This can be a little time consuming, but it allows you to narrow down the cause of the issue independent of the bazillion interfering factors of a large project.  ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "30": 0.10305609882147725,
                "able": 0.09096760381785479,
                "allows": 0.2061121976429545,
                "bit": 0.08340492941115776,
                "bugs": 0.08684058487660062,
                "cause": 0.09338994464840218,
                "complex": 0.09338994464840218,
                "context": 0.19227233636631072,
                "current": 0.09096760381785479,
                "data": 0.07454539339276797,
                "day": 0.08684058487660062,
                "end": 0.07788777828262435,
                "error": 0.09096760381785479,
                "errors": 0.0888007461071226,
                "explain": 0.15120059556463267,
                "eyes": 0.10305609882147725,
                "factors": 0.10764529736275683,
                "functionality": 0.10305609882147725,
                "head": 0.10305609882147725,
                "hours": 0.19227233636631072,
                "impossible": 0.10764529736275683,
                "input": 0.09930645059030581,
                "issue": 0.16680985882231553,
                "kept": 0.10764529736275683,
                "know": 0.05697337952757927,
                "knows": 0.09613616818315536,
                "large": 0.19861290118061162,
                "learn": 0.07079574516159653,
                "learned": 0.09930645059030581,
                "little": 0.09096760381785479,
                "lot": 0.1367468086620983,
                "number": 0.08505109787595116,
                "ones": 0.09338994464840218,
                "opportunity": 0.09930645059030581,
                "outside": 0.09930645059030581,
                "overall": 0.10764529736275683,
                "possible": 0.07454539339276797,
                "principle": 0.10764529736275683,
                "problem": 0.2705018510177844,
                "problems": 0.2551532936278535,
                "productive": 0.09613616818315536,
                "project": 0.3680696704077702,
                "read": 0.07913459193404755,
                "reproduce": 0.10764529736275683,
                "require": 0.08188081546880074,
                "second": 0.09930645059030581,
                "set": 0.07913459193404755,
                "similar": 0.08505109787595116,
                "solve": 0.26052175462980187,
                "solving": 0.10305609882147725,
                "specific": 0.08505109787595116,
                "stupid": 0.21529059472551365,
                "tend": 0.09613616818315536,
                "time": 0.055293578795818706,
                "times": 0.08340492941115776,
                "trivial": 0.09930645059030581,
                "try": 0.06995619485148838,
                "used": 0.06029004067841333,
                "work": 0.05611633357484466
            },
            "Max term": "project",
            "Max score": 0.3680696704077702
        }
    },
    {
        "ID:": "648",
        "Question": "We, as programmers, are constantly being asked 'How long will it take'? And you know, the situation is almost always like this:  The requirements are unclear. Nobody has done an in depth analysis of all the implications. The new feature will probably break some assumptions you made in your code and you start thinking immediately of all the things you might have to refactor.  You have other things to do from past assignments and you will have to come up with an estimate that takes that other work into account. The 'done' definition is probably unclear: When will it be done? 'Done' as in just finished coding it, or 'done' as in \"the users are using it\"? No matter how conscious you are of all these things, sometimes your \"programmer's pride\" makes you give/accept shorter times than you originally suppose it might take. Specially when you feel the pressure of deadlines and management expectations.  Many of these are organizational or cultural issues that are not simple and easy to solve, but in the end the reality is that you are being asked for an estimate and they expect you to give a reasonable answer. It's part of your job. You cannot simply say: I don't know.  As a result, I always end up giving estimates that I later realize I cannot fulfill. It has happened countless of times, and I always promise it won't happen again. But it does. What is your personal process for deciding and delivering an estimate? What techniques have you found useful? ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "accept": 0.12783304423139535,
                    "account": 0.12318189836357196,
                    "analysis": 0.13352558670896666,
                    "answer": 0.09122307019897735,
                    "asked": 0.19632056533524261,
                    "break": 0.12318189836357196,
                    "code": 0.055257487300201344,
                    "coding": 0.0878165943222266,
                    "come": 0.11015039221072266,
                    "definition": 0.12783304423139535,
                    "easy": 0.09980670386532796,
                    "end": 0.19322741536210442,
                    "estimate": 0.40057676012689997,
                    "estimates": 0.12783304423139535,
                    "expectations": 0.13352558670896666,
                    "feature": 0.10156675854437205,
                    "feel": 0.10156675854437205,
                    "happen": 0.11015039221072266,
                    "happened": 0.12318189836357196,
                    "immediately": 0.12783304423139535,
                    "issues": 0.12318189836357196,
                    "job": 0.09122307019897735,
                    "know": 0.141342057936377,
                    "later": 0.11584293468829399,
                    "like": 0.05555586116213553,
                    "long": 0.08677519771247864,
                    "makes": 0.09661370768105221,
                    "management": 0.10156675854437205,
                    "matter": 0.11924941056504472,
                    "new": 0.07677393966797318,
                    "organizational": 0.13352558670896666,
                    "originally": 0.12318189836357196,
                    "past": 0.10771896524863624,
                    "personal": 0.10771896524863624,
                    "probably": 0.19632056533524261,
                    "process": 0.09661370768105221,
                    "programmer": 0.08577465087027432,
                    "programmers": 0.08298890329042997,
                    "promise": 0.12783304423139535,
                    "reality": 0.13352558670896666,
                    "realize": 0.12783304423139535,
                    "requirements": 0.11283821001817726,
                    "result": 0.11584293468829399,
                    "say": 0.07893105566037953,
                    "simple": 0.10549924634289928,
                    "simply": 0.11584293468829399,
                    "situation": 0.11283821001817726,
                    "solve": 0.10771896524863624,
                    "start": 0.09122307019897735,
                    "suppose": 0.13352558670896666,
                    "takes": 0.103457302890947,
                    "techniques": 0.12318189836357196,
                    "things": 0.21882041796262208,
                    "thinking": 0.11283821001817726,
                    "times": 0.206914605781894,
                    "useful": 0.0951555579975046,
                    "users": 0.10156675854437205,
                    "using": 0.07819156404612805,
                    "work": 0.06960793037977744
                },
                "Max term": "estimate",
                "Max score": 0.40057676012689997
            }
        ],
        "Best Answer": "From The Pragmatic Programmer: From Journeyman to Master:  What to Say When Asked for an Estimate You say \"I'll get back to you.\" You almost always get better results if you slow the process down and spend some time going through the steps we describe in this section. Estimates given at the coffee machine will (like the coffee) come back to haunt you.  In the section, the authors recommend the following process:  Determine the accuracy that you need. Based on the duration, you can quote the estimate in different precision. Saying \"5 to 6 months\" is different than saying \"150 days\". If you slip a little into the 7th month, you're still pretty accurate. But if you slip into the 180th or 210th day, not so much. Make sure you understand what is being asked. Determine the scope of the problem. Model the system. A model might be a mental model, diagrams, or existing data records. Decompose this model and build estimates from the components. Assign values and error ranges (+/-) to each value. Calculate the estimate based on your model. Track your estimates. Record information about the problem you are estimating, your estimate, and the actual values. Other things to include in your estimate are developing and documenting requirements or changes to requirements specifications, creating or updating design documents and specifications, testing (unit, integration, and acceptance), creating or updating user's manuals or READMEs with the changes. If 2 or more people working together, there's overhead of communication (phone calls, emails, meetings) and merging source code. If it's a long task, account for things like other work, time off (holidays, vacation, sick time), meetings, and other overhead tasks when picking a delivery date.  ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "account": 0.0777126221209701,
                "actual": 0.0777126221209701,
                "asked": 0.12385412232764138,
                "authors": 0.08423821682604778,
                "based": 0.1305376584064161,
                "better": 0.05411325137209451,
                "build": 0.07523170615570156,
                "calls": 0.07523170615570156,
                "changes": 0.13898269015279233,
                "code": 0.03486067585385384,
                "coffee": 0.16847643365209555,
                "come": 0.06949134507639616,
                "communication": 0.07523170615570156,
                "components": 0.0806469229075097,
                "creating": 0.1612938458150194,
                "data": 0.05833576724528262,
                "date": 0.0777126221209701,
                "day": 0.06795741381515139,
                "days": 0.07118702741589243,
                "design": 0.05411325137209451,
                "determine": 0.1612938458150194,
                "developing": 0.07308263899493424,
                "diagrams": 0.08423821682604778,
                "different": 0.11667153449056523,
                "emails": 0.0806469229075097,
                "error": 0.07118702741589243,
                "estimate": 0.42119108413023887,
                "estimates": 0.2419407687225291,
                "existing": 0.07523170615570156,
                "following": 0.07308263899493424,
                "given": 0.07308263899493424,
                "going": 0.0600314495847789,
                "include": 0.07308263899493424,
                "information": 0.06526882920320805,
                "integration": 0.08423821682604778,
                "like": 0.07009782610031412,
                "little": 0.07118702741589243,
                "long": 0.054744473326744536,
                "machine": 0.0806469229075097,
                "make": 0.04718018941416908,
                "master": 0.0806469229075097,
                "meetings": 0.1612938458150194,
                "model": 0.35593513707946217,
                "month": 0.0806469229075097,
                "need": 0.04800570866001279,
                "overhead": 0.16847643365209555,
                "people": 0.043588895495631004,
                "pragmatic": 0.08423821682604778,
                "pretty": 0.060951362630922205,
                "problem": 0.10584110098694897,
                "process": 0.12190272526184441,
                "programmer": 0.05411325137209451,
                "recommend": 0.0806469229075097,
                "record": 0.08423821682604778,
                "requirements": 0.14237405483178486,
                "say": 0.09959156959961733,
                "saying": 0.16847643365209555,
                "scope": 0.08423821682604778,
                "section": 0.1612938458150194,
                "slow": 0.08423821682604778,
                "source": 0.06407612832458803,
                "spend": 0.07118702741589243,
                "steps": 0.07308263899493424,
                "sure": 0.06296575037131849,
                "task": 0.06526882920320805,
                "tasks": 0.06795741381515139,
                "testing": 0.06296575037131849,
                "things": 0.09203250736993476,
                "time": 0.129810570284193,
                "track": 0.0777126221209701,
                "understand": 0.055401466458743026,
                "unit": 0.06407612832458803,
                "user": 0.05916128649112633,
                "value": 0.07118702741589243,
                "values": 0.16847643365209555,
                "work": 0.04391403982312828,
                "working": 0.055401466458743026
            },
            "Max term": "estimate",
            "Max score": 0.42119108413023887
        }
    },
    {
        "ID:": "678",
        "Question": "I know some people are massive proponents of test driven development. I have used unit tests in the past, but only to test operations that can be tested easily or which I believe will quite possibly be correct. Complete or near complete code coverage sounds like it would take a lot of time.  What projects do you use test-driven development for? Do you only use it for projects above a certain size? Should I be using it or not? Convince me!  ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "believe": 0.1709215541491911,
                    "certain": 0.1709215541491911,
                    "code": 0.07920119322164687,
                    "complete": 0.3234646130716068,
                    "convince": 0.19138376190572998,
                    "correct": 0.1660390130257834,
                    "coverage": 0.18322457518341018,
                    "development": 0.22626558303614738,
                    "driven": 0.3234646130716068,
                    "easily": 0.1660390130257834,
                    "know": 0.1012936000885025,
                    "like": 0.07962885591580728,
                    "lot": 0.12156182997089351,
                    "operations": 0.19138376190572998,
                    "past": 0.15439483402391366,
                    "people": 0.09903114182125054,
                    "possibly": 0.1617323065358034,
                    "projects": 0.28138852829167355,
                    "quite": 0.1512132853408201,
                    "size": 0.1709215541491911,
                    "test": 0.38715025543190124,
                    "tested": 0.18322457518341018,
                    "tests": 0.14828654426395682,
                    "time": 0.09830706383311041,
                    "unit": 0.14557680526924455,
                    "use": 0.17345624157406306,
                    "used": 0.10719032854357036,
                    "using": 0.11207286966697813
                },
                "Max term": "test",
                "Max score": 0.38715025543190124
            }
        ],
        "Best Answer": "Ok, some advantages to TDD:  It means you end up with more tests.  Everyone likes having tests, but few people like writing them.  Building test-writing into your development flow means you end up with more tests. Writing to a test forces you to think about the testability of your design, and testable design is almost always better design.  It's not entirely clear to me why this happens to be the case, but my experience and that of most TDD evangelists seems to bear it out. Here's a study saying that although TDD takes a bit longer to write, there's a good return on investment because you get higher quality code, and therefore fewer bugs to fix. It gives you confidence in refactoring.  It's a great feeling to be able to change one system without worrying about breaking everything else because it's pretty well covered by unit tests. You almost never get a repeat bug, since every one you find should get a test before it gets a fix.  You asked to be convinced, so these were benefits.  See this question for a more balanced view. ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "able": 0.10522519131907182,
                "advantages": 0.1245168228490948,
                "asked": 0.0915375609199288,
                "benefits": 0.11920834736727093,
                "better": 0.07998756845484566,
                "bit": 0.09647719941942866,
                "bug": 0.10271871640268794,
                "bugs": 0.10045133403972172,
                "building": 0.11920834736727093,
                "case": 0.0983813761195003,
                "change": 0.08622908543810494,
                "clear": 0.11487100708408331,
                "code": 0.05152935049251672,
                "covered": 0.1245168228490948,
                "design": 0.23996270536453698,
                "development": 0.0736056999800138,
                "end": 0.18019066188919358,
                "entirely": 0.11920834736727093,
                "experience": 0.08290421747745344,
                "feeling": 0.1245168228490948,
                "fewer": 0.1245168228490948,
                "fix": 0.20090266807944343,
                "forces": 0.1245168228490948,
                "gets": 0.10802719188451179,
                "gives": 0.1245168228490948,
                "good": 0.06801898145709971,
                "great": 0.09307290063767645,
                "happens": 0.11920834736727093,
                "higher": 0.1112038381269252,
                "like": 0.05180759353360695,
                "longer": 0.11920834736727093,
                "means": 0.1967627522390006,
                "ok": 0.1245168228490948,
                "people": 0.06443097899169808,
                "pretty": 0.09009533094459679,
                "quality": 0.10045133403972172,
                "question": 0.07431588731012725,
                "repeat": 0.11920834736727093,
                "return": 0.10522519131907182,
                "saying": 0.1245168228490948,
                "study": 0.1245168228490948,
                "takes": 0.09647719941942866,
                "tdd": 0.3240815756535354,
                "test": 0.2518851092254162,
                "tests": 0.38590879767771463,
                "think": 0.06491159147558968,
                "unit": 0.09471420716234223,
                "view": 0.1245168228490948,
                "write": 0.07431588731012725,
                "writing": 0.2552051741919923
            },
            "Max term": "tests",
            "Max score": 0.38590879767771463
        }
    },
    {
        "ID:": "724",
        "Question": "When learning a new programming language you sometimes come across a language feature which  makes you wish you had it in your other programming languages that you know. What are some language feature which were at the time of learning very new to you and that you wish your other programming languages had.   An example of this is generators in Python or C#. Other examples may include list comprehensions in Python, template in C++ or LINQ in .NET or lazy evaluation in Haskell. What other semi-unique language features have you come across which were completely new and enlightening to you?  Are there other features of older programming languages which were unique and have fallen out of fashion? ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "come": 0.2727673119604116,
                    "completely": 0.13971160072767513,
                    "example": 0.1006468935820348,
                    "examples": 0.1363836559802058,
                    "feature": 0.2515115121849168,
                    "features": 0.26124959939997955,
                    "haskell": 0.14343192643419173,
                    "include": 0.14343192643419173,
                    "know": 0.08750194265423891,
                    "language": 0.35272497306253,
                    "languages": 0.3223243732929978,
                    "learning": 0.23221978320557246,
                    "list": 0.11610989160278623,
                    "makes": 0.11962309354412007,
                    "net": 0.12153799867230443,
                    "new": 0.28517494216155825,
                    "programming": 0.32127819099262833,
                    "python": 0.2667463275284395,
                    "time": 0.08492203904803086,
                    "unique": 0.330651708392158
                },
                "Max term": "language",
                "Max score": 0.35272497306253
            }
        ],
        "Best Answer": "Practically anything in Haskell  Monads. Yes - the big scary word that makes increadibly easy parsers, IO, operations on Lists and other things so easy (once you notice common pattern) Arrows. The same for advanced users ;) Standard stuff like lambdas etc.  Currying functions Algebraic data types Pattern matching  And many more. PS. Yes. I am Haskell fanboy if anyone asked. ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "asked": 0.15636269863717944,
                "big": 0.1648004939892921,
                "common": 0.14937925741588817,
                "data": 0.14729486305530992,
                "easy": 0.31797067274771057,
                "functions": 0.19622044199483785,
                "haskell": 0.36905993735258497,
                "like": 0.0884967335091975,
                "lists": 0.20362940313353597,
                "makes": 0.15389910916929306,
                "notice": 0.20362940313353597,
                "operations": 0.2126972387154055,
                "pattern": 0.3924408839896757,
                "practically": 0.2126972387154055,
                "standard": 0.1617889845692889,
                "stuff": 0.1648004939892921,
                "things": 0.11618871414421617,
                "types": 0.18452996867629248,
                "users": 0.1617889845692889,
                "word": 0.20362940313353597,
                "yes": 0.31797067274771057
            },
            "Max term": "pattern",
            "Max score": 0.3924408839896757
        }
    },
    {
        "ID:": "729",
        "Question": "As programmers we have a lot of inputs:  Ebooks  Code snippets  Interesting emails  Documents Web articles  Blog posts StackOverflow questions Podcasts ...  Which tools do you use to store, organize, search and consult all of this stuff? Is there a silver bullet solution to handle this huge amount of data?  ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "articles": 0.2690874899145552,
                    "blog": 0.2510190127730471,
                    "code": 0.11631654902688136,
                    "data": 0.19464382042543016,
                    "emails": 0.2690874899145552,
                    "handle": 0.28107024426208443,
                    "huge": 0.2690874899145552,
                    "interesting": 0.21777675808034622,
                    "lot": 0.17852827691669518,
                    "organize": 0.28107024426208443,
                    "programmers": 0.17469094795834558,
                    "questions": 0.2066265747729594,
                    "search": 0.2592968667284755,
                    "solution": 0.2375234891948666,
                    "stackoverflow": 0.28107024426208443,
                    "stuff": 0.21777675808034622,
                    "tools": 0.22674752173217752,
                    "use": 0.12737075419183033,
                    "web": 0.2003016544503041
                },
                "Max term": "handle",
                "Max score": 0.28107024426208443
            }
        ],
        "Best Answer": "I'm currently using OneNote from Microsoft to organize and keep record of most of my data, activities and notes. I'm using its online storage to have it automatically shared between my home desktop, personal notebook and office notebook. Unfortunately it has some limits (for example, no integration with eBooks) but it is the most comprehensive and powerful tool I've found. I tried for a while also Evernote and, while its online sharing is quite better and it can be used on Android (my current mobile platform), it is not powerful as OneNote. ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "android": 0.192674318167612,
                "better": 0.12377082759813297,
                "current": 0.1628229144268282,
                "currently": 0.17774861629722008,
                "data": 0.13342879992319376,
                "desktop": 0.16715866228883153,
                "example": 0.11729606171341757,
                "home": 0.192674318167612,
                "integration": 0.192674318167612,
                "microsoft": 0.1589444558019742,
                "mobile": 0.18446011168075466,
                "notes": 0.192674318167612,
                "office": 0.192674318167612,
                "online": 0.385348636335224,
                "organize": 0.192674318167612,
                "personal": 0.1554359632078511,
                "platform": 0.18446011168075466,
                "powerful": 0.35549723259444016,
                "quite": 0.15223296041843962,
                "record": 0.192674318167612,
                "sharing": 0.192674318167612,
                "tool": 0.1589444558019742,
                "tried": 0.1720741278043505,
                "unfortunately": 0.192674318167612,
                "used": 0.10791314404441328,
                "using": 0.2256572191198646
            },
            "Max term": "online",
            "Max score": 0.385348636335224
        }
    },
    {
        "ID:": "739",
        "Question": "What is the recommended  User Account Control (UAC) setting when developing on Windows? Even on Win7 I find it annoying enough to turn it off (because it makes me more productive with it off) but sometimes I feel bad because I know I'll find more problems in my code if I leave it on. ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "account": 0.2824099934266149,
                    "annoying": 0.2824099934266149,
                    "bad": 0.2328545670583782,
                    "code": 0.12668473884987627,
                    "control": 0.2824099934266149,
                    "developing": 0.26558449624864366,
                    "feel": 0.2328545670583782,
                    "know": 0.16202222153981982,
                    "leave": 0.25869578706645596,
                    "makes": 0.22149907505562216,
                    "problems": 0.24187028988848472,
                    "productive": 0.27339427059650834,
                    "setting": 0.30612419978677385,
                    "turn": 0.2824099934266149,
                    "user": 0.21499388481656473,
                    "windows": 0.26558449624864366
                },
                "Max term": "setting",
                "Max score": 0.30612419978677385
            }
        ],
        "Best Answer": "The recommendation (even from Microsoft) is to leave it ON, and also to run your IDE unelevated whenever possible. First of all, it forces the programmer to live with the same \"annoyances\" a real world user will have (if you don't know it, would you program correctly around it?). Then, disabling UAC and working as an administrator is as bad as in Unix to work as root (decades of common wisdom will tell you why that's bad). ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "bad": 0.3822815765788643,
                "common": 0.17647968489680943,
                "correctly": 0.23181881054041495,
                "decades": 0.251284832420942,
                "forces": 0.251284832420942,
                "ide": 0.21800744821848655,
                "know": 0.13299741352190023,
                "leave": 0.2123527886598879,
                "live": 0.23181881054041495,
                "microsoft": 0.20729452331935525,
                "possible": 0.17401713911689976,
                "program": 0.19469864660724578,
                "programmer": 0.1614212624047903,
                "real": 0.18473006401603106,
                "run": 0.2123527886598879,
                "tell": 0.1985414263379595,
                "unix": 0.251284832420942,
                "user": 0.17647968489680943,
                "wisdom": 0.23181881054041495,
                "work": 0.13099674415792228,
                "working": 0.165264042135504,
                "world": 0.17401713911689976
            },
            "Max term": "bad",
            "Max score": 0.3822815765788643
        }
    },
    {
        "ID:": "745",
        "Question": "What methods do you use to stay awake and alert while working? Personally I drink coffee non stop throughout the day.  But I've also heard of this thing called exercise that should help too.  Does anyone else have tips and tricks to stay more awake and alert while working?  Redbull? Maybe a magic pill that won't require me to sleep? ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "called": 0.22442113493596857,
                    "coffee": 0.23441484862063422,
                    "day": 0.189109260290071,
                    "exercise": 0.20935187940146027,
                    "heard": 0.1980965039883108,
                    "help": 0.15806595017399586,
                    "magic": 0.23441484862063422,
                    "maybe": 0.1980965039883108,
                    "methods": 0.19337782481989338,
                    "non": 0.16463173770234724,
                    "personally": 0.189109260290071,
                    "require": 0.17830856928538513,
                    "sleep": 0.23441484862063422,
                    "stay": 0.432511352608945,
                    "stop": 0.23441484862063422,
                    "thing": 0.17521865250373167,
                    "tips": 0.20935187940146027,
                    "tricks": 0.2162556763044725,
                    "use": 0.10622823536856911,
                    "working": 0.3083381121446443
                },
                "Max term": "stay",
                "Max score": 0.432511352608945
            }
        ],
        "Best Answer": "Caffeine is a major cause of the problem, not the solution.  It might seem to work in the short-term but it makes things worse overall by interfering with your sleep. If you don't sleep properly you will be tired and unfocused.  If you try to solve that with a high caffeine intake you won't sleep properly. Exercise, eat well, try to restrict the coffee to a couple of cups a day and don't work stupid long hours. ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "cause": 0.16205927171719403,
                "coffee": 0.1867965396067683,
                "couple": 0.1723261655210738,
                "day": 0.15069418869002246,
                "exercise": 0.166824784617863,
                "high": 0.166824784617863,
                "hours": 0.166824784617863,
                "long": 0.12139476077880182,
                "major": 0.1723261655210738,
                "makes": 0.13515841209322682,
                "overall": 0.1867965396067683,
                "problem": 0.11735024883871446,
                "properly": 0.3576658361647187,
                "short": 0.166824784617863,
                "sleep": 0.5603896188203049,
                "solution": 0.15785579143537926,
                "solve": 0.15069418869002246,
                "stupid": 0.1867965396067683,
                "things": 0.10204011050909603,
                "try": 0.24278952155760364,
                "work": 0.1947569876996183,
                "worse": 0.17883291808235935
            },
            "Max term": "sleep",
            "Max score": 0.5603896188203049
        }
    },
    {
        "ID:": "750",
        "Question": "I'm freshly out of college, and starting university somewhere next week. We've seen unit tests, but we kinda not used them much; and everyone talks about them, so I figured maybe I should do some. The problem is, I don't know what to test. Should I test the common case? The edge case? How do I know that a function is adequately covered? I always have the terrible feeling that while a test will prove that a function works for a certain case, it's utterly useless to prove that the function works, period. ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "adequately": 0.16179638254595147,
                    "case": 0.3835084385019753,
                    "certain": 0.1444975732794555,
                    "college": 0.15489858263313253,
                    "common": 0.113631110696411,
                    "covered": 0.16179638254595147,
                    "edge": 0.15489858263313253,
                    "feeling": 0.16179638254595147,
                    "function": 0.4101868707836673,
                    "know": 0.1712678014705206,
                    "maybe": 0.13672895692788908,
                    "problem": 0.10164452614026517,
                    "prove": 0.32359276509190293,
                    "seen": 0.11706931077724694,
                    "starting": 0.1403698589763563,
                    "terrible": 0.16179638254595147,
                    "test": 0.32729793900423537,
                    "tests": 0.12536187084652556,
                    "unit": 0.12307104970986035,
                    "university": 0.15489858263313253,
                    "used": 0.09061901192434699,
                    "useless": 0.15489858263313253,
                    "week": 0.15489858263313253,
                    "works": 0.288995146558911
                },
                "Max term": "function",
                "Max score": 0.4101868707836673
            }
        ],
        "Best Answer": "My personal philosophy has thusfar been:  Test the common case of everything you can.  This will tell you when that code breaks after you make some change (which is, in my opinion, the single greatest benefit of automated unit testing). Test the edge cases of a few unusually complex code that you think will probably have errors. Whenever you find a bug, write a test case to cover it before fixing it Add edge-case tests to less critical code whenever someone has time to kill.  ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "add": 0.1565371045275302,
                "automated": 0.1804314503944749,
                "benefit": 0.1804314503944749,
                "breaks": 0.17273918915094968,
                "bug": 0.14884484328400496,
                "case": 0.427679424648318,
                "cases": 0.14884484328400496,
                "change": 0.12495049741706027,
                "code": 0.22400624834086744,
                "common": 0.12671869290443288,
                "complex": 0.1565371045275302,
                "critical": 0.1804314503944749,
                "edge": 0.34547837830189937,
                "errors": 0.14884484328400496,
                "fixing": 0.1804314503944749,
                "make": 0.10105615155011556,
                "opinion": 0.1664541540830507,
                "personal": 0.14555928652960035,
                "probably": 0.1326427586605855,
                "single": 0.1565371045275302,
                "tell": 0.142559808216106,
                "test": 0.364994821987967,
                "testing": 0.13486754697258077,
                "tests": 0.13980055564332167,
                "think": 0.09406032317053635,
                "time": 0.0926812491028753,
                "unit": 0.13724588678250563,
                "write": 0.10768764435123147
            },
            "Max term": "case",
            "Max score": 0.427679424648318
        }
    },
    {
        "ID:": "756",
        "Question": "I'm trying to find places where I can hone my craft outside the context of school or work. Are there places online, or books available, where I can access lists of programming puzzles or challenges? ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "access": 0.23665867112442107,
                    "available": 0.2479056568480939,
                    "books": 0.23665867112442107,
                    "challenges": 0.2808493221575425,
                    "context": 0.2619910706675794,
                    "lists": 0.2808493221575425,
                    "online": 0.29335584350178096,
                    "outside": 0.27063075017493743,
                    "places": 0.5239821413351587,
                    "programming": 0.1425198060758062,
                    "school": 0.2808493221575425,
                    "trying": 0.20905685320883938,
                    "work": 0.15292869055486874
                },
                "Max term": "places",
                "Max score": 0.5239821413351587
            }
        ],
        "Best Answer": "Moderator note: this is intended to be a canonical list; please check to see if your suggestion has already been added to the answer. If it hasn't, edit the answer to add yours, preferably with an explanation or reason why you're suggesting it. On Stack Exchange Pick a tag, follow the new questions posted, and try to solve them. If you find a good one, bookmark it for later use:  Stack Overflow Code Review Community Challenges Programming Puzzles and Code Golf Solve algorithmic and datatypes problems  Books  Algorithms for Interviews by Adnan Aziz Cracking the Coding Interview (6th Edition) by Gayle Laakmann Programming Challenges by Steven S. Skiena The Art of Computer Programming by Donald E. Knuth  Communities and Blogs  Algorithm Geeks Google Group CodeKata LessThanDot's Programmer Puzzles forum The Daily WTF's Bring Your Own Code series /r/dailyprogrammer  Game sites and ongoing contests  Codingame - fun games (solo and multiplayer) to practice your coding skills. Supports 25+ programming languages. CodeChef Code Combat - Javascript and Python solo and multiplayer games in the style of a strategy game. Hacker.org Challenge — \"The hacker.org challenges are a series of puzzles, tricks, tests, and brainteasers designed to probe the depths your hacking skills. To master this series you will need to crack cryptography, write clever code, and dissect the impenetrable; and in the process you will enrich your understanding of the world of hacking.\" Pex for fun — game from Microsoft research where you duel against other programmers Rankk — \"You start with the easy levels and progress to the intermediate and hard levels by solving the minimum number of required challenges at each level. The journey to the top is an arduous yet rewarding one. You need to be sufficiently determined and persevering to go far. Only a few are expected to reach the apex and attain Geb.\" TopCoder Google Code Jam—algorithmic puzzles  Language specific  4Clojure (Clojure) — \"4Clojure is a resource to help fledgling clojurians learn the language through interactive problems. The first few problems are easy enough that even someone with no prior experience should find the learning curve forgiving. See 'Help' for more information.\"  Prolog Problems (Prolog) — \"The purpose of this problem collection is to give you the opportunity to practice your skills in logic programming. Your goal should be to find the most elegant solution of the given problems. Efficiency is important, but logical clarity is even more crucial. Some of the (easy) problems can be trivially solved using built-in predicates. However, in these cases, you learn more if you try to find your own solution.\"  Python Challenge (Python) — \"Python Challenge is a game in which each level can be solved by a bit of (Python) programming.\"  Ruby Quiz (Ruby) - \"Ruby Quiz is a weekly programming challenge for Ruby programmers in the spirit of the Perl Quiz of the Week. A new Ruby Quiz is sent to the Ruby Talk mailing list each Friday.\"  IOCCC (C) - \"A contest to write the most obscure/obfuscated C program. (Fun to try to understand the previous year's entries, or to submit a new one.)\"  Underhanded C Contest (C) - \"contest to turn out code that is malicious, but passes a rigorous inspection, and looks like an honest mistake. (Try to understand previous year's entries, and learn to find similar mistakes in other people's code)\"  CheckiO - Python programming challenges. Custom \"Missions\" can be created by members.  109 Python Problems for CCPS 109 Python problems of various levels of difficulty, with an automated pseudorandom fuzz tester to verify that the functions are correct.   Online judges / automatic assessment  Codingbat has lots of coding challenges ranging from warm-ups to Harder recursion problems. It is available in Java and Python. Cyber-dojo has a nice variety of katas and supports a good selection of languages. It is intended to support doing deliberate practice of TDD, but could be used for personal development too. LeetCode Peking University JudgeOnline for ACIP/ICPC Sphere Online Judge University of Valladolid Online Judge Codewars — Training with code challenges. Rosalind algorithms and bioinformatics Quizful - interactive programming quizzes in \"Duolingo style\". This site looks fun and has a good set of questions, at least in Java. Plus, as they say, it has adaptive learning algorithm, that makes learning more effective. exercism - Challenges in more than 30 languages that will be evaluated automatically.  Problem lists and contest archives  ACM/ICPC Problem Index @ HIT — List of problems from the ACM International Collegiate Programming Contest Algorithmist — Includes lists of algorithms and other puzzle sites Career Cup — Collects community-subumitted interview questions from various tech companies Educational Computing Organization of Ontairo's past computer programming puzzles Engineering Puzzles at Facebook — Puzzles provided for the purposes of evaluating potential hires Google Code Jam contest archives Ninth Annual ICFP Programming Contest Task archive Ponder this at IBM Research — Puzzles provided for the purposes of evaluating potential hires Programming Praxis Project Euler Rosetta Code TopCoder Match List International Olympiad in Informatics - yearly contents for teams of students. (previous year's problem sets)  Security oriented  Smashthestack gera's insecure programming challenges  ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "30": 0.04067705986412126,
                "add": 0.036861752119597385,
                "added": 0.03794570833762699,
                "algorithm": 0.08135411972824252,
                "algorithms": 0.12203117959236377,
                "answer": 0.058055197070264346,
                "automated": 0.042488452939608644,
                "available": 0.03590563497464151,
                "bit": 0.032920587383164446,
                "books": 0.0342766678542718,
                "bring": 0.042488452939608644,
                "built": 0.039197043957125074,
                "career": 0.03231900751761574,
                "cases": 0.035050359044110004,
                "challenges": 0.36609353877709133,
                "check": 0.033570343137113816,
                "code": 0.19341503956213366,
                "coding": 0.08383092695130769,
                "companies": 0.03794570833762699,
                "computer": 0.06584117476632889,
                "computing": 0.04067705986412126,
                "correct": 0.036861752119597385,
                "created": 0.042488452939608644,
                "daily": 0.039197043957125074,
                "designed": 0.039197043957125074,
                "development": 0.02511622323899107,
                "easy": 0.0952768501848793,
                "edit": 0.0342766678542718,
                "effective": 0.03794570833762699,
                "engineering": 0.04067705986412126,
                "euler": 0.042488452939608644,
                "experience": 0.028289124812113438,
                "far": 0.0342766678542718,
                "follow": 0.03590563497464151,
                "fun": 0.1567881758285003,
                "functions": 0.039197043957125074,
                "game": 0.14020143617644001,
                "games": 0.07589141667525398,
                "given": 0.036861752119597385,
                "goal": 0.039197043957125074,
                "golf": 0.042488452939608644,
                "good": 0.06962965870425204,
                "google": 0.11058525635879217,
                "group": 0.04067705986412126,
                "hard": 0.032920587383164446,
                "help": 0.057299934068521095,
                "important": 0.030278934154630257,
                "information": 0.032920587383164446,
                "interview": 0.07372350423919477,
                "interviews": 0.04067705986412126,
                "java": 0.058055197070264346,
                "javascript": 0.036861752119597385,
                "language": 0.04532484798420436,
                "languages": 0.08283679544583408,
                "later": 0.036861752119597385,
                "learn": 0.08383092695130769,
                "learning": 0.08952011206916927,
                "level": 0.06584117476632889,
                "like": 0.017678129343492437,
                "list": 0.11936014942555902,
                "lists": 0.08135411972824252,
                "logic": 0.04067705986412126,
                "logical": 0.039197043957125074,
                "looks": 0.07589141667525398,
                "lots": 0.036861752119597385,
                "makes": 0.03074292405900233,
                "master": 0.04067705986412126,
                "match": 0.04067705986412126,
                "members": 0.04067705986412126,
                "microsoft": 0.035050359044110004,
                "minimum": 0.042488452939608644,
                "mistakes": 0.042488452939608644,
                "need": 0.048426673072757,
                "new": 0.07328945716630902,
                "nice": 0.036861752119597385,
                "note": 0.039197043957125074,
                "number": 0.033570343137113816,
                "online": 0.12746535881882592,
                "opportunity": 0.039197043957125074,
                "org": 0.08497690587921729,
                "organization": 0.03794570833762699,
                "oriented": 0.03590563497464151,
                "overflow": 0.036861752119597385,
                "passes": 0.042488452939608644,
                "past": 0.0342766678542718,
                "people": 0.021985564328600105,
                "personal": 0.0342766678542718,
                "pick": 0.03794570833762699,
                "plus": 0.042488452939608644,
                "potential": 0.07589141667525398,
                "practice": 0.10771690492392454,
                "previous": 0.11383712501288097,
                "prior": 0.042488452939608644,
                "problem": 0.10676922679041793,
                "problems": 0.3357034313711382,
                "process": 0.03074292405900233,
                "program": 0.032920587383164446,
                "programmer": 0.02729388656315319,
                "programmers": 0.052814897861495486,
                "programming": 0.2889877495393471,
                "project": 0.0242133365363785,
                "provided": 0.07839408791425015,
                "purpose": 0.036861752119597385,
                "python": 0.3084900106884462,
                "questions": 0.09370515389875837,
                "reason": 0.031758950061626434,
                "required": 0.03794570833762699,
                "resource": 0.042488452939608644,
                "review": 0.04067705986412126,
                "ruby": 0.23518226374275045,
                "say": 0.02511622323899107,
                "security": 0.03794570833762699,
                "set": 0.03123505129958613,
                "similar": 0.033570343137113816,
                "site": 0.03590563497464151,
                "sites": 0.07372350423919477,
                "skills": 0.10515107713233,
                "solo": 0.08135411972824252,
                "solution": 0.07181126994928302,
                "solve": 0.0685533357085436,
                "solving": 0.04067705986412126,
                "specific": 0.033570343137113816,
                "stack": 0.07372350423919477,
                "start": 0.029027598535132173,
                "style": 0.07010071808822001,
                "support": 0.036861752119597385,
                "talk": 0.039197043957125074,
                "task": 0.032920587383164446,
                "tdd": 0.036861752119597385,
                "teams": 0.042488452939608644,
                "tester": 0.039197043957125074,
                "tests": 0.032920587383164446,
                "training": 0.042488452939608644,
                "tricks": 0.039197043957125074,
                "try": 0.11044906059444544,
                "turn": 0.039197043957125074,
                "understand": 0.05588728463420512,
                "understanding": 0.04067705986412126,
                "university": 0.08135411972824252,
                "use": 0.019254212802105843,
                "used": 0.02379695740408749,
                "using": 0.024880913622117102,
                "various": 0.08497690587921729,
                "week": 0.04067705986412126,
                "world": 0.029423658224098745,
                "write": 0.05071711610355397,
                "year": 0.1028300035628154
            },
            "Max term": "challenges",
            "Max score": 0.36609353877709133
        }
    },
    {
        "ID:": "775",
        "Question": "On any team, you are going to have the need for more grizzled and grey developers and some young pups. Some reasons include:  Money. There are often tasks that don't require the same level of experience to deliver, so it makes sense not to pay top dollar to have those tasks fulfilled. Energy. There's an energy and enthusiasm that new people can bring to a team that stops it from getting too stale and set in its ways. There's also calmness and wisdom that the more senior people can bring. Knowledge transfer and career growth. Both in terms of the project and skills, it's useful and often fun to teach people and to learn new stuff. It's satisfying to help \"bring on\" new team members.  I realise there are some cutting edge projects where it may be important for there to be more senior people than junior, but in general, is there an ideal mix of experiences on a team, or is it totally dependent on the project? ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "bring": 0.4022860784298361,
                    "career": 0.10200015842332358,
                    "cutting": 0.13409535947661205,
                    "deliver": 0.12837852610646855,
                    "dependent": 0.13409535947661205,
                    "developers": 0.09417642345764056,
                    "edge": 0.12837852610646855,
                    "experience": 0.08928167769137035,
                    "experiences": 0.13409535947661205,
                    "fun": 0.12370753313428749,
                    "general": 0.11633725305181014,
                    "getting": 0.10389876999290239,
                    "going": 0.09556160036716105,
                    "help": 0.09042051104832811,
                    "important": 0.09556160036716105,
                    "include": 0.11633725305181014,
                    "knowledge": 0.10200015842332358,
                    "learn": 0.0881913202846837,
                    "level": 0.10389876999290239,
                    "makes": 0.09702597218386916,
                    "members": 0.12837852610646855,
                    "money": 0.11975826484812545,
                    "need": 0.07641831703283866,
                    "new": 0.23130463513300356,
                    "pay": 0.12370753313428749,
                    "people": 0.2775494938476774,
                    "project": 0.15283663406567732,
                    "projects": 0.09857914662700824,
                    "reasons": 0.11062041968166664,
                    "require": 0.10200015842332358,
                    "senior": 0.2567570522129371,
                    "sense": 0.11062041968166664,
                    "set": 0.09857914662700824,
                    "skills": 0.11062041968166664,
                    "stuff": 0.10389876999290239,
                    "tasks": 0.21635723494626,
                    "teach": 0.13409535947661205,
                    "team": 0.37144925302745896,
                    "terms": 0.13409535947661205,
                    "useful": 0.09556160036716105,
                    "ways": 0.10817861747313,
                    "wisdom": 0.12370753313428749
                },
                "Max term": "bring",
                "Max score": 0.4022860784298361
            }
        ],
        "Best Answer": "I really like what Eric Brechner has to say on this subject  Think of your team as a river instead of a lake. A lake stagnates. There’s no energy or impetus to change. The same is true of groups that stagnate. They cultivate mediocrity and complacency; they abhor risk. A river is always running and changing with lots of great energy. You want a river. A river depends on the flow of water, and your team depends on the flow of people and information. You can think of the people divided into three groups: new blood, new leaders, and elders ready for a new challenge. Here’s how those groups should balance and flow:  The largest group should be the new blood. Not all of them will become technical or organizational leaders.  Sometimes you’ll have more new leaders than elders, sometimes the reverse, but ideally you should maintain a balance.  For flow, you want a steady stream of new blood becoming your new leaders, and new leaders becoming elders.  The key to flow is new blood coming in and elders moving out. For this to work, you WANT your elders to transfer before they clog the stream and disrupt the flow of opportunitiesfor others.   Not all technologies flow at the same rate. Central engines, like the Windows kernel, flow slowly, while web-based services, like MSN Search, flow quickly. You need to adjust for your situation, but even the most conservative technologies do change and flow. How do you successfully encourage and maintain a healthy flow?  Keep a constant supply of new people.  Instill information sharing as a way of life.  Shape the organization and roles to create growth opportunities.  Find new challenges for your elders.    ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "based": 0.08142398602545539,
                "challenges": 0.10060842218224272,
                "change": 0.14554974418724964,
                "changing": 0.10060842218224272,
                "coming": 0.10060842218224272,
                "constant": 0.10508862305923308,
                "create": 0.08477804153010612,
                "depends": 0.1823436960298483,
                "encourage": 0.09694783152734035,
                "great": 0.07855085560604103,
                "group": 0.10060842218224272,
                "information": 0.16284797205091078,
                "instead": 0.07855085560604103,
                "kernel": 0.10508862305923308,
                "key": 0.10060842218224272,
                "life": 0.09117184801492415,
                "like": 0.1311723639557696,
                "lots": 0.09117184801492415,
                "maintain": 0.21017724611846617,
                "moving": 0.09694783152734035,
                "need": 0.059887946494416984,
                "new": 0.6646572081003224,
                "organization": 0.09385284622804181,
                "organizational": 0.10508862305923308,
                "people": 0.16313368851697652,
                "quickly": 0.09117184801492415,
                "really": 0.06042338255457476,
                "risk": 0.10060842218224272,
                "running": 0.09694783152734035,
                "say": 0.062121097239889164,
                "search": 0.09694783152734035,
                "sharing": 0.10508862305923308,
                "situation": 0.0888070399954476,
                "slowly": 0.10060842218224272,
                "subject": 0.10060842218224272,
                "successfully": 0.10508862305923308,
                "team": 0.14554974418724964,
                "technical": 0.0830310564830314,
                "technologies": 0.1938956630546807,
                "think": 0.10956703861646536,
                "true": 0.0888070399954476,
                "want": 0.17508698133418396,
                "way": 0.05885809704931588,
                "web": 0.07489026495113867,
                "windows": 0.09117184801492415,
                "work": 0.05478351930823268
            },
            "Max term": "new",
            "Max score": 0.6646572081003224
        }
    },
    {
        "ID:": "778",
        "Question": "What question have you found especially valuable in interviewing software developers?  What is it about the question that has made it particularly useful? I'm looking for a particular question you like to ask, not just an interviewing approach like \"make them write code\". ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "approach": 0.22465937855750984,
                    "ask": 0.20356270746056646,
                    "code": 0.1127014848368762,
                    "developers": 0.19126321188843687,
                    "especially": 0.22465937855750984,
                    "interviewing": 0.5024760816639284,
                    "like": 0.226620078120751,
                    "looking": 0.21100835783001096,
                    "make": 0.15252938365720467,
                    "particular": 0.21517304338181165,
                    "particularly": 0.2512380408319642,
                    "question": 0.48761593733095643,
                    "software": 0.15947712790198162,
                    "useful": 0.1940763722848683,
                    "write": 0.16253864577698546
                },
                "Max term": "interviewing",
                "Max score": 0.5024760816639284
            }
        ],
        "Best Answer": "Take a look at this sample code and tell me how you'd improve it. ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "code": 0.27775175584270756,
                "look": 0.4782994052627361,
                "sample": 0.6425527874094844,
                "tell": 0.5302919539686679
            },
            "Max term": "sample",
            "Max score": 0.6425527874094844
        }
    },
    {
        "ID:": "779",
        "Question": "It doesn't have to be programming or software development related, but just asked during an interview for an IT related job. I know some \"left field\" questions are meant to see how the candidate copes with unexpected and novel situations, but here I'm looking for a question that appeared to be completely unrelated to the job they were interviewing you for, or something that made you think \"what useful information could they possibly get from my answer to that question?\". ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "answer": 0.15338562880095835,
                    "asked": 0.1650500980444056,
                    "candidate": 0.22451454477138763,
                    "completely": 0.18973007330997224,
                    "development": 0.13271740994885392,
                    "field": 0.20712230904067994,
                    "information": 0.17395669125546495,
                    "interview": 0.1947823214078966,
                    "interviewing": 0.20712230904067994,
                    "job": 0.3067712576019167,
                    "know": 0.11882871506793305,
                    "left": 0.22451454477138763,
                    "looking": 0.17395669125546495,
                    "meant": 0.22451454477138763,
                    "possibly": 0.18973007330997224,
                    "programming": 0.10907493438705548,
                    "question": 0.2679958776162471,
                    "questions": 0.1650500980444056,
                    "related": 0.3895646428157932,
                    "situations": 0.21494290674721345,
                    "software": 0.13147400314400084,
                    "think": 0.11704118429194446,
                    "unexpected": 0.22451454477138763,
                    "useful": 0.15999784994648122
                },
                "Max term": "related",
                "Max score": 0.3895646428157932
            }
        ],
        "Best Answer": " Where do you see yourself in 5 years?  Do they really think people are dumb enough to say that they want to do something completely different? Or don't want to work for them? I guess it can be useful as an indicator of who not to hire but it's so stupid easy to fake that you can't use it as an indicator of who to hire in any way if they answer correctly. ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "answer": 0.1878141144044203,
                "completely": 0.23231632567636962,
                "correctly": 0.25361237131513403,
                "different": 0.1903766963432782,
                "easy": 0.20548648118511742,
                "guess": 0.2631883573044854,
                "hire": 0.5498168339077968,
                "people": 0.14225080621326158,
                "really": 0.15806560178940812,
                "say": 0.16250676814017573,
                "stupid": 0.2749084169538984,
                "think": 0.14331190313247102,
                "use": 0.1245784394325645,
                "useful": 0.19591049519576603,
                "want": 0.3053478956879232,
                "way": 0.15397086586267456,
                "work": 0.14331190313247102,
                "years": 0.19307074896678642
            },
            "Max term": "hire",
            "Max score": 0.5498168339077968
        }
    },
    {
        "ID:": "811",
        "Question": "Literate programming has good ideals. Why do you think that this isn't mainstream? It is because it has failed to deliver? ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "deliver": 0.51244016298256,
                    "failed": 0.493795265953833,
                    "good": 0.292392762030301,
                    "mainstream": 0.51244016298256,
                    "programming": 0.2600429016266636,
                    "think": 0.27903504452357747
                },
                "Max term": "deliver",
                "Max score": 0.51244016298256
            }
        ],
        "Best Answer": "I would blame the network effect. For other people to edit your code and documentation, they must be able to understand it.   This pushes people away from something like cweb/noweb, because using them would require you to learn TeX and the program-specific syntax on top of the programming language you are using for the project. This can be seen as a huge waste of time, especially if they don't need any of the math typesetting that is such a big draw for TeX in the first place. (And for many applications programmers, they really won't need it.) Instead they prefer something like Visual Studio's XML comments, because that's already popular and well-established.  The places I have seen literate programming take off are in scientific/statistical computing, where most of the programmers have significant training (aka PhDs) in math, CS, or statistics, and thus are already famliiar with LaTeX. The documentation they write is more likely to include a lot of complicated formulae that are best written in TeX, and they are more likely to be programming in R. The proportion of R programmers who know about SWeave is definitely much higher than, say, the proportion of C programmers who know about cweb.  ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "able": 0.12196398929068855,
                "applications": 0.11403148764118379,
                "away": 0.12889369505890869,
                "best": 0.09167102137039285,
                "big": 0.11182440221093828,
                "code": 0.059726431217106794,
                "comments": 0.1190587944791889,
                "complicated": 0.13314422242608404,
                "computing": 0.13817152926408915,
                "definitely": 0.1443244555614795,
                "documentation": 0.25042344155315854,
                "draw": 0.1443244555614795,
                "edit": 0.11643072609776715,
                "especially": 0.1190587944791889,
                "higher": 0.12889369505890869,
                "huge": 0.13817152926408915,
                "include": 0.12521172077657927,
                "instead": 0.10787856134379344,
                "know": 0.15277308314000343,
                "language": 0.0769795503971975,
                "learn": 0.09491875285628354,
                "like": 0.12009787207227327,
                "likely": 0.2328614521955343,
                "lot": 0.09167102137039285,
                "need": 0.1644953567929035,
                "network": 0.1443244555614795,
                "people": 0.14936079722399614,
                "place": 0.11182440221093828,
                "places": 0.12889369505890869,
                "popular": 0.13314422242608404,
                "prefer": 0.12889369505890869,
                "program": 0.11182440221093828,
                "programmers": 0.3588024911252838,
                "programming": 0.21034958608377094,
                "project": 0.08224767839645175,
                "really": 0.08298302457970794,
                "require": 0.10978096027400848,
                "say": 0.0853145971184272,
                "seen": 0.2088546638066549,
                "specific": 0.11403148764118379,
                "studio": 0.13314422242608404,
                "syntax": 0.13314422242608404,
                "time": 0.07413436398303175,
                "training": 0.1443244555614795,
                "understand": 0.09491875285628354,
                "using": 0.16903059838343576,
                "visual": 0.12889369505890869,
                "write": 0.08613775817747146,
                "written": 0.12889369505890869,
                "xml": 0.1443244555614795
            },
            "Max term": "programmers",
            "Max score": 0.3588024911252838
        }
    },
    {
        "ID:": "812",
        "Question": "I originally tried asking this on StackOverflow, but it was too subjective :-(. I am interested in methods of defining the power of programming languages. Turing completeness is one, but it is almost universally satisfied. What would be nice is to define a measure of power that discriminates among programming languages that are actually in used. For example, can anyone propose a non-subjective method that would discriminate between assembly and Java? Turing completeness means that a language is maximally powerful in what it can output (which pretty much means it can do anything non-time based in the real world). So if we want to define a stronger measure of power, we need to take another approach. Shortness was suggested in the original question, but this is not easy to define at all. Does anyone have any other suggestions? ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "actually": 0.10467547983304287,
                    "approach": 0.12469262398710548,
                    "asking": 0.12194019613051144,
                    "assembly": 0.15115384922377115,
                    "based": 0.11711590226044732,
                    "define": 0.40497872809635627,
                    "easy": 0.11298334528544914,
                    "example": 0.0920192758193572,
                    "interested": 0.12469262398710548,
                    "java": 0.10326648650973318,
                    "language": 0.08062220161360714,
                    "languages": 0.19646279750087958,
                    "means": 0.23885485273610443,
                    "measure": 0.3023076984475423,
                    "method": 0.13113670506970854,
                    "methods": 0.12469262398710548,
                    "need": 0.08613961598522481,
                    "nice": 0.13113670506970854,
                    "non": 0.2123135202785748,
                    "original": 0.13113670506970854,
                    "originally": 0.1394445705221148,
                    "output": 0.15115384922377115,
                    "power": 0.4341293044235042,
                    "powerful": 0.1394445705221148,
                    "pretty": 0.10936880461421401,
                    "programming": 0.14686884721185198,
                    "question": 0.09021377327479253,
                    "real": 0.11111956091564595,
                    "stackoverflow": 0.15115384922377115,
                    "time": 0.07764238175849508,
                    "tried": 0.13499290936545208,
                    "universally": 0.14470976814116807,
                    "used": 0.08465833567898028,
                    "want": 0.0839452467425691,
                    "world": 0.10467547983304287
                },
                "Max term": "power",
                "Max score": 0.4341293044235042
            }
        ],
        "Best Answer": "If I understand your question correctly, you are nonetheless looking for something that is relatively measurable and not just a subjective judgement call. If so, I would personally favour the amount of time taken to solve any particular problem (averaged over all problems and all programmers). In this measure, you might need to consider not just the language itself but also the framework/API used with it. Succinct syntax is a very small factor: a much more important one is that the most commonly required functionality is easily accessible. If you are looking for something more subjective, I’d say how fun it is. Programmers tend to be people who want problems solved, so a programming language that is fun for programmers to use is inevitably going to be the one that will solve the most problems. This measure takes into account that different people have different preferences on how to use things, so the “best” programming language will be the one that is most appealing to the widest range of programmers. However, you might need to consider not just the programming language and API here, but also the environment (IDE), which is of course what the programmer actually interacts with. ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "account": 0.12282124433297478,
                "actually": 0.09219701158752978,
                "best": 0.08456355603591413,
                "commonly": 0.12745877249782062,
                "consider": 0.2196557840853504,
                "correctly": 0.12282124433297478,
                "course": 0.11250784041201715,
                "different": 0.18439402317505957,
                "easily": 0.11550376779878699,
                "environment": 0.1098278920426752,
                "framework": 0.10126938968311613,
                "fun": 0.24564248866594957,
                "functionality": 0.12745877249782062,
                "going": 0.09487695995687176,
                "ide": 0.11550376779878699,
                "important": 0.09487695995687176,
                "language": 0.2840445945215715,
                "looking": 0.2063087977244113,
                "measure": 0.2662692965078648,
                "need": 0.1517416530748617,
                "particular": 0.10519036387782937,
                "people": 0.13778051075254516,
                "personally": 0.10740358385327882,
                "problem": 0.08363850922797071,
                "problems": 0.3155710916334881,
                "programmer": 0.08552351840706023,
                "programmers": 0.3309837079430426,
                "programming": 0.1940406984018976,
                "question": 0.07945929947717581,
                "required": 0.11890027013826152,
                "say": 0.07869995999014406,
                "small": 0.09787288734364158,
                "solve": 0.21480716770655764,
                "syntax": 0.12282124433297478,
                "taken": 0.11890027013826152,
                "takes": 0.10315439886220565,
                "tend": 0.11890027013826152,
                "things": 0.0727265839561016,
                "time": 0.06838655606918645,
                "understand": 0.08755948342268395,
                "use": 0.12066350603342701,
                "used": 0.07456613113238438,
                "want": 0.07393805023857712
            },
            "Max term": "programmers",
            "Max score": 0.3309837079430426
        }
    },
    {
        "ID:": "827",
        "Question": "For decades, the accepted degree to get to become a software developer was \"Compter Science.\" We've had a few questions already about whether that degree really prepares students to develop software. Some schools have, in the last 8 years or so, started offering multiple distinct majors in programming.  Using the curriculum from my school:  Computer Science, which starts out with some intro programming courses in the first year, and then focuses on theoretical computer science, algorithms, and a bit of OS stuff.  Most classes involve several smaller projects and homeworks, done solo or in pairs. Software Engineering, which starts out with the same intro programming courses, does a few classes of theory, and then goes into software development practices (testing, process methodologies, sofware metrics, requirements gathering) and software design (distributed system design, info system design, real-time/embedded design, subsystem design, etc)  Different schools do it differently, so the above is just a real-world example I'm familiar with.  What I ask is: Is there a need for distinct majors in programming? ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "accepted": 0.11970860131934442,
                    "algorithms": 0.11460511280649253,
                    "ask": 0.08947888727913815,
                    "bit": 0.09275172894271476,
                    "classes": 0.22087051814428918,
                    "computer": 0.18550345788542952,
                    "decades": 0.11970860131934442,
                    "degree": 0.22921022561298507,
                    "design": 0.38449422831280095,
                    "develop": 0.10690969797430691,
                    "developer": 0.08071951893356573,
                    "development": 0.07076341326518841,
                    "different": 0.08289934624618342,
                    "differently": 0.11970860131934442,
                    "engineering": 0.11460511280649253,
                    "example": 0.07287607202411803,
                    "familiar": 0.11970860131934442,
                    "goes": 0.10690969797430691,
                    "multiple": 0.10690969797430691,
                    "need": 0.06821958554632061,
                    "practices": 0.09875222952633798,
                    "process": 0.08661629654534297,
                    "programming": 0.23263005695723105,
                    "projects": 0.0880028347590353,
                    "questions": 0.0880028347590353,
                    "real": 0.1760056695180706,
                    "really": 0.06882951172092945,
                    "requirements": 0.10116191682494477,
                    "school": 0.11460511280649253,
                    "schools": 0.23941720263868885,
                    "science": 0.35912580395803323,
                    "smaller": 0.11970860131934442,
                    "software": 0.35050221450572966,
                    "solo": 0.11460511280649253,
                    "started": 0.09657240221372028,
                    "stuff": 0.09275172894271476,
                    "testing": 0.08947888727913815,
                    "theory": 0.11460511280649253,
                    "time": 0.06149007101798859,
                    "using": 0.07010044290114593,
                    "world": 0.08289934624618342,
                    "year": 0.09657240221372028,
                    "years": 0.08407246882647518
                },
                "Max term": "design",
                "Max score": 0.38449422831280095
            }
        ],
        "Best Answer": "Yes, they should be. The relationship between computer science and software engineering is the same as the relationship between physics and mechanical engineering. One provides the theoretical background while the other takes those theories, along with good engineering principles, and applies them to the design and implementation of software. You need both in order to produce new and better software. A good computer science education trains people to produce new and better algorithms, data structures, programming languages and paradigms, compilers, and a number of other things that can be used to enhance software systems. A good software engineering education, on the other hand, trains you to take these tools and knowledge obtained through a scientific study of computation, along with a knowledge of the software development lifecycle and process models to actually build the system that a customer wants and needs. ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "actually": 0.08692536209877093,
                "algorithms": 0.12017092269329561,
                "background": 0.10889948238886211,
                "better": 0.16126689309092807,
                "build": 0.11210177919484753,
                "computer": 0.19451245368545275,
                "customer": 0.10607485642287456,
                "data": 0.08692536209877093,
                "design": 0.08063344654546403,
                "development": 0.0742000462000587,
                "engineering": 0.48068369077318246,
                "good": 0.20570464928537407,
                "hand": 0.11579855955449951,
                "implementation": 0.12017092269329561,
                "knowledge": 0.1909579977951704,
                "languages": 0.08157402210594206,
                "need": 0.07153267720871814,
                "needs": 0.10889948238886211,
                "new": 0.14434444902993046,
                "number": 0.09917577925723717,
                "paradigms": 0.12017092269329561,
                "people": 0.06495124180867973,
                "physics": 0.12552226268612446,
                "process": 0.09082282649732104,
                "produce": 0.23159711910899902,
                "programming": 0.06098194030388986,
                "provides": 0.12552226268612446,
                "science": 0.2510445253722489,
                "software": 0.441029271644964,
                "structures": 0.12017092269329561,
                "study": 0.12552226268612446,
                "systems": 0.11579855955449951,
                "takes": 0.09725622684272638,
                "things": 0.06856821642845802,
                "tools": 0.10126245153063869,
                "used": 0.07030258180150857,
                "wants": 0.10889948238886211,
                "yes": 0.09382443926440831
            },
            "Max term": "engineering",
            "Max score": 0.48068369077318246
        }
    },
    {
        "ID:": "843",
        "Question": "I was instructed by my project manager that frequent deployment in PROD or to test server should be avoided. But I don't understand why? We roll our testing copy to PROD on every sprint end but suddenly client would ask a simple change to the existing application which would require a re-deployment. When every thing was well tested and QA approved. why should we avoid frequent deployment? How it was done universally? ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "application": 0.2014252854908198,
                    "ask": 0.20480374825369846,
                    "avoid": 0.22103973968220073,
                    "change": 0.189744165973306,
                    "client": 0.25276973915406203,
                    "copy": 0.25276973915406203,
                    "end": 0.19825170754527263,
                    "existing": 0.24470025874934845,
                    "manager": 0.25276973915406203,
                    "project": 0.1561443961703998,
                    "qa": 0.27399502825651934,
                    "require": 0.20841538736649873,
                    "server": 0.25276973915406203,
                    "simple": 0.21648486777121226,
                    "test": 0.18475486829935098,
                    "tested": 0.26231390873900556,
                    "testing": 0.20480374825369846,
                    "thing": 0.20480374825369846,
                    "understand": 0.18019999638836248,
                    "universally": 0.26231390873900556
                },
                "Max term": "qa",
                "Max score": 0.27399502825651934
            }
        ],
        "Best Answer": "If you are talking about a hosted web application, the users don't get a say-so in when they get upgrades. That is, they are forced to upgrade each time you do a push to production. If your changes dramatically change the system rules or UI, you should definitely consider bundling your releases and doing it less frequently. It is very frustrating to users to have to continually re-learn how to use the tools they rely on and violates the UI principle of making them feel they are in control of their computer/software. ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "application": 0.1596864542170101,
                "change": 0.15042586633951693,
                "changes": 0.179191879696423,
                "computer": 0.168303609286162,
                "consider": 0.179191879696423,
                "control": 0.2003914418217883,
                "definitely": 0.21721848093082227,
                "feel": 0.1652280851022433,
                "forced": 0.21721848093082227,
                "frequently": 0.18356440271275434,
                "learn": 0.14285941510797615,
                "making": 0.179191879696423,
                "principle": 0.21721848093082227,
                "production": 0.21721848093082227,
                "push": 0.21721848093082227,
                "rely": 0.21721848093082227,
                "rules": 0.20795789305332907,
                "say": 0.12840448360046383,
                "software": 0.12720148386784405,
                "time": 0.11157744449142988,
                "tools": 0.1752364514956107,
                "ui": 0.4007828836435766,
                "use": 0.09843547051093797,
                "users": 0.3304561702044866,
                "web": 0.15479838935584828
            },
            "Max term": "ui",
            "Max score": 0.4007828836435766
        }
    },
    {
        "ID:": "866",
        "Question": "I know this is obviously not true for some games, minesweeper, card games, etc.  But what about any game involving simulating the real world environment.  Obviously these games have some form of a physics engineer powering the graphics.  For someone like me who personally did not enjoy physics but loves video games, do I have a chance at ever getting involved in the development cycle of a video game such as this while disliking physics?  ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "chance": 0.1529523625201962,
                    "cycle": 0.16579590195755078,
                    "development": 0.0980070253815666,
                    "environment": 0.13677141645787919,
                    "form": 0.1529523625201962,
                    "game": 0.27354283291575837,
                    "games": 0.5922779017816571,
                    "getting": 0.1284607487573632,
                    "graphics": 0.15872759214695453,
                    "involved": 0.14806947544541427,
                    "know": 0.087750724627688,
                    "like": 0.06898253988189502,
                    "obviously": 0.2876794525369509,
                    "personally": 0.13375236493255865,
                    "physics": 0.4973877058726523,
                    "real": 0.1218835505794001,
                    "true": 0.14010882308284164,
                    "world": 0.11481524076880385
                },
                "Max term": "games",
                "Max score": 0.5922779017816571
            }
        ],
        "Best Answer": "There are many aspects to game programing and you don't need to be an expert at all of them.  If you're on a bigger team you may not even be doing the core game programming but just network communication for example.  For core game programming I would think that above a sound physics understanding you would need a strong mathematical background.  Having a strong mathematical background will allow you to do things like modelling transformations, clippings, keyframe animation, ray tracing, image processing, texture mapping, etc. Having a strong physics background may help you with coming up with new computer graphics methods, but it is not required if you want to become a game programmer.  ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "allow": 0.13545043318493682,
                "aspects": 0.13545043318493682,
                "background": 0.36823755029742417,
                "bigger": 0.13545043318493682,
                "coming": 0.13545043318493682,
                "communication": 0.12635531301942288,
                "computer": 0.10962217615155848,
                "core": 0.2829643723146272,
                "example": 0.08613137130409272,
                "expert": 0.13545043318493682,
                "game": 0.4668563885070585,
                "graphics": 0.13545043318493682,
                "help": 0.09540144883843078,
                "like": 0.058866355765979136,
                "methods": 0.11671409712676463,
                "need": 0.161255849545702,
                "network": 0.1414821861573136,
                "new": 0.08134878933585779,
                "physics": 0.2829643723146272,
                "programmer": 0.09088584009338628,
                "programming": 0.13747136238108737,
                "required": 0.12635531301942288,
                "sound": 0.1414821861573136,
                "strong": 0.3915663964871196,
                "team": 0.09797776106859243,
                "things": 0.07728653828894416,
                "think": 0.07375576776518783,
                "understanding": 0.13545043318493682,
                "want": 0.07857396346599946
            },
            "Max term": "game",
            "Max score": 0.4668563885070585
        }
    },
    {
        "ID:": "870",
        "Question": "One per answer please. I'll add my favourite as an answer. ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "add": 0.4560064781944786,
                    "answer": 0.718184688318793,
                    "favourite": 0.5256128283338475
                },
                "Max term": "answer",
                "Max score": 0.718184688318793
            }
        ],
        "Best Answer": " Code Complete by Steve McConnell. I don't even think it needs explanation. It's the definitive book on software construction. Incredibly well written and covers all aspects of the practical (programming) side of creating software.  ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "aspects": 0.3256391459380998,
                "book": 0.25872897502324854,
                "code": 0.14076173402044115,
                "complete": 0.2874416279486431,
                "creating": 0.3256391459380998,
                "incredibly": 0.3256391459380998,
                "needs": 0.29509579891233234,
                "programming": 0.16524885149537735,
                "software": 0.3983670151741866,
                "steve": 0.3401402061432937,
                "think": 0.17731774390320343,
                "written": 0.30377338225420986
            },
            "Max term": "software",
            "Max score": 0.3983670151741866
        }
    },
    {
        "ID:": "874",
        "Question": "In my current job it feels like we have a lot requirement changes. We are an \"Agile\" shop, so I get that we are supposed to adjust and what not, but sometime the change is large and nothing trivial.  My question is, how do you effectively communicate the cost of the change? Because of being agile, if a change is big enough something will get dropped from the current sprint, but it usually just get added next time around. Since our model is SaaS, the end customer is effectively the business itself, and they know they will get the cut feature n weeks later. I guess what I am trying to get at is the removal of a feature really isn't anything to use for communication as it was only delayed by n weeks. What other ways do you have to get the business to understand what a change costs? ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "added": 0.1368206401430175,
                    "agile": 0.28266514875464477,
                    "big": 0.11870158805764924,
                    "business": 0.25276178897429624,
                    "change": 0.424370916231241,
                    "changes": 0.12638089448714812,
                    "communication": 0.1368206401430175,
                    "cost": 0.1329122249325745,
                    "costs": 0.15320039036191238,
                    "current": 0.2589295167854648,
                    "customer": 0.1294647583927324,
                    "effectively": 0.28266514875464477,
                    "end": 0.11084959891102983,
                    "feature": 0.2330649494273593,
                    "feels": 0.146669059916486,
                    "guess": 0.146669059916486,
                    "job": 0.10466465872908966,
                    "know": 0.08108430370579633,
                    "large": 0.14133257437732238,
                    "later": 0.1329122249325745,
                    "like": 0.06374193760692773,
                    "lot": 0.09730877697880454,
                    "model": 0.1294647583927324,
                    "question": 0.0914352188362647,
                    "really": 0.08808646954228705,
                    "supposed": 0.1329122249325745,
                    "time": 0.07869361749710198,
                    "trivial": 0.14133257437732238,
                    "trying": 0.10917659296339453,
                    "understand": 0.10075624351864665,
                    "use": 0.06942481340957754,
                    "usually": 0.11262405950323665,
                    "ways": 0.12359120025019253,
                    "weeks": 0.30640078072382476
                },
                "Max term": "change",
                "Max score": 0.424370916231241
            }
        ],
        "Best Answer": "You could try setting a minimum age of a new addition / change (not applicable to bug fixes).  For example no new changes can be worked on until it is 3 weeks old.   Having a minimum age of a task is nice because at the start, every task looks like it's extremely important, but if you wait some time then it's importance will often drop significantly.  Depending on your time interval it will give you at least that amount of time of stability in the tasks you're working on. To track the age you would allow the tasks to be added to some list, but they wouldn't be considered as tasks to work on until that period has expired. ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "added": 0.15154540712238118,
                "allow": 0.16245372316681944,
                "applicable": 0.1696879615855867,
                "bug": 0.13998212614358235,
                "change": 0.11751052912034524,
                "changes": 0.13998212614358235,
                "considered": 0.15154540712238118,
                "depending": 0.1696879615855867,
                "drop": 0.16245372316681944,
                "example": 0.10330245257103894,
                "extremely": 0.15154540712238118,
                "importance": 0.1696879615855867,
                "important": 0.12092628138252785,
                "like": 0.07060190535078606,
                "list": 0.11917344036603503,
                "looks": 0.15154540712238118,
                "minimum": 0.3393759231711734,
                "new": 0.19513283777660176,
                "nice": 0.14721636456234957,
                "old": 0.13147636547721317,
                "setting": 0.1696879615855867,
                "start": 0.11592876850923324,
                "task": 0.26295273095442634,
                "tasks": 0.410676607105796,
                "time": 0.26148809760863856,
                "track": 0.15654291999567582,
                "try": 0.11027629070157799,
                "wait": 0.16245372316681944,
                "weeks": 0.1696879615855867,
                "work": 0.08845965861270152,
                "worked": 0.13689220236859867,
                "working": 0.1115997259492016
            },
            "Max term": "tasks",
            "Max score": 0.410676607105796
        }
    },
    {
        "ID:": "937",
        "Question": "I know that they are implemented extremely unsafely in C/C++. Can't they be implemented in a safer way? Are the disadvantages of macros really bad enough to outweigh the massive power they provide? ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "bad": 0.2905078856388923,
                    "extremely": 0.34108496346076345,
                    "implemented": 0.6301187121070113,
                    "know": 0.202137899207486,
                    "power": 0.36563643387537687,
                    "provide": 0.36563643387537687,
                    "really": 0.21959384354445988,
                    "way": 0.21390520040976324
                },
                "Max term": "implemented",
                "Max score": 0.6301187121070113
            }
        ],
        "Best Answer": "I think the main reason is that macros are lexical. This has several consequences:  The compiler has no way of checking that a macro is semantically closed, i.e. that it represents a “unit of meaning” like a function does. (Consider #define TWO 1+1 — what does TWO*TWO equal? 3.) Macros are not typed like functions are. The compiler cannot check that the parameters and return type make sense. It can only check the expanded expression that uses the macro. If the code doesn’t compile, the compiler has no way of knowing whether the error is in the macro itself or the place where the macro is used. The compiler will either report the wrong place half of the time, or it has to report both even though one of them is probably fine. (Consider #define min(x,y) (((x)<(y))?(x):(y)): What should the compiler do if the types of x and y don’t match or don’t implement operator<?) Automated tools cannot work with them in semantically useful ways. In particular, you can’t have things like IntelliSense for macros that work like functions but expand to an expression. (Again, the min example.) The side-effects of a macro are not as explicit as they are with functions, causing potential confusion for the programmer. (Consider again the min example: in a function call, you know that the expression for x is evaluated only once, but here you can’t know without looking at the macro.)  Like I said, these are all consequences of the fact that macros are lexical. When you try to turn them into something more proper, you end up with functions and constants. ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "automated": 0.10287176066951646,
                "causing": 0.10287176066951646,
                "check": 0.16255900442895846,
                "code": 0.04257187816096246,
                "compile": 0.09848607039256485,
                "compiler": 0.49243035196282425,
                "consider": 0.254588616259431,
                "define": 0.18374600892585918,
                "effects": 0.09490270052056708,
                "end": 0.07443384042657349,
                "equal": 0.10287176066951646,
                "error": 0.08693364037161772,
                "example": 0.12525231699600597,
                "fact": 0.08127950221447923,
                "fine": 0.10287176066951646,
                "function": 0.17386728074323543,
                "functions": 0.37961080208226833,
                "half": 0.10287176066951646,
                "implement": 0.09187300446292959,
                "know": 0.10889378369300577,
                "knowing": 0.09848607039256485,
                "like": 0.2140087676872309,
                "looking": 0.07970633318173222,
                "main": 0.084862872086477,
                "make": 0.057616475474301286,
                "match": 0.09848607039256485,
                "operator": 0.10287176066951646,
                "particular": 0.08127950221447923,
                "place": 0.15941266636346443,
                "potential": 0.09187300446292959,
                "probably": 0.07562536405734074,
                "programmer": 0.06608313487564436,
                "proper": 0.09848607039256485,
                "reason": 0.07689381193752763,
                "report": 0.18980540104113416,
                "return": 0.08693364037161772,
                "said": 0.07689381193752763,
                "sense": 0.084862872086477,
                "things": 0.05619507646705032,
                "think": 0.053627851644167064,
                "time": 0.05284158197153627,
                "tools": 0.08298963431464576,
                "try": 0.06685398350343753,
                "turn": 0.09490270052056708,
                "type": 0.08127950221447923,
                "typed": 0.09187300446292959,
                "types": 0.0892485623634286,
                "unit": 0.07824980615684177,
                "used": 0.057616475474301286,
                "useful": 0.07331044206552986,
                "uses": 0.0892485623634286,
                "way": 0.11523295094860257,
                "ways": 0.08298963431464576,
                "work": 0.10725570328833413,
                "wrong": 0.08298963431464576
            },
            "Max term": "compiler",
            "Max score": 0.49243035196282425
        }
    },
    {
        "ID:": "940",
        "Question": "This is more a discussion question than an actual attempt to determine the \"best\", since that clearly varies by the needs of the organization. I'm more curious about the arguments in favor of different systems across categories (centralized vs distributed, open vs proprietary, etc). So, what do you think is the best version control system? ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "actual": 0.23666770067843648,
                    "arguments": 0.2565408879710496,
                    "attempt": 0.24560388377580056,
                    "best": 0.32589577604269143,
                    "clearly": 0.23666770067843648,
                    "control": 0.23666770067843648,
                    "determine": 0.24560388377580056,
                    "different": 0.17765700763207165,
                    "needs": 0.2225674498991852,
                    "open": 0.19513882745264624,
                    "organization": 0.22911226552451067,
                    "question": 0.15311235289067693,
                    "systems": 0.23666770067843648,
                    "think": 0.13373676693424286,
                    "version": 0.24560388377580056,
                    "vs": 0.45822453104902133
                },
                "Max term": "vs",
                "Max score": 0.45822453104902133
            }
        ],
        "Best Answer": "Mercurial Because of it's sophisticated ability to branch and merge code, it is the best I've used. The whole DVCS paradigm just makes so much sense. I've not used Git, but I suppose that it qualifies as well.  ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "ability": 0.41741502909956263,
                "best": 0.2873940855687686,
                "code": 0.18724590200180952,
                "makes": 0.3273858751882092,
                "sense": 0.3732563776072153,
                "suppose": 0.4524657226596366,
                "used": 0.5068345295718462
            },
            "Max term": "used",
            "Max score": 0.5068345295718462
        }
    },
    {
        "ID:": "966",
        "Question": "There are a lot of questions about what programming books should be on the programmer's bookshelf. How about non-programming related books that can help you become a better programmer or developer? It would also be interesting to know why they would help. My first choice would be Sun Tzu's \"Art of War\" (however cliché), because it made it obvious that the success of any project depends on the strength of its weakest link (and warfare is a big project). ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "better": 0.16032303375340282,
                    "big": 0.1933740154594962,
                    "books": 0.40267913949443285,
                    "choice": 0.20588419619519893,
                    "depends": 0.21652423576999863,
                    "developer": 0.16828858804112307,
                    "help": 0.33657717608224613,
                    "interesting": 0.1933740154594962,
                    "know": 0.13209256636661093,
                    "lot": 0.15852348103974193,
                    "non": 0.1752790063526441,
                    "obvious": 0.23024163256600644,
                    "programmer": 0.32064606750680563,
                    "programming": 0.2425001061606864,
                    "project": 0.2844560492931014,
                    "questions": 0.18347325406390527,
                    "related": 0.21652423576999863,
                    "war": 0.23893517790129232
                },
                "Max term": "books",
                "Max score": 0.40267913949443285
            }
        ],
        "Best Answer": "The Design of Everyday Things by Donald Norman  ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "design": 0.7618004295900059,
                "things": 0.6478117824464776
            },
            "Max term": "design",
            "Max score": 0.7618004295900059
        }
    },
    {
        "ID:": "991",
        "Question": "What are the first 5 things you do before starting a new project? Do you always spend a day researching new frameworks? Or, using similar or competing products? ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "day": 0.3106364844848836,
                    "frameworks": 0.3253991977615783,
                    "new": 0.44279643168621463,
                    "products": 0.38505678873089655,
                    "project": 0.2194363166013705,
                    "similar": 0.3042353305577994,
                    "spend": 0.3253991977615783,
                    "starting": 0.3340641260424585,
                    "things": 0.21034242581308857,
                    "using": 0.22548631539116415
                },
                "Max term": "new",
                "Max score": 0.44279643168621463
            }
        ],
        "Best Answer": "This is pretty project-dependent.  Is this a project I'm starting with the intent of selling, or a project for a specific customer?  Also, what constitutes \"starting\"? Is that before or after requirements gathering? A rough list, though:  Get a context for the project.  That is, figure out what your customer or potential user is trying to accomplish and why.  If you're building a hotel registration system, what's wrong with OTS options, for example. Gather requirements.  Meet with stakeholders.  Meet with users.  Meet with anyone who has a say in the project, if you can.  Look at existing solutions that this project will replace, either that the customer is using or that exist in the market place.  From there, write it all down in a non-technical language as you can- a good reqs doc should describe what's to be done but not how to do it.  Then discuss this doc with the customer and iterate until they agree with it.  This step can be less formal for smaller projects (possibly even entirely verbal). Start making technical decisions.  Pick languages, frameworks, ORMs, databases, etc that best solve the problem, whether this means sticking with something you know or learning something new. Analyze the risks for this project.  If this is a government contract, you probably want a 100 page leather-bound risk report.  If it's a 3-man 4-month project, you might be fine with some notes in a text file or a spreadsheet.  Either way, you want to figure out what can go wrong with the project, how likely it is to happen, how much it'll hurt, and what you are going to do to prepare for it, handle it, and/or mitigate it's effects after the fact.  A common one, for example, is \"One of the devs gets hit by a bus, quits, gets sick, etc.\"  So you might mitigate that by pair programming to share knowledge, using good source control practices to keep code centralized, etc.  Overall, the process of sitting and thinking about what could go wrong and being prepared for the possibilities is more important than actually writing out all the contingency plans. Set up the technology.  It's the sort of thing that no one wants to do once you're in the thick of actually coding, so set up your repo, your build server, your build system, your wikis, your bug tracker, or whatever you intend to use for your project.  ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "100": 0.07405357925702453,
                "actually": 0.11484446077235419,
                "agree": 0.07938399383108773,
                "best": 0.05266795434425381,
                "bug": 0.06840311210863241,
                "build": 0.14810715851404907,
                "building": 0.07938399383108773,
                "code": 0.034314758420524796,
                "coding": 0.05453388068677989,
                "common": 0.05823482201840413,
                "constitutes": 0.08291904816418122,
                "context": 0.07405357925702453,
                "contract": 0.07938399383108773,
                "control": 0.07649564413169052,
                "customer": 0.2802889603967993,
                "dependent": 0.08291904816418122,
                "discuss": 0.08291904816418122,
                "effects": 0.07649564413169052,
                "entirely": 0.07938399383108773,
                "example": 0.10095873578981811,
                "exist": 0.08291904816418122,
                "existing": 0.07405357925702453,
                "fact": 0.0655147624092352,
                "figure": 0.16583809632836244,
                "file": 0.06424672074310864,
                "fine": 0.08291904816418122,
                "formal": 0.07649564413169052,
                "frameworks": 0.07007224009919982,
                "gets": 0.1438763328834518,
                "going": 0.059091358376744514,
                "good": 0.09059128028596022,
                "handle": 0.08291904816418122,
                "happen": 0.06840311210863241,
                "important": 0.059091358376744514,
                "intent": 0.08291904816418122,
                "know": 0.04388652841195082,
                "knowledge": 0.06307269753456923,
                "language": 0.04422723108297587,
                "languages": 0.05388717605308359,
                "learning": 0.05823482201840413,
                "likely": 0.06689320217791353,
                "list": 0.05823482201840413,
                "look": 0.059091358376744514,
                "making": 0.06840311210863241,
                "man": 0.07938399383108773,
                "market": 0.07938399383108773,
                "means": 0.0655147624092352,
                "meet": 0.24875714449254366,
                "month": 0.07938399383108773,
                "new": 0.04767642036247359,
                "non": 0.05823482201840413,
                "notes": 0.08291904816418122,
                "overall": 0.08291904816418122,
                "page": 0.07938399383108773,
                "pair": 0.07649564413169052,
                "pick": 0.07405357925702453,
                "place": 0.06424672074310864,
                "possibly": 0.07007224009919982,
                "potential": 0.07405357925702453,
                "practices": 0.06840311210863241,
                "prepare": 0.07938399383108773,
                "prepared": 0.08291904816418122,
                "pretty": 0.05999686560439072,
                "probably": 0.06095728471927059,
                "problem": 0.05209181581211391,
                "process": 0.05999686560439072,
                "programming": 0.04028420406862561,
                "project": 0.4725394029594881,
                "projects": 0.06095728471927059,
                "replace": 0.07938399383108773,
                "report": 0.07649564413169052,
                "requirements": 0.14014448019839965,
                "risk": 0.07938399383108773,
                "rough": 0.08291904816418122,
                "say": 0.049015983881935406,
                "server": 0.07649564413169052,
                "set": 0.12191456943854118,
                "share": 0.07649564413169052,
                "smaller": 0.08291904816418122,
                "solve": 0.06689320217791353,
                "sort": 0.08291904816418122,
                "source": 0.06307269753456923,
                "specific": 0.0655147624092352,
                "start": 0.05664929350207853,
                "starting": 0.1438763328834518,
                "step": 0.07649564413169052,
                "technical": 0.1310295248184704,
                "text": 0.07649564413169052,
                "thing": 0.061979708076141705,
                "thinking": 0.07007224009919982,
                "trying": 0.059091358376744514,
                "use": 0.037575879756565095,
                "user": 0.05823482201840413,
                "users": 0.06307269753456923,
                "using": 0.09711352295804082,
                "want": 0.0921003334489546,
                "wants": 0.0719381664417259,
                "way": 0.04644134866372178,
                "write": 0.04948891642296753,
                "writing": 0.05664929350207853,
                "wrong": 0.20067960653374062
            },
            "Max term": "project",
            "Max score": 0.4725394029594881
        }
    },
    {
        "ID:": "1007",
        "Question": "Tester and blogger Lanette Creamer recently posted this question on Twitter:  If you are a professional software developer who works with testers, think of the best testers you know. What traits do they have in common?  I thought it would make an excellent question for here. My thoughts are:  They want to remove ambiguity from requirements even if it means asking awkward questions. They create new features by seeing the way software \"should\" work, rather than just how it's documented. They demonstrate honesty and integrity and encourage but not demand it from those around them. In other words, they model behavior.  What are the traits of the best testers you've worked with? ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "asking": 0.1419435566194692,
                    "best": 0.22351678544590758,
                    "common": 0.12357096815920263,
                    "create": 0.1419435566194692,
                    "developer": 0.11864275241581482,
                    "documented": 0.16231939031817558,
                    "encourage": 0.16231939031817558,
                    "excellent": 0.17594948701395927,
                    "features": 0.13901858611452117,
                    "know": 0.09312470815652596,
                    "make": 0.09854589089637021,
                    "means": 0.13901858611452117,
                    "model": 0.14868929362239186,
                    "new": 0.10116664254067953,
                    "professional": 0.16844830350733336,
                    "question": 0.21002531144006226,
                    "questions": 0.1293478786066505,
                    "recently": 0.15713746805223835,
                    "remove": 0.17594948701395927,
                    "requirements": 0.14868929362239186,
                    "seeing": 0.17594948701395927,
                    "software": 0.20606935227660744,
                    "tester": 0.16231939031817558,
                    "testers": 0.5278484610418778,
                    "think": 0.09172384068320874,
                    "thought": 0.16231939031817558,
                    "twitter": 0.16844830350733336,
                    "want": 0.09771582515076602,
                    "way": 0.09854589089637021,
                    "words": 0.16231939031817558,
                    "work": 0.09172384068320874,
                    "worked": 0.1419435566194692,
                    "works": 0.15713746805223835
                },
                "Max term": "testers",
                "Max score": 0.5278484610418778
            }
        ],
        "Best Answer": "Some of the best testers I've worked with really understand how the users are going to use the software.  They understand what business function the software is supposed to play and how that software will effect the user's role/job/function.  It makes for a successful project when the tester has as much knowledge of the business as the developer and the business owner. ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "best": 0.13042472537215644,
                "business": 0.5081718412522259,
                "developer": 0.13845893828832095,
                "function": 0.34704794537542333,
                "going": 0.1463313751997931,
                "job": 0.14028394760202748,
                "knowledge": 0.15619059742966418,
                "makes": 0.14857373552987768,
                "play": 0.1833831949175827,
                "project": 0.11701768679997737,
                "really": 0.11806389881519144,
                "software": 0.36073181651226327,
                "successful": 0.20533727234298504,
                "supposed": 0.17814467485506646,
                "tester": 0.18943062251534837,
                "testers": 0.20533727234298504,
                "understand": 0.2700908550790224,
                "use": 0.0930513413495025,
                "user": 0.14421028428789595,
                "users": 0.15619059742966418,
                "worked": 0.1656515357762395
            },
            "Max term": "business",
            "Max score": 0.5081718412522259
        }
    },
    {
        "ID:": "1009",
        "Question": "I'd like to sell my software on the 'net but am not sure how to do the whole Merchant setup.  I have access to Commerce Server 2009, and I want to seem professional so a plain old PayPal account is out. What do I need to know/do to sell a few things using ASP.NET, accept credit cards, and what not?  ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "accept": 0.2432181394596286,
                    "access": 0.20494862239895922,
                    "account": 0.23436876055975953,
                    "asp": 0.2432181394596286,
                    "cards": 0.2540489039033167,
                    "know": 0.13446035242833476,
                    "like": 0.10570188067705814,
                    "need": 0.14477749085504238,
                    "net": 0.3735240987617289,
                    "old": 0.196840283933937,
                    "professional": 0.2432181394596286,
                    "sell": 0.5080978078066334,
                    "server": 0.23436876055975953,
                    "software": 0.14876909834293847,
                    "sure": 0.18989456885484532,
                    "things": 0.13877761485079387,
                    "using": 0.14876909834293847,
                    "want": 0.1410893472601642
                },
                "Max term": "sell",
                "Max score": 0.5080978078066334
            }
        ],
        "Best Answer": "You can use a simple checkout service like 2checkout.com, paypal, or Google Checkout. Or you can use a service which has an affiliate network like regnow.  This will get your product onto hundreds and hundreds of sites, but it is extremely rare to ever have a sale on any of those sites.  In my experience 99.999% of sales came directly from my own company website. ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "com": 0.24978410548219052,
                "company": 0.20237054788011996,
                "directly": 0.279687497632466,
                "experience": 0.1862179952788224,
                "extremely": 0.24978410548219052,
                "google": 0.24264877855949074,
                "like": 0.23273861093187684,
                "network": 0.279687497632466,
                "product": 0.22563201990354156,
                "sales": 0.26776369336423483,
                "simple": 0.22098251682705475,
                "sites": 0.4852975571189815,
                "use": 0.25348828799006756,
                "website": 0.24264877855949074
            },
            "Max term": "sites",
            "Max score": 0.4852975571189815
        }
    },
    {
        "ID:": "1025",
        "Question": "I'm considering learning iPhone development and Objective C but don't want to avoid developing something for the most saturated markets and app categories. What categories should I avoid?  Are there too many dating applications, or should I just stick to coming up with a creative game or two? ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "app": 0.26459755878686053,
                    "applications": 0.25914510942202157,
                    "avoid": 0.5291951175737211,
                    "coming": 0.3140051648086937,
                    "considering": 0.3140051648086937,
                    "developing": 0.28455302787655007,
                    "development": 0.19388382159074485,
                    "game": 0.27057004132094026,
                    "learning": 0.23034914222636282,
                    "stick": 0.32798815136430354,
                    "want": 0.18215246542716287
                },
                "Max term": "avoid",
                "Max score": 0.5291951175737211
            }
        ],
        "Best Answer": "The iOS market has way to many apps in general. Try to make an iPad app. There are less iPad apps out than iPhone/iPod touch.  Alternatively, try to make something for a particular (local) business. That way you are guaranteed to get paid (by the business) and you get an app out there that is unique. Games are always good, provided that the gameplay attracts people. Like the speakers at the WWDC 2010 said, watch play testers as they do their thing. It helps a lot with your game development. ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "app": 0.3224092830550624,
                "apps": 0.32968668886598534,
                "business": 0.32968668886598534,
                "development": 0.11812267694691939,
                "game": 0.16484334443299267,
                "games": 0.17846029655163997,
                "general": 0.17336240388885527,
                "good": 0.10915709211510964,
                "helps": 0.19130596012623713,
                "like": 0.08314100179781235,
                "local": 0.19982501958209972,
                "lot": 0.1269234903342257,
                "make": 0.22383622609300755,
                "market": 0.19130596012623713,
                "particular": 0.15788276603731208,
                "people": 0.10339905359064117,
                "play": 0.17846029655163997,
                "provided": 0.18434538173055653,
                "said": 0.14936370658144948,
                "testers": 0.19982501958209972,
                "thing": 0.14936370658144948,
                "touch": 0.18434538173055653,
                "try": 0.2597233385677712,
                "unique": 0.19982501958209972,
                "way": 0.22383622609300755
            },
            "Max term": "apps",
            "Max score": 0.32968668886598534
        }
    },
    {
        "ID:": "1058",
        "Question": "I'm not exactly sure when to use Enterprise Library, and when not to... and that is making me not learn it at all.  I feel that I have enough of a reason to start learning then perhaps one day I'll use it. Are there times when I should use EntLib? When shouldn't I use it?   ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "day": 0.2463439646477898,
                    "enterprise": 0.29234312505946475,
                    "exactly": 0.2817063564032666,
                    "feel": 0.2322743995775819,
                    "learn": 0.20082896226556327,
                    "learning": 0.21445821801768522,
                    "library": 0.2463439646477898,
                    "making": 0.2519044279906131,
                    "reason": 0.22824930662731233,
                    "start": 0.2086192782142811,
                    "sure": 0.22824930662731233,
                    "times": 0.2365979111208162,
                    "use": 0.553514610931104
                },
                "Max term": "use",
                "Max score": 0.553514610931104
            }
        ],
        "Best Answer": "I've used EntLib for many years (since they were indiviual App Blocks).  I've found that at times it can be pretty heavy as far as the size of the components, especially if you only need one block and it needs to be downloaded.  Often I'll use the Data and Logging components together and that feels like enough functionality to justify the size.  If your app is strictly on the server side then this really isn't too much of an issue.  One of the things that is nice about it is that if you need more than one block you don't have to go to multiple implementations from multiple vendors that are configured in different ways.  They also provide a tool to help with the configuration (that's a plus and a minus, a plus that they make it easy, a minus that they NEED a tool to help configure it). I've had the pleasure of being invinted to a couple of Patterns and Practices workshops where I was working side by side with the team members who wrote EntLib.  The intent in creating EntLib was to implement Microsoft's Best Practices in common components that everyone needs that are not part of the base Framework.  They are very stable, provide very good performance and very good flexibility. I would start by using some of the easier blocks, like Data and Logging.  They're not too hard to configure and get started with.  Then once you understand those it will be a bit easier to move on to some of the other blocks.  I have not found a situation where you shouldn't use them, other than when you don't need them. ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "app": 0.1876331897471568,
                "base": 0.10728385876952017,
                "best": 0.07386592321284359,
                "bit": 0.0901049490183062,
                "common": 0.0816733618209032,
                "components": 0.334004162435961,
                "couple": 0.10728385876952017,
                "creating": 0.11133472081198699,
                "data": 0.16106743135271717,
                "different": 0.08053371567635859,
                "easier": 0.2017841453922743,
                "easy": 0.0869255017497416,
                "especially": 0.09593421824417278,
                "far": 0.0938165948735784,
                "feels": 0.11133472081198699,
                "framework": 0.08845840114585157,
                "functionality": 0.11133472081198699,
                "good": 0.12705275222230078,
                "hard": 0.0901049490183062,
                "help": 0.1568321846115284,
                "implement": 0.10385890371366575,
                "intent": 0.11629257526395134,
                "issue": 0.0901049490183062,
                "like": 0.096771477658932,
                "make": 0.06513321310854438,
                "members": 0.11133472081198699,
                "microsoft": 0.09593421824417278,
                "multiple": 0.2077178074273315,
                "need": 0.26509143701235605,
                "needs": 0.2017841453922743,
                "nice": 0.10089207269613715,
                "performance": 0.10385890371366575,
                "plus": 0.23258515052790268,
                "practices": 0.19186843648834556,
                "pretty": 0.08414459841705876,
                "provide": 0.22266944162397398,
                "really": 0.06686538046530277,
                "server": 0.10728385876952017,
                "situation": 0.09827514227508898,
                "size": 0.2077178074273315,
                "stable": 0.11629257526395134,
                "start": 0.07944968465142038,
                "started": 0.0938165948735784,
                "strictly": 0.11629257526395134,
                "team": 0.08053371567635859,
                "things": 0.06352637611115039,
                "times": 0.0901049490183062,
                "tool": 0.19186843648834556,
                "understand": 0.07648285363389175,
                "use": 0.10539908311651762,
                "used": 0.06513321310854438,
                "using": 0.06810004412607301,
                "ways": 0.0938165948735784,
                "working": 0.07648285363389175,
                "wrote": 0.11629257526395134,
                "years": 0.0816733618209032
            },
            "Max term": "components",
            "Max score": 0.334004162435961
        }
    },
    {
        "ID:": "1059",
        "Question": "I have often heard it said that objects have not delivered in terms of code reuse. Do you agree? If you believe that they haven't, why not? ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "agree": 0.4249800032218275,
                    "believe": 0.39644377704405204,
                    "code": 0.1837031048745238,
                    "heard": 0.37512978858789386,
                    "objects": 0.4249800032218275,
                    "said": 0.3318066434643342,
                    "terms": 0.4439048182804405
                },
                "Max term": "terms",
                "Max score": 0.4439048182804405
            }
        ],
        "Best Answer": "No, not necessarily. Objects deliver better semantics, organization of code/functionality and, possibly, ease-of-use. Well designed libraries deliver on the promise of code reuse, not objects per se. ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "better": 0.16881440655369281,
                "code": 0.21750621731681025,
                "deliver": 0.5031803517921087,
                "designed": 0.242436184343716,
                "functionality": 0.25159017589605437,
                "libraries": 0.242436184343716,
                "necessarily": 0.23469659476506488,
                "objects": 0.5031803517921087,
                "organization": 0.23469659476506488,
                "possibly": 0.2220786125916018,
                "promise": 0.25159017589605437,
                "use": 0.1190885182410791
            },
            "Max term": "deliver",
            "Max score": 0.5031803517921087
        }
    },
    {
        "ID:": "1060",
        "Question": "Aspect oriented programming promises to deal with cross cutting concerns, but I'm not completely sold on it yet. Have there been any other attempts to deal with this problem? ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "completely": 0.3093340398993272,
                    "concerns": 0.36604629903256036,
                    "cutting": 0.36604629903256036,
                    "deal": 0.6753803389318875,
                    "oriented": 0.3093340398993272,
                    "problem": 0.2299594219913751,
                    "programming": 0.177834697036026
                },
                "Max term": "deal",
                "Max score": 0.6753803389318875
            }
        ],
        "Best Answer": "When possible, you can encapsulate cross-cutting concerns into separate modules that are then used throughout the app via dependency injection.  This allows you to somewhat decouple the cross-cutting concern implementation from it's use throughout the code. This doesn't always work elegantly, though.  That's the reason people are trying to address the issue with things like AOP. ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "allows": 0.2742869450786041,
                "app": 0.2311288609508087,
                "code": 0.11856408079320097,
                "concerns": 0.2865012367376285,
                "cutting": 0.573002473475257,
                "implementation": 0.2742869450786041,
                "issue": 0.22198475931358913,
                "like": 0.11920429127690886,
                "people": 0.148249487442426,
                "possible": 0.19840483442716828,
                "reason": 0.21415179514955449,
                "somewhat": 0.2643071421342968,
                "things": 0.15650513611891886,
                "trying": 0.2041719922052472,
                "use": 0.12983188133617213,
                "used": 0.16046377910145038,
                "work": 0.1493553305556362
            },
            "Max term": "cutting",
            "Max score": 0.573002473475257
        }
    },
    {
        "ID:": "1063",
        "Question": "I have often wondered if it would be possible to write a programming language that would work as a conversation. I would tell the computer that I want to store coordinates and it would ask what representation I would use. I would then ask to find the shortest path between points and it would ask if I want to use Djkstra's, brute force or use Floyd's? What research has been done towards producing a system like this? ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "ask": 0.6275884449731872,
                    "computer": 0.21684785132289136,
                    "language": 0.14927734706729037,
                    "like": 0.11644580696348451,
                    "path": 0.2679397219436684,
                    "points": 0.23651035456970165,
                    "possible": 0.1938135850886395,
                    "programming": 0.13596869993510685,
                    "tell": 0.22112779133394542,
                    "use": 0.3804823978188406,
                    "want": 0.3108603705142395,
                    "work": 0.14589912665516608,
                    "write": 0.16703677738711314
                },
                "Max term": "ask",
                "Max score": 0.6275884449731872
            }
        ],
        "Best Answer": "I think such a language would need an artificial intelligence in place, or at least a system that can learn. The problem is that humans don't know what they want. Also, even writing in classical imperative language we still make logical errors. Imagine trying telling a non-intelligent software what he has to do. ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "errors": 0.268970436844415,
                "imperative": 0.3260490922112347,
                "know": 0.17256786065231625,
                "language": 0.34781510074906863,
                "learn": 0.21443471296817365,
                "logical": 0.30079138484401147,
                "make": 0.1826137649685772,
                "need": 0.18580898693375794,
                "non": 0.22898732287167683,
                "place": 0.2526269348191585,
                "problem": 0.2048321782896613,
                "software": 0.19093185886076056,
                "telling": 0.3260490922112347,
                "think": 0.16997193624392576,
                "trying": 0.23235534153886936,
                "want": 0.181075583826802,
                "writing": 0.222752806860357
            },
            "Max term": "language",
            "Max score": 0.34781510074906863
        }
    },
    {
        "ID:": "1065",
        "Question": "I'm comparing different STS's for claims based authentication and am trying when it's appropriate to use each one.   It appears that ADFSv2 should be used in all Windows Environments.  Ping and Siteminder are more for the Unix side... although a sales rep said Ping was better for Windows, I didn't really understand \"why\" Any comparative information is much appreciated! ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "based": 0.22979316167162842,
                    "better": 0.19051751460732486,
                    "comparing": 0.29657903189546175,
                    "different": 0.205383803531975,
                    "environments": 0.29657903189546175,
                    "information": 0.22979316167162842,
                    "really": 0.17052567423767798,
                    "said": 0.221684669872102,
                    "sales": 0.28393509766058206,
                    "trying": 0.21135382338280514,
                    "understand": 0.1950529570426781,
                    "unix": 0.29657903189546175,
                    "use": 0.1343987694933087,
                    "used": 0.16610815646767146,
                    "windows": 0.5146067696623164
                },
                "Max term": "windows",
                "Max score": 0.5146067696623164
            }
        ],
        "Best Answer": "We are in the middle of doing SSO where I'm at right now.  We couldn't get Site Minder to let us pay for a developer license; they literally didn't return the numerous calls we made begging to use their software (one of our clients was using it and we figured it would be the easiest path). We went with Ping Identity's Pingfederate product (or is it the other way around)? The documentation isn't amazing, but it's working for us.  When you can get past first-level support, they have been very helpful and getting us going.  Your application will be dependent upon their APIs, but your application will also support numerous open standards for SSO.  They also have consulting available to do the heavy lifting if you have the budget. ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "apis": 0.20489121755133288,
                "application": 0.301248327405422,
                "available": 0.17314702602527338,
                "calls": 0.18298483103620788,
                "clients": 0.20489121755133288,
                "dependent": 0.20489121755133288,
                "developer": 0.13815816350853613,
                "documentation": 0.17775769062702193,
                "getting": 0.15875229067598384,
                "going": 0.14601349910096245,
                "helpful": 0.18298483103620788,
                "let": 0.17775769062702193,
                "level": 0.15875229067598384,
                "license": 0.20489121755133288,
                "open": 0.155851304111897,
                "past": 0.16529169043284705,
                "path": 0.1961561729210145,
                "pay": 0.18901912178830313,
                "product": 0.16529169043284705,
                "return": 0.17314702602527338,
                "right": 0.14825098834476816,
                "site": 0.17314702602527338,
                "software": 0.11998273255726766,
                "standards": 0.16902264599670358,
                "support": 0.35551538125404386,
                "use": 0.09284920563295672,
                "using": 0.11998273255726766,
                "way": 0.11475559214808168,
                "went": 0.17775769062702193,
                "working": 0.13475206793968122
            },
            "Max term": "support",
            "Max score": 0.35551538125404386
        }
    },
    {
        "ID:": "1070",
        "Question": "Dcpromo.exe is famous among MCSEs for being they only way to create a Windows Domain Controller (in other words an Active Directory Domain) ... which in turn is often used by the ASP.NET Membership system. I'm trying to determine if I should put content on \"www.dcpromo.com\" geared for developers or more towards sysadmins. To me, a logical extension of this \"domain controller on the internet\" is to use WIF for the ASP.NET Membership system.  We'd then have a website that will serve the developer's interests in the SSO, SAML, user managment and identity areas we all struggle with. So my question is:  Q:  Do programmers see a connection between the utility dcpromo.exe and ASP.NET Membership?  If so does it make sense to have a purpose of http://www.dcpromo.com  help developers in the areas of membership and cloud computing?   ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "areas": 0.26053944505933546,
                    "asp": 0.40556547893902073,
                    "com": 0.2522219227419989,
                    "computing": 0.13518849297967359,
                    "connection": 0.12611096137099945,
                    "controller": 0.2824171629478983,
                    "create": 0.11391706005947168,
                    "determine": 0.13518849297967359,
                    "developer": 0.09521695717972173,
                    "developers": 0.19834421141266723,
                    "directory": 0.14120858147394916,
                    "domain": 0.40556547893902073,
                    "help": 0.09521695717972173,
                    "http": 0.12611096137099945,
                    "internet": 0.13026972252966773,
                    "logical": 0.13026972252966773,
                    "make": 0.07908818434042371,
                    "net": 0.31142512714334775,
                    "programmers": 0.0877640428366934,
                    "purpose": 0.12250847859419921,
                    "question": 0.08427809823544032,
                    "sense": 0.11648839009992362,
                    "trying": 0.10063076070563635,
                    "turn": 0.13026972252966773,
                    "use": 0.06399056423747401,
                    "used": 0.07908818434042371,
                    "user": 0.09917210570633361,
                    "utility": 0.14120858147394916,
                    "way": 0.07908818434042371,
                    "website": 0.12250847859419921,
                    "windows": 0.12250847859419921,
                    "words": 0.13026972252966773
                },
                "Max term": "asp",
                "Max score": 0.40556547893902073
            }
        ],
        "Best Answer": "I've been a Microsoft developer for 11 years, mostly as a web developer.  Been coding since 1.1 and I've used .NET membership in many of my applications, and I've never heard of dcpromo. ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "applications": 0.3192400624839995,
                "coding": 0.26573246758029134,
                "developer": 0.5448986463334793,
                "heard": 0.34144772086525993,
                "microsoft": 0.3333144009170917,
                "net": 0.29703240410273907,
                "used": 0.22629921110967544,
                "web": 0.28794012596155183,
                "years": 0.28376639914791607
            },
            "Max term": "developer",
            "Max score": 0.5448986463334793
        }
    },
    {
        "ID:": "1090",
        "Question": "Language shortcuts can often be used to make code more concise. For example, ternary and null coalescing operators can reduce the amount of code, but arguably to the detriment of readability: In C#: Person newGuy = new Person(); if (boss == null) {     newGuy.Boss = GetDefaultBoss(); } else {     newGuy.Boss = boss; }  is functionally equivalent to: Person newGuy = new Person(); newGuy.Boss = boss ?? GetDefaultBoss();  but obviously a lot more verbose. Where do you draw the line when it comes to conciseness vs readability? ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "arguably": 0.1291184070440982,
                    "boss": 0.7747104422645891,
                    "code": 0.10686728908388854,
                    "comes": 0.11911612512169058,
                    "draw": 0.1291184070440982,
                    "example": 0.07860456331189736,
                    "language": 0.06886897223057936,
                    "line": 0.09821442013556203,
                    "lot": 0.08201254739123902,
                    "make": 0.0723167124225337,
                    "new": 0.14847983875981297,
                    "obviously": 0.11201939315846185,
                    "operators": 0.12361375407944274,
                    "person": 0.40806844494421696,
                    "readability": 0.23823225024338116,
                    "reduce": 0.1291184070440982,
                    "used": 0.0723167124225337,
                    "vs": 0.11531343402119835
                },
                "Max term": "boss",
                "Max score": 0.7747104422645891
            }
        ],
        "Best Answer": "Both. Your first example is certainly more verbose, and arguably more explicit... but it also requires me to scan five lines instead of one. Worse, it deemphasizes its purpose - assigning a value to newGuy.Boss. Your second example may cost me a second if I'm unfamiliar with the null coalescing operator, but there can be no doubt as to its purpose, and if I'm scanning through a larger routine looking for the source of a value, it will be much easier for me to pick this one out. Now, contrast this: if (boss == null) {     newGuy.Boss = GetDefaultBoss();     newGuy.IsTemp = true;     newGuy.AddTask(\"orientation\"); } else {     newGuy.Boss = boss;     newGuy.IsTemp = false; }  ...with: newGuy.Boss = boss ?? GetDefaultBoss(); newGuy.IsTemp = boss == null; if ( boss == null ) newGuy.AddTask(\"orientation\");  The latter example is again much shorter, but now it obscures its purpose by making tasks triggered by the same test appear to be distinct. Here, I feel the verbosity of the former is justified. ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "appear": 0.09446791459194807,
                "arguably": 0.09446791459194807,
                "boss": 0.8502112313275326,
                "certainly": 0.08714986648399801,
                "cost": 0.0819576287207543,
                "easier": 0.0819576287207543,
                "example": 0.1725302226881471,
                "false": 0.09446791459194807,
                "feel": 0.0718573878462983,
                "instead": 0.07061216811579454,
                "lines": 0.08436767371749206,
                "looking": 0.07319492761127085,
                "making": 0.0779302162237446,
                "operator": 0.09446791459194807,
                "pick": 0.08436767371749206,
                "purpose": 0.2458728861622629,
                "second": 0.17429973296799603,
                "source": 0.0718573878462983,
                "tasks": 0.07621000783333642,
                "test": 0.06369972196214266,
                "true": 0.07983181837604794,
                "unfamiliar": 0.09446791459194807,
                "value": 0.15966363675209588,
                "worse": 0.09044050209493837
            },
            "Max term": "boss",
            "Max score": 0.8502112313275326
        }
    },
    {
        "ID:": "1095",
        "Question": "I used ad-hoc MUML (made-up modeling language) to design and explain system fairly frequently.  It looks similar to UML and tends to be pretty well understood. However, I've had a professor or two that harped on the use of strict, formal UML, as close to the spec as possible.  I always suspected that strict UML wasn't really as common as they claimed.  So, how 'bout it- how often do you actually draw out complete diagrams that use all the proper line endings, multiplicity, member type symbols, etc? ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "actually": 0.18406624816864464,
                    "close": 0.24520583965253864,
                    "common": 0.18667100057953795,
                    "complete": 0.22461569759813801,
                    "design": 0.1707429871349409,
                    "diagrams": 0.26579598170693924,
                    "draw": 0.26579598170693924,
                    "explain": 0.18667100057953795,
                    "fairly": 0.24520583965253864,
                    "formal": 0.24520583965253864,
                    "frequently": 0.22461569759813801,
                    "language": 0.14176984135904797,
                    "line": 0.20217875061604326,
                    "looks": 0.2373778309485715,
                    "possible": 0.18406624816864464,
                    "pretty": 0.1923192094666008,
                    "proper": 0.2544644088337012,
                    "really": 0.15282617486666258,
                    "similar": 0.21000675932001037,
                    "type": 0.21000675932001037,
                    "use": 0.2408980341554973,
                    "used": 0.14886716783611637
                },
                "Max term": "diagrams",
                "Max score": 0.26579598170693924
            }
        ],
        "Best Answer": "Never. Heck, it's been years since I last created any UML. Line diagrams on whiteboards and scraps of paper don't count. In fact, we just removed the sole UML question from the guide we use during interviews, because none of us really cared about the answers. ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "answers": 0.30191235191277804,
                "created": 0.3479972605347969,
                "diagrams": 0.3479972605347969,
                "fact": 0.2749544085197359,
                "guide": 0.3479972605347969,
                "interviews": 0.3331612336990522,
                "line": 0.2647054741042162,
                "paper": 0.3479972605347969,
                "question": 0.207696635734751,
                "really": 0.20008989545315586,
                "use": 0.1576996300244338,
                "years": 0.2444017264888272
            },
            "Max term": "created",
            "Max score": 0.3479972605347969
        }
    },
    {
        "ID:": "1106",
        "Question": "This goes back to a conversation I've had with my girlfriend. I tried to tell her that I simply don't feel adequate enough in my programming language (C++) to call myself good. She then asked me, \"Well, when do you consider yourself good enough?\" That's an interesting question. I didn't know what to tell her. So I'm asking you. For any programming language, framework or the like, when do you reach a point were you sit back, look at what you've done and say, \"Hey, I'm actually pretty good at this.\"? How do you define \"good\" so that you can tell others, honestly, \"Yeah, I'm good at X\". Additionally, do you reach these conclusions by comparing what others can do? Additional Info I have read the canonical paper on how it takes ten-thousand hours before you are an expert on the field. (Props to anybody that knows what this paper is called again) I have also read various articles from Coding Horror about interviewing people. Some people, it was said, \"Cannot function outside of a framework.\" So they may be \"good\" for that framework, but not otherwise in the language. Is this true?  ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "actually": 0.09287496664303346,
                    "anybody": 0.13411363126316764,
                    "articles": 0.12839601891931826,
                    "asked": 0.09859257898688284,
                    "asking": 0.10819335785352843,
                    "called": 0.12839601891931826,
                    "coding": 0.0882033372029916,
                    "comparing": 0.13411363126316764,
                    "consider": 0.11063549278117586,
                    "define": 0.11977458306720563,
                    "expert": 0.12839601891931826,
                    "feel": 0.10201405692906325,
                    "field": 0.1237243894792764,
                    "framework": 0.3060421707871897,
                    "function": 0.11333514769538516,
                    "goes": 0.11977458306720563,
                    "good": 0.4395681991865098,
                    "hours": 0.11977458306720563,
                    "interesting": 0.10391292720278728,
                    "interviewing": 0.1237243894792764,
                    "know": 0.07098226305259737,
                    "knows": 0.11977458306720563,
                    "language": 0.2145999511297587,
                    "like": 0.0558005282886058,
                    "look": 0.09557462155724276,
                    "outside": 0.1237243894792764,
                    "paper": 0.2682272625263353,
                    "people": 0.13879365632208335,
                    "point": 0.09557462155724276,
                    "pretty": 0.09703919290873998,
                    "programming": 0.13031169579979948,
                    "question": 0.08004358993149481,
                    "read": 0.19718515797376568,
                    "said": 0.10024625099728461,
                    "say": 0.07927866677059758,
                    "simply": 0.11635310512502525,
                    "sit": 0.13411363126316764,
                    "takes": 0.10391292720278728,
                    "tell": 0.317891590023402,
                    "tried": 0.11977458306720563,
                    "true": 0.11333514769538516,
                    "various": 0.13411363126316764
                },
                "Max term": "good",
                "Max score": 0.4395681991865098
            }
        ],
        "Best Answer": "You can't call yourself good at X.  Only other people can. ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "good": 0.7259956126799759,
                "people": 0.6876993313719495
            },
            "Max term": "good",
            "Max score": 0.7259956126799759
        }
    },
    {
        "ID:": "1135",
        "Question": "Planning Poker Summary, in case you don't want to read the wiki article:  Get a list of tasks you want to do for the upcoming iteration For each task: 2.1 Discuss with the group what it entails 2.2 Everyone writes down / selects an estimation of how much effort is required for the task 2.3 Everyone reveals their estimation 2.4 The highest and lowest outliers explain their reasoning 2.5 Repeat until a consensus is reached  Usually something similar to numbers from the Fibonacci sequence like 0, ½, 1, 2, 3, 5, 8, 13, 20, 40, 100 are the allowed values, so you don't get long arguments over close values like 23 vs 27. Further, the numbers represent a unit-less value of effort, whose value is determined by a baseline task that everyone agrees equals about a 1, and all else is relative to that. Ultimately, the goal is to get a good feel for a given team's \"velocity\", which is the number of these points that can be completed in a given iteration.  With that, it's possible to make reasonably accurate estimates of how long any given feature will take.  We did this at iteration planning meetings at one company I worked at, and I thought it was one of the few good things about that particular company.  So, what I'm wondering is, has anyone used this?  Do you think it's a useful tool for estimation?  Does it work in all situations, or does it lend itself to certain teams, projects, etc? ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "100": 0.10972513424410321,
                    "20": 0.1228610930422381,
                    "arguments": 0.1228610930422381,
                    "article": 0.11762320562139357,
                    "case": 0.0970731755635156,
                    "certain": 0.10972513424410321,
                    "close": 0.11334353998348708,
                    "company": 0.17779462380389208,
                    "completed": 0.1228610930422381,
                    "discuss": 0.1228610930422381,
                    "effort": 0.21945026848820642,
                    "estimates": 0.11762320562139357,
                    "explain": 0.08628649320883067,
                    "feature": 0.09345476982413177,
                    "feel": 0.09345476982413177,
                    "given": 0.31977218586679995,
                    "goal": 0.11334353998348708,
                    "good": 0.13422903376786166,
                    "group": 0.11762320562139357,
                    "like": 0.10223739128231715,
                    "list": 0.08628649320883067,
                    "long": 0.1596891787212122,
                    "make": 0.06881211236147917,
                    "meetings": 0.11762320562139357,
                    "number": 0.0970731755635156,
                    "particular": 0.0970731755635156,
                    "planning": 0.22668707996697415,
                    "points": 0.10382598692473603,
                    "possible": 0.08508247678145064,
                    "projects": 0.09032036420229518,
                    "reached": 0.1228610930422381,
                    "read": 0.09032036420229518,
                    "reasonably": 0.1228610930422381,
                    "reasoning": 0.1228610930422381,
                    "repeat": 0.11762320562139357,
                    "represent": 0.1228610930422381,
                    "required": 0.10972513424410321,
                    "similar": 0.0970731755635156,
                    "situations": 0.11762320562139357,
                    "task": 0.2855829574616669,
                    "tasks": 0.09911560876098044,
                    "team": 0.08508247678145064,
                    "teams": 0.1228610930422381,
                    "things": 0.06711451688393083,
                    "think": 0.06404844660602542,
                    "thought": 0.11334353998348708,
                    "tool": 0.1013528412014221,
                    "ultimately": 0.1228610930422381,
                    "unit": 0.09345476982413177,
                    "used": 0.06881211236147917,
                    "useful": 0.08755562250476458,
                    "usually": 0.09032036420229518,
                    "value": 0.20765197384947207,
                    "values": 0.2457221860844762,
                    "vs": 0.10972513424410321,
                    "want": 0.13646499673619233,
                    "work": 0.06404844660602542,
                    "worked": 0.09911560876098044
                },
                "Max term": "given",
                "Max score": 0.31977218586679995
            }
        ],
        "Best Answer": "We use it in our company for the project I'm involved in.  Some notes about planning poker are expressed in my recent blog post, and here's a bigger list of why it's cool:  It makes everyone agree.  People are not forced to accept any result; instead they're forced to make their own estimate!  The time to defend their own estimates is also allocated, if it's necessary. It keeps everyone busy.  You can't slack during the meeting, while trying to show that you're so involved. Also, necessity of moving your hands constitutes a good physical exercise to keep you off of sleeping. However, a downside of this is that sometimes you do need to do something else (for example, take some notes and write down the details of the agreement you've just reached).   It keeps meetings faster.  There's no need for a constant involvement of a meeting leader to keep everything on pace.  The game with clear rules is way better for that.  Yes, you need to make some extra moves to put cards on, reveal them, et cetera, but these pay their way. A lot of people just like to play cards, especially poker :-)  This increases motivation.  A company that sells decks of such cards accompanied their site with an article about Planning Poker, which is also worth reading. ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "accept": 0.11692776681162984,
                "agree": 0.11692776681162984,
                "article": 0.11692776681162984,
                "better": 0.07845732248348665,
                "bigger": 0.11692776681162984,
                "blog": 0.10907639221775933,
                "cards": 0.3664040567906069,
                "clear": 0.11267340439141486,
                "company": 0.17674342577789576,
                "constant": 0.12213468559686896,
                "constitutes": 0.12213468559686896,
                "details": 0.10321212318596075,
                "especially": 0.10075359976025473,
                "estimate": 0.12213468559686896,
                "estimates": 0.11692776681162984,
                "example": 0.07435302097011567,
                "exercise": 0.10907639221775933,
                "extra": 0.11267340439141486,
                "faster": 0.10907639221775933,
                "forced": 0.24426937119373793,
                "game": 0.10075359976025473,
                "good": 0.0667177070920785,
                "hands": 0.12213468559686896,
                "instead": 0.09129231855480062,
                "involved": 0.21815278443551867,
                "like": 0.05081646000095855,
                "list": 0.08577633047505018,
                "lot": 0.07757667492913155,
                "make": 0.13681053131500906,
                "makes": 0.08837171288894788,
                "meeting": 0.24426937119373793,
                "meetings": 0.11692776681162984,
                "moving": 0.11267340439141486,
                "necessary": 0.11267340439141486,
                "need": 0.2088064902710252,
                "notes": 0.24426937119373793,
                "pay": 0.11267340439141486,
                "people": 0.1263966937445308,
                "physical": 0.12213468559686896,
                "planning": 0.22534680878282973,
                "play": 0.10907639221775933,
                "post": 0.11267340439141486,
                "project": 0.06960216342367508,
                "reached": 0.12213468559686896,
                "reading": 0.09463148953486175,
                "result": 0.10596051854549386,
                "rules": 0.11692776681162984,
                "site": 0.10321212318596075,
                "time": 0.06273626463211866,
                "trying": 0.08703795613458565,
                "use": 0.05534697227839492,
                "way": 0.13681053131500906,
                "worth": 0.08978635149411876,
                "write": 0.07289414654014136,
                "yes": 0.09129231855480062
            },
            "Max term": "cards",
            "Max score": 0.3664040567906069
        }
    },
    {
        "ID:": "1180",
        "Question": "I've been in workplaces where, at the start of a project, the \"Should we use VB.Net or C#\" question has been raised. Granted, it's probably less common to have to make that decision now than it was in the early days of .Net, particularly given the trend towards language convergence, but it can still be a heated debate. So, between VB.Net and C#, Which language do you prefer and why? ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "common": 0.16935087803045654,
                    "days": 0.20377490606239262,
                    "early": 0.21535291486787278,
                    "given": 0.20920114853201133,
                    "granted": 0.23085412800970495,
                    "language": 0.25723167538455943,
                    "make": 0.1350546442922808,
                    "net": 0.5318039618786098,
                    "particularly": 0.22245460791677266,
                    "prefer": 0.21535291486787278,
                    "probably": 0.17726798729286994,
                    "project": 0.13741771679131518,
                    "question": 0.14391718148218538,
                    "start": 0.1647400517743514,
                    "use": 0.10927324938900093,
                    "vb": 0.4617082560194099
                },
                "Max term": "net",
                "Max score": 0.5318039618786098
            }
        ],
        "Best Answer": "I hate VB.NET. The days I still spend using it are the days I regret. That said, my tastes are a part of my situation and experience, and don't necessarily have any relevance to what you're doing...  I think it is important, when comparing continually-evolving languages like C# and VB.NET, to look back at their history and see how they arrived at their current state: The original advantages of BASIC on microcomputers included size and simplicity (small, easy-to-parse syntax made for small, reasonably fast interpreters and left room in memory for the actual program and data), an interactive environment that enabled experimentation, and a syntax that eschewed terse symbols and structures for a reasonably clear, English-like syntax. It was poorly-suited for large, structured programs however, and tended to encourage spaghetti code. Still, its availability and simplicity made it an excellent choice for an introduction to programming. QuickBasic updated the syntax to allow for large more structured programs, and added compilation for faster execution. VisualBasic provided a powerful, easy-to-use form builder to enable rapid construction of GUI applications, while adopting the QB syntax for use in scripting these UIs. It worked best when used to create UIs for low-level logic provided as pre-built components (usually written in some other language). Over time, the syntax became increasingly large and inconsistent as new features were tacked on. The focus on drawing up a UI first and then filling in bits of script worked well for small, UI-centered apps, but tended to encourage copy-paste programming and a variation on spaghetti code while discouraging re-use, complex data structures, and separation of concerns. In the minds of many, \"VB code\" became synonymous with \"big ball of mud\"; \"VB programmer\" with \"inexperienced hack\".  VB.NET is a VB-like language on the .NET platform, an attempt (not entirely successful) to clean up and modernize the overgrown VB syntax. It was not perfectly compatible with existing VB code, and made no effort to provide compatibility with VB forms (arguably the most important part of VB) whatsoever. This left many VB product owners with the unpleasant choice of effectively re-writing their applications in VB.NET (dealing with subtle incompatibilities in every routine that wasn't carefully examined) or actually re-writing their applications in C# (dealing with an unfamiliar syntax in addition to the new runtime library and forms designer). Most VB.NET users were VB users who stuck with it for the syntax alone, many using it as a crutch while learning C#. As a result, it immediately took on a reputation as a haven for programmers who had become stuck in their ways, unwilling or unable to expand or improve their skills.  At this point in time, VB.NET continues to evolve, slowly shedding baggage while picking up new and interesting syntax (LINQ, XML literals). Still, it retains almost none of the original advantages of BASIC: it is a large, complex language with a fairly steep learning curve and limited opportunity for interactive experimentation.   For old programmers who have stuck with it over the past 30+ years, it's not a bad choice, provided they don't limit themselves to it. For new programmers, the increasingly-vague resemblance of VB programs to English is hardly worth the bizarre nods to backwards compatibility and social stigma. For new projects, VB.NET is a strange choice unless the project is heavily involved with one of the few tasks the language is optimized for: integration with poorly-typed COM components (Office...) (though C# 4.0 reduces this advantage considerably), or inline XML generation.  ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "30": 0.03899565186483348,
                "actual": 0.037576813205981816,
                "actually": 0.028207415593201363,
                "added": 0.03637720221278283,
                "advantages": 0.08146434007978824,
                "allow": 0.03899565186483348,
                "applications": 0.09654808521049726,
                "apps": 0.033601533729017426,
                "arguably": 0.04073217003989412,
                "attempt": 0.03899565186483348,
                "bad": 0.030983084076966774,
                "basic": 0.07515362641196363,
                "best": 0.025871981402341145,
                "big": 0.0315597973174073,
                "bits": 0.04073217003989412,
                "built": 0.037576813205981816,
                "choice": 0.1344061349160697,
                "clear": 0.037576813205981816,
                "code": 0.06742550021052843,
                "com": 0.03637720221278283,
                "comparing": 0.04073217003989412,
                "complex": 0.07067610380815612,
                "components": 0.07799130372966696,
                "concerns": 0.04073217003989412,
                "copy": 0.037576813205981816,
                "create": 0.03285982347781928,
                "current": 0.03442145637206951,
                "data": 0.056414831186402725,
                "days": 0.06884291274413902,
                "dealing": 0.08146434007978824,
                "easy": 0.060892353790210234,
                "effectively": 0.037576813205981816,
                "effort": 0.03637720221278283,
                "encourage": 0.07515362641196363,
                "english": 0.07515362641196363,
                "entirely": 0.03899565186483348,
                "environment": 0.033601533729017426,
                "excellent": 0.04073217003989412,
                "existing": 0.03637720221278283,
                "experience": 0.027119778725871534,
                "fairly": 0.037576813205981816,
                "fast": 0.03533805190407806,
                "faster": 0.03637720221278283,
                "features": 0.03218269507016575,
                "focus": 0.04073217003989412,
                "form": 0.037576813205981816,
                "gui": 0.037576813205981816,
                "hardly": 0.04073217003989412,
                "history": 0.03899565186483348,
                "immediately": 0.03899565186483348,
                "important": 0.0580546764725069,
                "included": 0.04073217003989412,
                "integration": 0.04073217003989412,
                "interesting": 0.0315597973174073,
                "involved": 0.03637720221278283,
                "language": 0.08690264236022188,
                "languages": 0.026470897418140727,
                "large": 0.15030725282392726,
                "learning": 0.05721316694325635,
                "left": 0.08146434007978824,
                "level": 0.0315597973174073,
                "library": 0.03285982347781928,
                "like": 0.05084218327011236,
                "limited": 0.04073217003989412,
                "logic": 0.03899565186483348,
                "look": 0.02902733823625345,
                "low": 0.03533805190407806,
                "necessarily": 0.03637720221278283,
                "net": 0.23955147014609598,
                "new": 0.11709999717149554,
                "office": 0.04073217003989412,
                "old": 0.0315597973174073,
                "opportunity": 0.037576813205981816,
                "original": 0.07067610380815612,
                "parse": 0.04073217003989412,
                "past": 0.03285982347781928,
                "platform": 0.03899565186483348,
                "point": 0.02902733823625345,
                "powerful": 0.037576813205981816,
                "product": 0.03285982347781928,
                "program": 0.0315597973174073,
                "programmer": 0.026165679181591243,
                "programmers": 0.07594764876677654,
                "programming": 0.03957746950486248,
                "programs": 0.10326436911620852,
                "project": 0.023212465335812112,
                "projects": 0.029943933768261998,
                "provide": 0.03899565186483348,
                "provided": 0.11273043961794543,
                "reasonably": 0.08146434007978824,
                "result": 0.03533805190407806,
                "room": 0.04073217003989412,
                "runtime": 0.037576813205981816,
                "said": 0.030446176895105117,
                "situation": 0.03442145637206951,
                "size": 0.03637720221278283,
                "skills": 0.033601533729017426,
                "slowly": 0.03899565186483348,
                "small": 0.08983180130478599,
                "spend": 0.03442145637206951,
                "state": 0.03899565186483348,
                "structures": 0.07799130372966696,
                "stuck": 0.12219651011968234,
                "successful": 0.04073217003989412,
                "suited": 0.04073217003989412,
                "syntax": 0.3757681320598182,
                "tasks": 0.03285982347781928,
                "think": 0.02123399811403943,
                "time": 0.041845347800670354,
                "took": 0.03899565186483348,
                "typed": 0.03637720221278283,
                "ui": 0.07515362641196363,
                "unable": 0.04073217003989412,
                "unfamiliar": 0.04073217003989412,
                "unless": 0.04073217003989412,
                "updated": 0.037576813205981816,
                "use": 0.055374988890822055,
                "used": 0.022813297457385303,
                "users": 0.06196616815393355,
                "using": 0.04770489553218016,
                "usually": 0.029943933768261998,
                "vague": 0.04073217003989412,
                "vb": 0.6629260817021693,
                "ways": 0.03285982347781928,
                "worked": 0.06571964695563856,
                "worth": 0.029943933768261998,
                "writing": 0.05565545448610894,
                "written": 0.03637720221278283,
                "xml": 0.08146434007978824,
                "years": 0.028606583471628175
            },
            "Max term": "vb",
            "Max score": 0.6629260817021693
        }
    },
    {
        "ID:": "1189",
        "Question": "By now I work with asp.net and C#. I have done a decent work in Java as well. I am planning my career in such a way I should be language-agnostic someday. What are the things that I need to learn?  First would OOP paradigms as its speaks about the Class design. Are there any others? ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "agnostic": 0.30415681642502773,
                    "asp": 0.30415681642502773,
                    "career": 0.24166069203160434,
                    "class": 0.25629881331244087,
                    "design": 0.20408607880327326,
                    "java": 0.2170496586626967,
                    "language": 0.16945498905125633,
                    "learn": 0.2089445332302954,
                    "need": 0.18105171269835554,
                    "net": 0.23355556659920304,
                    "oop": 0.30415681642502773,
                    "paradigms": 0.30415681642502773,
                    "planning": 0.2930902121022454,
                    "things": 0.1735485585814314,
                    "way": 0.1779382981171027,
                    "work": 0.3312402771841113
                },
                "Max term": "work",
                "Max score": 0.3312402771841113
            }
        ],
        "Best Answer": "To be language agnostic you need to have experience in all of the common styles and types of languages.  An imperative language (You tell it what to do, step by step. Eg - C) A declarative language (You tell it your goal, it figures out what to do. Eg - SQL/HTML/Prolog)  Also:  A functional language (Functions are key, avoiding state and side effects are the goals. Eg - Haskell/OCaml/Lisp/F#) An object oriented language (Architecture where objects encapsulate related data and the methods that act on them). Eg - Java/C#)  Some typing styles:  A statically typed language (Data types are defined and checked at compile time. Eg - C#) A dynamically typed language (Data types are checked at runtime. Eg - Python/Javascript) Experience of strong vs. weak typing is also useful.  Some different runtime styles:  Something compiled (Eg - C++) Something interpreted (Eg - PHP) Something Managed (Eg - C#/Java)  Lower level stuff:  Something fairly low level (Eg - C) Some dialect of assembly (Eg - NASM)  On top of that I would say you need experience of some concurrent programming and something event driven. You should probably also make sure you know something about the various domains such as web programming (client & server), rich client development/desktop, games. You might also want to learn about embedded programming, or dedicated hardware (like games consoles), and mobile development is becoming an increasingly relevant domain. Others have also mentioned that it's worth getting some experience of Generic programming and Meta programming approaches. When you learn these paradigms avoid just learning the syntax and writing in your old style. I've seen many C# devs write JavaScript as if it's statically typed. Don't do this, try to learn the language paradigms and embrace them. If you've done all of this, the differences between languages will become largely syntactical so switching will become a fairly simple exercise of learning some new syntax. Don't forget though that modern programming is almost always dependant on a framework, so familiarising yourself with the common and popular frameworks for each language you learn is also critical. Knowing C# is irrelevant without .net.  ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "agnostic": 0.0723986267780601,
                "approaches": 0.06976443641046373,
                "architecture": 0.0756226152290112,
                "assembly": 0.0756226152290112,
                "avoid": 0.06100695801187457,
                "client": 0.13952887282092746,
                "common": 0.10622093803363451,
                "compile": 0.0723986267780601,
                "concurrent": 0.0756226152290112,
                "critical": 0.0756226152290112,
                "data": 0.15710814331180345,
                "defined": 0.0756226152290112,
                "desktop": 0.0656079923919484,
                "development": 0.08940567870088545,
                "different": 0.052369381103934486,
                "domain": 0.0723986267780601,
                "driven": 0.06390625759191627,
                "dynamically": 0.0756226152290112,
                "effects": 0.06976443641046373,
                "event": 0.0723986267780601,
                "exercise": 0.06753726018895805,
                "experience": 0.20140037613255898,
                "fairly": 0.13952887282092746,
                "framework": 0.057522637351895244,
                "frameworks": 0.06390625759191627,
                "functional": 0.06100695801187457,
                "functions": 0.06976443641046373,
                "games": 0.1350745203779161,
                "getting": 0.05859335279466677,
                "goal": 0.06976443641046373,
                "hardware": 0.06976443641046373,
                "haskell": 0.0656079923919484,
                "html": 0.06976443641046373,
                "imperative": 0.0756226152290112,
                "interpreted": 0.0756226152290112,
                "irrelevant": 0.0723986267780601,
                "java": 0.10332891706669557,
                "javascript": 0.1312159847838968,
                "key": 0.0723986267780601,
                "know": 0.040024748538631465,
                "knowing": 0.0723986267780601,
                "language": 0.36301924076469244,
                "languages": 0.09829078530596676,
                "learn": 0.19894076294535248,
                "learning": 0.10622093803363451,
                "level": 0.11718670558933354,
                "like": 0.03146422806242882,
                "lisp": 0.0723986267780601,
                "low": 0.0656079923919484,
                "lower": 0.0756226152290112,
                "make": 0.04235475826687168,
                "managed": 0.06976443641046373,
                "mentioned": 0.0723986267780601,
                "methods": 0.06238400394099729,
                "mobile": 0.0723986267780601,
                "modern": 0.0756226152290112,
                "need": 0.0861916923595089,
                "net": 0.055593369554885586,
                "new": 0.04348115025909543,
                "object": 0.0723986267780601,
                "objects": 0.0723986267780601,
                "old": 0.05859335279466677,
                "oriented": 0.06390625759191627,
                "paradigms": 0.1447972535561202,
                "php": 0.05974981357340093,
                "popular": 0.06976443641046373,
                "probably": 0.055593369554885586,
                "programming": 0.22043645687225358,
                "python": 0.06100695801187457,
                "related": 0.0656079923919484,
                "relevant": 0.05974981357340093,
                "runtime": 0.13952887282092746,
                "say": 0.044702839350442725,
                "seen": 0.05471746218750553,
                "server": 0.06976443641046373,
                "simple": 0.05974981357340093,
                "sql": 0.0756226152290112,
                "state": 0.0723986267780601,
                "statically": 0.1512452304580224,
                "step": 0.13952887282092746,
                "strong": 0.06976443641046373,
                "stuff": 0.05859335279466677,
                "style": 0.06238400394099729,
                "styles": 0.2092933092313912,
                "sure": 0.05652582512244983,
                "syntax": 0.13952887282092746,
                "tell": 0.11949962714680186,
                "time": 0.03884466053189527,
                "try": 0.04914539265298338,
                "typed": 0.20261178056687412,
                "types": 0.19682397717584518,
                "typing": 0.1350745203779161,
                "useful": 0.05389163475485347,
                "various": 0.0756226152290112,
                "vs": 0.06753726018895805,
                "want": 0.041997998246936924,
                "web": 0.05389163475485347,
                "worth": 0.055593369554885586,
                "write": 0.04513415635626432,
                "writing": 0.051664458533347786
            },
            "Max term": "language",
            "Max score": 0.36301924076469244
        }
    },
    {
        "ID:": "1200",
        "Question": "Coming from a procedural/OO programming background, I tend to write Scheme programs in a procedural fashion. I would be intersted in learning Scheme or Lisp in a functional way from the ground up, to kind of reset my programmer's mind. Is there a tutorial or book out there that's the de-facto standard for describing best practices, design methodologies, and other helpful information on functional programming concepts? What about that book makes it special? ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "background": 0.20382415915627713,
                    "best": 0.14922539786157465,
                    "book": 0.35741082033598015,
                    "coming": 0.2249206032544017,
                    "concepts": 0.2249206032544017,
                    "design": 0.15091939907772003,
                    "functional": 0.37906027805778925,
                    "helpful": 0.20981780981035558,
                    "information": 0.1820317987200856,
                    "kind": 0.20382415915627713,
                    "learning": 0.1649981396333168,
                    "lisp": 0.2249206032544017,
                    "makes": 0.16999058064307423,
                    "mind": 0.2249206032544017,
                    "practices": 0.19380820361203616,
                    "programmer": 0.15091939907772003,
                    "programming": 0.2282764331564885,
                    "programs": 0.19853738460217435,
                    "standard": 0.17870541016799008,
                    "tend": 0.20981780981035558,
                    "way": 0.13158340432730503,
                    "write": 0.14021815228829496
                },
                "Max term": "functional",
                "Max score": 0.37906027805778925
            }
        ],
        "Best Answer": "Use it. If you do functional programming daily, maybe smaller applications or exercises from books, then you will be better on it. I have used it since the first programming lecture in university. At the beginning it was very hard, because it is so different, but now I prefer it to imperative programming. If you are looking for a good book, I would recommend Real World Functional Programming: With Examples in F# and C# by Tomas Petricek and Jon Skeet ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "applications": 0.18107142749968225,
                "better": 0.1472175301223162,
                "book": 0.1743219842193954,
                "books": 0.184881195671897,
                "daily": 0.21142067789106994,
                "different": 0.15870507415249424,
                "examples": 0.18905432454388196,
                "functional": 0.369762391343794,
                "good": 0.1251892843473881,
                "hard": 0.1775667805137039,
                "imperative": 0.22917385129502862,
                "looking": 0.1775667805137039,
                "maybe": 0.19366750448711126,
                "prefer": 0.20467123461078307,
                "programming": 0.44535418083826017,
                "real": 0.16847535051225324,
                "recommend": 0.21940357493526966,
                "smaller": 0.22917385129502862,
                "university": 0.21940357493526966,
                "use": 0.10385320707686103,
                "used": 0.12835582376110655,
                "world": 0.15870507415249424
            },
            "Max term": "programming",
            "Max score": 0.44535418083826017
        }
    },
    {
        "ID:": "1217",
        "Question": "I think we’ve all seen this. Beginners ask questions on Stack Overflow that follow the basic outline...  I’m trying to do (very vague description of the goal) but it doesn’t work/I get an error/exception. Please help!  Isn’t it bizarre that so many of them seem to consider it unnecessary to paste the error message? I wonder what the psychology of this is. What is it about error messages that makes people initially assume that they are useless and not worth paying any attention to? The answer I’m looking for is not “they don’t understand the error message”. That doesn’t explain why they wouldn’t consider telling anyone else who might understand it. ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "answer": 0.11000493291949504,
                    "ask": 0.1203558457271085,
                    "assume": 0.16101708895477143,
                    "attention": 0.16101708895477143,
                    "basic": 0.14854374487532537,
                    "consider": 0.2656583796131091,
                    "error": 0.5442816031835173,
                    "exception": 0.16101708895477143,
                    "explain": 0.11308380552845254,
                    "follow": 0.13607040079587931,
                    "goal": 0.14854374487532537,
                    "help": 0.10857383527387361,
                    "initially": 0.1541525123512794,
                    "looking": 0.1247580643769879,
                    "makes": 0.11650544549066266,
                    "message": 0.32203417790954286,
                    "overflow": 0.13969376641004658,
                    "paying": 0.16101708895477143,
                    "people": 0.08331796811361285,
                    "questions": 0.11837044386532172,
                    "seen": 0.11650544549066266,
                    "stack": 0.13969376641004658,
                    "telling": 0.16101708895477143,
                    "think": 0.08393946504311076,
                    "trying": 0.11474707825115446,
                    "understand": 0.21179419957175133,
                    "useless": 0.1541525123512794,
                    "vague": 0.16101708895477143,
                    "wonder": 0.1541525123512794,
                    "work": 0.08393946504311076,
                    "worth": 0.11837044386532172
                },
                "Max term": "error",
                "Max score": 0.5442816031835173
            }
        ],
        "Best Answer": "I think if it is a true beginner there's a good chance they don't know there is an error message at all.  They only know it doesn't run and that there is an error.  For example in Visual studio they may not see that part of the screen.   Basically they don't know which part of the information they have available is useful to figure out what the problem is.  If they did there would be a better chance they could fix it themselves and not ask about it in the first place.  ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "ask": 0.1664928563655746,
                "available": 0.1882314029572045,
                "better": 0.1430852445184591,
                "chance": 0.41097251621009845,
                "error": 0.376462805914409,
                "example": 0.13560009250168245,
                "figure": 0.22274111325289395,
                "fix": 0.17969171923750699,
                "good": 0.12167531507323939,
                "information": 0.17258261422433344,
                "know": 0.3536702752277382,
                "message": 0.22274111325289395,
                "place": 0.17258261422433344,
                "problem": 0.13993152722135482,
                "run": 0.1882314029572045,
                "screen": 0.21324508121929364,
                "studio": 0.20548625810504922,
                "think": 0.11611668060156434,
                "true": 0.1882314029572045,
                "useful": 0.1587340332513302,
                "visual": 0.19892626663310342
            },
            "Max term": "chance",
            "Max score": 0.41097251621009845
        }
    },
    {
        "ID:": "1224",
        "Question": "I've never found the ideal way to perform code reviews and yet often my customers require them. Each customer seems to do them in a different way and I've never felt satisfied in any of them.  What has been the most effective way for you to perform code reviews? For example:  Is one person regarded as the gatekeeper for quality and reviews the code, or do the team own the standard?   Do you do review code as a team exercise using a projector? Is it done in person, via email or using a tool?  Do you eschew reviews and use things like pair programming and collective code ownership to ensure code quality?  ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "code": 0.48000471939692585,
                    "customer": 0.16336511117721783,
                    "customers": 0.1783405153089892,
                    "different": 0.13387311491400086,
                    "effective": 0.17264713089332037,
                    "email": 0.1783405153089892,
                    "example": 0.11768665503818633,
                    "exercise": 0.17264713089332037,
                    "like": 0.08043276682460934,
                    "pair": 0.1783405153089892,
                    "person": 0.30547978570634965,
                    "programming": 0.0939178406033562,
                    "quality": 0.311907123143898,
                    "require": 0.14704650843750602,
                    "review": 0.18507435982562961,
                    "standard": 0.14704650843750602,
                    "team": 0.2677462298280017,
                    "things": 0.10560140902196868,
                    "tool": 0.15947373736981524,
                    "use": 0.0876037039107463,
                    "using": 0.22640865273312138,
                    "way": 0.3248174773745594
                },
                "Max term": "code",
                "Max score": 0.48000471939692585
            }
        ],
        "Best Answer": "I like code reviews, though they can be a pain.  The reason I like them is that they get more eyes on the code and a different perspective.  I believe that even with pair programming, code should be reviewed.  It's easy enough for two people working on the same code to collectively make the same mistake that a different set of eyes may not miss. If done as a group with a projector, it really should be reviewed individually before the meeting.  Otherwise, it is just an annoying waste of time.   I've only done code reviews via email and in a group.  Generally speaking, I don't think they should be done in person.  You feel a little more pressure to rush through the code with someone looking over your shoulder.  I do believe that a tool designed for code reviewing would be a good asset, as it can help with some of the mundane aspects and it should make it easier to flag problem bits of code then it is via email. The problem with having one person do all code reviews is that it can be a bottleneck.  With well documented and designed coding standards it should not be necessary.  Depending on the environment/release-schedule it may be a good idea to always have someone as a standby code reviewer. I do believe that code ownership is a good idea as this person can make it their priority to understand that code and potentially play a gatekeeper role. ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "annoying": 0.10019562444547646,
                "aspects": 0.10397884641887135,
                "believe": 0.2909908675312248,
                "bits": 0.10860913589971061,
                "code": 0.539354419980489,
                "coding": 0.07142963878362033,
                "depending": 0.10860913589971061,
                "designed": 0.20039124889095292,
                "different": 0.1504257215140304,
                "documented": 0.10019562444547646,
                "easier": 0.09422614306878255,
                "easy": 0.08118234213370913,
                "email": 0.20039124889095292,
                "environment": 0.08959585358794328,
                "eyes": 0.2079576928377427,
                "feel": 0.08261396301281354,
                "generally": 0.08959585358794328,
                "good": 0.17798758348790647,
                "group": 0.2079576928377427,
                "help": 0.07323514856069255,
                "idea": 0.1716252632290968,
                "like": 0.0903777953529657,
                "little": 0.09178211299124231,
                "looking": 0.08415172362426193,
                "make": 0.18248960377826143,
                "meeting": 0.10860913589971061,
                "necessary": 0.10019562444547646,
                "pair": 0.10019562444547646,
                "people": 0.05619957844524788,
                "person": 0.25743789484364515,
                "play": 0.09699695584374159,
                "problem": 0.13646194036377093,
                "programming": 0.05276510875568656,
                "really": 0.062447591150671465,
                "reason": 0.08118234213370913,
                "release": 0.09699695584374159,
                "schedule": 0.10860913589971061,
                "set": 0.07984315023785447,
                "speaking": 0.10397884641887135,
                "standards": 0.08959585358794328,
                "think": 0.05661879012591646,
                "time": 0.05578866853401603,
                "tool": 0.08959585358794328,
                "understand": 0.07142963878362033,
                "working": 0.07142963878362033
            },
            "Max term": "code",
            "Max score": 0.539354419980489
        }
    },
    {
        "ID:": "1262",
        "Question": "I'm considering whether I should start using VIM again instead of an IDE. What are the most useful features of VIM that aren't standard in an IDE? ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "considering": 0.36168647105725865,
                    "features": 0.29849598230558494,
                    "ide": 0.6555241251781961,
                    "instead": 0.2823896960754816,
                    "standard": 0.28736953497049345,
                    "start": 0.2581034546869803,
                    "useful": 0.2692299020220718,
                    "using": 0.2212325540421262
                },
                "Max term": "ide",
                "Max score": 0.6555241251781961
            }
        ],
        "Best Answer": "I don't think its necessarily the advanced features of VIM that make it so powerful. Its the fact that you never have to take your hands off the keyboard to do anything. Finding something in a huge file is as simple as a couple of keystrokes. Opening and closing multiple files in the same window is incredibly fast as well. While it may not seem intuitive at first, its well worth your time. Even if you don't use it as your standard IDE (I generally use Visual Studio or Eclipse, for example), you'll find your self using VIM to quickly open and edit files because it becomes way faster than waiting for the IDE to load. Invest the time to learn how to use VIM well and you'll never regret it. I'd say its comparable to learning to touch-type. ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "couple": 0.1645483457110222,
                "edit": 0.1438927128810016,
                "example": 0.10858522173296202,
                "fact": 0.140927576941917,
                "fast": 0.15474484091004898,
                "faster": 0.15929526575063252,
                "features": 0.140927576941917,
                "file": 0.13819991629114098,
                "files": 0.3014621634857804,
                "generally": 0.147140651820436,
                "hands": 0.17836560967915419,
                "huge": 0.17076142058954125,
                "ide": 0.30948968182009795,
                "incredibly": 0.17076142058954125,
                "keyboard": 0.15929526575063252,
                "learn": 0.11730680817281176,
                "learning": 0.1252678336743936,
                "load": 0.17076142058954125,
                "make": 0.09989911428222559,
                "multiple": 0.15929526575063252,
                "necessarily": 0.15929526575063252,
                "open": 0.13567449698152734,
                "powerful": 0.1645483457110222,
                "quickly": 0.15474484091004898,
                "say": 0.1054373638227753,
                "simple": 0.140927576941917,
                "standard": 0.13567449698152734,
                "studio": 0.1645483457110222,
                "think": 0.09298338428390049,
                "time": 0.18324019970928668,
                "touch": 0.1645483457110222,
                "type": 0.140927576941917,
                "use": 0.24248631106111185,
                "using": 0.10444953912280917,
                "visual": 0.15929526575063252,
                "waiting": 0.17836560967915419,
                "way": 0.09989911428222559,
                "worth": 0.13112407214094374
            },
            "Max term": "ide",
            "Max score": 0.30948968182009795
        }
    },
    {
        "ID:": "1280",
        "Question": "What best practices should be undertaken for a website that needs to \"scale out\" to handle capacity?  This is especially relevant now that people are considering the cloud, but may be missing out on the fundamentals. I'm interested in hearing about anything you consider a best practice from development-level tasks, to infrastructure, to management. ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "best": 0.37390437009741256,
                    "consider": 0.2428063028469542,
                    "considering": 0.28178446057747936,
                    "development": 0.17398901102449535,
                    "especially": 0.2428063028469542,
                    "handle": 0.29433262463788645,
                    "interested": 0.2428063028469542,
                    "level": 0.2280526170929332,
                    "management": 0.22388525941088416,
                    "needs": 0.2553544669073613,
                    "people": 0.1523018233254968,
                    "practice": 0.2487311033987831,
                    "practices": 0.2428063028469542,
                    "relevant": 0.2325537062878096,
                    "tasks": 0.2374466688097262,
                    "website": 0.2553544669073613
                },
                "Max term": "best",
                "Max score": 0.37390437009741256
            }
        ],
        "Best Answer": "Design for Concurrency That is, as you're coding, plan around having multiple threads going.  Plan the shared state (often just the db).  Plan for multiple processes. Plan for physical distribution. This allows you to distribute your system across multiple machines, and across multiple processes with load balancing.  It allows you to have redundant processes running in case of failure, and in case you need to modify the system in-place, you don't have to kill all service to do so. ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "allows": 0.28902802926175397,
                "case": 0.23853174617271375,
                "coding": 0.09927580676044986,
                "concurrency": 0.15094937859984825,
                "design": 0.09696740952509415,
                "going": 0.10757243389877254,
                "load": 0.14451401463087699,
                "modify": 0.15094937859984825,
                "multiple": 0.5392412006374769,
                "need": 0.08602309218437272,
                "physical": 0.15094937859984825,
                "place": 0.11695747585100118,
                "plan": 0.603797514399393,
                "running": 0.1392559394122639,
                "state": 0.14451401463087699,
                "threads": 0.15094937859984825
            },
            "Max term": "plan",
            "Max score": 0.603797514399393
        }
    },
    {
        "ID:": "1323",
        "Question": "I recently saw that Microsoft released a coding standards document (All-In-One Code Framework Coding Standards) and it got me thinking...  The company that I work for has no formal coding standards at all.  There are only a few developers and we have been together long enough to have evolved into similar styles and its never been an issue. Does the company you work for have a documented coding standards?  If no, why not?  Does having a standard make a difference?  Is it worth writing a standard from scratch or should you adopt another standard as your own (ie. make Microsoft's standards yours)? ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "code": 0.059244570856857366,
                    "coding": 0.3766118728103726,
                    "company": 0.20716966804362624,
                    "developers": 0.10054265855889587,
                    "difference": 0.13207004267557873,
                    "document": 0.14316007602745273,
                    "documented": 0.13207004267557873,
                    "formal": 0.13207004267557873,
                    "framework": 0.10889527043806511,
                    "got": 0.1180982530165647,
                    "issue": 0.11092222631266352,
                    "long": 0.09303643000567664,
                    "make": 0.1603623570871582,
                    "microsoft": 0.2361965060331294,
                    "recently": 0.12785380767455787,
                    "released": 0.14316007602745273,
                    "saw": 0.14316007602745273,
                    "similar": 0.11311150543908595,
                    "standard": 0.32668581131419533,
                    "standards": 0.5904912650828235,
                    "styles": 0.13207004267557873,
                    "thinking": 0.12098000932370476,
                    "work": 0.149260929697355,
                    "worth": 0.10524300155446714,
                    "writing": 0.09780523708619113
                },
                "Max term": "standards",
                "Max score": 0.5904912650828235
            }
        ],
        "Best Answer": "It's important for a team to have a single coding standard for each language to avoid several problems:  A lack of standards can make your code unreadable. Disagreement over standards can cause check-in wars between developers. Seeing different standards in the same class can be extremely irritating.  I'm a big fan of what Uncle Bob has to say about standards:   Let them evolve during the first few iterations. Let them be team specific instead of company specific. Don't write them down if you can avoid it. Rather, let the code be   the way the standards are captured. Don't legislate good design. (e.g. don't tell people not to use goto) Make sure everyone knows that the standard is about communication, and   nothing else. After the first few iterations, get the team together to decide.   ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "avoid": 0.21910941729998107,
                "big": 0.10522041916917706,
                "cause": 0.1178171265351679,
                "check": 0.10729716136069399,
                "class": 0.10955470864999053,
                "code": 0.11239836750995438,
                "coding": 0.08931316211030675,
                "communication": 0.12128165547247471,
                "company": 0.09826019561329782,
                "decide": 0.12528116061108122,
                "design": 0.08723641991878982,
                "developers": 0.09537439906886086,
                "different": 0.09404357266764776,
                "extremely": 0.12128165547247471,
                "good": 0.07418318300536442,
                "goto": 0.13580112578555512,
                "important": 0.09677719618622008,
                "instead": 0.10150760674356107,
                "knows": 0.12128165547247471,
                "lack": 0.12528116061108122,
                "language": 0.07243339020913285,
                "let": 0.3534513796055037,
                "make": 0.15211914683452107,
                "people": 0.07027001880012762,
                "problems": 0.10729716136069399,
                "say": 0.0802761963629106,
                "seeing": 0.13580112578555512,
                "single": 0.1178171265351679,
                "specific": 0.21459432272138798,
                "standard": 0.20659531244417503,
                "standards": 0.5601378595901749,
                "sure": 0.10150760674356107,
                "team": 0.28213071800294326,
                "tell": 0.10729716136069399,
                "use": 0.06154010310418014,
                "way": 0.07605957341726054,
                "write": 0.08105074422512941
            },
            "Max term": "standards",
            "Max score": 0.5601378595901749
        }
    },
    {
        "ID:": "1338",
        "Question": "Have you ever had to work to coding standards that:  Greatly decreased your productivity? Were originally included for good reasons but were kept long after the original concern became irrelevant? Were in a list so long that it was impossible to remember them all? Made you think the author was just trying to leave their mark rather than encouraging good coding practice? You had no idea why they were included?  If so, what is your least favorite rule and why?  Some examples here ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "author": 0.1982530606852463,
                    "coding": 0.27238510524433296,
                    "examples": 0.17082947936315226,
                    "favorite": 0.2070814819752567,
                    "good": 0.22624206368731825,
                    "idea": 0.16361613394426053,
                    "impossible": 0.2070814819752567,
                    "included": 0.4141629639505134,
                    "irrelevant": 0.1982530606852463,
                    "kept": 0.2070814819752567,
                    "leave": 0.17499794855745243,
                    "list": 0.14543525900416387,
                    "long": 0.2691549535020957,
                    "original": 0.17965790065316264,
                    "originally": 0.19103971526635458,
                    "practice": 0.17499794855745243,
                    "productivity": 0.2070814819752567,
                    "reasons": 0.17082947936315226,
                    "remember": 0.17499794855745243,
                    "rule": 0.1982530606852463,
                    "standards": 0.17082947936315226,
                    "think": 0.10795319260938942,
                    "trying": 0.1475743672353584,
                    "work": 0.10795319260938942
                },
                "Max term": "included",
                "Max score": 0.4141629639505134
            }
        ],
        "Best Answer": "Had a professor once who demanded we have at least one comment for each line of code. //Set x to 3 var x = 3;  //if x is greater than 2 if(x>2){      //Print x     Print(x); }  It was pretty ridiculous. ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "code": 0.24670505551295155,
                "comment": 0.5961443216277954,
                "line": 0.4534595043895265,
                "pretty": 0.4313458914133291,
                "set": 0.43825079944585704
            },
            "Max term": "comment",
            "Max score": 0.5961443216277954
        }
    },
    {
        "ID:": "1371",
        "Question": "Having worked on a failed project is one of the few things that most programmers have in common, regardless of language used, industry or experience. These projects can be great learning experiences, soul-crushing disasters (or both!), and can occur for a multitude of reasons:  upper management change of heart under-skilled / under-resourced team emergence of superior competitor during dev cycle over/under management  Once you've worked on a couple of such projects, is it possible to recognise at an early stage exactly when a project is doomed to fail?  For me, a big sign is having a hard & fast external deadline combined with feature creep. I've seen projects which were well planned out and proceeding right on schedule go horribly off the rails once the late feature requests started to roll in and get added to the final \"deliverable\". The proposers of these requests earned the nickname of Columbo, due to rarely leaving the room without asking for \"just one more thing\". What are the warning signs you look out for that set off the alarm bells of impending doom in your head? ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "added": 0.14193331705991885,
                    "asking": 0.12820952301195415,
                    "big": 0.12313719710484787,
                    "change": 0.110057173649927,
                    "common": 0.11161461120978912,
                    "couple": 0.14661385204032604,
                    "cycle": 0.15892514138372374,
                    "dev": 0.15892514138372374,
                    "early": 0.14193331705991885,
                    "exactly": 0.14661385204032604,
                    "experience": 0.10581352930823719,
                    "experiences": 0.15892514138372374,
                    "fail": 0.15214974993719343,
                    "failed": 0.14661385204032604,
                    "fast": 0.13787885324009053,
                    "feature": 0.24177405783257133,
                    "great": 0.11879217245016249,
                    "hard": 0.12313719710484787,
                    "head": 0.15214974993719343,
                    "horribly": 0.15892514138372374,
                    "industry": 0.15214974993719343,
                    "language": 0.08476724116460396,
                    "learning": 0.11161461120978912,
                    "look": 0.11325627455329512,
                    "management": 0.24177405783257133,
                    "possible": 0.110057173649927,
                    "programmers": 0.09877524985124125,
                    "project": 0.1811366461323118,
                    "projects": 0.3504976952893719,
                    "rarely": 0.15892514138372374,
                    "reasons": 0.13110346179356022,
                    "right": 0.11499179693764182,
                    "room": 0.15892514138372374,
                    "schedule": 0.15892514138372374,
                    "seen": 0.11499179693764182,
                    "set": 0.11683256509645731,
                    "stage": 0.15892514138372374,
                    "started": 0.12820952301195415,
                    "team": 0.110057173649927,
                    "thing": 0.11879217245016249,
                    "things": 0.08681498609988861,
                    "used": 0.08901088550629377,
                    "worked": 0.2564190460239083
                },
                "Max term": "projects",
                "Max score": 0.3504976952893719
            }
        ],
        "Best Answer": "Heroic Coding Coding late into the night, working long hours, and clocking lots of overtime are a sure sign that something went wrong.  Further, my experience is that if you see someone working late at any point in the project, it only ever gets worse.  He might be doing it just to get his one feature back on schedule, and he might succeed; however, cowboy coding like that is almost always the result of a planning failure that will inevitably cause more of it soon.  So, the earlier in the project you see it, the worse it will eventually become. ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "cause": 0.18049865132987256,
                "coding": 0.4104896914653055,
                "earlier": 0.19193372977562312,
                "eventually": 0.2080505676401332,
                "experience": 0.13852159982309273,
                "feature": 0.15825447608466445,
                "gets": 0.18049865132987256,
                "hours": 0.18580639239492505,
                "like": 0.08656339758844543,
                "long": 0.1352072631630954,
                "lots": 0.18049865132987256,
                "planning": 0.19193372977562312,
                "point": 0.14826497560085242,
                "project": 0.23712788121588518,
                "result": 0.18049865132987256,
                "schedule": 0.2080505676401332,
                "soon": 0.19918083171187492,
                "sure": 0.15551207753710422,
                "went": 0.18049865132987256,
                "working": 0.27365979431020365,
                "worse": 0.39836166342374985,
                "wrong": 0.16784042982289013
            },
            "Max term": "coding",
            "Max score": 0.4104896914653055
        }
    },
    {
        "ID:": "1376",
        "Question": "I have a tester that while testing will have an error occur (ok so far), but then he frequently reports it right away.  We (the developers) then later find that the tester has not tried to reproduce the issue and (when asked) cannot find a way to make it happen again. Now these are still bugs, I don't want to ignore them.  But without repro steps I am kind of stuck.  Sometimes there is a stack trace (though frequently it is not useful because this is compact framework and there are no line numbers).  But when there is one I can take the stack trace and crack open the code and start guessing, but that does not lead to testable \"fixes\". What do you do in scenarios like this? ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "asked": 0.1407102125241956,
                    "away": 0.1709409289377214,
                    "bugs": 0.15441233542842797,
                    "code": 0.0792101710616721,
                    "developers": 0.13442583967208574,
                    "error": 0.1617506396784737,
                    "far": 0.15441233542842797,
                    "framework": 0.14559330710735996,
                    "frequently": 0.3235012793569474,
                    "happen": 0.15789772274878347,
                    "issue": 0.14830335326415167,
                    "kind": 0.16605783435455707,
                    "later": 0.16605783435455707,
                    "lead": 0.1765780479316961,
                    "like": 0.07963788223347655,
                    "line": 0.14559330710735996,
                    "make": 0.10720247908806055,
                    "ok": 0.19140545618491853,
                    "open": 0.14559330710735996,
                    "reproduce": 0.19140545618491853,
                    "right": 0.13849323749997305,
                    "scenarios": 0.18324534457914493,
                    "stack": 0.33211566870911413,
                    "start": 0.13076589885413753,
                    "steps": 0.16605783435455707,
                    "stuck": 0.19140545618491853,
                    "tester": 0.3531560958633922,
                    "testing": 0.14307031449556107,
                    "tried": 0.1709409289377214,
                    "useful": 0.13640301784811223,
                    "want": 0.10629949769608728,
                    "way": 0.10720247908806055
                },
                "Max term": "tester",
                "Max score": 0.3531560958633922
            }
        ],
        "Best Answer": "A bug without context is not a bug, it's a fluke. The problem could be your code, it could be a third party library, it could be the hardware, or it could be solar radiation causing a single bit to flip on it's own. If you can't reproduce it with at least some regularity (even if only \"it happens once every 10 or 20 times I do X\"), it's not much better than your tester telling you \"Something somewhere went wrong somehow - fix it\". You may have to explain to your tester that his job is not to just generate input until something breaks. If it were, you could replace him with a random number generator. Part of his job is to identify bugs, which entails identifying how to produce them. ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "10": 0.15933377427965553,
                "20": 0.18854549083876665,
                "better": 0.1211185365177181,
                "bit": 0.14608741616649745,
                "breaks": 0.1805073069819633,
                "bug": 0.31107685466636786,
                "bugs": 0.15210511839738872,
                "causing": 0.18854549083876665,
                "code": 0.07802661888497614,
                "context": 0.16838674295606068,
                "explain": 0.13241725929641396,
                "fix": 0.15210511839738872,
                "generate": 0.18854549083876665,
                "happens": 0.1805073069819633,
                "hardware": 0.1739396325592111,
                "input": 0.1739396325592111,
                "job": 0.2576240100554516,
                "library": 0.15210511839738872,
                "number": 0.14897075291043174,
                "party": 0.1805073069819633,
                "problem": 0.11844898365850202,
                "produce": 0.1739396325592111,
                "replace": 0.1805073069819633,
                "reproduce": 0.18854549083876665,
                "single": 0.16357661118998731,
                "telling": 0.18854549083876665,
                "tester": 0.3478792651184222,
                "times": 0.14608741616649745,
                "went": 0.16357661118998731,
                "wrong": 0.15210511839738872
            },
            "Max term": "tester",
            "Max score": 0.3478792651184222
        }
    },
    {
        "ID:": "1380",
        "Question": "We are starting a push for code coverage here at my work, and it has got me to thinking.... How much code coverage is enough? When do you get to the point of diminishing returns on code coverage?  What is the sweet spot between good coverage and not enough?  Does it vary by the type of project your are making (ie WPF, WCF, Mobile, ASP.NET)  (These are C# classes we are writing.) ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "asp": 0.1850959665273077,
                    "classes": 0.17836133586087452,
                    "code": 0.2400303790275203,
                    "coverage": 0.7403838661092308,
                    "good": 0.10561373757003807,
                    "got": 0.15949235529977637,
                    "making": 0.15949235529977637,
                    "mobile": 0.1850959665273077,
                    "net": 0.1421312658569609,
                    "point": 0.13778057218219425,
                    "project": 0.11017981496261149,
                    "push": 0.19333848831202352,
                    "starting": 0.16773487708449222,
                    "thinking": 0.16338418340972555,
                    "type": 0.15275772463334322,
                    "work": 0.10078886276296743,
                    "wpf": 0.19333848831202352,
                    "writing": 0.1320865230863465
                },
                "Max term": "coverage",
                "Max score": 0.7403838661092308
            }
        ],
        "Best Answer": "I'm of the opinion that code coverage alone is a poor metric.  It's easy to produce tons of useless tests that cover the code, but don't adequately check the output, or don't test edge cases, for example.  Covering code just means it doesn't throw an exception, not that it's right.  You need quality tests- the quantity isn't that important. ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "adequately": 0.23167616962374207,
                "cases": 0.19111858317878042,
                "check": 0.1830485219599724,
                "code": 0.28762673843132874,
                "coverage": 0.22179921293604227,
                "easy": 0.1731715652722726,
                "edge": 0.22179921293604227,
                "example": 0.14103956639449336,
                "exception": 0.23167616962374207,
                "important": 0.1651015040534646,
                "means": 0.1830485219599724,
                "need": 0.13202770810535533,
                "opinion": 0.21372915171723425,
                "output": 0.23167616962374207,
                "poor": 0.23167616962374207,
                "produce": 0.21372915171723425,
                "quality": 0.18689988847628974,
                "right": 0.16763149505929853,
                "test": 0.15621925871902792,
                "tests": 0.35901121641382505,
                "throw": 0.22179921293604227,
                "useless": 0.22179921293604227
            },
            "Max term": "tests",
            "Max score": 0.35901121641382505
        }
    },
    {
        "ID:": "1386",
        "Question": "Sometimes I feel like a musician who can't play live shows. Programming is a pretty cool skill, and a very broad world, but a lot of it happens \"off camera\"- in your head, in your office, away from spectators.  You can of course talk about programming with other programmers, and there is peer programming, and you do get to create something that you can show to people, but when it comes to explaining to non programmers what is it that you do, or how was your day at work, it's sort of tricky.  How do you get the non programmers in your life to understand what is it that you do?  NOTE: this is not a repeat of Getting non-programmers to understand the development process, because that question was about managing client expectations.  ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "away": 0.15016673945350925,
                    "client": 0.1551187880032456,
                    "comes": 0.1551187880032456,
                    "course": 0.14209333198303367,
                    "create": 0.13564684061788687,
                    "day": 0.13564684061788687,
                    "development": 0.09939520215638732,
                    "expectations": 0.16814424402345754,
                    "explaining": 0.16814424402345754,
                    "feel": 0.1278995753119552,
                    "getting": 0.1302802737067919,
                    "happens": 0.16097581829282284,
                    "head": 0.16097581829282284,
                    "life": 0.14587707988190346,
                    "like": 0.06995961228419856,
                    "live": 0.1551187880032456,
                    "lot": 0.10680071182126767,
                    "non": 0.35426781930988116,
                    "note": 0.1551187880032456,
                    "office": 0.16814424402345754,
                    "people": 0.08700590013752593,
                    "play": 0.15016673945350925,
                    "pretty": 0.12166236629794139,
                    "process": 0.12166236629794139,
                    "programmers": 0.4180204483660393,
                    "programming": 0.24506638182076015,
                    "question": 0.10035422045612089,
                    "repeat": 0.16097581829282284,
                    "shows": 0.16814424402345754,
                    "sort": 0.16814424402345754,
                    "talk": 0.1551187880032456,
                    "understand": 0.22116891944027492,
                    "work": 0.08765490660045286,
                    "world": 0.1164414900097147
                },
                "Max term": "programmers",
                "Max score": 0.4180204483660393
            }
        ],
        "Best Answer": "I don't even try. If they aren't tech oriented enough to have at least a basic understanding of programming, I am only going to bore them with the details. Usually I just go with something very high level like \"I create web sites\" or \"I write computer programs to do X\" ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "basic": 0.2909227573948823,
                "computer": 0.24433852887083451,
                "create": 0.2544034376005702,
                "details": 0.26649372703366947,
                "going": 0.22473202379440865,
                "high": 0.2816352710923689,
                "level": 0.24433852887083451,
                "like": 0.1312081120152259,
                "oriented": 0.26649372703366947,
                "programming": 0.15320600094466716,
                "programs": 0.26649372703366947,
                "sites": 0.2735900845168343,
                "try": 0.20493985015144017,
                "understanding": 0.3019075221930285,
                "usually": 0.23182838127757346,
                "web": 0.22473202379440865,
                "write": 0.18821270400009657
            },
            "Max term": "understanding",
            "Max score": 0.3019075221930285
        }
    },
    {
        "ID:": "1474",
        "Question": "I've read Peopleware in 2009. It was one of the best book I ever read. But this book is a little old. I'd like to know, in your opinion, what is and what is not relevant in this book? ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "best": 0.19137644011414312,
                    "book": 0.6875506257750952,
                    "know": 0.15946789050415588,
                    "like": 0.12536078947789808,
                    "little": 0.254617367011359,
                    "old": 0.23344952083116272,
                    "opinion": 0.27795771148568393,
                    "read": 0.4429937822284538,
                    "relevant": 0.23805712906279297
                },
                "Max term": "book",
                "Max score": 0.6875506257750952
            }
        ],
        "Best Answer": "It's been a while since I read it, but I don't remember anything in the book that wasn't relevant to someone. What stood out the most was the discussion of process improvement using CMM and CMMI, and no mention of agile processes (although the second edition was printed in 1999, which is a few years before the Manifesto for Agile Software Development and agile development went mainstream). But the book is about people, and people haven't changed that much since the first printing of the book in 1987. ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "agile": 0.5853636515339705,
                "book": 0.48264793322575256,
                "development": 0.25005498142495663,
                "mainstream": 0.2024886733956519,
                "mention": 0.2024886733956519,
                "people": 0.2188864077012452,
                "process": 0.1530369680061716,
                "read": 0.15548675647221488,
                "relevant": 0.1671117398842969,
                "remember": 0.1787367232963789,
                "second": 0.19512121717799016,
                "software": 0.12385612945094142,
                "using": 0.12385612945094142,
                "went": 0.18349623376590815,
                "years": 0.14854243641393494
            },
            "Max term": "agile",
            "Max score": 0.5853636515339705
        }
    },
    {
        "ID:": "1483",
        "Question": "I've heard it said (by coworkers) that everyone \"codes in English\" regardless of where they're from. I find that difficult to believe, however I wouldn't be surprised if, for most programming languages, the supported character set is relatively narrow. Have you ever worked in a country where English is not the primary language? If so, what did their code look like? ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "believe": 0.26848485489709867,
                    "character": 0.2773386799262489,
                    "code": 0.12440982634191411,
                    "difficult": 0.2608153228034283,
                    "english": 0.5546773598524978,
                    "heard": 0.25405031605631323,
                    "language": 0.1603479783009524,
                    "languages": 0.19537057882390166,
                    "like": 0.12508160209868224,
                    "look": 0.21423859506355705,
                    "primary": 0.3006270437961845,
                    "programming": 0.14605234200052675,
                    "said": 0.22471044744010746,
                    "set": 0.2210036018106721,
                    "worked": 0.2425245593869898
                },
                "Max term": "english",
                "Max score": 0.5546773598524978
            }
        ],
        "Best Answer": "I'm Italian and always use English, for names and comments. But many other Italian programmers use Italian language, or more often a strange English-Italian mix (something like IsUtenteCopy). A real life code sample: // Trovo la foto collegata al verbale tblVerbali rsVerbale; hr = rsVerbale.OpenByID(GetDBConn(), m_idVerbale); if( FAILED(hr) )     throw CErrorHR(hr); hr = rsVerbale.MoveFirst(); if( S_OK != hr )     throw CError(_T(\"Record del verbale non trovato.\"));   By the way, the Visual Studio MFC wizard creates a skeleton application with localized comments: BOOL CMainFrame::PreCreateWindow(CREATESTRUCT& cs) {     if( !CMDIFrameWndEx::PreCreateWindow(cs) )         return FALSE;     // TODO: modificare la classe o gli stili Window modificando      //  la struttura CREATESTRUCT      return TRUE; }  ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "application": 0.1492643605322437,
                "code": 0.08402556800301238,
                "comments": 0.33499349041978016,
                "english": 0.3746253940739995,
                "failed": 0.18731269703699974,
                "false": 0.20304150286825517,
                "language": 0.10829795644793869,
                "life": 0.17615293170024943,
                "like": 0.08447928087435717,
                "names": 0.20304150286825517,
                "non": 0.14259794394250916,
                "programmers": 0.1261944774839596,
                "real": 0.1492643605322437,
                "record": 0.20304150286825517,
                "return": 0.34316778241148865,
                "sample": 0.19438531637789583,
                "studio": 0.18731269703699974,
                "throw": 0.38877063275579166,
                "true": 0.17158389120574433,
                "use": 0.18402196518858605,
                "visual": 0.18133288258866953,
                "way": 0.11371960287387863
            },
            "Max term": "throw",
            "Max score": 0.38877063275579166
        }
    },
    {
        "ID:": "1516",
        "Question": "A few years ago I considered myself somewhat of a web developer, knowing the basic 3 languages (HTML, CSS, JS) and lots of PHP. Moving on from simple text to actual websites was a pain because of the so called \"standards\" out there, which at the time were ridiculously complicated for me. It pretty much boiled down to this (minus the IE related stuff):  Standards are there to replace old ways of doing things in a simpler way. However when trying to actually implement some of the stuff (Entirely CSS based layout for example), it took me 10x longer to actually do it then if I did the simpler and still working solution. If it rendered the same, then why should I use the more complicated example that takes 10x longer and breaks once you change browsers? This sparked many long religious debates in ##php, ##css, and ##js in Freenode IRC and actually got me banned from ##css because I messed with their little world over there. My question: Should I follow every single standard and coding conventions even if they take me 10x longer but get me the same result as the simple one?  For the poll tag, those of you who have websites of any size (huge or small), do you follow all the standards?  ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "actual": 0.0978846032862987,
                    "actually": 0.22043420791995785,
                    "ago": 0.09475971226577774,
                    "based": 0.08221075649168243,
                    "basic": 0.0978846032862987,
                    "breaks": 0.10158056490198066,
                    "browsers": 0.10610405633627287,
                    "called": 0.10158056490198066,
                    "change": 0.07347806930665261,
                    "coding": 0.06978210769097065,
                    "complicated": 0.1957692065725974,
                    "considered": 0.09475971226577774,
                    "css": 0.4244162253450915,
                    "developer": 0.0715459732213903,
                    "entirely": 0.10158056490198066,
                    "example": 0.12918782387216426,
                    "follow": 0.179330300472649,
                    "got": 0.08752931710431663,
                    "html": 0.0978846032862987,
                    "huge": 0.10158056490198066,
                    "implement": 0.09475971226577774,
                    "knowing": 0.10158056490198066,
                    "languages": 0.06895457787236038,
                    "little": 0.0896651502363245,
                    "long": 0.06895457787236038,
                    "longer": 0.304741694705942,
                    "lots": 0.09205280853860885,
                    "moving": 0.0978846032862987,
                    "old": 0.08221075649168243,
                    "php": 0.16766671097726935,
                    "pretty": 0.07677259868544857,
                    "question": 0.06332652017141611,
                    "related": 0.09205280853860885,
                    "replace": 0.10158056490198066,
                    "result": 0.09205280853860885,
                    "simple": 0.16766671097726935,
                    "simpler": 0.21220811267254575,
                    "single": 0.09205280853860885,
                    "size": 0.09475971226577774,
                    "small": 0.07800156074094484,
                    "solution": 0.0896651502363245,
                    "somewhat": 0.0978846032862987,
                    "standard": 0.08070846446811375,
                    "standards": 0.26258795131294993,
                    "stuff": 0.16442151298336485,
                    "takes": 0.08221075649168243,
                    "text": 0.0978846032862987,
                    "things": 0.05796076124755118,
                    "time": 0.05450189783781037,
                    "took": 0.10158056490198066,
                    "trying": 0.0756139024386605,
                    "use": 0.04808247743849349,
                    "way": 0.0594268215089886,
                    "ways": 0.0855972210190543,
                    "web": 0.0756139024386605,
                    "websites": 0.21220811267254575,
                    "working": 0.06978210769097065,
                    "world": 0.07347806930665261,
                    "years": 0.07451786981369035
                },
                "Max term": "css",
                "Max score": 0.4244162253450915
            }
        ],
        "Best Answer": "Product first, then polish. Get your site/application/game doing what it's supposed to do. Get it up and running, and get people interested. Then, when you have the time, go back and polish it up. But only because you care, not because anybody else does. Of course, if the non-compliance issues mean people can't view it, or it's unreadably ugly, or it takes a month to load, or it's hard to maintain, or it crashes the browser, this is a major problem. But it would still be a major problem even if you were standards-compliant. Ordinary users do not look at the source for a website that isn't loading and go, \"Well, it's not displaying the pictures, but it's completely W3C-compliant\". They simply browse to another website and never return. Bottom line, standards are there to make writing browsers easier, and to close up potential security holes. Amazon, Penny-Arcade and Stack Overflow do not make their money from running a standard-compliant website. And unless you're in a website-writing competition, neither will you. ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "anybody": 0.135058342229071,
                "application": 0.0992870758075888,
                "browsers": 0.135058342229071,
                "care": 0.12930045440368299,
                "close": 0.12459591749913453,
                "completely": 0.11413349276919804,
                "course": 0.11413349276919804,
                "easier": 0.1171727090183299,
                "game": 0.11141482119294188,
                "hard": 0.10464490113342345,
                "interested": 0.11141482119294188,
                "issues": 0.12459591749913453,
                "line": 0.10273265501152112,
                "load": 0.12930045440368299,
                "look": 0.09624785955845695,
                "maintain": 0.135058342229071,
                "major": 0.24919183499826905,
                "make": 0.15128710954291935,
                "mean": 0.11141482119294188,
                "money": 0.12061828822226221,
                "month": 0.12930045440368299,
                "non": 0.09485273523928575,
                "ordinary": 0.135058342229071,
                "overflow": 0.1171727090183299,
                "people": 0.13977133389214333,
                "potential": 0.12061828822226221,
                "problem": 0.16969404360156004,
                "product": 0.10895548360196611,
                "return": 0.11413349276919804,
                "running": 0.24919183499826905,
                "security": 0.12061828822226221,
                "simply": 0.1171727090183299,
                "site": 0.11413349276919804,
                "source": 0.10273265501152112,
                "stack": 0.1171727090183299,
                "standard": 0.10273265501152112,
                "standards": 0.22282964238588376,
                "supposed": 0.1171727090183299,
                "takes": 0.10464490113342345,
                "time": 0.06937468956873838,
                "unless": 0.135058342229071,
                "users": 0.10273265501152112,
                "view": 0.135058342229071,
                "website": 0.4686908360733196,
                "writing": 0.1845404605631693
            },
            "Max term": "website",
            "Max score": 0.4686908360733196
        }
    },
    {
        "ID:": "1533",
        "Question": "If you're developer (Senior or Lead Developer) and you'd rather stay with code/design than pursue a management career, what are the available career paths at your company, or any you've heard of? How far can you go? Is it possible to continue being a geek until you bite the dust or is that too naive? Are people like Uncle Bob for example still considered developers, as they claim? ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "available": 0.22506109125390547,
                    "career": 0.405159307462179,
                    "claim": 0.2663230323327266,
                    "code": 0.1102136447372637,
                    "company": 0.19270056195752017,
                    "considered": 0.237848530819751,
                    "design": 0.1710815558282686,
                    "developer": 0.3591632817340797,
                    "developers": 0.1870411531568642,
                    "example": 0.16213184576591447,
                    "far": 0.21485051795570134,
                    "heard": 0.22506109125390547,
                    "lead": 0.24569206179331604,
                    "like": 0.11080876537022777,
                    "management": 0.2025796537310895,
                    "people": 0.1378083162468033,
                    "possible": 0.18443123574543416,
                    "senior": 0.25496898992275724,
                    "stay": 0.24569206179331604
                },
                "Max term": "career",
                "Max score": 0.405159307462179
            }
        ],
        "Best Answer": "At my company, the management and individual contributor tracks are separate and mostly parallel.  Individual contributors can rise very high in the company (up to Technical Fellow) without being a people manager.  It helps to partially avoid the Peter Principle, though never completely. ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "avoid": 0.2767882262309303,
                "company": 0.4965056379237844,
                "completely": 0.28994233215956267,
                "helps": 0.3284721635121345,
                "high": 0.30641617057123155,
                "management": 0.26097988294478014,
                "manager": 0.31652085659301743,
                "people": 0.1775360831184423,
                "principle": 0.34309938102647225,
                "technical": 0.27108456896656596
            },
            "Max term": "company",
            "Max score": 0.4965056379237844
        }
    },
    {
        "ID:": "1588",
        "Question": "Use of desktops are decreasing day by day in daily life but for coding purpose are there any reasons for using desktop over laptop?  ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "coding": 0.24219747810454845,
                    "daily": 0.33973470916346826,
                    "day": 0.5941761219188599,
                    "desktop": 0.31949390493082985,
                    "life": 0.31949390493082985,
                    "purpose": 0.31949390493082985,
                    "reasons": 0.3037939174431366,
                    "use": 0.1668831045945724,
                    "using": 0.2156517201240323
                },
                "Max term": "day",
                "Max score": 0.5941761219188599
            }
        ],
        "Best Answer": "Assuming you have an external monitor and keyboard to connect to your laptop the difference is small.  It is always better to work in a desktop like setting (bigger screen realestate, more ergonomic environment), but you can't take your work with you without a laptop. So if portability is important, get a laptop and a good external screen and keyboard to connect it to. Otherwise you might as well stay with a desktop.  ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "assuming": 0.22919203110490904,
                "better": 0.14722920853455024,
                "bigger": 0.21942097969264868,
                "desktop": 0.397680746361109,
                "difference": 0.2114374493844455,
                "environment": 0.18906932176829414,
                "good": 0.12519921531191847,
                "important": 0.16333120973962748,
                "keyboard": 0.4093749413741454,
                "like": 0.09535970575650814,
                "monitor": 0.2114374493844455,
                "screen": 0.43884195938529735,
                "setting": 0.22919203110490904,
                "small": 0.1684887152562,
                "stay": 0.2114374493844455,
                "work": 0.23895918884105471
            },
            "Max term": "screen",
            "Max score": 0.43884195938529735
        }
    },
    {
        "ID:": "1620",
        "Question": "I am excited about the changes in PHP 6 previewed in PHP 5.3+. However, I wonder why it takes so long to release PHP 6? Books about it have been published since 2008, and announcements on it since 2007, but I am yet to hear about an alpha or a beta. Why does it take so long to release it? Or is that the way it goes with all languages when they transition to a major release where I guess it takes around 4-5 years to release? ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "alpha": 0.1781373537789131,
                    "beta": 0.1781373537789131,
                    "books": 0.1437085722230807,
                    "changes": 0.1469523547490233,
                    "goes": 0.15909141432235857,
                    "guess": 0.17054289583102292,
                    "languages": 0.11576735571913344,
                    "long": 0.23153471143826687,
                    "major": 0.16433777187422144,
                    "php": 0.42224169237666537,
                    "published": 0.1781373537789131,
                    "release": 0.6363656572894343,
                    "takes": 0.2760461215012836,
                    "way": 0.09977127258502401,
                    "wonder": 0.17054289583102292,
                    "years": 0.12510752742366493
                },
                "Max term": "release",
                "Max score": 0.6363656572894343
            }
        ],
        "Best Answer": "The release timetable is not unusual for languages, and it's not even that unusual for PHP: 5.0 was released in 2004, but 4.0 was released in 2000.  Compare this to the last stable releases for C (2000), Fortran (2003), or C++ (2003). One other thing to keep in mind is that 5.3 was a major release in all but name. It adds a lot of stuff that was originally destined for PHP 6. Due to development problems with unicode support (a major part of PHP 6), it was decided to release what was stable at the time as a 5.x branch. ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "development": 0.10802653720712604,
                "languages": 0.11876217853561798,
                "lot": 0.11607513057979439,
                "major": 0.3371781566959684,
                "mind": 0.17495472464452047,
                "originally": 0.1685890783479842,
                "php": 0.43316479800126495,
                "problems": 0.14438826600042165,
                "release": 0.4896210032751022,
                "released": 0.36549129211659565,
                "stable": 0.36549129211659565,
                "stuff": 0.1415936235312231,
                "support": 0.15854483371073527,
                "thing": 0.13659734458664427,
                "time": 0.09386996949681242
            },
            "Max term": "release",
            "Max score": 0.4896210032751022
        }
    },
    {
        "ID:": "1674",
        "Question": "i wonder apart from those very simple hello world apps, what other programs should i try developing for learning. i am entering uni next year and wonder what kind of programs will be developed in that environment.  this is not really a language specific thing, but if you want to know what i use currently mainly  windows: C#/WPF - i studied java/vb etc in poly but i think C# is the way to go, maybe even F# web: PHP/MySQL, Zend Framework/Doctrine, + HTML/CSS/JS(jQuery) of course. looking to try google app engine with python too.   for now, i am thinking of   todo lists apps that integrate with api eg. twitter/tumblr which i use text editor - i am currently trying to develop a text editor that uses markdown and generates html files for viewing (link to blog entry). not very pratical after i started developing it. cos when editing theres no formatting and in HTML format, i cannot edit directly  blog software (for web)  ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "apart": 0.12141015555894524,
                    "app": 0.10230669547235573,
                    "apps": 0.20923191391695287,
                    "blog": 0.22651560203490545,
                    "course": 0.1071687270976782,
                    "css": 0.12681667991955417,
                    "currently": 0.2339854070172324,
                    "develop": 0.11325780101745272,
                    "developing": 0.22004496263817072,
                    "directly": 0.12681667991955417,
                    "edit": 0.10230669547235573,
                    "engine": 0.12141015555894524,
                    "environment": 0.10461595695847643,
                    "files": 0.1071687270976782,
                    "format": 0.1169927035086162,
                    "framework": 0.09646360241698393,
                    "google": 0.11002248131908536,
                    "hello": 0.12681667991955417,
                    "html": 0.35097811052584854,
                    "java": 0.08663962600604595,
                    "kind": 0.11002248131908536,
                    "know": 0.06712020880146753,
                    "language": 0.06764128064847633,
                    "learning": 0.08906453881932457,
                    "lists": 0.12141015555894524,
                    "looking": 0.09825915758496745,
                    "maybe": 0.1071687270976782,
                    "php": 0.10019850490814737,
                    "programs": 0.2143374541953564,
                    "python": 0.10230669547235573,
                    "really": 0.07291648269823854,
                    "simple": 0.10019850490814737,
                    "software": 0.07426287945590619,
                    "specific": 0.10019850490814737,
                    "started": 0.10230669547235573,
                    "text": 0.2339854070172324,
                    "thing": 0.09479198054753844,
                    "think": 0.0661105249144137,
                    "thinking": 0.1071687270976782,
                    "try": 0.16483046799479734,
                    "trying": 0.09037452849720941,
                    "twitter": 0.12141015555894524,
                    "use": 0.11493736171087475,
                    "uses": 0.11002248131908536,
                    "vb": 0.12141015555894524,
                    "want": 0.07042928474259588,
                    "way": 0.0710275597575388,
                    "web": 0.18074905699441882,
                    "windows": 0.11002248131908536,
                    "wonder": 0.24282031111789049,
                    "world": 0.08782175835800761,
                    "wpf": 0.12681667991955417,
                    "year": 0.10230669547235573
                },
                "Max term": "html",
                "Max score": 0.35097811052584854
            }
        ],
        "Best Answer": "Have a look at Project Euler.  There's nothing else like it for sharpening your foundational programming skills. ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "euler": 0.5849772280178298,
                "like": 0.2433909070446874,
                "look": 0.4168776630743841,
                "programming": 0.284196967412233,
                "project": 0.3333670564152106,
                "skills": 0.4825702151075308
            },
            "Max term": "euler",
            "Max score": 0.5849772280178298
        }
    },
    {
        "ID:": "1701",
        "Question": "I am currently reading the recently published Being Geek by Michael \"Rands\" Lopp and I can't get enough of it.  Is there any other career guidance books aimed directly or indirectly at programmers that are worth reading? ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "books": 0.2816167163365081,
                    "career": 0.2655326010994258,
                    "currently": 0.3220424708794332,
                    "directly": 0.34908464994153804,
                    "programmers": 0.21696330245165263,
                    "published": 0.34908464994153804,
                    "reading": 0.5409503489739266,
                    "recently": 0.31176151154884174,
                    "worth": 0.256626829042706
                },
                "Max term": "reading",
                "Max score": 0.5409503489739266
            }
        ],
        "Best Answer": "Joel on Software blog contains tons of invaluable information which can help you to be successful programmer. A lot of the things can be easily reflected to non-software development professions. If you prefer to read books, there are several books which compile all the wisdom of Joel's articles. ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "articles": 0.227773363101332,
                "blog": 0.21247901476151262,
                "books": 0.3838680543360095,
                "compile": 0.227773363101332,
                "contains": 0.227773363101332,
                "development": 0.14063962967477892,
                "easily": 0.20640934418896037,
                "help": 0.16042701625767547,
                "information": 0.18434058234746098,
                "joel": 0.42495802952302525,
                "lot": 0.15111808451189543,
                "non": 0.1670908784075932,
                "prefer": 0.21247901476151262,
                "programmer": 0.1528335714371317,
                "read": 0.17490233327863106,
                "software": 0.27864400188579286,
                "successful": 0.23791635509928966,
                "things": 0.12996499409121393,
                "wisdom": 0.21948593520693468
            },
            "Max term": "joel",
            "Max score": 0.42495802952302525
        }
    },
    {
        "ID:": "1719",
        "Question": "In chapter one of \"The Pragmatic Programmer\" the first learning goal is:  Learn at least one new language every year. Different languages solve the same problems in different ways. By learning several different approaches, you can help broaden your thinking and avoid getter struck in a rut. [...]  To achieve this over a career, the list of languages is likely to get quite long (particularly if you do not want to \"progress\" into management). Clearly the education of a programmer (or whatever form) is going to get you started with a core of commercially useful languages (the usual list from job posting: C, C++, Ruby, Python, JavaScript, C#, Java, VB, ...). Additionally a formal or informal learning programme is likely to have covered functional approaches (via something like Haskell, LISP or an ML derived language) But once a reasonable subset of that list is learned- what's next, and why? ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "approaches": 0.25648086313270446,
                    "avoid": 0.11214250449846241,
                    "career": 0.10573765400239667,
                    "clearly": 0.12824043156635223,
                    "core": 0.13900888922955656,
                    "covered": 0.13900888922955656,
                    "different": 0.2887949381881929,
                    "form": 0.12824043156635223,
                    "formal": 0.12824043156635223,
                    "functional": 0.11214250449846241,
                    "goal": 0.12824043156635223,
                    "going": 0.09906317393745999,
                    "haskell": 0.12060008926386866,
                    "help": 0.09373370453277452,
                    "java": 0.09496919633919233,
                    "javascript": 0.12060008926386866,
                    "job": 0.09496919633919233,
                    "language": 0.14828868402759002,
                    "languages": 0.27101600848184354,
                    "learn": 0.09142283163497641,
                    "learned": 0.12824043156635223,
                    "learning": 0.29288172389162215,
                    "like": 0.057837293515680274,
                    "likely": 0.22428500899692483,
                    "lisp": 0.1330825793274401,
                    "list": 0.29288172389162215,
                    "long": 0.09033866949394784,
                    "management": 0.10573765400239667,
                    "new": 0.07992670422248942,
                    "particularly": 0.12824043156635223,
                    "posting": 0.1330825793274401,
                    "pragmatic": 0.13900888922955656,
                    "problems": 0.10983163160066432,
                    "programmer": 0.1785940692777971,
                    "python": 0.11214250449846241,
                    "quite": 0.10983163160066432,
                    "ruby": 0.12824043156635223,
                    "solve": 0.11214250449846241,
                    "started": 0.11214250449846241,
                    "thinking": 0.11747197390314788,
                    "useful": 0.09906317393745999,
                    "usual": 0.13900888922955656,
                    "vb": 0.1330825793274401,
                    "want": 0.07720038600214782,
                    "ways": 0.11214250449846241,
                    "year": 0.11214250449846241
                },
                "Max term": "learning",
                "Max score": 0.29288172389162215
            }
        ],
        "Best Answer": "Make it interesting and spend each year writing an interpreter or compiler for your own programming language that fills up a niche you've never used a programming language for. Each year, write your next compiler/interpreter using the language you wrote the previous year. ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "compiler": 0.45214480165400384,
                "interesting": 0.1829639666978884,
                "language": 0.37785537727418056,
                "make": 0.13225723075096635,
                "previous": 0.21089226737685302,
                "programming": 0.2294454156231329,
                "spend": 0.19955407615620033,
                "used": 0.13225723075096635,
                "using": 0.13828157433479202,
                "write": 0.14093619645634065,
                "writing": 0.16132775852042175,
                "wrote": 0.2361396471517059,
                "year": 0.5715021159383157
            },
            "Max term": "year",
            "Max score": 0.5715021159383157
        }
    },
    {
        "ID:": "1745",
        "Question": "To put it another way... What is the most commonly held and frustrating misunderstanding about programming, you have encountered? Which widespread and longstanding myths/misconceptions do you find hard for programmers to dispel/correct. Please, explain why this is a myth. ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "commonly": 0.44165659071088564,
                    "correct": 0.40023137913984147,
                    "encountered": 0.46132403208519956,
                    "explain": 0.32399217666006874,
                    "hard": 0.35743965853030324,
                    "programmers": 0.28672239102544156,
                    "programming": 0.22412306775982968,
                    "way": 0.25837863187481125
                },
                "Max term": "encountered",
                "Max score": 0.46132403208519956
            }
        ],
        "Best Answer": "That because you're a programmer, you know how to fix [person]'s virus ridden machine. ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "fix": 0.40932189159525173,
                "know": 0.2685432336958693,
                "machine": 0.48575349152675484,
                "person": 0.40088716945315894,
                "programmer": 0.32593557006515606,
                "virus": 0.5073846151596967
            },
            "Max term": "virus",
            "Max score": 0.5073846151596967
        }
    },
    {
        "ID:": "1750",
        "Question": "I work for a company that supports several languages: COBOL, VB6, C#, and Java. I use those languages for my primary work, but I often find myself coding some minor programs (e.g. scripts) in Python because I find it to be the best tool for that type of task. For example: an analyst gives me a complex CSV file to populate some DB tables, so I use Python to parse it and create a DB script. What's the problem? The main problem I see is that a few parts of these quick and dirty scripts are slowly gaining importance and:  My company does not support Python They're not version controlled (I back them up in another way) My coworkers do not know Python  The analysts have even started to reference them in emails (\"launch the script that exports...\"), so they are needed more often than I initially thought. I should add that these scripts are just utilities that are not part of the main project; they simply help to get trivial tasks done in less time. For my own small tasks they help a lot. In short, if I were a lottery winner to be in a accident, my coworkers would need to keep the project alive without those scripts; they would spend more time fixing CSV errors by hand, for example. Is this a common scenario? Am I doing something wrong? What should I do? ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "add": 0.11636425962419503,
                    "best": 0.08519354629582583,
                    "cobol": 0.12840832794437523,
                    "coding": 0.08821179304996316,
                    "common": 0.09419828560695506,
                    "company": 0.19409699165693003,
                    "complex": 0.11636425962419503,
                    "create": 0.10820373009687387,
                    "emails": 0.12840832794437523,
                    "errors": 0.11064609914626641,
                    "example": 0.1633067552853666,
                    "file": 0.1039228890912901,
                    "fixing": 0.13412648842230382,
                    "gives": 0.13412648842230382,
                    "hand": 0.12373625064618077,
                    "help": 0.18088300259753015,
                    "importance": 0.13412648842230382,
                    "initially": 0.12840832794437523,
                    "java": 0.09163359900120549,
                    "know": 0.07098906795559878,
                    "languages": 0.174331419740458,
                    "lot": 0.08519354629582583,
                    "main": 0.22129219829253283,
                    "need": 0.07643605680884626,
                    "needed": 0.11636425962419503,
                    "parse": 0.13412648842230382,
                    "primary": 0.13412648842230382,
                    "problem": 0.16852321595843953,
                    "programs": 0.1133460128700577,
                    "project": 0.1528721136176925,
                    "python": 0.43281492038749547,
                    "short": 0.11978606557543735,
                    "simply": 0.11636425962419503,
                    "slowly": 0.12840832794437523,
                    "small": 0.09860203082608622,
                    "spend": 0.1133460128700577,
                    "started": 0.10820373009687387,
                    "support": 0.11636425962419503,
                    "task": 0.1039228890912901,
                    "tasks": 0.21640746019374774,
                    "thought": 0.12373625064618077,
                    "time": 0.13779205850846632,
                    "tool": 0.11064609914626641,
                    "trivial": 0.12373625064618077,
                    "type": 0.10597402184807196,
                    "use": 0.12156243740636469,
                    "version": 0.12840832794437523,
                    "way": 0.0751216415500488,
                    "work": 0.13984237026470658,
                    "wrong": 0.10820373009687387
                },
                "Max term": "python",
                "Max score": 0.43281492038749547
            }
        ],
        "Best Answer": "You need to get the situation formalised as it shouldn't really have got to this point. However, these things happen so you need to explain to your boss that you created these scripts for personal use, but they've \"escaped\" into wider circulation. Admit (if necessary) that you were at fault for not bringing this to his attention sooner. At the very least the scripts should be put under source control \"just in case\" - then at least if you aren't available (for what ever reason) your co-workers will have access to the scripts. Then you either need to convince your boss that Python is the way to go for these or accept that you are going to have to re-write them in a supported language. If the cost of documenting the scripts and educating your co-workers in Python is lower than that of the re-write you might even win the argument. ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "accept": 0.17787862108741603,
                "access": 0.14989004696396688,
                "attention": 0.18579974674377622,
                "available": 0.1570134336132483,
                "boss": 0.37159949348755245,
                "case": 0.1468013265120042,
                "control": 0.17140659017851226,
                "convince": 0.18579974674377622,
                "cost": 0.16119448307726816,
                "created": 0.18579974674377622,
                "explain": 0.13048889757229898,
                "going": 0.13240816994674026,
                "got": 0.153273357420908,
                "happen": 0.153273357420908,
                "language": 0.09910157576971658,
                "lower": 0.18579974674377622,
                "necessary": 0.17140659017851226,
                "need": 0.3176509017173728,
                "personal": 0.14989004696396688,
                "point": 0.13240816994674026,
                "python": 0.29978009392793376,
                "really": 0.10683030045711425,
                "reason": 0.13888020085564404,
                "situation": 0.1570134336132483,
                "source": 0.14132930234758775,
                "things": 0.10149559906306758,
                "use": 0.08419764935821152,
                "way": 0.10406283008789191,
                "wider": 0.18579974674377622,
                "win": 0.17140659017851226,
                "write": 0.2217832534643898
            },
            "Max term": "boss",
            "Max score": 0.37159949348755245
        }
    },
    {
        "ID:": "1752",
        "Question": "In fact this question is about cautions to be taken to enhance quality user experience and reduce avoidable support calls. ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "calls": 0.3671881638690882,
                    "experience": 0.27374457487523596,
                    "fact": 0.32484919104142723,
                    "quality": 0.3316840634776183,
                    "question": 0.24538644229673054,
                    "reduce": 0.4111468122223151,
                    "support": 0.3566990753568545,
                    "taken": 0.3671881638690882,
                    "user": 0.28875224647770975
                },
                "Max term": "reduce",
                "Max score": 0.4111468122223151
            }
        ],
        "Best Answer": "A lack of proper input validation is one of those things which tends to lead quite quickly to users doing \"bad\" things with your application, when it should really be handled by the programmer. I've seen legacy apps where users have been trained to:  not enter apostrophes in names not enter any symbol other than a-z0-9, ensure there are no spaces before or after the text they've entered check that a correctly formatted email address is being entered in to the email field, otherwise subsequent mailings to that user will use whatever's in the field and will fail make sure \"http://\" is put before web addresses  etc etc All of the above issues are ones which should be handled by an application developer. When your input validation is essentially \"make sure the user knows what format this field should be in and trust what they've entered is right\", then unexpected things are bound to find their way in to the app. Aside from the obvious security implications, users make mistakes. As programmers we often produce our best products by bending over backwards to make sure that the user can't get it wrong, no matter how hard they try! ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "app": 0.09431907501070025,
                "application": 0.1718989231400202,
                "apps": 0.09644804033719341,
                "bad": 0.08893218288560928,
                "best": 0.07426154788110871,
                "check": 0.09237548194433885,
                "correctly": 0.1078584693502827,
                "developer": 0.07883608760475642,
                "email": 0.2157169387005654,
                "essentially": 0.11193102774313725,
                "fail": 0.11193102774313725,
                "field": 0.3235754080508481,
                "format": 0.1078584693502827,
                "handled": 0.23383087276379555,
                "hard": 0.09058754964135256,
                "http": 0.1044151702915531,
                "input": 0.2157169387005654,
                "issues": 0.1078584693502827,
                "knows": 0.1044151702915531,
                "lack": 0.1078584693502827,
                "lead": 0.1078584693502827,
                "legacy": 0.11691543638189777,
                "make": 0.26192826210122294,
                "matter": 0.1044151702915531,
                "mistakes": 0.11691543638189777,
                "names": 0.11691543638189777,
                "obvious": 0.1078584693502827,
                "ones": 0.10143244897595394,
                "produce": 0.1078584693502827,
                "products": 0.11691543638189777,
                "programmer": 0.0751045622354087,
                "programmers": 0.07266535262791073,
                "proper": 0.11193102774313725,
                "quickly": 0.10143244897595394,
                "quite": 0.09237548194433885,
                "really": 0.06722351034190067,
                "right": 0.08459527550044302,
                "security": 0.1044151702915531,
                "seen": 0.08459527550044302,
                "spaces": 0.11691543638189777,
                "sure": 0.262173219916735,
                "text": 0.1078584693502827,
                "things": 0.19159986700624781,
                "trust": 0.11691543638189777,
                "try": 0.07598064429248905,
                "unexpected": 0.11691543638189777,
                "use": 0.05298179943496108,
                "user": 0.2463324090053283,
                "users": 0.26679654865682784,
                "way": 0.06548206552530574,
                "web": 0.08331851491272378,
                "wrong": 0.09431907501070025
            },
            "Max term": "field",
            "Max score": 0.3235754080508481
        }
    },
    {
        "ID:": "1785",
        "Question": "Please, stay on technical issues, avoid behavior, cultural, career or political issues. ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "avoid": 0.3263938735185413,
                    "career": 0.3077523782882764,
                    "issues": 0.746494674571942,
                    "stay": 0.373247337285971,
                    "technical": 0.3196680137770043
                },
                "Max term": "issues",
                "Max score": 0.746494674571942
            }
        ],
        "Best Answer": " The bug is in your code, not the compiler or the runtime libraries. If you see a bug that cannot possibly happen, check that you have correctly built and deployed your program.  (Especially if you are using a complicated IDE or build framework that tries to hide the messy details from you ... or if your build involves lots of manual steps.) Concurrent / multi-threaded programs are hard to write and harder to properly test.  It is best to delegate as much as you can to concurrency libraries and frameworks. Writing the documentation is part of your job as a programmer.  Don't leave it for \"someone else\" to do.  EDIT Yes, my point #1 is overstated.  Even the best engineered application platforms do have their share of bugs, and some of the less well engineered ones are rife with them.  But even so, you should always suspect your code first, and only start blaming compiler / library bugs when you have clear evidence that your code is not at fault.   Back in the days when I did C / C++ development, I remember cases where supposed optimizer \"bugs\" turned out to be a due to me / some other programmer having done things that the language spec says have undefined results.  This applies even for supposedly safe languages like Java; e.g. take a long hard look at the Java memory model (JLS chapter 17). ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "application": 0.09507854194849749,
                "best": 0.16429840435063287,
                "bug": 0.21338444433606343,
                "bugs": 0.3130113894655533,
                "build": 0.23101115393348645,
                "built": 0.11931460436512865,
                "cases": 0.10669222216803172,
                "check": 0.10218709896051374,
                "clear": 0.11931460436512865,
                "code": 0.16056803774793188,
                "compiler": 0.24763945514529329,
                "complicated": 0.11931460436512865,
                "concurrency": 0.12933355275772732,
                "concurrent": 0.12933355275772732,
                "correctly": 0.11931460436512865,
                "days": 0.10929565597252999,
                "details": 0.10929565597252999,
                "development": 0.0764530162576644,
                "documentation": 0.1122060473531124,
                "edit": 0.1043371298218511,
                "especially": 0.10669222216803172,
                "evidence": 0.11931460436512865,
                "framework": 0.09837807156212834,
                "frameworks": 0.10929565597252999,
                "happen": 0.10669222216803172,
                "hard": 0.2004185245900878,
                "ide": 0.1122060473531124,
                "java": 0.17671824633905936,
                "job": 0.08835912316952968,
                "language": 0.06898372631186533,
                "languages": 0.08405089157833612,
                "leave": 0.10929565597252999,
                "libraries": 0.2386292087302573,
                "library": 0.1043371298218511,
                "like": 0.053811685667968824,
                "long": 0.08405089157833612,
                "look": 0.0921681505679151,
                "lots": 0.1122060473531124,
                "model": 0.10929565597252999,
                "ones": 0.1122060473531124,
                "point": 0.0921681505679151,
                "possibly": 0.10929565597252999,
                "program": 0.1002092622950439,
                "programmer": 0.16616351378085797,
                "programs": 0.10929565597252999,
                "properly": 0.12381972757264664,
                "remember": 0.10929565597252999,
                "runtime": 0.11931460436512865,
                "share": 0.11931460436512865,
                "start": 0.08835912316952968,
                "steps": 0.1122060473531124,
                "supposed": 0.1122060473531124,
                "suspect": 0.12933355275772732,
                "test": 0.08720962441723619,
                "things": 0.07065018465392554,
                "using": 0.07573674097243274,
                "write": 0.07719067602463754,
                "writing": 0.08835912316952968,
                "yes": 0.09667327377543306
            },
            "Max term": "bugs",
            "Max score": 0.3130113894655533
        }
    },
    {
        "ID:": "1849",
        "Question": "If you've always loved unit testing, good for you! But for the unfortunate ones who weren't born with a liking for it, how have you managed to make this task more enjoyable ?  This is not a \"what is the right way to unit test\" question. I simply want to know little personal tricks that reduce the boredom (dare I say) of writing unit tests. ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "good": 0.13570292536975076,
                    "know": 0.13148131411820643,
                    "little": 0.2099320804089943,
                    "make": 0.13913539695851557,
                    "managed": 0.22917620004808795,
                    "ones": 0.21552227987203273,
                    "personal": 0.2004078801897646,
                    "question": 0.14826572073552216,
                    "reduce": 0.24842031968718156,
                    "right": 0.17974688402308417,
                    "say": 0.14684884420793531,
                    "simply": 0.21552227987203273,
                    "task": 0.19247918613651543,
                    "test": 0.16750984037461578,
                    "testing": 0.18568735694971963,
                    "tests": 0.19247918613651543,
                    "tricks": 0.22917620004808795,
                    "unit": 0.5668856565036758,
                    "want": 0.13796344015782303,
                    "way": 0.13913539695851557,
                    "writing": 0.16971776586213164
                },
                "Max term": "unit",
                "Max score": 0.5668856565036758
            }
        ],
        "Best Answer": "Smug superiority. I'm only half-joking.  \"Look at me, cultivating good programming habits!  This 'unit testing' stuff is something Me From Ten Years Ago never would have done -- what a fool!  And just think of all the bugs I'm going to catch as a result of this boring, tedious work I'm doing right now -- my code will be awesome!  I'll get a raise for sure!*\" * -- No, I won't. I find it's like working out or eating healthy; until the tangible benefits actually kick in (\"Holy balls, I really AM catching a crap-ton of regression errors that would have snuck into production!\"), the moral pride of knowing that you're doing The Right Thing can help carry you through. ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "actually": 0.17156571954732266,
                "ago": 0.22125674194195896,
                "benefits": 0.2371829155812336,
                "bugs": 0.19986301972765158,
                "code": 0.10252538398311821,
                "errors": 0.20437431756427812,
                "going": 0.17655272793749502,
                "good": 0.13533398200007368,
                "half": 0.24774492503675735,
                "help": 0.16705442171069612,
                "knowing": 0.2371829155812336,
                "like": 0.10307899031340854,
                "look": 0.17655272793749502,
                "production": 0.24774492503675735,
                "programming": 0.12036084998691852,
                "really": 0.14244725970967234,
                "result": 0.2149363270198019,
                "right": 0.3585163916056865,
                "stuff": 0.1919558818722012,
                "sure": 0.1851825180231247,
                "testing": 0.1851825180231247,
                "thing": 0.1851825180231247,
                "think": 0.12915136281324974,
                "unit": 0.18844814392500356,
                "work": 0.12915136281324974,
                "working": 0.16293592946169297,
                "years": 0.1739935748769325
            },
            "Max term": "right",
            "Max score": 0.3585163916056865
        }
    },
    {
        "ID:": "1877",
        "Question": "As an example, say there's an interface that contains a table/grid of information that is periodically updated.  The table is meant to represent an event that has happened, perhaps the date and time of a stock price change. The actual frequency of these events could be dozens of events per second.  This is obviously too much information for a user to process/understand, so I'm trying to find out how much information a user COULD process in a given amount of time so that we can throttle the data and come up with an alternate display. I know some studies have been done on this, but I can't seem to find an authoritative source. ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "actual": 0.18348886540609957,
                    "change": 0.137737776081845,
                    "come": 0.16407743961802254,
                    "contains": 0.1904171031542001,
                    "data": 0.137737776081845,
                    "date": 0.18348886540609957,
                    "event": 0.1904171031542001,
                    "example": 0.12108404402096844,
                    "given": 0.17255691732019832,
                    "happened": 0.18348886540609957,
                    "information": 0.46232271245096074,
                    "interface": 0.19889658085637585,
                    "know": 0.10526990649373917,
                    "meant": 0.19889658085637585,
                    "obviously": 0.17255691732019832,
                    "process": 0.28782702394713744,
                    "represent": 0.19889658085637585,
                    "say": 0.11757384843739117,
                    "second": 0.18348886540609957,
                    "source": 0.15129146031892418,
                    "time": 0.20433226597422982,
                    "trying": 0.1417414864196458,
                    "understand": 0.1308095383337445,
                    "updated": 0.18348886540609957,
                    "user": 0.2793738529971112
                },
                "Max term": "information",
                "Max score": 0.46232271245096074
            }
        ],
        "Best Answer": "This depends on a lot of factors:  Is the table as a whole updating (eg, every row changes), or is it just one row at a time? If it's a row at a time, is it an arbitrary row that a user has to jump their eyes to, or is it always a new row at the top? The former would require more spacing between updates than the latter. How much data is on each row? Is most of it unimportant, and only the outliers are important to the user (in which case they're probably skimming the data, so you can put it out a lot faster)?  Or does all the data need to be read and mentally processed.  My (admittedly minimal- a couple college classes worth) experience with calculating user experience metrics (like data processed per second) has lead me to believe that the field is pretty immature, and that you're better off doing empirical measurement.  If you really want to try to optimize a specific UI, nothing beats usability testing. ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "believe": 0.15125359661518228,
                "better": 0.10879487270475047,
                "case": 0.1338131599472418,
                "changes": 0.13971258148363927,
                "classes": 0.15624148645341449,
                "college": 0.16214090798981198,
                "couple": 0.15624148645341449,
                "data": 0.4691370199098662,
                "depends": 0.14693288990728318,
                "experience": 0.22552388980890667,
                "eyes": 0.16214090798981198,
                "factors": 0.1693612164134559,
                "faster": 0.15125359661518228,
                "field": 0.15624148645341449,
                "important": 0.12069342998720042,
                "lead": 0.15624148645341449,
                "like": 0.070465956804401,
                "lot": 0.21514740005431807,
                "need": 0.09651563767356151,
                "new": 0.0973785484227949,
                "pretty": 0.1225429182403903,
                "probably": 0.12450456340111046,
                "read": 0.12450456340111046,
                "really": 0.0973785484227949,
                "require": 0.12882527010900963,
                "second": 0.15624148645341449,
                "specific": 0.1338131599472418,
                "testing": 0.1265928515235979,
                "time": 0.17398972354835246,
                "try": 0.11006394655382264,
                "ui": 0.15624148645341449,
                "user": 0.35683189253920267,
                "want": 0.09405694379242681,
                "worth": 0.12450456340111046
            },
            "Max term": "data",
            "Max score": 0.4691370199098662
        }
    },
    {
        "ID:": "1885",
        "Question": "As programmers I think we are the most inclined to use new technologies and things that are not so mainstream. I absolutely love OpenId's ability to log in with credentials you already have, but I always use a provider that I already use and that is the fastest to log in, like google. God knows I'd never used it if i had to type in the whole \"https://www.google.com/accounts/o8/id\" I like to click on the google button and then just say yes (the first time, then its just clicking the button). Does any of you ever uses the Generic \"Enter your own provider\" OpenId? Do you think its worth to even offer it to more casual end users? ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "ability": 0.19644949693666383,
                    "absolutely": 0.20386710681320683,
                    "com": 0.19017799714657208,
                    "end": 0.15407876094838127,
                    "google": 0.5542361307668904,
                    "knows": 0.19017799714657208,
                    "like": 0.17720007764407358,
                    "love": 0.21294552759471497,
                    "mainstream": 0.20386710681320683,
                    "new": 0.12243845910787898,
                    "programmers": 0.13235003291320982,
                    "say": 0.1258786102759631,
                    "technologies": 0.19644949693666383,
                    "things": 0.11632434526851992,
                    "think": 0.22202033070718583,
                    "time": 0.10938257961791197,
                    "type": 0.16824934626424567,
                    "use": 0.2894973730434283,
                    "used": 0.1192666547959523,
                    "users": 0.16197784647415395,
                    "uses": 0.1847453769222968,
                    "worth": 0.15654522624987863,
                    "yes": 0.1591709254827375
                },
                "Max term": "google",
                "Max score": 0.5542361307668904
            }
        ],
        "Best Answer": "Yes. I set up delegation on my own site, so I just use one of my own URLs. Easy to remember, and doesn't tie me to a provider. ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "easy": 0.41200093083823347,
                "remember": 0.4657948390354485,
                "set": 0.4052045229844862,
                "site": 0.4657948390354485,
                "use": 0.24978009605581994,
                "yes": 0.41200093083823347
            },
            "Max term": "remember",
            "Max score": 0.4657948390354485
        }
    },
    {
        "ID:": "1890",
        "Question": "What is the best practice, most commonly accepted naming conventions for private variables in C#?  private int myInteger; private int MyInteger; private int mMyInteger; private int _myInteger; private int _MyInteger; Mysterious other option  Which do you use and why?  (My company is fairly new to C# and I would like to pick the most \"industry accepted\" method to try and get into our coding standard.) ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "accepted": 0.3201819632616442,
                    "best": 0.10168549565069855,
                    "coding": 0.10528802108290496,
                    "commonly": 0.1532658873873055,
                    "company": 0.11583535173198597,
                    "fairly": 0.1476893793483561,
                    "industry": 0.1532658873873055,
                    "int": 0.8004549081541106,
                    "like": 0.06660889922301823,
                    "method": 0.13889030249809653,
                    "new": 0.09204839063467656,
                    "option": 0.1600909816308221,
                    "pick": 0.14297450898205213,
                    "practice": 0.13528777706589012,
                    "standard": 0.1217738298493266,
                    "try": 0.10403943487833772,
                    "use": 0.07254737734035883,
                    "variables": 0.1600909816308221
                },
                "Max term": "int",
                "Max score": 0.8004549081541106
            }
        ],
        "Best Answer": "The MSDN class design guidlines http://msdn.microsoft.com/en-us/library/ta31s3bc.aspx recommends option 1 - myInteger.  I have always used this style. I have a personal dislike for the _ character. ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "character": 0.337174574009312,
                "class": 0.2948492976884791,
                "com": 0.3264105338712737,
                "design": 0.2347831276525845,
                "http": 0.3264105338712737,
                "library": 0.2948492976884791,
                "microsoft": 0.30150462092238933,
                "option": 0.36548740858870604,
                "personal": 0.2948492976884791,
                "style": 0.30150462092238933,
                "used": 0.20470240011510923
            },
            "Max term": "option",
            "Max score": 0.36548740858870604
        }
    },
    {
        "ID:": "1947",
        "Question": " Possible Duplicate: Really “wow” them in the interview   Let's say I appear for an interview. What questions could I expect and how do I prepare? ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "appear": 0.3681054462685711,
                    "interview": 0.6387152638159023,
                    "let": 0.31935763190795113,
                    "possible": 0.25491652654029406,
                    "prepare": 0.3524121552615339,
                    "questions": 0.2706098175473312,
                    "really": 0.2116516094018242,
                    "say": 0.21759838083798735
                },
                "Max term": "interview",
                "Max score": 0.6387152638159023
            }
        ],
        "Best Answer": "Programming Interviews Exposed is also helpful.  This classic book uncovers what   interviews are really like at   America's top software and computer   companies and provides you with the   tools to succeed in any situation. The   authors take you step-by-step through   new problems and complex brainteasers   they were asked during recent   technical interviews. 50 interview scenarios are presented   along with in-depth analysis of the   possible solutions. The   problem-solving process is clearly   illustrated so you'll be able to   easily apply what you've learned   during crunch time. You'll also find   expert tips on what questions to ask,   how to approach a problem, and how to   recover if you become stuck.  I've used it in preparing for my last round of interviews and while I didn't end up needing it, reading through it certainly made me feel more confident and prepared. The book also has a section on non-programming questions such as salary negotiation, which I found very helpful. ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "50": 0.13363987092705262,
                "able": 0.11293478796192563,
                "analysis": 0.13363987092705262,
                "apply": 0.13363987092705262,
                "approach": 0.11024466965788417,
                "ask": 0.09989212817532067,
                "asked": 0.09824429780979937,
                "authors": 0.13363987092705262,
                "book": 0.2033073785615878,
                "certainly": 0.12328732944448913,
                "clearly": 0.12328732944448913,
                "companies": 0.11935147583942049,
                "complex": 0.115942084368426,
                "computer": 0.10354585173958036,
                "easily": 0.115942084368426,
                "end": 0.09669639911353982,
                "expert": 0.1279424562165108,
                "feel": 0.1016536892807939,
                "helpful": 0.23870295167884098,
                "interview": 0.115942084368426,
                "interviews": 0.5117698248660432,
                "learned": 0.12328732944448913,
                "like": 0.05560341128574477,
                "new": 0.07683965029228564,
                "non": 0.09385652959486378,
                "possible": 0.09254688309925754,
                "prepared": 0.13363987092705262,
                "problem": 0.16791180544433454,
                "problems": 0.1055895428858625,
                "process": 0.09669639911353982,
                "programming": 0.12985136591222313,
                "provides": 0.13363987092705262,
                "questions": 0.19648859561959875,
                "reading": 0.10354585173958036,
                "really": 0.07683965029228564,
                "scenarios": 0.1279424562165108,
                "section": 0.1279424562165108,
                "situation": 0.11293478796192563,
                "software": 0.07825848801162544,
                "solving": 0.1279424562165108,
                "step": 0.24657465888897825,
                "stuck": 0.13363987092705262,
                "technical": 0.1055895428858625,
                "time": 0.06864607107234973,
                "tips": 0.11935147583942049,
                "tools": 0.10781116164349876,
                "used": 0.07484909654063093
            },
            "Max term": "interviews",
            "Max score": 0.5117698248660432
        }
    },
    {
        "ID:": "1969",
        "Question": "I'm posting this here since programmers write viruses, and AV software.  They also have the best knowledge of heuristics and how AV systems work (cloaking etc). The EICAR test file was used to functionally test an antivirus system.  As it stands today almost every AV system will flag EICAR as being a \"test\" virus.  For more information on this historic test virus please click here. Currently the EICAR test file is only good for testing the presence of an AV solution, but it doesn't check for engine file or DAT file up-to-dateness. In other words, why do a functional test of a system that could have definition files that are more than 10 years old.  With the increase of zero day threats it doesn't make much sense to functionally test your system using EICAR. That being said, I think EICAR needs to be updated/modified to be effective test that works in conjunction with an AV management solution. This question is about real world testing, without using live viruses... which is the intent of the original EICAR. That being said I'm proposing a new EICAR file format with the appendage of an XML blob that will conditionally cause the Antivirus engine to respond. X5O!P%@AP[4\\PZX54(P^)7CC)7}$EICAR-EXTENDED-ANTIVIRUS-TEST-FILE!$H+H* <?xml version=\"1.0\"?> <engine-valid-from>2010-1-1Z</engine-valid-from> <signature-valid-from>2010-1-1Z</signature-valid-from> <authkey>MyTestKeyHere</authkey>   In this sample, the antivirus engine would only alert on the EICAR file if both the signature  or engine file is equal to or newer than the valid-from date. Also there is a passcode that will protect the usage of EICAR to the system administrator. If you have a backgound in \"Test Driven Design\" TDD for software you may get that all I'm doing is applying the principals of TDD to my infrastructure.   Based on your experience and contacts how can I make this idea happen? ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "10": 0.06035172649679506,
                    "applying": 0.0714164083964598,
                    "based": 0.055334330872181425,
                    "best": 0.04536178622561822,
                    "cause": 0.061958809075115334,
                    "check": 0.05642646812528296,
                    "currently": 0.06588406744662743,
                    "date": 0.06588406744662743,
                    "day": 0.05761368891048703,
                    "definition": 0.06837174146473136,
                    "design": 0.045876731550836956,
                    "driven": 0.06035172649679506,
                    "effective": 0.06378076903352367,
                    "engine": 0.4102304487883882,
                    "equal": 0.0714164083964598,
                    "experience": 0.04754957055348427,
                    "file": 0.4426746469774514,
                    "files": 0.06035172649679506,
                    "format": 0.06588406744662743,
                    "functional": 0.05761368891048703,
                    "good": 0.03901216917764276,
                    "happen": 0.058914142143386895,
                    "idea": 0.05642646812528296,
                    "information": 0.055334330872181425,
                    "intent": 0.0714164083964598,
                    "knowledge": 0.054323169712179216,
                    "live": 0.06588406744662743,
                    "make": 0.07999788700139591,
                    "management": 0.054323169712179216,
                    "needs": 0.061958809075115334,
                    "new": 0.04106268442380072,
                    "old": 0.055334330872181425,
                    "original": 0.061958809075115334,
                    "posting": 0.06837174146473136,
                    "programmers": 0.04438676927652588,
                    "question": 0.0426237486393102,
                    "real": 0.05250120975377086,
                    "said": 0.10676360238710904,
                    "sample": 0.06837174146473136,
                    "sense": 0.058914142143386895,
                    "software": 0.08364180691821262,
                    "solution": 0.12070345299359012,
                    "systems": 0.06588406744662743,
                    "tdd": 0.12391761815023067,
                    "test": 0.4815608958914256,
                    "testing": 0.10676360238710904,
                    "think": 0.037229931027898636,
                    "updated": 0.06588406744662743,
                    "usage": 0.0714164083964598,
                    "used": 0.03999894350069796,
                    "using": 0.08364180691821262,
                    "valid": 0.35708204198229904,
                    "version": 0.06837174146473136,
                    "virus": 0.1428328167929196,
                    "words": 0.06588406744662743,
                    "work": 0.037229931027898636,
                    "works": 0.06378076903352367,
                    "world": 0.049456542822042426,
                    "write": 0.0426237486393102,
                    "xml": 0.1428328167929196,
                    "years": 0.05015641067088419
                },
                "Max term": "test",
                "Max score": 0.4815608958914256
            }
        ],
        "Best Answer": "As you said in the question, it would have to work in conjunction with an AV solution.  In order for that to happen you would either need to write an AV engine, or become involved with an existing AV vendor. If such a thing did exist... Where does the benefit come in?  Just thinking devil's advocate here..  Couldn't the AV engine just report when it's database was updated? ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "advocate": 0.25666987482697123,
                "benefit": 0.25666987482697123,
                "come": 0.21173685192254918,
                "engine": 0.49145474317424687,
                "exist": 0.25666987482697123,
                "existing": 0.22922746147248138,
                "happen": 0.21173685192254918,
                "involved": 0.22922746147248138,
                "need": 0.14627113081215526,
                "question": 0.1531893366462035,
                "report": 0.23678669544317024,
                "said": 0.19185367253874816,
                "solution": 0.21690351605936925,
                "thing": 0.19185367253874816,
                "thinking": 0.21690351605936925,
                "updated": 0.23678669544317024,
                "work": 0.1338040087888431,
                "write": 0.1531893366462035
            },
            "Max term": "engine",
            "Max score": 0.49145474317424687
        }
    },
    {
        "ID:": "1997",
        "Question": "People make mistakes, even in the real life... Which should we, geeky programmers, avoid? ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "avoid": 0.4078940461800153,
                    "life": 0.4386566770513394,
                    "make": 0.28318497245983054,
                    "mistakes": 0.5056146956626139,
                    "people": 0.26162930509087046,
                    "programmers": 0.3142499510001934,
                    "real": 0.37169865844006506
                },
                "Max term": "mistakes",
                "Max score": 0.5056146956626139
            }
        ],
        "Best Answer": "Learn that what constitutes \"An acceptable degree of precision\" to you is \"Annoying goddamn nitpicking\" to most of the world. ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "annoying": 0.48092183402376276,
                "constitutes": 0.521305247786028,
                "degree": 0.49908065143753266,
                "learn": 0.34285003040394224,
                "world": 0.36100884781771214
            },
            "Max term": "constitutes",
            "Max score": 0.521305247786028
        }
    },
    {
        "ID:": "2042",
        "Question": "I've been working in the enterprise space for the past 4½ years and have noticed that generally speaking, enterprises are not conducive environments for the test-first style of development. Projects are usually fixed-cost, fixed-timeline and waterfall style. Any unit testing, if done at all, usually comes after development in the QA phase and done by another team. Prior to working for an enterprise, I consulted for many small to medium sized companies, and none of them were willing to pay for a test-first style of development project. They usually wanted development started immediately, or after a short design stint: i.e., something more akin to Agile, though some clients wanted everything mapped out similar to waterfall. With what types of shops, companies, and clients does test-driven development work best? What types of projects tend to be conducive to TDD? ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "agile": 0.11297740522441808,
                    "best": 0.07778598229787093,
                    "clients": 0.24492842727463973,
                    "comes": 0.11297740522441808,
                    "companies": 0.21874137611381736,
                    "cost": 0.10624640753657628,
                    "design": 0.078669005901761,
                    "development": 0.36196169967335506,
                    "driven": 0.10349059681151629,
                    "enterprise": 0.2344864924321097,
                    "enterprises": 0.12246421363731987,
                    "environments": 0.12246421363731987,
                    "fixed": 0.2344864924321097,
                    "generally": 0.10102544011531127,
                    "immediately": 0.11724324621605485,
                    "past": 0.09879543462896581,
                    "pay": 0.11297740522441808,
                    "phase": 0.11297740522441808,
                    "prior": 0.12246421363731987,
                    "project": 0.06978995499502157,
                    "projects": 0.18005720287166543,
                    "qa": 0.12246421363731987,
                    "short": 0.10937068805690868,
                    "similar": 0.0967595991236745,
                    "small": 0.09002860143583272,
                    "space": 0.10937068805690868,
                    "speaking": 0.11724324621605485,
                    "started": 0.09879543462896581,
                    "style": 0.3030763203459338,
                    "tdd": 0.10624640753657628,
                    "team": 0.08480763401456769,
                    "tend": 0.10937068805690868,
                    "test": 0.24773288558466677,
                    "testing": 0.09153863170240947,
                    "types": 0.21249281507315257,
                    "unit": 0.09315288195616513,
                    "usually": 0.2700858043074981,
                    "willing": 0.11724324621605485,
                    "work": 0.06384155027501039,
                    "working": 0.16108358604586184,
                    "years": 0.08600776109576515
                },
                "Max term": "development",
                "Max score": 0.36196169967335506
            }
        ],
        "Best Answer": "Every line of code I write is using test driven development.  If management isn't on board with writing tests first then I don't tell management about it.  I feel that strongly that test driven development is a better process. ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "better": 0.17787450775378374,
                "code": 0.11458977977187583,
                "development": 0.32736531200366786,
                "driven": 0.46799470144522815,
                "feel": 0.2106232668618009,
                "line": 0.2106232668618009,
                "management": 0.4212465337236018,
                "process": 0.20035191658227683,
                "tell": 0.21877823251090275,
                "test": 0.3734241931129714,
                "tests": 0.21454376833422667,
                "using": 0.16214914108176776,
                "write": 0.16526195418775413,
                "writing": 0.1891731244930693
            },
            "Max term": "driven",
            "Max score": 0.46799470144522815
        }
    },
    {
        "ID:": "2051",
        "Question": "See title, but I am asking from a technical perspective, not   Take my 40 year old virgin niece on a date or you're fired.  ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "asking": 0.43897855608089664,
                    "date": 0.5019934210668551,
                    "old": 0.42161134145936163,
                    "technical": 0.42993271166625013,
                    "year": 0.43897855608089664
                },
                "Max term": "date",
                "Max score": 0.5019934210668551
            }
        ],
        "Best Answer": "To market Neal Stephenson's sci-fi thriller Snow Crash, I was asked to write a \"benign\" computer virus. It would \"benignly\" pretend to take over the user's computer and replace the screen with snow, a.k.a., a \"snow crash.\" After a minute or so of snow, the snow would fade out and be replaced by an advertisement for the book. This would be \"benign,\" you see. The virus would spread through normal means, but nobody would mind because after taking over their computer \"you'd just get a fun ad and then be relieved that nothing bad happened to your computer.\" I was actually told to do this at a major worldwide corporation. I had to write a memo explaining all the laws this would break and all 17 bad things that could happen if they really made me implement this. ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "actually": 0.12042025565660128,
                "asked": 0.12783362402784393,
                "bad": 0.2645397195819362,
                "book": 0.1322698597909681,
                "break": 0.1604191436139691,
                "computer": 0.5389276233230952,
                "explaining": 0.17388967498441854,
                "fun": 0.1604191436139691,
                "happen": 0.14344828113488858,
                "happened": 0.1604191436139691,
                "implement": 0.15529788526925536,
                "major": 0.1604191436139691,
                "market": 0.16647630661317586,
                "means": 0.1373911181356818,
                "mind": 0.16647630661317586,
                "minute": 0.17388967498441854,
                "normal": 0.16647630661317586,
                "really": 0.09998230110934016,
                "replace": 0.16647630661317586,
                "screen": 0.16647630661317586,
                "things": 0.09498956291778085,
                "told": 0.16647630661317586,
                "user": 0.12212434293149664,
                "virus": 0.3477793499688371,
                "write": 0.2075665792757681
            },
            "Max term": "computer",
            "Max score": 0.5389276233230952
        }
    },
    {
        "ID:": "2086",
        "Question": "When writing or using an algorithm, should the Big Oh complexity be mentioned? ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "algorithm": 0.5316162404709648,
                    "big": 0.43024542474787913,
                    "mentioned": 0.5316162404709648,
                    "using": 0.32517339757241204,
                    "writing": 0.37936721224924785
                },
                "Max term": "algorithm",
                "Max score": 0.5316162404709648
            }
        ],
        "Best Answer": "If you can back it up with real analysis, then yes, absolutely. @Casebash test != analysis.  If it should always be documented then just start throwing  // this algorithm is O(n!) on every function.  I've worked with people who would say things like 'This function is O(1) because there are no loops', and then I would point to the call $(someHugeList).each(function(//... ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "absolutely": 0.22964737645655606,
                "algorithm": 0.22964737645655606,
                "analysis": 0.479747640555769,
                "documented": 0.22129176345770624,
                "function": 0.608129119912584,
                "like": 0.09980406740196929,
                "people": 0.12412222478334055,
                "point": 0.170943470686899,
                "real": 0.17634134837662646,
                "say": 0.14179674717392673,
                "start": 0.16387890055709367,
                "test": 0.16174693517581465,
                "things": 0.13103428565069358,
                "worked": 0.19351317112644364,
                "yes": 0.1792990836857488
            },
            "Max term": "function",
            "Max score": 0.608129119912584
        }
    },
    {
        "ID:": "2164",
        "Question": "So I'm sure everyone has run into this person at one point or another, someone catches wind of your project or idea and initially shows some interest. You get to talking about some of your methods and usually around this time they interject stating how you should use method X instead, or just use library Y. But not as a friendly suggestion, but bordering on a commandment. Often repeating the same advice over and over like a overzealous parrot. Personally, I like to reinvent the wheel when I'm learning, or even just for fun, even if it turns out worse than what's been done before. But this person apparently cannot fathom recreating ANY utility for such purposes, or possibly try something that doesn't strictly follow traditional OOP practices, and will settle for nothing except their sense of perfection, and thus naturally heave their criticism sludge down my ears full force. To top it off, they eventually start justifying their advice (retardation) by listing all the incredibly complex things they've coded single-handedly (usually along the lines of \"trust me, I've made/used program X for a long time, blah blah blah\"). Now, I'm far from being a programming master, I'm probably not even that good, and as such I value advice and critique, but I think advice/critique has a time and place. There is also a big difference between being helpful and being narcissistic. In the past I probably would have used a somewhat stronger George Carlin style dismissal, but I don't think burning bridges is the best approach anymore. Do you have any advice on how to deal with this kind of verbal flogging? ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "advice": 0.5855165287077776,
                    "apparently": 0.11710330574155552,
                    "approach": 0.09660302099790964,
                    "best": 0.07438087745707714,
                    "big": 0.09073311318258157,
                    "complex": 0.10159543899529906,
                    "deal": 0.10803178522881487,
                    "difference": 0.10803178522881487,
                    "eventually": 0.11710330574155552,
                    "far": 0.09447063467445492,
                    "follow": 0.09896026471607423,
                    "fun": 0.10803178522881487,
                    "good": 0.06396924848824032,
                    "helpful": 0.1045829531933519,
                    "idea": 0.09252391848255842,
                    "incredibly": 0.1121108877441661,
                    "initially": 0.1121108877441661,
                    "instead": 0.087531500485169,
                    "kind": 0.10159543899529906,
                    "learning": 0.08224274540782876,
                    "library": 0.09447063467445492,
                    "like": 0.09744611734356204,
                    "lines": 0.1045829531933519,
                    "long": 0.07610273625426375,
                    "master": 0.1121108877441661,
                    "method": 0.10159543899529906,
                    "methods": 0.09660302099790964,
                    "oop": 0.1121108877441661,
                    "past": 0.09447063467445492,
                    "person": 0.18504783696511684,
                    "personally": 0.09447063467445492,
                    "place": 0.09073311318258157,
                    "point": 0.08345239796981778,
                    "possibly": 0.09896026471607423,
                    "practices": 0.09660302099790964,
                    "probably": 0.1721751444980852,
                    "program": 0.09073311318258157,
                    "programming": 0.05689179470877325,
                    "project": 0.06673487866157231,
                    "run": 0.09896026471607423,
                    "sense": 0.09660302099790964,
                    "shows": 0.11710330574155552,
                    "single": 0.10159543899529906,
                    "somewhat": 0.10803178522881487,
                    "start": 0.08000356593435483,
                    "strictly": 0.11710330574155552,
                    "style": 0.09660302099790964,
                    "sure": 0.087531500485169,
                    "things": 0.06396924848824032,
                    "think": 0.12209373430527083,
                    "time": 0.18045546870805876,
                    "trust": 0.11710330574155552,
                    "try": 0.07610273625426375,
                    "use": 0.10613386991438625,
                    "used": 0.13117457501079344,
                    "usually": 0.1721751444980852,
                    "utility": 0.11710330574155552,
                    "value": 0.09896026471607423,
                    "worse": 0.1121108877441661
                },
                "Max term": "advice",
                "Max score": 0.5855165287077776
            }
        ],
        "Best Answer": "Don't just let them talk. Get them in front of a keyboard. The phrase \"ok, show me\" should do it. My experience is most blow hards aren't that great, and when they actually try to do what they say it doesn't work and things get real quiet. ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "actually": 0.26624537884471117,
                "experience": 0.2559793447647403,
                "great": 0.287376696210486,
                "keyboard": 0.34335871545734237,
                "let": 0.3335503384118259,
                "ok": 0.3844645748422496,
                "real": 0.2826361019814022,
                "say": 0.2272687617726821,
                "talk": 0.35468165577760075,
                "things": 0.21001892104811934,
                "try": 0.2498546557080201,
                "work": 0.20042438321158793
            },
            "Max term": "ok",
            "Max score": 0.3844645748422496
        }
    },
    {
        "ID:": "2185",
        "Question": "When should a project be released to alpha, beta and to the public? Is it a good idea to extend the alpha and beta phases when it is needed? When in a later phase (eg. beta), is it wise to go back to an early phase (eg. alpha) if it didn't work out? ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "alpha": 0.5749445018026874,
                    "beta": 0.5749445018026874,
                    "early": 0.17115769004138898,
                    "good": 0.10469037707023574,
                    "idea": 0.1514221933642924,
                    "later": 0.16626840346560043,
                    "needed": 0.16626840346560043,
                    "phase": 0.35360391433250893,
                    "project": 0.1092165341304703,
                    "public": 0.19164816726756248,
                    "released": 0.19164816726756248,
                    "work": 0.09990768521129137
                },
                "Max term": "alpha",
                "Max score": 0.5749445018026874
            }
        ],
        "Best Answer": "The right time is when the product is ready for each stage. It's up to you and the customer to define \"ready\". This might be when a certain number of bugs have been found and fixed or how much documentation has been completed. It all depends on the application and what the customer is expecting. I'll ignore the alpha phase for now. A beta phase is usually when you think you're feature complete for this release and require feedback on the fine details of your application. This is often seen as public testing, but that depends on your application. A small scale application will be beta tested by a few select users, a large application (like Visual Studio, or Stack Overflow) will be beta tested by anybody and everybody willing to help. The official release is when you (and your customers/users) are confident that your product can do the job it's designed for. It might not have all it's features, but those you implemented for this release will be. Alpha testing is more nebulous. It means different things to different people. You might release an early version that not feature complete because you need more user feedback on one particular aspect. You might also need to get something \"out there\" to meet a specific demand and can't afford to wait. ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "alpha": 0.20220315422125298,
                "anybody": 0.10110157711062649,
                "application": 0.3716201378299194,
                "beta": 0.30330473133187946,
                "bugs": 0.08156157587308738,
                "certain": 0.09029208389787219,
                "complete": 0.17087542953161536,
                "completed": 0.10110157711062649,
                "customer": 0.17087542953161536,
                "customers": 0.09326964593821709,
                "define": 0.09029208389787219,
                "depends": 0.17542560467661036,
                "designed": 0.09326964593821709,
                "details": 0.08543771476580768,
                "different": 0.14002760962130897,
                "documentation": 0.08771280233830518,
                "early": 0.09029208389787219,
                "feature": 0.15380661825110178,
                "features": 0.07988087116589578,
                "fine": 0.10110157711062649,
                "fixed": 0.09679135435529711,
                "help": 0.06817280110076607,
                "implemented": 0.0834025795829758,
                "job": 0.06907137795314149,
                "large": 0.09326964593821709,
                "like": 0.04206523498356379,
                "means": 0.07988087116589578,
                "meet": 0.10110157711062649,
                "need": 0.11523161431260946,
                "number": 0.07988087116589578,
                "overflow": 0.08771280233830518,
                "particular": 0.07988087116589578,
                "people": 0.052314807283003806,
                "phase": 0.18653929187643417,
                "product": 0.16312315174617475,
                "public": 0.10110157711062649,
                "release": 0.36116833559148875,
                "require": 0.07690330912555089,
                "right": 0.07315300728353578,
                "seen": 0.07315300728353578,
                "select": 0.10110157711062649,
                "small": 0.07432402756598387,
                "specific": 0.07988087116589578,
                "stack": 0.08771280233830518,
                "stage": 0.10110157711062649,
                "studio": 0.09326964593821709,
                "tested": 0.19358270871059421,
                "testing": 0.15114129682113278,
                "things": 0.05522808999957738,
                "think": 0.0527050411404753,
                "time": 0.051932301338805074,
                "user": 0.07100458192862605,
                "users": 0.15380661825110178,
                "usually": 0.07432402756598387,
                "version": 0.09679135435529711,
                "visual": 0.09029208389787219,
                "wait": 0.09679135435529711,
                "willing": 0.09679135435529711
            },
            "Max term": "application",
            "Max score": 0.3716201378299194
        }
    },
    {
        "ID:": "2192",
        "Question": "What things tend to slow a developer down? Please try to refrain from posting answers that:  are slow now but useful in the feature. (TDD, Refactoring, ...) list a distraction.  ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "answers": 0.2746988723553623,
                    "developer": 0.2135035147487079,
                    "feature": 0.24084571161807508,
                    "list": 0.22237208329780503,
                    "posting": 0.30313107307411735,
                    "slow": 0.6332596493387657,
                    "tdd": 0.2746988723553623,
                    "tend": 0.2827766639320956,
                    "things": 0.1729632806247598,
                    "try": 0.20577041685081074,
                    "useful": 0.22564280290890423
                },
                "Max term": "slow",
                "Max score": 0.6332596493387657
            }
        ],
        "Best Answer": "Oh this ones easy:  Meetings More Meetings Meetings about the last meeting Meetings to prepare for the upcoming meeting Developing a power point presentation for a meeting Developing a power point presentation for a meeting discussing features that haven't been implemented, shouldn't be implemented, and for whatever reason that guy from sales will jump all over.  I can't predict what document you want displayed in the app based upon your current location without an internet connection or access to your hard-drive.  No really, just give up asking for it too.  ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "access": 0.1091993598234884,
                "app": 0.1091993598234884,
                "asking": 0.1091993598234884,
                "based": 0.10487912893221166,
                "connection": 0.1208882694238105,
                "current": 0.11438895898388972,
                "developing": 0.23486995588636206,
                "document": 0.1353606447575809,
                "drive": 0.1353606447575809,
                "easy": 0.10117835928919008,
                "features": 0.10694913505633544,
                "hard": 0.10487912893221166,
                "implemented": 0.22332840435207135,
                "internet": 0.1248748018707353,
                "meeting": 0.5414425790303236,
                "meetings": 0.5183594759617421,
                "ones": 0.11743497794318103,
                "point": 0.19292658433897975,
                "power": 0.25917973798087107,
                "prepare": 0.12958986899043554,
                "really": 0.07782905306896208,
                "reason": 0.10117835928919008,
                "sales": 0.12958986899043554,
                "want": 0.07517428621077678
            },
            "Max term": "meeting",
            "Max score": 0.5414425790303236
        }
    },
    {
        "ID:": "2204",
        "Question": "What steps and measures can I take to prevent deep indentations in my code? ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "code": 0.4305316735559292,
                    "steps": 0.9025754694567824
                },
                "Max term": "steps",
                "Max score": 0.9025754694567824
            }
        ],
        "Best Answer": "The best thing you can do is extract methods: int Step1(int state) {     if (state == 100)     {         return Step2(state);     }     else     {         return Step3(state);     } }  int Step2(int state) {     if (state != 100)     {         throw new InvalidStateException(2, state);     }      // .... }  ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "100": 0.21372003371302636,
                "best": 0.07600035738301146,
                "int": 0.47861189011792044,
                "methods": 0.09870633919795382,
                "new": 0.06879752653020976,
                "return": 0.20222981342158008,
                "state": 0.8018629893147117,
                "thing": 0.08943730628860878,
                "throw": 0.11455185561638738
            },
            "Max term": "state",
            "Max score": 0.8018629893147117
        }
    },
    {
        "ID:": "2226",
        "Question": "In an earlier question, I asked for career advice for new software engineers who did well before and during college.  But what about people who weren't fortunate enough to go to MIT or Yale, for whatever reason?  What if you went to what Joel Spolsky calls a JavaSchool? What can/should JavaSchool alumni do to develop their skills and make up for the things they missed in college?  (Or, was Joel wrong about those schools being disadvantageous?) ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "advice": 0.23587142182388912,
                    "asked": 0.1733990166986616,
                    "calls": 0.2106527199385745,
                    "career": 0.1794165173759608,
                    "college": 0.45163122128278227,
                    "develop": 0.2106527199385745,
                    "earlier": 0.21759941465983,
                    "joel": 0.421305439877149,
                    "make": 0.13210700295354982,
                    "missed": 0.23587142182388912,
                    "new": 0.13562028637984075,
                    "people": 0.12205119177105184,
                    "question": 0.14077611043117833,
                    "reason": 0.17630740091471822,
                    "schools": 0.23587142182388912,
                    "skills": 0.19457940807877736,
                    "software": 0.13812450363084902,
                    "things": 0.12884792191287023,
                    "went": 0.20463521926127534,
                    "wrong": 0.19028432015785118
                },
                "Max term": "college",
                "Max score": 0.45163122128278227
            }
        ],
        "Best Answer": "Despite the claims made by Joel in that article- and he concedes the point himself- a lot of the subject areas that may be missed by a \"JavaSchool\" are not necessary of many jobs. I attended something that I suppose resembles a JavaSchool in that we spend most of our time focusing on high level languages like C# and Java, but that doesn't change the fact that \"Algorithms & Data Structures\" is still part of the required class list- not to mention all of the other theory-oriented classes. Granted not all \"JavaSchools\" are the same, but that isn't the point. In my opinion, more important than an understanding of some of the grittier development topics is being able to problem solve effectively when unique challenges arise. As software engineers we do the vast majority of our learning on the job and as such, two of the biggest aspects of our job description are being able to problem solve and being able to pick up unfamiliar concepts. If, during an interview, one is unable to make a discernible and logical attempt at solving a problem which is new to them, then their incompatibility for a given position will likely reveal itself. Obviously, when hiring someone for a position that requires constant exposure to and use of some intricate topic that may be missed by a JavaSchool, it is often the logical choice to go with someone who has a prior understanding, but lack of experience shouldn't always preclude job eligibility.  More than likely, the 50 year old Java guy at your company that has been there for as long as anyone can remember did not have any understanding of Java until his job (current or previous) asked him to learn it- and he did so. Strictly speaking, it's bad practice to fire \"the old guy\" so that a younger and more \"up-to-date\" candidate can take his place; that being said, if the job description for any employee young or old changes, it is the responsibility of that employee to get caught up or find a new job. Just because an individual (especially a programmer with past experience) doesn't understand some concept, doesn't mean they are unwilling or incapable of learning it. In fact, if they are unwilling to learn then they probably do not belong at any job- much less yours. It's fair to say that some \"JavaSchools\" are better than others, and that fact should certainly be considered when selecting a candidate for a position, but there are a lot more important personal traits than just where someone went to school. It is our aptitude to tackle a problem and find a solution that defines us as engineers, most everything else is secondary. ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "50": 0.08021187421670578,
                "able": 0.20335348149887886,
                "algorithms": 0.07679223373851463,
                "areas": 0.0739981840248327,
                "article": 0.07679223373851463,
                "asked": 0.05896712712877213,
                "aspects": 0.07679223373851463,
                "attempt": 0.07679223373851463,
                "bad": 0.061013475108082874,
                "better": 0.051526794797646616,
                "candidate": 0.16042374843341156,
                "caught": 0.08021187421670578,
                "certainly": 0.0739981840248327,
                "challenges": 0.07679223373851463,
                "change": 0.05554748665058098,
                "changes": 0.0661698601945478,
                "choice": 0.0661698601945478,
                "class": 0.06470924640166427,
                "classes": 0.0739981840248327,
                "company": 0.05803806415779436,
                "concept": 0.07163584865204968,
                "concepts": 0.07679223373851463,
                "considered": 0.07163584865204968,
                "constant": 0.08021187421670578,
                "current": 0.0677844938329596,
                "data": 0.05554748665058098,
                "date": 0.0739981840248327,
                "development": 0.047415690613827534,
                "effectively": 0.0739981840248327,
                "especially": 0.0661698601945478,
                "experience": 0.10681131291624921,
                "fact": 0.1901274314425976,
                "given": 0.06958950067273896,
                "granted": 0.07679223373851463,
                "high": 0.07163584865204968,
                "hiring": 0.08021187421670578,
                "important": 0.11432424057798558,
                "interview": 0.06958950067273896,
                "java": 0.16439935474862935,
                "job": 0.3835984944134685,
                "jobs": 0.07679223373851463,
                "joel": 0.07163584865204968,
                "lack": 0.0739981840248327,
                "languages": 0.052127846172389816,
                "learn": 0.1055068738737981,
                "learning": 0.11266709693829503,
                "level": 0.062149168341613444,
                "like": 0.033373676591669565,
                "likely": 0.12941849280332854,
                "list": 0.05633354846914752,
                "logical": 0.1479963680496654,
                "long": 0.052127846172389816,
                "lot": 0.10189686019423942,
                "make": 0.04492511310661416,
                "mean": 0.0661698601945478,
                "mention": 0.07679223373851463,
                "missed": 0.16042374843341156,
                "necessary": 0.0739981840248327,
                "new": 0.0922397233901071,
                "obviously": 0.06958950067273896,
                "old": 0.18644750502484034,
                "opinion": 0.0739981840248327,
                "oriented": 0.0677844938329596,
                "past": 0.06470924640166427,
                "personal": 0.06470924640166427,
                "pick": 0.07163584865204968,
                "place": 0.062149168341613444,
                "point": 0.11432424057798558,
                "position": 0.24063562265011734,
                "practice": 0.0677844938329596,
                "previous": 0.07163584865204968,
                "prior": 0.08021187421670578,
                "probably": 0.05896712712877213,
                "problem": 0.20156440625646418,
                "programmer": 0.051526794797646616,
                "remember": 0.0677844938329596,
                "required": 0.07163584865204968,
                "said": 0.05995617000267472,
                "say": 0.047415690613827534,
                "school": 0.07679223373851463,
                "software": 0.04697146108592489,
                "solution": 0.0677844938329596,
                "solve": 0.12941849280332854,
                "solving": 0.07679223373851463,
                "speaking": 0.07679223373851463,
                "spend": 0.0677844938329596,
                "strictly": 0.08021187421670578,
                "structures": 0.07679223373851463,
                "subject": 0.07679223373851463,
                "suppose": 0.08021187421670578,
                "theory": 0.07679223373851463,
                "time": 0.04120200042195446,
                "unable": 0.08021187421670578,
                "understand": 0.05275343693689905,
                "understanding": 0.23037670121554388,
                "unfamiliar": 0.08021187421670578,
                "unique": 0.08021187421670578,
                "use": 0.03634908754195807,
                "went": 0.06958950067273896,
                "year": 0.06470924640166427
            },
            "Max term": "job",
            "Max score": 0.3835984944134685
        }
    },
    {
        "ID:": "2247",
        "Question": "How can I track that I'm developing software more or less productive than the previous days?  ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "days": 0.40962913050463945,
                    "developing": 0.42053698480175633,
                    "previous": 0.4329032900741782,
                    "productive": 0.4329032900741782,
                    "software": 0.2838536909425768,
                    "track": 0.44717914182130647
                },
                "Max term": "track",
                "Max score": 0.44717914182130647
            }
        ],
        "Best Answer": "There's a simple answer: you can't. And moreover, you shouldn't. You want to measure your own productivity, but you can generalize: how can you measure productivity of programmers? First of all you have to define what you mean for \"productivity\": amount of code produced? Amount of design (or specification) implemented? Number of issues fixed? Quality of produced code? (Yes, quality is a productivity counter, you can produce a lot of bad code or few good code, what has been more productive?). All these values can hardly be mapped to a daily base, and any attempt to track daily productivity is dangerous for the project, for the company, and for the programmer. My advice is to clearly define what you mean as \"productivity\", then define a measure unit, and apply it on a weekly and monthly base. ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "advice": 0.10893448362089679,
                "answer": 0.07442272519721566,
                "apply": 0.10893448362089679,
                "attempt": 0.10429032372189663,
                "bad": 0.08286144002643417,
                "base": 0.20099153758335653,
                "clearly": 0.10049576879167826,
                "code": 0.18032336703693272,
                "company": 0.07882058125589898,
                "daily": 0.20099153758335653,
                "define": 0.2918625549344345,
                "design": 0.0699777288429512,
                "fixed": 0.10429032372189663,
                "good": 0.0595069200442772,
                "hardly": 0.10893448362089679,
                "implemented": 0.0898642454368526,
                "issues": 0.10049576879167826,
                "lot": 0.06919226084819723,
                "mean": 0.1797284908737052,
                "measure": 0.32680345086269036,
                "number": 0.08606969050663425,
                "produce": 0.10049576879167826,
                "productive": 0.09728751831147817,
                "productivity": 0.6536069017253807,
                "programmer": 0.0699777288429512,
                "programmers": 0.06770502604801844,
                "project": 0.06207962704781128,
                "quality": 0.17576121767753325,
                "simple": 0.08606969050663425,
                "track": 0.10049576879167826,
                "unit": 0.08286144002643417,
                "values": 0.10893448362089679,
                "want": 0.06049817555616985,
                "yes": 0.08142553060763409
            },
            "Max term": "productivity",
            "Max score": 0.6536069017253807
        }
    },
    {
        "ID:": "2252",
        "Question": "I've been asked this in a few interviews. And it always catches me off guard.My professional and academic background are already in the resumé, which the interviewer has obviously looked at. What more to tell him/her? Should I start with my hobbies? I like gardening, or looking at NSFW pictures on reddit in my free time? What and how do you answer to this specific question? Do you have a prepared answer for it? Am I wrong if I think this question is a bit silly? UPDATE There have been a lot of great answers to this question. I'm in pickle which to choose as the 'correct' answer, because most of them are very insightful. I found a great writing on this subject matter. It's a bit crazy for my taste, but it's interesting: How To Introduce Yourself… I Mean Practically ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "answer": 0.38214586844986576,
                    "answers": 0.16176061159265628,
                    "asked": 0.13706893218086758,
                    "background": 0.16176061159265628,
                    "bit": 0.2889311572500656,
                    "correct": 0.16176061159265628,
                    "free": 0.16651734209746896,
                    "great": 0.2787359194886493,
                    "interesting": 0.1444655786250328,
                    "interviews": 0.17850334569183837,
                    "like": 0.07757702360808598,
                    "looking": 0.1444655786250328,
                    "lot": 0.11842949198548126,
                    "matter": 0.16651734209746896,
                    "mean": 0.15381166628004964,
                    "obviously": 0.16176061159265628,
                    "practically": 0.186452291004445,
                    "prepared": 0.186452291004445,
                    "professional": 0.17850334569183837,
                    "question": 0.33384326221833377,
                    "specific": 0.14731690505693126,
                    "start": 0.12738195614995526,
                    "subject": 0.17850334569183837,
                    "tell": 0.14731690505693126,
                    "think": 0.09719903436691554,
                    "time": 0.09577394179675632,
                    "update": 0.186452291004445,
                    "writing": 0.12738195614995526,
                    "wrong": 0.15041647335362496
                },
                "Max term": "answer",
                "Max score": 0.38214586844986576
            }
        ],
        "Best Answer": "Don't assume the interviewer knows your resumé inside out. Often, they'll be interviewing several people for the position and may have just had a cursory glance over your resumé before starting the interview. With that in mind, and assuming this question comes early on in the interview, use this question as an opportunity to give a brief history of your career and why you are applying for the job, as well as what your stand-out skills or attributes are.  Your answer can effectively steer the course of the interview, giving the interviewer some \"jumping off\" points that could change what questions you get asked next. Focusing on your strengths with this answer means that it will be more natural to talk about what makes you great in answers to subsequent questions and not as something you have to try to shoehorn in to some other answer. ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "answer": 0.34880684676664464,
                "answers": 0.14764835503665957,
                "applying": 0.17018589252708202,
                "asked": 0.12511081754623712,
                "assume": 0.17018589252708202,
                "assuming": 0.17018589252708202,
                "career": 0.12945256321270923,
                "change": 0.11785535103849291,
                "comes": 0.1570022782365877,
                "course": 0.14381866394609336,
                "early": 0.15199010070313165,
                "effectively": 0.1570022782365877,
                "great": 0.12720927423842104,
                "history": 0.16293042601933783,
                "interview": 0.4429450651099788,
                "interviewing": 0.1570022782365877,
                "job": 0.11626894892221488,
                "knows": 0.15199010070313165,
                "makes": 0.12313962048253872,
                "means": 0.13446474074616524,
                "mind": 0.16293042601933783,
                "opportunity": 0.1570022782365877,
                "people": 0.08806234704032624,
                "points": 0.14381866394609336,
                "position": 0.17018589252708202,
                "question": 0.20314549185283845,
                "questions": 0.25022163509247425,
                "skills": 0.14039288852891538,
                "starting": 0.14764835503665957,
                "talk": 0.1570022782365877,
                "try": 0.11059988453074869,
                "use": 0.0771220217241201
            },
            "Max term": "interview",
            "Max score": 0.4429450651099788
        }
    },
    {
        "ID:": "2259",
        "Question": "Sometimes, one creates a exploratory prototype and forgets about structure in the directories... What are good tips on dividing the programming files over (several levels of) directories? ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "files": 0.5907736590992156,
                    "good": 0.3818840532374425,
                    "programming": 0.33963302169061427,
                    "tips": 0.62434002288398
                },
                "Max term": "tips",
                "Max score": 0.62434002288398
            }
        ],
        "Best Answer": "If your language is OOP and package based (Eg Java), then you should probably keep each package in its own folder (eg my/package/name) to keep with the convention. If your language isn't package based (Eg PHP), then organize by what each file does. Here's an example  Does this do utility functions? Goes in /util Is this a 3rd party plugin? Goes in /plugin Is this part of the admin panel? Goes in /admin, along with ALL supporting files Is this Javascript? Goes in /javascript Is this CSS? Goes in /css Is this a template? Goes in /templates/templateName etc  Language agnostic, Most people have a /src directory for all source files, a /lib directory for libraries, and a /bin or /dist directory for builds.  ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "agnostic": 0.1211536490610346,
                "based": 0.1961031256450762,
                "css": 0.25309750182470975,
                "directory": 0.3796462527370646,
                "example": 0.07704021084874749,
                "file": 0.0980515628225381,
                "files": 0.21388461769668277,
                "functions": 0.11674552988034813,
                "goes": 0.6781111093082021,
                "java": 0.08645658014019736,
                "javascript": 0.21958006773305058,
                "language": 0.20249511929203676,
                "libraries": 0.11674552988034813,
                "oop": 0.1211536490610346,
                "organize": 0.12654875091235487,
                "party": 0.1211536490610346,
                "people": 0.06548239607222556,
                "php": 0.09998681283451855,
                "probably": 0.09303131682069571,
                "source": 0.0962598011722041,
                "utility": 0.12654875091235487
            },
            "Max term": "goes",
            "Max score": 0.6781111093082021
        }
    },
    {
        "ID:": "2329",
        "Question": "Google sometimes come up with irrelevant links, not everything is available on SO, there are cases where the local documentation is also annoying to look through... Are there other efficient ways you use to search? ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "annoying": 0.31525561969987176,
                    "available": 0.2887833382800387,
                    "cases": 0.28190448935997664,
                    "come": 0.28190448935997664,
                    "documentation": 0.2964732371246669,
                    "google": 0.2964732371246669,
                    "irrelevant": 0.32715915335501455,
                    "local": 0.3417279011197048,
                    "look": 0.24352867428500086,
                    "search": 0.31525561969987176,
                    "use": 0.15485858564744404,
                    "ways": 0.2756818135945396
                },
                "Max term": "local",
                "Max score": 0.3417279011197048
            }
        ],
        "Best Answer": "Practise your Google-fu. Google is pretty awesome, but it's not magic. Sometimes you'll need to use search operators to get better answers, especially on some code phrases that can be difficult to search. Check out the Google Guide, for example. If I know where the answer is, I might use the site: operator, or if I need something citable I often use inurl:edu. Google Code is handy for finding examples, and I use it to search for APIs sometimes. ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "answer": 0.11363235559694286,
                "answers": 0.14430018107460296,
                "apis": 0.16632664212143367,
                "better": 0.10684551186048438,
                "check": 0.13141552733861173,
                "code": 0.1376633878380564,
                "difficult": 0.14430018107460296,
                "especially": 0.13720924443268603,
                "example": 0.10125615216600614,
                "examples": 0.13720924443268603,
                "google": 0.5772007242984118,
                "guide": 0.16632664212143367,
                "know": 0.08803162924245746,
                "magic": 0.16632664212143367,
                "need": 0.1895725865272776,
                "operator": 0.16632664212143367,
                "operators": 0.15923570547951676,
                "pretty": 0.12034722316192649,
                "search": 0.4603259651563273,
                "site": 0.1405573346494512,
                "use": 0.30149260238942305
            },
            "Max term": "google",
            "Max score": 0.5772007242984118
        }
    },
    {
        "ID:": "2331",
        "Question": "Please, explain why and list which languages have the (mis)feature implemented As far you know. Post what you consider a harmful feature, not what you dislike. ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "consider": 0.3148196291151294,
                    "explain": 0.2680209204561307,
                    "far": 0.3078703943547101,
                    "feature": 0.5805736795597621,
                    "implemented": 0.3148196291151294,
                    "know": 0.20198409358712988,
                    "languages": 0.24801124182992432,
                    "list": 0.2680209204561307,
                    "post": 0.3520648340709423
                },
                "Max term": "feature",
                "Max score": 0.5805736795597621
            }
        ],
        "Best Answer": "Register Globals in PHP Information : http://php.net/manual/en/security.globals.php This is by far the worst feature to be ever implemented for readability reasons and security reasons. Basicly all the GET parameter received are transformed into variables. For example with this URL : /index.php?value=foobar You can do the following : <?php echo $value; // return foobar ?>  When you are reading code, it is very confusing to know where the variable comes from. Also if the feature is misused, it can lead to security hole. Here's a code example from php.net that shows how it can be misused : <?php // define $authorized = true only if user is authenticated if (authenticated_user()) {     $authorized = true; }  // Because we didn't first initialize $authorized as false, this might be // defined through register_globals, like from GET auth.php?authorized=1 // So, anyone can be seen as authenticated! if ($authorized) {     include \"/highly/sensitive/data.php\"; } ?>  ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "code": 0.08839457683422564,
                "comes": 0.09852612117819606,
                "data": 0.07395963121260858,
                "define": 0.09538075019011547,
                "defined": 0.1067994430289432,
                "example": 0.130034497380018,
                "false": 0.1067994430289432,
                "far": 0.08615820964174717,
                "feature": 0.16247482613855707,
                "following": 0.09265610590810626,
                "http": 0.09538075019011547,
                "implemented": 0.08810296833344551,
                "include": 0.09265610590810626,
                "information": 0.08274955084161278,
                "know": 0.05652569457369772,
                "lead": 0.09852612117819606,
                "like": 0.044435940521584914,
                "net": 0.15702553757453866,
                "php": 0.7594450565162322,
                "readability": 0.09852612117819606,
                "reading": 0.08274955084161278,
                "reasons": 0.17620593666689102,
                "return": 0.09025279932744892,
                "security": 0.28614225057034637,
                "seen": 0.07727575233791953,
                "shows": 0.1067994430289432,
                "true": 0.18050559865489785,
                "user": 0.07500624638310587,
                "value": 0.18050559865489785,
                "variables": 0.1067994430289432
            },
            "Max term": "php",
            "Max score": 0.7594450565162322
        }
    },
    {
        "ID:": "2410",
        "Question": "I am referring to explaining to the non-programmer what programming is. I made sure to search for similar questions before creating this one, but the few ones I did find seemed to dodge the question, and I specifically would like to see some metaphors or analogies. I personally find it easier to explain something technical to someone through the use of metaphors or analogies. The reason I'm interested in this is because many people encounter the work of a programmer on a daily basis, but if you ask the average person what a programmer is or does, they don't really know. This leads to certain situations of misunderstanding (ex. \"[...] but I thought you were good with computers!\") I really would like to find the best one out there. I would like to be able to easily explain to someone what my career choice is about. Of course, at least the general idea. I personally don't have a solid one, but I have long thought about it and I have usually gravitated towards the 'language' metaphor, where we happen to know a language that computers understand, and therefore we are able to tell computers what to do, or \"teach\" them, to solve our problems. For example:  Imagine that in an alternate reality, humanoid robots with artificial intelligence exist, and some people are able to communicate with them through a common language, which is a variation of English. These people who can communicate with the robots are able to teach them how to solve certain problems or do certain tasks, like doing our chores. Well, although robots like that don't exist yet, programmers of our time are like those people, but instead of communicating with the robots, they communicate with computers. Programmers \"teach\" the computers how to perform certain tasks or solve certain problems by means of software which they create by using this \"common language\". Programmers and this \"common language\" are what give us things like email, websites, video games, word processors, smart phones (to put it simply), and many other things which we use on a daily basis.  I don't mean to put programming on the throne or anything, it's just the best metaphor I could come up with. I'm sure someone will find some issue with this one, it's probably a bit contrived, but then again that's why I'm asking this question. ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "able": 0.2814859929546832,
                    "ask": 0.062244405367074075,
                    "asking": 0.06717888357183899,
                    "best": 0.10578576769128792,
                    "bit": 0.0645210997852154,
                    "career": 0.06334206266530988,
                    "certain": 0.3718492026853641,
                    "choice": 0.06869524188833796,
                    "come": 0.06869524188833796,
                    "common": 0.17545057797335487,
                    "course": 0.0703714982386708,
                    "create": 0.06717888357183899,
                    "creating": 0.07972301976010092,
                    "daily": 0.15364466951986938,
                    "easier": 0.07224539340943563,
                    "easily": 0.07224539340943563,
                    "email": 0.07682233475993469,
                    "encounter": 0.08327317128119859,
                    "english": 0.07682233475993469,
                    "example": 0.05069495058067043,
                    "exist": 0.16654634256239717,
                    "explain": 0.11696705198223657,
                    "explaining": 0.08327317128119859,
                    "games": 0.07436984053707282,
                    "general": 0.07224539340943563,
                    "good": 0.045489084636493454,
                    "happen": 0.06869524188833796,
                    "idea": 0.06579455688817173,
                    "instead": 0.062244405367074075,
                    "interested": 0.06869524188833796,
                    "issue": 0.0645210997852154,
                    "know": 0.08814790999890526,
                    "language": 0.2220805635620363,
                    "like": 0.2425317124139497,
                    "long": 0.05411731249547735,
                    "mean": 0.06869524188833796,
                    "means": 0.06579455688817173,
                    "non": 0.058483525991118286,
                    "ones": 0.07224539340943563,
                    "people": 0.1723581384948576,
                    "person": 0.06579455688817173,
                    "personally": 0.13435776714367798,
                    "probably": 0.06121761553767267,
                    "problems": 0.1973836706645152,
                    "programmer": 0.16047996574035736,
                    "programmers": 0.15526797511563498,
                    "programming": 0.08091249235498366,
                    "question": 0.09940053835762432,
                    "questions": 0.06121761553767267,
                    "reality": 0.08327317128119859,
                    "really": 0.09576006495052101,
                    "reason": 0.062244405367074075,
                    "search": 0.07682233475993469,
                    "similar": 0.06579455688817173,
                    "simply": 0.07224539340943563,
                    "situations": 0.07972301976010092,
                    "software": 0.04876413327244926,
                    "solve": 0.20153665071551696,
                    "specifically": 0.07682233475993469,
                    "sure": 0.12448881073414815,
                    "tasks": 0.13435776714367798,
                    "teach": 0.24981951384359574,
                    "technical": 0.06579455688817173,
                    "tell": 0.06579455688817173,
                    "things": 0.09097816927298691,
                    "thought": 0.15364466951986938,
                    "time": 0.04277448035930382,
                    "understand": 0.05476677901640878,
                    "use": 0.0754727108013726,
                    "using": 0.04876413327244926,
                    "usually": 0.06121761553767267,
                    "websites": 0.08327317128119859,
                    "word": 0.07972301976010092,
                    "work": 0.04341095404942117
                },
                "Max term": "certain",
                "Max score": 0.3718492026853641
            }
        ],
        "Best Answer": "I write very, very detailed instructions for a very, very dumb machine.  ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "machine": 0.8486034913327951,
                "write": 0.5290294079706636
            },
            "Max term": "machine",
            "Max score": 0.8486034913327951
        }
    },
    {
        "ID:": "2497",
        "Question": "How useful are infix operators in a programming language? Are they worth the extra complexity they provide? Can you provide any examples where infix operators are better suited to the problem that can't be handled by just overloading the normal operators? ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "better": 0.14839387345528515,
                    "examples": 0.19056496525400235,
                    "extra": 0.21311003719958643,
                    "handled": 0.23100506753563355,
                    "language": 0.1232131184502701,
                    "normal": 0.2211567216725517,
                    "operators": 0.6634701650176551,
                    "problem": 0.1451231495796317,
                    "programming": 0.1122281971093824,
                    "provide": 0.4423134433451034,
                    "suited": 0.23100506753563355,
                    "useful": 0.16462325044498996,
                    "worth": 0.16982155469853483
                },
                "Max term": "operators",
                "Max score": 0.6634701650176551
            }
        ],
        "Best Answer": "I think infix operators stem from mathematics. This: 2 + 3 * 4  is more readable to most people, than (+ 2 (* 3 4))  because most people are familiar with mathematics. Interesting enough in Haskell you can hop between infix and prefix. This is using the same funtion \"(+)\": (+) 1 2 1 + 2  and this is using the same function \"elem\": elem 42 [1,2,42] 42 `elem` [1,2,42]  ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "familiar": 0.36041824694711083,
                "function": 0.3045779527787712,
                "haskell": 0.3126884402505291,
                "interesting": 0.2792565879010466,
                "operators": 0.3450526812079382,
                "people": 0.3729953907580411,
                "readable": 0.36041824694711083,
                "think": 0.18788884482326104,
                "using": 0.4221163468988633
            },
            "Max term": "using",
            "Max score": 0.4221163468988633
        }
    },
    {
        "ID:": "2654",
        "Question": "In response to This Question, I ask:   What are the best parts of your coding standard? What are the best practices that help with code quality, reliability, maintainability, readability, etc. Please include the language, the item from the standard, and the reason it improves your code. ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "ask": 0.23411584340894487,
                    "best": 0.3978851444986141,
                    "code": 0.2592341544792721,
                    "coding": 0.20599073257434122,
                    "help": 0.21119751071269752,
                    "include": 0.27173191085552684,
                    "language": 0.1670594429698347,
                    "practices": 0.2583789562776848,
                    "quality": 0.2526755761251432,
                    "question": 0.18693439784395763,
                    "readability": 0.2889468633992326,
                    "reason": 0.23411584340894487,
                    "standard": 0.4764887811747231
                },
                "Max term": "standard",
                "Max score": 0.4764887811747231
            }
        ],
        "Best Answer": "Just one public class must be put in each file, no more. ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "class": 0.5376824053064548,
                "file": 0.5164101914321637,
                "public": 0.6664969206296915
            },
            "Max term": "public",
            "Max score": 0.6664969206296915
        }
    },
    {
        "ID:": "2682",
        "Question": "We’re working on a .Net framework which ultimately amounts to a single DLL.  We intend to charge for commercial use of the framework, but make it free for open source/non-commercial use.  The rough plan at the moment is to administer this through some form of fairly simple licence which will be issued whether you’re using it for free or paying. We’re debating whether to make the source code available.  It’s our perception (and our own preference) that it’s far more appealing to use something where you have access to the source code. I’m interested in whether people think making the source code available will damage our ability to make money from the framework, or whether it will encourage more usage and enough “good” people will arrange to pay for the correct licence if using it commercially. My feeling is that, generally, commercial operations don’t mess about on the licencing front and so making the source code available will only encourage usage and therefore ultimately generate more revenue, but I’d be interested in others views/experience. ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "ability": 0.09984901350615168,
                    "access": 0.08731504026861531,
                    "available": 0.27439382179825633,
                    "charge": 0.10823341974621793,
                    "code": 0.1791628695141281,
                    "commercial": 0.32470025923865375,
                    "correct": 0.09390018260754708,
                    "encourage": 0.19969802701230335,
                    "experience": 0.07206260779592472,
                    "fairly": 0.09984901350615168,
                    "far": 0.08731504026861531,
                    "feeling": 0.10823341974621793,
                    "form": 0.09984901350615168,
                    "framework": 0.246984519163867,
                    "free": 0.19332282038658632,
                    "generally": 0.089285910881926,
                    "generate": 0.10823341974621793,
                    "good": 0.05912395451720287,
                    "interested": 0.178571821763852,
                    "make": 0.18185830981375292,
                    "making": 0.178571821763852,
                    "moment": 0.10823341974621793,
                    "money": 0.09666141019329316,
                    "net": 0.07956694546887624,
                    "non": 0.07601334162548833,
                    "open": 0.08232817305462234,
                    "operations": 0.10823341974621793,
                    "pay": 0.09984901350615168,
                    "paying": 0.10823341974621793,
                    "people": 0.11201032975792644,
                    "plan": 0.10823341974621793,
                    "rough": 0.10823341974621793,
                    "simple": 0.08551577636748084,
                    "single": 0.09390018260754708,
                    "source": 0.41164086527311167,
                    "think": 0.05642292636302673,
                    "ultimately": 0.21646683949243586,
                    "usage": 0.21646683949243586,
                    "use": 0.14714228115497865,
                    "using": 0.1267613283806608,
                    "views": 0.10823341974621793,
                    "working": 0.07118253922880999
                },
                "Max term": "source",
                "Max score": 0.41164086527311167
            }
        ],
        "Best Answer": "If it is a managed .NET framework, people can use Reflector to look at the source code anyway. I've seen a number of companies that appear to work this dual-licensing model successfully.  Having access to the source code doesn't necessarily mean that people will steal the code. Personally, I would rather be properly licensed, as has any company I have ever worked for.  But having access to the source code can encourage people to try your product out.   There's something about having access to the source that feels like a security blanket; you know that you will probably never need it, but if you spend many man-hours worth of effort committing to a third-party library, it's good to know you can dig into the code and fix something if you ever get into a bind, or the original author of the code gets thrown under a bus. ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "access": 0.33880644849424535,
                "appear": 0.1399918442450509,
                "author": 0.1340236284182562,
                "code": 0.3476006844604201,
                "companies": 0.12502431422767016,
                "company": 0.10129242979551337,
                "effort": 0.12502431422767016,
                "encourage": 0.12914724102361752,
                "feels": 0.1340236284182562,
                "fix": 0.11293548283141512,
                "framework": 0.10648534257040346,
                "gets": 0.12145287258778417,
                "good": 0.07647241906733675,
                "hours": 0.12502431422767016,
                "know": 0.14818684454112574,
                "library": 0.11293548283141512,
                "like": 0.05824627065418523,
                "look": 0.0997636661449174,
                "man": 0.1340236284182562,
                "managed": 0.12914724102361752,
                "mean": 0.11548465676098948,
                "model": 0.11830263780218411,
                "necessarily": 0.12502431422767016,
                "need": 0.07977860812846345,
                "net": 0.10291390093051743,
                "number": 0.11060826936635078,
                "original": 0.12145287258778417,
                "party": 0.1340236284182562,
                "people": 0.21731549285898397,
                "personally": 0.11293548283141512,
                "probably": 0.10291390093051743,
                "product": 0.11293548283141512,
                "properly": 0.1340236284182562,
                "security": 0.12502431422767016,
                "seen": 0.10129242979551337,
                "source": 0.42594137028161383,
                "spend": 0.11830263780218411,
                "successfully": 0.1399918442450509,
                "thrown": 0.1399918442450509,
                "try": 0.09097746927692806,
                "use": 0.0634391834290753,
                "work": 0.07297884089575601,
                "worked": 0.11293548283141512,
                "worth": 0.10291390093051743
            },
            "Max term": "source",
            "Max score": 0.42594137028161383
        }
    },
    {
        "ID:": "2699",
        "Question": "This is a \"Share the Knowledge\" question. I am interested in learning from your successes and/or failures. Information that might be helpful... Background:  Context: Language, Application, Environment, etc. How was the bug identified ? Who or what identified the bug ? How complex was reproducing the bug ?   The Hunting.  What was your plan  ? What difficulties did you encounter ? How was the offending code finally found ?  The Killing.  How complex was the fix ? How did you determine the scope of the fix ? How much code was involved in the fix ?  Postmortem.  What was the root cause technically ? buffer overrun, etc. What was the root cause from 30,000 ft ? How long did the process ultimately take ? Were there any features adversely effected by the fix ? What methods, tools, motivations did you find particularly helpful ? ...horribly useless ? If you could do it all again ?............  These examples are general, not applicable in every situation and possibly useless. Please season as needed. ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "000": 0.1364447235183297,
                    "30": 0.13062773065866523,
                    "applicable": 0.1364447235183297,
                    "application": 0.10030626308542007,
                    "background": 0.11837549330187487,
                    "bug": 0.33767550132663127,
                    "cause": 0.23675098660374974,
                    "code": 0.11293105333327517,
                    "complex": 0.23675098660374974,
                    "context": 0.12185644156528289,
                    "determine": 0.13062773065866523,
                    "encounter": 0.1364447235183297,
                    "environment": 0.11255850044221041,
                    "examples": 0.11255850044221041,
                    "features": 0.10780567120835119,
                    "fix": 0.44029567046399626,
                    "general": 0.11837549330187487,
                    "helpful": 0.24371288313056577,
                    "horribly": 0.1364447235183297,
                    "information": 0.10571908678203476,
                    "interested": 0.11255850044221041,
                    "involved": 0.12185644156528289,
                    "knowledge": 0.1037872113488281,
                    "language": 0.07277667135239368,
                    "learning": 0.09582640376801473,
                    "long": 0.08867227736609114,
                    "methods": 0.11255850044221041,
                    "needed": 0.11837549330187487,
                    "particularly": 0.125874901424806,
                    "plan": 0.1364447235183297,
                    "possibly": 0.11530507933128231,
                    "process": 0.09872587687148243,
                    "question": 0.08143486530602058,
                    "scope": 0.1364447235183297,
                    "share": 0.125874901424806,
                    "situation": 0.11530507933128231,
                    "tools": 0.11007391761599906,
                    "ultimately": 0.1364447235183297,
                    "useless": 0.26125546131733046
                },
                "Max term": "fix",
                "Max score": 0.44029567046399626
            }
        ],
        "Best Answer": "It was actually in a 3rd party image viewer sub-component of our application.  We found that there were 2-3 of the users of our application would frequently have the image viewer component throw an exception and die horribly. However, we had dozens of other users who never saw the issue despite using the application for the same task for most of the work day. Also there was one user in particular who got it a lot more frequently than the rest of them. We tried the usual steps:  (1) Had them switch computers with another user who never had the problem to rule out the computer/configuration. - The problem followed them. (2) Had them log into the application and work as a user that never saw the problem. - The problem STILL followed them. (3) Had the user report which image they were viewing and set up a test harness to repeat viewing that image thousands of times in quick succession. The problem did not present itself in the harness.   (4) Had a developer sit with the users and watch them all day. They saw the errors, but didn't notice them doing anything out of the ordinary to cause them. We struggled with this for weeks trying to figure out what the \"Error Users\" had in common that the other users didn't. I have no idea how, but the developer in step (4) had a eureka moment on the drive in to work one day worthy of Encyclopedia Brown. He realized that all the \"Error Users\" were left handed, and confirmed this fact. Only left-handed users got the errors, never Righties. But how could being left handed cause a bug? We had him sit down and watch the left-handers again specifically paying attention to anything they might be doing differently, and that's how we found it. It turned out that the bug only happened if you moved the mouse to rightmost column of pixels in the image viewer while it was loading a new image (overflow error because the vendor had a 1-off calculation for mouseover event).  Apparently, while waiting for the next image to load, the users all naturally moved their hand (and thus the mouse)  towards the keyboard.  The one user who happened to get the error most frequently was one of those ADD types that compulsively moved her mouse around a lot impatiently while waiting for the next page to load, thus she was moving the mouse to the right much more quickly and hitting the timing just right so she did it when the load event happened. Until we got a fix from the vendor, we told her just to let go of the mouse after clicking (next document) and not touch it until it loaded.  It was henceforth known in legend on the dev team as \"The Left Handed Bug\" ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "actually": 0.046656935511418966,
                "add": 0.05845148072286128,
                "apparently": 0.06737370974353074,
                "application": 0.19811700680876726,
                "attention": 0.06737370974353074,
                "bug": 0.16673749359626527,
                "cause": 0.11690296144572256,
                "common": 0.04731718564672304,
                "computer": 0.05220199714243329,
                "day": 0.1630569798061273,
                "dev": 0.06737370974353074,
                "developer": 0.09086019516274596,
                "differently": 0.06737370974353074,
                "document": 0.06737370974353074,
                "drive": 0.06737370974353074,
                "error": 0.2277414837746215,
                "errors": 0.11115832906417684,
                "event": 0.12900278710551577,
                "exception": 0.06737370974353074,
                "fact": 0.053232311322923595,
                "figure": 0.06737370974353074,
                "fix": 0.05435232660204243,
                "frequently": 0.17080611283096614,
                "got": 0.16673749359626527,
                "hand": 0.06215454034359305,
                "happened": 0.18646362103077915,
                "horribly": 0.06737370974353074,
                "idea": 0.053232311322923595,
                "issue": 0.05220199714243329,
                "keyboard": 0.06017030422796804,
                "known": 0.06737370974353074,
                "left": 0.3368685487176537,
                "let": 0.05845148072286128,
                "load": 0.19350418065827366,
                "lot": 0.08558794504609647,
                "moment": 0.06737370974353074,
                "moving": 0.06215454034359305,
                "new": 0.03873823178423085,
                "notice": 0.06450139355275789,
                "ordinary": 0.06737370974353074,
                "overflow": 0.05845148072286128,
                "page": 0.06450139355275789,
                "particular": 0.053232311322923595,
                "party": 0.06450139355275789,
                "paying": 0.06737370974353074,
                "problem": 0.21162923093314567,
                "quickly": 0.05845148072286128,
                "repeat": 0.06450139355275789,
                "report": 0.06215454034359305,
                "right": 0.09749777640351566,
                "rule": 0.06450139355275789,
                "saw": 0.2021211292305922,
                "set": 0.049529251702191815,
                "sit": 0.13474741948706148,
                "specifically": 0.06215454034359305,
                "step": 0.06215454034359305,
                "steps": 0.05845148072286128,
                "task": 0.05220199714243329,
                "team": 0.046656935511418966,
                "test": 0.04543009758137298,
                "throw": 0.06450139355275789,
                "times": 0.05220199714243329,
                "told": 0.06450139355275789,
                "touch": 0.06215454034359305,
                "tried": 0.06017030422796804,
                "trying": 0.04801314192298592,
                "types": 0.05845148072286128,
                "user": 0.23658592823361524,
                "users": 0.40998460165838874,
                "using": 0.03945352999585628,
                "usual": 0.06737370974353074,
                "waiting": 0.13474741948706148,
                "weeks": 0.06737370974353074,
                "work": 0.10536732201319934
            },
            "Max term": "users",
            "Max score": 0.40998460165838874
        }
    },
    {
        "ID:": "2700",
        "Question": "I have had a few that I am proud of and some of them were written by myself few years ago. It doesn't have to be necessarily buggy, just bad code.  ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "ago": 0.468367573238306,
                    "bad": 0.3989166570778235,
                    "code": 0.21703096985896714,
                    "necessarily": 0.468367573238306,
                    "written": 0.468367573238306,
                    "years": 0.3683184869708691
                },
                "Max term": "ago",
                "Max score": 0.468367573238306
            }
        ],
        "Best Answer": "I don't know about being proud of the fix because it was so obvious, but the most horrible code I remember fixing was this. if (userName==\"John O'Reily\") { userName= \"John O''Reily\";} if (userName==\"Stacy O'Neil\") { userName= \"Stacy O''Neil\";} if (userName==\"Finnegan O'Connor\") { userName= \"Finnegan O''Connor\";} ... someSQL = \"SELECT * from Users where UserName='\" + userName + \"'\";  Apparently the previous developer just kept adding new lines every time a new (usually Irish) user started getting errors in the application. I'll leave it as an exercise for the class as to how it was fixed. ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "apparently": 0.2392714921236347,
                "application": 0.1758985515813673,
                "class": 0.19302725552693142,
                "code": 0.09901878556159979,
                "developer": 0.16134078525579773,
                "errors": 0.19738425684440988,
                "exercise": 0.2136892643876029,
                "fix": 0.19302725552693142,
                "fixed": 0.22907072711554358,
                "fixing": 0.2392714921236347,
                "getting": 0.185390559546902,
                "kept": 0.2392714921236347,
                "know": 0.12663911814884796,
                "leave": 0.2022006983459768,
                "lines": 0.2136892643876029,
                "new": 0.275150486934086,
                "obvious": 0.22073609523480575,
                "previous": 0.2136892643876029,
                "remember": 0.2022006983459768,
                "select": 0.2392714921236347,
                "started": 0.19302725552693142,
                "time": 0.12290529570229691,
                "user": 0.16804260379724104,
                "users": 0.18200279411646927,
                "usually": 0.1758985515813673
            },
            "Max term": "new",
            "Max score": 0.275150486934086
        }
    },
    {
        "ID:": "2715",
        "Question": "Should curly braces be on their own line or not? What do you think about it? if (you.hasAnswer()) {     you.postAnswer(); } else {     you.doSomething(); }  or should it be if (you.hasAnswer()) {     you.postAnswer(); } else {     you.doSomething(); }  or even if (you.hasAnswer())     you.postAnswer(); else     you.doSomething();  Please be constructive! Explain why, share experiences, back it up with facts and references. ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "braces": 0.43875419722095454,
                    "experiences": 0.43875419722095454,
                    "explain": 0.3081411708248155,
                    "line": 0.33374009212631267,
                    "references": 0.43875419722095454,
                    "share": 0.40476568020227116,
                    "think": 0.22872598703167082
                },
                "Max term": "braces",
                "Max score": 0.43875419722095454
            }
        ],
        "Best Answer": "For a long time I argued that they were of equal worth, or so very close to equal that the possible gain by making the right choice was far, far, below the cost of arguing about it.  Being consistent is important, though. So I said let's flip a coin and get on to writing code. I've seen programmers resist change like this before. Get over it! I've switched many times in my career. I even use different styles in my C# than in my PowerShell.  A few years ago I was working on a team (~20 developers) that decided to ask for input, and then make a decision, and then enforce that across all the code base. We'd have 1 week to decide. Lots of groans & eye-rolling. Lots of \"I like my way, because it's better\" but no substance.  As we were studying the finer points of the question, someone asked how to deal with this issue in brace-on-the-same-line style: void MyFunction(     int parameterOne,     int parameterTwo) {     int localOne,     int localTwo }  Note that it's not immediately obvious where the parameter list ends, and the body begins. Compare to: void MyFunction(     int parameterOne,     int parameterTwo)  {     int localOne,     int localTwo }  We did some reading on how folks around the world had dealt with this problem, and found the pattern of adding a blank line after the open brace: void MyFunction(     int parameterOne,     int parameterTwo) {      int localOne,     int localTwo }  If you're going to make a visual break, you may as well do it with a brace. Then your visual breaks become consistent, too. Edit: Two alternatives to the 'extra blank line' solution when using K&R: 1/ Indent the function arguments differently from the function body 2/ Put the first argument on the same line as the function name and align further arguments on new lines to that first argument Examples: 1/ void MyFunction(         int parameterOne,         int parameterTwo) {     int localOne,     int localTwo }  2/ void MyFunction(int parameterOne,                 int parameterTwo) {     int localOne,     int localTwo }  /Edit I still argue that consistency is more important than other considerations, but if we don't have an established precedent, then brace-on-next-line is the way to go. ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "20": 0.045029348822632875,
                "ago": 0.04021493885610589,
                "arguments": 0.09005869764526575,
                "ask": 0.03365819985486925,
                "asked": 0.033102970881548205,
                "base": 0.04154110689015161,
                "better": 0.02892611647979946,
                "body": 0.09005869764526575,
                "break": 0.04154110689015161,
                "breaks": 0.04310963075789285,
                "career": 0.034251749885563565,
                "change": 0.031183252816808178,
                "choice": 0.03714644178735051,
                "close": 0.04154110689015161,
                "code": 0.0372693913133861,
                "consistency": 0.045029348822632875,
                "consistent": 0.09005869764526575,
                "cost": 0.03906615985209054,
                "deal": 0.04154110689015161,
                "decide": 0.04154110689015161,
                "developers": 0.03162453226788743,
                "different": 0.031183252816808178,
                "differently": 0.045029348822632875,
                "edit": 0.07265296458222838,
                "ends": 0.045029348822632875,
                "equal": 0.09005869764526575,
                "examples": 0.03714644178735051,
                "extra": 0.04154110689015161,
                "far": 0.07265296458222838,
                "function": 0.11415859487301105,
                "going": 0.032089675987128016,
                "immediately": 0.04310963075789285,
                "important": 0.06417935197425603,
                "indent": 0.045029348822632875,
                "input": 0.04154110689015161,
                "int": 0.9005869764526575,
                "issue": 0.034889305450341794,
                "let": 0.03906615985209054,
                "like": 0.037470634850894385,
                "line": 0.17125874942781785,
                "lines": 0.04021493885610589,
                "list": 0.03162453226788743,
                "long": 0.02926353475206815,
                "lots": 0.07813231970418108,
                "make": 0.050440127692531686,
                "making": 0.03714644178735051,
                "new": 0.025890771911244344,
                "note": 0.04154110689015161,
                "obvious": 0.04154110689015161,
                "open": 0.034251749885563565,
                "pattern": 0.04154110689015161,
                "points": 0.03805286495767035,
                "possible": 0.031183252816808178,
                "problem": 0.028288560915021233,
                "programmers": 0.027986668074468528,
                "question": 0.0268750513880906,
                "reading": 0.034889305450341794,
                "right": 0.03258141343127188,
                "said": 0.03365819985486925,
                "seen": 0.03258141343127188,
                "solution": 0.03805286495767035,
                "style": 0.03714644178735051,
                "styles": 0.04154110689015161,
                "team": 0.031183252816808178,
                "time": 0.02312998252824829,
                "times": 0.034889305450341794,
                "use": 0.02040565387973887,
                "using": 0.026368842850281207,
                "visual": 0.08042987771221179,
                "way": 0.050440127692531686,
                "week": 0.04310963075789285,
                "working": 0.02961472894906694,
                "world": 0.031183252816808178,
                "worth": 0.033102970881548205,
                "writing": 0.030763507953082306,
                "years": 0.03162453226788743
            },
            "Max term": "int",
            "Max score": 0.9005869764526575
        }
    },
    {
        "ID:": "2756",
        "Question": "Coding standards are common in any software development organization, but how important are they to follow?  I can understand the need for some consistency, but when dealing with simple things like the position of braces, line length, etc., I'm not sure excessively strict standards contribute much to software development. Isn't it more important that your code is readable, not that it conforms to a predefined standard?  It seems they're more like... guidelines anyway. ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "braces": 0.2280987938856768,
                    "code": 0.09439513816779671,
                    "coding": 0.15001513748602405,
                    "common": 0.16019591346784245,
                    "consistency": 0.2280987938856768,
                    "dealing": 0.2280987938856768,
                    "development": 0.2696723383136689,
                    "follow": 0.19275900779574348,
                    "important": 0.3251042522368009,
                    "like": 0.1898096872172328,
                    "line": 0.17350423760611922,
                    "need": 0.12998903179049942,
                    "organization": 0.2037111192834622,
                    "position": 0.2280987938856768,
                    "readable": 0.2280987938856768,
                    "simple": 0.1802220191633671,
                    "software": 0.2671458241158023,
                    "standard": 0.17350423760611922,
                    "standards": 0.3763349366749175,
                    "sure": 0.17049757529249207,
                    "things": 0.12460201984513976,
                    "understand": 0.15001513748602405
                },
                "Max term": "standards",
                "Max score": 0.3763349366749175
            }
        ],
        "Best Answer": "Asking everyone to 100% adhere to the same standard code formatting guideline is like asking everyone to collaborate separately on writing a 100 page paper with the same writing style.   Hopefully everyone will write the paper in English (or same language), but different styles will be apparent.  Some will write it well, others not.  Some will use contractions, some will spell the words out fully (example: it's verus it is).  Etc. I think you touched on the most important points:   It's a guideline Readability  If you want the code to adhere to the same formatting, like a paper to be in the same writing style, it'll need editing and revising.  The code will need to be cleaned up, reviewed, re-factored, etc. I've never been in a shop where I was completely happy with another developer's coding style or formatting (at minimal because it's not exactly like mine).  But I'll be content if I can read/understand it and if it's consistent.  Everything else is the sugar on the syntactic sugar. So to answer your question: somewhat important, but it's certainly not the end of the world if they don't. ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "100": 0.25658133266489763,
                "answer": 0.09813942396247828,
                "asking": 0.23177201066082706,
                "certainly": 0.13252130762138087,
                "code": 0.17834100391799285,
                "coding": 0.09447467578466323,
                "completely": 0.1213933811697691,
                "consistent": 0.14364923407299263,
                "developer": 0.09686268941205473,
                "different": 0.0994784623842373,
                "end": 0.1039387689760525,
                "english": 0.13252130762138087,
                "exactly": 0.13252130762138087,
                "example": 0.08745062437565308,
                "important": 0.20474013050282058,
                "language": 0.07661940182500972,
                "like": 0.1793039918618916,
                "need": 0.16372576580965137,
                "page": 0.13752509422095494,
                "paper": 0.4309477022189778,
                "points": 0.1213933811697691,
                "question": 0.08573476296044298,
                "read": 0.10560260223627498,
                "readability": 0.13252130762138087,
                "somewhat": 0.13252130762138087,
                "standard": 0.10926735041409004,
                "style": 0.35550533490778835,
                "styles": 0.13252130762138087,
                "think": 0.07488546675518747,
                "understand": 0.09447467578466323,
                "use": 0.06509657872533473,
                "want": 0.07977746157682386,
                "words": 0.13252130762138087,
                "world": 0.0994784623842373,
                "write": 0.17146952592088596,
                "writing": 0.29441827188743486
            },
            "Max term": "paper",
            "Max score": 0.4309477022189778
        }
    },
    {
        "ID:": "2776",
        "Question": "The Joel Test is a well known test for determining how good your team is. What do you think about the points? Do you disagree with any of them? Is there anything that you would add? ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "add": 0.3503265398361643,
                    "good": 0.22058200348779394,
                    "joel": 0.36062823764922947,
                    "known": 0.4038015516199878,
                    "points": 0.3412397983816704,
                    "team": 0.27963641938469525,
                    "test": 0.5445668336637004,
                    "think": 0.2105049001108242
                },
                "Max term": "test",
                "Max score": 0.5445668336637004
            }
        ],
        "Best Answer": "Jeff Atwood has The Programmer's Bill of Rights. From the post:   Every programmer shall have two monitors Every programmer shall have a fast PC Every programmer shall have their choice of mouse and keyboard Every programmer shall have a comfortable chair Every programmer shall have a fast internet connection Every programmer shall have quiet working conditions   This seems to have some items that I'd like to see on Joel's list.  Specifically in the area of hardware (dual monitor, fast PC, mouse/keyboard, comfortable chair, fast connection).   The only thing not mentioned is having a comfortable and adjustable desk. This could all be added by changing: Current #9: Do you use the best tools money can buy? to  Improved #9: Do you use the best tools and equipment money can buy? ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "added": 0.11766523034376354,
                "best": 0.16737035648587092,
                "changing": 0.12613483390617886,
                "choice": 0.10868708877064896,
                "connection": 0.23533046068752708,
                "current": 0.11133920000489032,
                "fast": 0.4572160324888414,
                "hardware": 0.12154547663131529,
                "internet": 0.12154547663131529,
                "joel": 0.11766523034376354,
                "keyboard": 0.23533046068752708,
                "like": 0.054817824001094036,
                "list": 0.0925304869200311,
                "mentioned": 0.12613483390617886,
                "money": 0.23533046068752708,
                "monitor": 0.12154547663131529,
                "post": 0.12154547663131529,
                "programmer": 0.5924461851122659,
                "specifically": 0.12154547663131529,
                "thing": 0.098480812144224,
                "tools": 0.2125759246660456,
                "use": 0.11941015117122496,
                "working": 0.08664998636025548
            },
            "Max term": "programmer",
            "Max score": 0.5924461851122659
        }
    },
    {
        "ID:": "2777",
        "Question": "I have heard a lot of people mention Code Complete as a book worthwhile reading. Unfortunately, I am so busy that I don't have time to read it, so can anyone tell me what the key points of the book are? ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "book": 0.4772474804149249,
                    "code": 0.12982346274524323,
                    "complete": 0.2651051987751421,
                    "heard": 0.2651051987751421,
                    "key": 0.30033447531236396,
                    "lot": 0.19925934272612128,
                    "mention": 0.30033447531236396,
                    "people": 0.16232793002083368,
                    "points": 0.2651051987751421,
                    "read": 0.2306204719503423,
                    "reading": 0.24306543717085127,
                    "tell": 0.2478628353627422,
                    "time": 0.16114105002705764,
                    "unfortunately": 0.31370869141176305
                },
                "Max term": "book",
                "Max score": 0.4772474804149249
            }
        ],
        "Best Answer": "It's an intermediate book, a potpourri of software development best practices. If you're a beginning programmer you won't understand a lot of the material, and if you are experienced, the book will only confirm what you already know.  Consequently, the book might be of most value to intermediate programmers, who already have a bit of programming knowledge, but need a book of best practices to tie it all together. Several pages are spent on how to format code blocks, and the relative merits of each approach.  Personally, I think the great debate on where to put your curly braces is over. (or is it?) ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "approach": 0.16925476496921318,
                "best": 0.260640253320315,
                "bit": 0.15897030535903392,
                "book": 0.6242613394685337,
                "braces": 0.20517259486982065,
                "code": 0.08490748728241411,
                "development": 0.12128379215402318,
                "experienced": 0.19642555439378315,
                "format": 0.18927870194145627,
                "great": 0.15336087204084878,
                "know": 0.10859160968996359,
                "knowledge": 0.15606533486713342,
                "lot": 0.1303201266601575,
                "need": 0.11692384033577785,
                "personally": 0.1655186856802673,
                "practices": 0.33850952993842637,
                "programmer": 0.13179951593446396,
                "programmers": 0.12751899507178646,
                "programming": 0.09967811816483986,
                "software": 0.12014750496652596,
                "think": 0.10695807486444621,
                "understand": 0.1349371230923163,
                "value": 0.17338480901309186
            },
            "Max term": "book",
            "Max score": 0.6242613394685337
        }
    },
    {
        "ID:": "2806",
        "Question": "There's around a zillion \"PHP frameworks\". And most of them bill themselves as following the MVC pattern. While it's welcome to overcome osCommerce coding style (processing logic heavily intermixed with SQL and HTML), there are certainly simpler and easier to follow approaches to get a maintainable application design. The original MVC concept was targetted at GUI applications. And for Gtk/Python it seems feasible to follow it accordingly. But PHP web apps don't operate on live Views (GUI elements) and a persistent Controller runtime. It's quite certainly a misnomer if it just describes the used code + directory grouping or class naming. \"MVC\" seems to be used like a buzzword for PHP frameworks. And I've actually seen one or two mature PHP frameworks admit it, but redefining the phrase anyway to match interna. So is it generally snake oil? Why isn't better terminology used, and a more sensible concept for maintainable PHP propagated? Some elaborative reasoning Why I suspect that PHP implementations don't follow the real MVC pattern: Models: in theory, Models should be fat and contain business logic, and controllers should be thin handlers (input->output). In reality the PHP frameworks advocate shallow Models. CI and Symfony for example equate Model == ORM. Even HTTP input is handled by the controller, isn't treated as model. Views: workarounds with AJAX discounted, there can't be Views on web pages. PHP frameworks still pump out pages. The interface still effectively follows the ordinary HTTP model, there's no advantage over non-MVC applications. (And lastly, none of the widespread php frameworks can factually output to GUI Views instead of HTML. I've seen a PHP library that can operate Gtk/Console/Web, but the frameworks don't.) Controller: I'm unsure. Controllers probably don't need to be long-running and persistently active in the MVC model. In PHP framework context, they're however mostly request handlers. Not really something to get argumentative about, but it just feels slightly buzzwordish. Would there be better descriptors? I've seen acronyms like PMVC or HMVC thrown around. Though descriptions get more ambigous there, maybe these would describe the current web frameworks less hokey? ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "actually": 0.042983229592060614,
                    "advocate": 0.06206879218773963,
                    "application": 0.04562938337253697,
                    "applications": 0.09808173786935823,
                    "approaches": 0.05726057334228044,
                    "apps": 0.05120293399966194,
                    "better": 0.07974395186814719,
                    "business": 0.05120293399966194,
                    "certainly": 0.11452114668456088,
                    "class": 0.050072695679433885,
                    "code": 0.02568620427430437,
                    "coding": 0.04082116452707778,
                    "concept": 0.1108651467528082,
                    "context": 0.0554325733764041,
                    "controller": 0.18620637656321887,
                    "current": 0.05245235449682126,
                    "design": 0.03987197593407359,
                    "directory": 0.06206879218773963,
                    "easier": 0.0538490877801383,
                    "effectively": 0.05726057334228044,
                    "elements": 0.06206879218773963,
                    "example": 0.03778617175433304,
                    "feels": 0.05942263840726328,
                    "follow": 0.15735706349046377,
                    "following": 0.0538490877801383,
                    "framework": 0.04721286896880278,
                    "frameworks": 0.41961883597457006,
                    "generally": 0.05120293399966194,
                    "gui": 0.17178172002684133,
                    "handled": 0.06206879218773963,
                    "html": 0.11452114668456088,
                    "http": 0.1108651467528082,
                    "input": 0.11452114668456088,
                    "instead": 0.04639471515420276,
                    "interface": 0.06206879218773963,
                    "library": 0.050072695679433885,
                    "like": 0.051649804150262414,
                    "live": 0.05726057334228044,
                    "logic": 0.11884527681452656,
                    "long": 0.04033707581158426,
                    "maintainable": 0.11884527681452656,
                    "match": 0.05942263840726328,
                    "maybe": 0.05245235449682126,
                    "model": 0.20980941798728503,
                    "need": 0.03537178808991776,
                    "non": 0.04359149249751909,
                    "ordinary": 0.06206879218773963,
                    "original": 0.0538490877801383,
                    "output": 0.12413758437547925,
                    "pattern": 0.11452114668456088,
                    "php": 0.5394495582814702,
                    "probably": 0.04562938337253697,
                    "python": 0.050072695679433885,
                    "quite": 0.04904086893467911,
                    "real": 0.04562938337253697,
                    "reality": 0.06206879218773963,
                    "really": 0.03568803421228842,
                    "reasoning": 0.06206879218773963,
                    "request": 0.06206879218773963,
                    "running": 0.05726057334228044,
                    "runtime": 0.05726057334228044,
                    "seen": 0.13473139401243064,
                    "simpler": 0.06206879218773963,
                    "sql": 0.06206879218773963,
                    "style": 0.05120293399966194,
                    "suspect": 0.06206879218773963,
                    "theory": 0.05942263840726328,
                    "thrown": 0.06206879218773963,
                    "used": 0.10429057555337785,
                    "views": 0.2482751687509585,
                    "web": 0.1769306003568797
                },
                "Max term": "php",
                "Max score": 0.5394495582814702
            }
        ],
        "Best Answer": " But PHP web apps don't operate on live Views (GUI elements) and a persistent Controller runtime.   No, they sure do! Think of AJAX applications, then the view asks something to the controller and gets a partial view back, this view or data is then filled in somewhere in the page and thus live updated. The Controller is also persistent because you can use cookies/sessions.  \"MVC\" seems to be used like a buzzword for PHP frameworks.  MVC is a Software Architecture, some frameworks might use it as a buzz, but others do it properly... See a list of some frameworks on Wikipedia.  is MVC just the SEO of php programming?  MVC and SEO are two things apart, but yes... MVC is getting more popular. ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "apart": 0.13364341666528887,
                "applications": 0.11029448466670645,
                "apps": 0.1151570382335243,
                "architecture": 0.13959470125519366,
                "controller": 0.41878410376558095,
                "data": 0.09667065980175975,
                "elements": 0.13959470125519366,
                "filled": 0.13959470125519366,
                "frameworks": 0.3539010748252451,
                "gets": 0.1211083228234291,
                "getting": 0.10815972912523436,
                "gui": 0.128780863098471,
                "like": 0.05808103175615953,
                "list": 0.09803866255450003,
                "live": 0.257561726196942,
                "page": 0.13364341666528887,
                "php": 0.33088345400011937,
                "popular": 0.128780863098471,
                "programming": 0.06781869252923035,
                "properly": 0.13364341666528887,
                "runtime": 0.128780863098471,
                "software": 0.0817455911838551,
                "sure": 0.10434320007680166,
                "things": 0.07625547439235371,
                "think": 0.07277180715585525,
                "updated": 0.128780863098471,
                "use": 0.1265184255041811,
                "used": 0.0781842813699952,
                "view": 0.41878410376558095,
                "views": 0.13959470125519366,
                "web": 0.09948064650998381,
                "yes": 0.10434320007680166
            },
            "Max term": "controller",
            "Max score": 0.41878410376558095
        }
    },
    {
        "ID:": "2829",
        "Question": "I originally thought of creative commons when while reading a book about wordpress (professional wordpress), I learned that I should also specify that the product is provided   ... WITHOUT ANY WARRANTY; without even the   implied warranty of MERCHANTABILITY or   FITNESS FOR A PARTICULAR PURPOSE  and they recommend GNU GPL.  How do I write a license or select 1? btw, what does MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE mean actually? Isn't without warranty enough?  ",
        "TF-IDF scores": [
            {
                "Scores": {
                    "actually": 0.17263602527648447,
                    "book": 0.18962376996862707,
                    "learned": 0.22997894482758482,
                    "license": 0.2492904716257685,
                    "mean": 0.2056492983912157,
                    "originally": 0.22997894482758482,
                    "particular": 0.3939313434257072,
                    "product": 0.20110985700742112,
                    "professional": 0.2386625715059469,
                    "provided": 0.22997894482758482,
                    "purpose": 0.4325543970220746,
                    "reading": 0.19315339079564006,
                    "recommend": 0.2386625715059469,
                    "select": 0.2492904716257685,
                    "thought": 0.22997894482758482,
                    "write": 0.14878505709450626
                },
                "Max term": "purpose",
                "Max score": 0.4325543970220746
            }
        ],
        "Best Answer": "For small bits of code, I generally release them under the X11 licence. The problem with the GPL is that it's far too complicated for code that you don't really care enough about to protect. If you really don't want people using your code in commercial products, you would need to monitor for infringement and fight it out in court, which isn't really worth the time or the effort for small, free, open-source projects.  Copyright (c)   Permission is hereby granted, free of charge, to any person obtaining a copy    of this software and associated documentation files (the \"Software\"), to deal    in the Software without restriction, including without limitation the rights    to use, copy, modify, merge, publish, distribute, sublicense, and/or sell    copies of the Software, and to permit persons to whom the Software is    furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in    all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN    THE SOFTWARE.   EDIT: If the body of code is more substantial, and you feel that you've invested enough time in it that you would be willing to protect it, by all means use the GPL to protect it. ",
        "Best Answer TF-IDF scores": {
            "Scores": {
                "authors": 0.10711925719726284,
                "bits": 0.10711925719726284,
                "body": 0.10711925719726284,
                "care": 0.10255248511416847,
                "charge": 0.10711925719726284,
                "claim": 0.10711925719726284,
                "code": 0.17731855414606507,
                "commercial": 0.10711925719726284,
                "complicated": 0.09882116063354066,
                "connection": 0.0956663707367272,
                "contract": 0.10255248511416847,
                "copy": 0.1976423212670813,
                "deal": 0.09882116063354066,
                "documentation": 0.09293356742485506,
                "edit": 0.08641621301123119,
                "effort": 0.0956663707367272,
                "event": 0.10255248511416847,
                "far": 0.08641621301123119,
                "feel": 0.08148068096431943,
                "files": 0.09052306406981847,
                "following": 0.09293356742485506,
                "free": 0.1913327414734544,
                "generally": 0.08836679534176069,
                "granted": 0.10255248511416847,
                "included": 0.10711925719726284,
                "including": 0.21423851439452568,
                "kind": 0.09293356742485506,
                "limited": 0.10711925719726284,
                "means": 0.08463547086113288,
                "modify": 0.10711925719726284,
                "monitor": 0.09882116063354066,
                "need": 0.061045165088284344,
                "notice": 0.20510497022833693,
                "open": 0.08148068096431943,
                "particular": 0.08463547086113288,
                "people": 0.055428643713850756,
                "person": 0.08463547086113288,
                "problem": 0.06729499119191165,
                "products": 0.10711925719726284,
                "projects": 0.07874787765244728,
                "provided": 0.09882116063354066,
                "purpose": 0.09293356742485506,
                "really": 0.1847728422403216,
                "release": 0.0956663707367272,
                "sell": 0.10711925719726284,
                "small": 0.15749575530489457,
                "software": 0.5645539719793555,
                "source": 0.08148068096431943,
                "subject": 0.10255248511416847,
                "time": 0.11004674116745332,
                "use": 0.14562758800922848,
                "using": 0.06272821910881728,
                "want": 0.059490066065024855,
                "willing": 0.10255248511416847,
                "worth": 0.07874787765244728
            },
            "Max term": "software",
            "Max score": 0.5645539719793555
        }
    }
]