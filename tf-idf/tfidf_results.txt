Question 1:
A coworker of mine believes that any use of in-code comments (ie, not javadoc style method or class comments) is a code smell.  What do you think?


TF-IDF Scores:
class: 0.3302
code: 0.3388
comments: 0.6753
method: 0.3551
style: 0.3377
think: 0.2134
use: 0.1855

Termine con il punteggio TF-IDF più alto: comments (0.6753)

Best Answer:
Only if the comment describes what the code is doing.
If I wanted to know what was happening in a method or block, I would read the code. I would hope, anyway, that any developers working on a given project were at least familiar enough with the development language to read what is written and understand what it is doing.
In some cases of extreme optimization, you might be using techniques that makes it difficult for someone to follow what your code is doing. In these cases, comments can and should be used to not only explain why you have such optimizations, but what the code is doing. A good rule of thumb would be to have someone else (or multiple other people) familiar with the implementation language and project look at your code - if they can't understand both the why and the how, then you should comment both the why and the how.
However, what's not clear in the code is why you have done something. If you take an approach that might not be obvious to others, you should have a comment that explains why you made the decisions that you did. I would suspect that you might not even realize that a comment is needed until after something like a code review, where people want to know why you did X instead of Y - you can capture your answer in the code for everyone else who looks at it in the future.
The most important thing, though, is to change your comments when you change your code. If you change an algorithm, be sure to update the comments with why you went with algorithm X over Y. Stale comments are an even bigger code smell.


TF-IDF Scores:
algorithm: 0.2009
answer: 0.0717
approach: 0.0866
bigger: 0.1005
cases: 0.1731
change: 0.2180
clear: 0.0968
code: 0.4343
comment: 0.4197
comments: 0.3463
developers: 0.0737
development: 0.0620
difficult: 0.0910
explain: 0.0737
familiar: 0.2099
follow: 0.0887
given: 0.0910
good: 0.0573
implementation: 0.1005
important: 0.0748
instead: 0.0784
know: 0.1111
language: 0.1119
like: 0.0437
look: 0.0748
looks: 0.0937
makes: 0.0759
method: 0.0910
multiple: 0.0937
needed: 0.0910
obvious: 0.0968
people: 0.1086
project: 0.1196
read: 0.1543
realize: 0.1005
review: 0.1005
rule: 0.1005
sure: 0.0784
suspect: 0.1049
techniques: 0.0968
thing: 0.0784
understand: 0.1380
update: 0.1049
used: 0.0588
using: 0.0614
want: 0.0583
went: 0.0910
working: 0.0690
written: 0.0937

Termine con il punteggio TF-IDF più alto: code (0.4343)

----------------------------------------------------------------------------------------------------

Question 4:
When starting a project for a company that's not primarily a programming company, one of the expectations is that there's a finished product at the end free of all bugs and does everything needed right away. However, that's rarely the case. 
What are some ways to manage expectations and explain to non-programmers how software development differs from other types of product development?


TF-IDF Scores:
away: 0.1987
bugs: 0.1795
case: 0.1758
company: 0.3220
development: 0.2631
end: 0.1610
expectations: 0.4450
explain: 0.1563
free: 0.1987
needed: 0.1930
non: 0.1563
product: 0.3590
programmers: 0.1383
programming: 0.1081
project: 0.1268
rarely: 0.2225
right: 0.1610
software: 0.1303
starting: 0.1930
types: 0.1930
ways: 0.1795

Termine con il punteggio TF-IDF più alto: expectations (0.4450)

Best Answer:
Pretty much everybody with a computer has encountered the concept of "bugs" these days, so you might start there.  "What's the most annoying way an application has ever failed on you?  Multiply that by ten, and you'll have our users' experience if we don't devote enough resources to testing and maintenance."
And don't underestimate the value of establishing a good working relationship with the non-programmers.  If you can establish that your judgment may be trusted, they'll take you seriously when you sound the alarm that X is going to fail spectacularly if you don't do Y pronto, even if they don't completely understand your reasoning.


TF-IDF Scores:
annoying: 0.2193
application: 0.1747
bugs: 0.1917
completely: 0.2009
computer: 0.1842
concept: 0.2123
days: 0.2009
encountered: 0.2377
experience: 0.1582
fail: 0.2275
failed: 0.2193
going: 0.1694
good: 0.1298
non: 0.1669
pretty: 0.1720
programmers: 0.1477
reasoning: 0.2377
resources: 0.2275
seriously: 0.2377
sound: 0.2377
start: 0.1624
testing: 0.1777
understand: 0.1563
users: 0.1808
value: 0.2009
way: 0.1331
working: 0.1563

Termine con il punteggio TF-IDF più alto: encountered (0.2377)

----------------------------------------------------------------------------------------------------

Question 9:
Sometimes, the things I have to do for my job are interesting and engaging.  Sometimes, they aren't.  Occasionally, they really aren't.
Do you have any particular strategies or tricks for dealing with those dull stretches when your brain would rather be doing anything other than what you're supposed to be doing, particularly when the Internet and its boundless opportunities for interesting Slack beckon?


TF-IDF Scores:
dealing: 0.3445
interesting: 0.5338
internet: 0.3178
job: 0.2353
particular: 0.2722
particularly: 0.3178
really: 0.1981
supposed: 0.2989
things: 0.1882
tricks: 0.3178

Termine con il punteggio TF-IDF più alto: interesting (0.5338)

Best Answer:
Increments. I will pick something that I can do, even if it's a small task (i.e. modify comments in code). Pretty soon, the perfectionist in me wants to do more and more stuff and I'm back rolling.


TF-IDF Scores:
code: 0.1613
comments: 0.3215
modify: 0.3897
pick: 0.3481
pretty: 0.2820
small: 0.2865
soon: 0.3731
stuff: 0.3020
task: 0.3020
wants: 0.3381

Termine con il punteggio TF-IDF più alto: modify (0.3897)

----------------------------------------------------------------------------------------------------

Question 16:
I have read a few articles on Internet about programming language choice in the enterprise. Recently many dynamic typed languages have been popular, i.e. Ruby, Python, PHP and Erlang. But many enterprises still stay with static typed languages like C, C++, C# and Java.
And yes, one of the benefits of static typed languages is that programming errors are caught earlier, at compile time, rather than at run time. But there are also advantages with dynamic typed languages. (more on Wikipedia)
The main reason why enterprises don't start to use languages like Erlang, Ruby and Python, seem to be the fact that they are dynamic typed. That also seem to be the main reason why people on StackOverflow decide against Erlang. See Why did you decide "against" Erlang.
However, there seem to be a strong criticism against dynamic typing in the enterprises, but I don't really get it why it is that strong.
Really, why is there so much criticism against dynamic typing in the enterprises? Does it really affect the cost of projects that much, or what? But maybe I'm wrong.


TF-IDF Scores:
advantages: 0.0947
articles: 0.0907
benefits: 0.0907
caught: 0.0947
choice: 0.0781
compile: 0.0907
cost: 0.0822
decide: 0.1748
earlier: 0.0874
enterprise: 0.0907
enterprises: 0.3789
erlang: 0.3628
errors: 0.0781
fact: 0.0748
internet: 0.0874
java: 0.0647
language: 0.0505
languages: 0.3078
like: 0.0788
main: 0.1563
maybe: 0.0801
people: 0.0490
php: 0.0748
popular: 0.0874
programming: 0.0920
projects: 0.0696
python: 0.1528
read: 0.0696
really: 0.1634
reason: 0.1416
recently: 0.0846
ruby: 0.1748
run: 0.0801
stackoverflow: 0.0947
start: 0.0647
static: 0.1895
stay: 0.0874
strong: 0.1748
time: 0.0973
typed: 0.4230
typing: 0.1692
use: 0.0429
wrong: 0.0764
yes: 0.0708

Termine con il punteggio TF-IDF più alto: typed (0.4230)

Best Answer:

The main reason why enterprises don't start to use languages like Erlang, Ruby and Python, seem to be the fact that they are dynamic typed.

I think this is only their primary excuse. The real reason is that businesses don’t really take them all that seriously and feel that they are perhaps a bit too amateur. Java and .NET are “big business names”, have good commercial marketing, commercial customer support, and are thus widely taken very seriously indeed.
It is unfortunate that there is practically no statically-typed language that is anywhere near as popular as the big business names. Why are open-source/free-software programming environments almost always dynamically typed? This might indicate that a statically-typed language is actually not that easy to make, and that dynamic typing is a “lazy man’s hack”. If that is the case, the businesses who decide against dynamically-typed languages might actually have a point.


TF-IDF Scores:
actually: 0.1605
big: 0.1796
bit: 0.0898
business: 0.1912
case: 0.0916
commercial: 0.2318
customer: 0.0979
decide: 0.1069
dynamically: 0.2318
easy: 0.0866
enterprises: 0.1159
environments: 0.1159
erlang: 0.1109
fact: 0.0916
feel: 0.0882
free: 0.1035
good: 0.0633
java: 0.0792
language: 0.1236
languages: 0.1506
like: 0.0482
main: 0.0956
make: 0.0649
man: 0.1109
names: 0.2318
net: 0.0852
open: 0.0882
point: 0.0826
popular: 0.1069
practically: 0.1159
primary: 0.1159
programming: 0.0563
python: 0.0935
real: 0.0852
really: 0.0666
reason: 0.1732
ruby: 0.1069
seriously: 0.2318
software: 0.0679
source: 0.0882
start: 0.0792
statically: 0.2318
support: 0.1005
taken: 0.1035
think: 0.0604
typed: 0.5175
typing: 0.1035
use: 0.0525

Termine con il punteggio TF-IDF più alto: typed (0.5175)

----------------------------------------------------------------------------------------------------

Question 18:
At first glance, I'd say a good programming team needs to understand the following matters:

The details of the core language / framework
HTML, (asynchronous) javascript
SQL / data model
Usability / UI design
Security
Project management.

If this team is not complete: what is needed?


TF-IDF Scores:
complete: 0.2143
core: 0.2536
data: 0.1756
design: 0.1629
details: 0.2143
following: 0.2200
framework: 0.1929
good: 0.1385
html: 0.2340
javascript: 0.2200
language: 0.1353
management: 0.1929
model: 0.2143
needed: 0.2200
needs: 0.2200
programming: 0.1232
project: 0.1445
say: 0.1499
security: 0.2265
sql: 0.2536
team: 0.3513
ui: 0.2340
understand: 0.1668

Termine con il punteggio TF-IDF più alto: team (0.3513)

Best Answer:
Customer (or an advocate of some sort).  
Basically, someone that can say, "Yes, you're building what I want and it's going to solve my problem." or that the team can go to when they have questions about how something is supposed to work.  That may or may not be the same person that is doing Project Management.
Also, you're missing out on a QA person there.  You can't really depend on the developers to adequately test - they're usually too close to the code and the normal response for developers is to test happy path stuff, not doing weird crap like copy pasting War & Peace into a textbox and seeing what the application does.


TF-IDF Scores:
adequately: 0.1982
advocate: 0.1982
application: 0.1457
building: 0.1898
close: 0.1829
code: 0.0820
copy: 0.1829
customer: 0.1675
developers: 0.2785
going: 0.1413
like: 0.0825
management: 0.1508
normal: 0.1898
path: 0.1898
person: 0.3133
problem: 0.1245
project: 0.1130
qa: 0.1982
questions: 0.1457
really: 0.1140
say: 0.1172
seeing: 0.1982
solve: 0.1599
sort: 0.1982
stuff: 0.1536
supposed: 0.1720
team: 0.1373
test: 0.2674
usually: 0.1457
want: 0.1101
war: 0.1898
work: 0.1033
yes: 0.1482

Termine con il punteggio TF-IDF più alto: person (0.3133)

----------------------------------------------------------------------------------------------------

Question 38:
Where waterfall commonly includes:

Requirements
Functional design
Technical design
Build
Test
Review
(Deploy)

And iterations across this list. If I forgot a step, let me know.


TF-IDF Scores:
build: 0.2960
commonly: 0.3173
design: 0.4258
functional: 0.2674
know: 0.1754
let: 0.2876
list: 0.2328
requirements: 0.2801
review: 0.3173
step: 0.3058
technical: 0.2619
test: 0.2235

Termine con il punteggio TF-IDF più alto: design (0.4258)

Best Answer:
It depends on many factors, including:

The domain (eg, I'd spend more time on a defense contract's requirements than I would on a Twitter clone)
The developers (if they have experience building similar systems with similar technology, for example, I might spend less time on the design).
The customers (How likely the requirements are to change affects how long that phase will take)
The criticality of the system (I'll spend more time testing the space shuttle's launch system than I will the StackExchange rep system).

I'd give you a rough breakdown of what percent of the total effort I'd give to each section, but it'd have a margin of error +/- 10% on each based on the above factors so it'd be kinda meaningless.


TF-IDF Scores:
10: 0.1418
based: 0.1300
building: 0.1607
change: 0.1162
contract: 0.1607
customers: 0.1548
depends: 0.1456
design: 0.1078
developers: 0.1179
domain: 0.1607
effort: 0.1499
error: 0.1418
example: 0.1022
experience: 0.1117
factors: 0.3357
including: 0.1678
likely: 0.1354
long: 0.1091
phase: 0.1548
requirements: 0.2837
rough: 0.1678
section: 0.1607
similar: 0.2652
space: 0.1499
spend: 0.4255
systems: 0.1548
testing: 0.1255
time: 0.2586
twitter: 0.1607

Termine con il punteggio TF-IDF più alto: spend (0.4255)

----------------------------------------------------------------------------------------------------

Question 39:
What's your favourite quote about programming?
One quote per answer, and please check for duplicates before posting!


TF-IDF Scores:
answer: 0.3793
check: 0.4387
favourite: 0.5552
posting: 0.5316
programming: 0.2698

Termine con il punteggio TF-IDF più alto: favourite (0.5552)

Best Answer:

Debugging is twice as hard as writing the code in the first place. Therefore, if you write the code as cleverly as possible, you are, by definition, not smart enough to debug it.  

— Brian W. Kernighan


TF-IDF Scores:
code: 0.4085
definition: 0.4725
hard: 0.3824
place: 0.3824
possible: 0.3418
write: 0.2946
writing: 0.3372

Termine con il punteggio TF-IDF più alto: definition (0.4725)

----------------------------------------------------------------------------------------------------

Question 42:
We've all had them, managers who have either come from sales or last looked at code 10 or more years ago but think they know how to write code.
What can I do to give the impression that I'm grateful for their intervention, but keep it as short as possible so I can get on with my work?
Or, should I be engaging more with the manager to educate them with modern coding techniques and practices? After all, a manager who understands these will be able to talk sensibly to clients and more senior management when discussing the project and its timescales.


TF-IDF Scores:
10: 0.2020
able: 0.2020
ago: 0.2135
clients: 0.2391
code: 0.1979
coding: 0.1572
come: 0.1972
know: 0.1265
management: 0.1818
manager: 0.4411
modern: 0.2391
possible: 0.1656
practices: 0.1972
project: 0.1362
sales: 0.2289
senior: 0.2289
short: 0.2135
talk: 0.2205
techniques: 0.2205
think: 0.1246
work: 0.1246
write: 0.1427
years: 0.1679

Termine con il punteggio TF-IDF più alto: manager (0.4411)

Best Answer:
I say, go ahead and try to engage and educate.
If they're honestly trying to help you, the chance to learn something could be valuable to them.  If they're just shoving their nose in for ego or political reasons ("See, I'm helping, I'm helping!"), they'll likely get the notion you'll embarrass them if they keep this nonsense up -- or bore them to death with a wall of jargon they're only pretending to understand.
And if you've got the dreaded egomaniac who truly thinks they're an expert at your job no matter what evidence you can bring to the contrary, then smile, nod, and make whatever trivial cosmetic changes will make them go the hell away.  And update your resume.


TF-IDF Scores:
away: 0.2380
bring: 0.2665
chance: 0.2459
changes: 0.2199
evidence: 0.2459
expert: 0.2552
got: 0.2199
help: 0.1797
job: 0.1821
learn: 0.1753
likely: 0.2150
make: 0.2985
matter: 0.2380
reasons: 0.2199
say: 0.1575
trivial: 0.2459
try: 0.1732
trying: 0.1899
understand: 0.1753
update: 0.2665

Termine con il punteggio TF-IDF più alto: make (0.2985)

----------------------------------------------------------------------------------------------------

Question 44:
I am finishing my college degree in programming soon and I'm exploring the next steps to take to further my career. One option I've been considering is getting a certification or a series of certifications in the area of development I want to work in.
Are these certifications worth the time and money? Do employers place a lot of value in them?


TF-IDF Scores:
career: 0.2285
college: 0.2876
considering: 0.2876
degree: 0.2876
development: 0.1776
getting: 0.2327
lot: 0.1908
money: 0.2683
option: 0.3004
place: 0.2327
programming: 0.1459
soon: 0.2876
steps: 0.2606
time: 0.1543
value: 0.2538
want: 0.1668
work: 0.1566
worth: 0.2208

Termine con il punteggio TF-IDF più alto: option (0.3004)

Best Answer:
The main purpose of certifications is to make money for the certifying body.
Having said that, I think certifications are more important the earlier on in your career you are. As a hiring manager, I never use certifications or the lack thereof to filter potential employees, but I do think some companies may look for these as proof that you know what you are doing. Personally, I want the job candidate to show me they can do something (which is a whole other question, I realize!)
The more experience you have, the more you can prove by examples that you know what you are doing and the less important certifications become.


TF-IDF Scores:
body: 0.2203
candidate: 0.2203
career: 0.1676
companies: 0.1967
earlier: 0.2032
examples: 0.1817
experience: 0.1467
hiring: 0.2203
important: 0.3140
job: 0.1505
know: 0.2332
lack: 0.2032
look: 0.1570
main: 0.1817
make: 0.1234
manager: 0.2032
money: 0.1967
personally: 0.1777
potential: 0.1967
prove: 0.2203
purpose: 0.1911
question: 0.1315
realize: 0.2109
said: 0.1647
think: 0.2297
use: 0.0998
want: 0.1223

Termine con il punteggio TF-IDF più alto: important (0.3140)

----------------------------------------------------------------------------------------------------

Question 49:
During my four years at university we have been using much functional programming in several functional programming languages. But I have also used much object oriented programming to, and in fact I use object oriented languages more when doing my own small project to prepare for my first job. But I often wish that I was coding in a functional programming language when doing these projects.
However, when looking for a job, it is very rare to see a job where knowledge of a functional programming language is required.
Why isn't functional programming languages used more in the industry? There is quite much news about functional programming languages these days, so I wonder if functional programming is catching on in the industry now?


TF-IDF Scores:
coding: 0.0735
days: 0.0944
fact: 0.0883
functional: 0.6310
industry: 0.2139
job: 0.2290
knowledge: 0.0850
language: 0.1192
languages: 0.2904
looking: 0.0866
object: 0.2139
oriented: 0.1888
prepare: 0.1070
programming: 0.4343
project: 0.0637
projects: 0.0821
quite: 0.0883
required: 0.0998
small: 0.0821
university: 0.1070
use: 0.0506
used: 0.1252
using: 0.0654
wonder: 0.1070
years: 0.0785

Termine con il punteggio TF-IDF più alto: functional (0.6310)

Best Answer:
I would say that one of the reasons that functional programming is not more prevalent is the lack of knowledge base.  My experience is that corporations are very risk averse in terms of implementing technologies that are not main stream and would rather invest in tried and true frameworks (java, c++, c#).  It's only when there is a business need (like in Ericsson) that new paradigms are considered.  But even in Ericsson's case I heard that management demanded that c++ be used and Joe Armstrong was compelled to code erlang calls in c++!! This should show how reluctant corporations are to implement new technologies!


TF-IDF Scores:
base: 0.1946
business: 0.1741
calls: 0.1884
case: 0.1667
code: 0.0873
considered: 0.1884
erlang: 0.2020
experience: 0.1405
frameworks: 0.1783
functional: 0.1702
heard: 0.1783
implement: 0.1884
java: 0.1441
knowledge: 0.1605
lack: 0.1946
like: 0.0878
main: 0.1741
management: 0.1605
need: 0.1202
new: 0.2426
paradigms: 0.2020
programming: 0.1025
reasons: 0.1741
risk: 0.2020
say: 0.1247
technologies: 0.3893
terms: 0.2110
tried: 0.1884
true: 0.1783
used: 0.1182

Termine con il punteggio TF-IDF più alto: technologies (0.3893)

----------------------------------------------------------------------------------------------------

Question 57:
The coding standards for the code hosted in drupal.org suggest to use two spaces to indent the code; other sites suggest to use tabs to indent the code.
What is the proper indentation character for everything, and in every situation? Please explain the answer you give.


TF-IDF Scores:
answer: 0.1848
character: 0.2495
code: 0.3358
coding: 0.1779
explain: 0.1900
indent: 0.5409
org: 0.2705
proper: 0.2589
sites: 0.2346
situation: 0.2286
spaces: 0.2705
standards: 0.2231
use: 0.2451

Termine con il punteggio TF-IDF più alto: indent (0.5409)

Best Answer:
Tabs
Now, of course, consistency matters more than either one, and a good IDE makes the differences negligible.  That said, the point of this thread is to be a holy war, so:
I prefer tabs:

They're a character specifically meant for indentation
They allow developers with different preferences in indentation size to change how it's the code looks without changing the code (separation of data and presentation for the proverbial win!)
It's impossible to half-indent something with tabs.  So when you copy code from some website that used 3 spaces into your 4-space indented file, you don't have to deal with misalignment.



TF-IDF Scores:
allow: 0.1927
change: 0.1394
changing: 0.1927
character: 0.1857
code: 0.2499
consistency: 0.2012
copy: 0.1857
course: 0.1701
data: 0.1394
deal: 0.1857
developers: 0.1413
different: 0.1394
file: 0.1559
good: 0.1099
half: 0.2012
ide: 0.1746
impossible: 0.2012
indent: 0.2012
looks: 0.1797
makes: 0.1456
meant: 0.2012
point: 0.1434
prefer: 0.1797
said: 0.1504
size: 0.1797
space: 0.1797
spaces: 0.2012
specifically: 0.1857
used: 0.1127
war: 0.1927
website: 0.1746
win: 0.1857

Termine con il punteggio TF-IDF più alto: code (0.2499)

----------------------------------------------------------------------------------------------------

Question 73:
We often receive last minute requests from the business asking for an extra feature to be implemented.  The project manager is usually responsible for filtering out these requests as "must haves" or "nice to have", but there are cases where the business wants to squeeze all these features into a release.   Is there a good way to say NO to the business?  What steps can be taken to stop or minimize scope creep?


TF-IDF Scores:
asking: 0.1817
business: 0.5573
cases: 0.1858
extra: 0.2077
feature: 0.1713
features: 0.1779
good: 0.1230
implemented: 0.1858
manager: 0.2077
minute: 0.2252
nice: 0.1954
project: 0.1283
release: 0.2011
say: 0.1331
scope: 0.2252
steps: 0.1954
stop: 0.2252
taken: 0.2011
usually: 0.1655
wants: 0.1954
way: 0.1261

Termine con il punteggio TF-IDF più alto: business (0.5573)

Best Answer:
Ask them what they want you to drop so you'll have the time to squeeze this latest request in.
I've not had to do this for a while, and when I did, I used it sparingly otherwise it loses it's potency.
I found it most effective towards the end of the phase when you were tidying stuff up or doing the little improvements and tweaks you'd agreed on in the planning stage.


TF-IDF Scores:
ask: 0.2534
drop: 0.3246
effective: 0.3028
end: 0.2453
little: 0.2865
phase: 0.3128
planning: 0.3128
request: 0.3391
stage: 0.3391
stuff: 0.2627
time: 0.1742
used: 0.1899
want: 0.1883

Termine con il punteggio TF-IDF più alto: request (0.3391)

----------------------------------------------------------------------------------------------------

Question 94:
I realize there have been lots of discussions about this type of thing and they often devolve into dogma around whether you ask the "100 logical pirates" type of questions or whether you get them to write "fizz buzz". 
I'm interested in what techniques and questions have been effective for you when interviewing potential developers for jobs. 
One technique per answer so we can vote on them, please.


TF-IDF Scores:
100: 0.2283
answer: 0.1746
ask: 0.1911
developers: 0.1795
effective: 0.2283
interested: 0.2109
interviewing: 0.2358
jobs: 0.2447
logical: 0.2358
lots: 0.2218
potential: 0.2283
questions: 0.3758
realize: 0.2447
techniques: 0.2358
thing: 0.1911
type: 0.4039
write: 0.1526

Termine con il punteggio TF-IDF più alto: type (0.4039)

Best Answer:
Besides real technical questions, and typically at the end of the interview I try to get a grasp of their level of interest in the industry and it's culture with questions like:

Have you seen anything recently programming-related that you found interesting and would like to recommend to other fellow programmers? A new language, tool, platform, technique, website?
Can you name any well known person in our industry whose work you like or find inspiring and why? (developer, web site founder, author, speaker, etc)
What are you reading now or what was the last software related book you read?
What programming related sites do you frequent?

Although failing to answer these questions at all (sadly it happens very frequently) does not mean a 'no-hire' to me, they say a lot about the way a person approaches the software development profession.


TF-IDF Scores:
answer: 0.1033
approaches: 0.1395
author: 0.1448
book: 0.1151
developer: 0.1020
development: 0.0894
end: 0.1094
frequently: 0.1278
happens: 0.1448
hire: 0.1513
industry: 0.2896
interesting: 0.1172
interview: 0.1312
known: 0.1513
language: 0.0807
level: 0.1172
like: 0.1888
lot: 0.0961
mean: 0.1248
new: 0.0870
person: 0.2390
platform: 0.1448
programmers: 0.0940
programming: 0.1470
questions: 0.3336
read: 0.1112
reading: 0.1172
real: 0.1112
recently: 0.1351
recommend: 0.1448
related: 0.3937
say: 0.0894
seen: 0.1094
site: 0.1278
sites: 0.1312
software: 0.1771
technical: 0.1195
tool: 0.1248
try: 0.0983
way: 0.0847
web: 0.1078
website: 0.1312
work: 0.0789

Termine con il punteggio TF-IDF più alto: related (0.3937)

----------------------------------------------------------------------------------------------------

Question 104:
We've often run across scenarios where the business will promise a client a new feature.  The business will promise that the feature be implemented in a specific way.  These technical details promised by the business are usually poor.  Unfortunately, client is now set and want this feature to be implemented in the way described by the business.
In the end, the business just wants this feature to be completed without regard to quality and maintainability.  Is there a good way to push back?  How can we explain to the business that providing technical details before the requirements have been gathered is a bad idea?


TF-IDF Scores:
bad: 0.0948
business: 0.6171
client: 0.2300
completed: 0.1247
details: 0.2107
end: 0.0902
explain: 0.0876
feature: 0.3793
good: 0.0681
idea: 0.0985
implemented: 0.2057
new: 0.0717
poor: 0.1247
promise: 0.2387
push: 0.1247
quality: 0.1006
requirements: 0.1054
run: 0.1054
scenarios: 0.1194
set: 0.0917
specific: 0.0985
technical: 0.1970
unfortunately: 0.1247
usually: 0.0917
want: 0.0692
wants: 0.1082
way: 0.2095

Termine con il punteggio TF-IDF più alto: business (0.6171)

Best Answer:
That's an organizational issue.  If the higher-ups don't understand this, there's not much you can do.  Try to explain the issue to your non-technical bosses, but don't be surprised when you get nowhere.
It's is a common problem for developers working in non-development companies that, for whatever reason, sell software.
It's not a pleasant tactic, but you can just bludgeon them with evidence.  At the start of a project, write down exactly why it's going to fail (because technical details were poor) and email it to relevant people.  Keep emailing them throughout, and when the project eventually ends up a disaster with pissed off customers, cite those emails you sent at every opportunity.  It may generate some ill will, but there's really no good way to try to fix a systemic issue like that.


TF-IDF Scores:
common: 0.1183
companies: 0.1504
customers: 0.1554
details: 0.1424
developers: 0.1183
development: 0.0996
email: 0.1554
emails: 0.1613
ends: 0.1685
eventually: 0.1685
evidence: 0.1554
exactly: 0.1554
explain: 0.1183
fail: 0.1613
fix: 0.1359
generate: 0.1685
going: 0.1200
good: 0.0920
higher: 0.1504
issue: 0.3916
like: 0.0701
non: 0.2366
opportunity: 0.1554
organizational: 0.1685
people: 0.0872
poor: 0.1685
problem: 0.1058
project: 0.1920
really: 0.0969
reason: 0.1259
relevant: 0.1331
sell: 0.1685
software: 0.0986
start: 0.1151
technical: 0.2662
try: 0.2190
understand: 0.1108
way: 0.0943
working: 0.1108
write: 0.1005

Termine con il punteggio TF-IDF più alto: issue (0.3916)

----------------------------------------------------------------------------------------------------

Question 134:
How do you bill your programming projects? Do you do it per hour? Per job? 
Please include what kind of project you are doing in the answer. (Mobile, Web, Desktop, etc... You can be more specific if you want.)
BONUS:
If you'd like to give specific amounts in your answer, you may. ;-)


TF-IDF Scores:
answer: 0.4300
desktop: 0.2730
include: 0.2730
job: 0.2150
kind: 0.2730
like: 0.1309
mobile: 0.3013
programming: 0.1529
project: 0.1794
projects: 0.2314
specific: 0.4973
want: 0.1748
web: 0.2243

Termine con il punteggio TF-IDF più alto: specific (0.4973)

Best Answer:
There's always going to be a struggle between you and the client over costs: you want to charge as much as you can from a client, and a client is going to want to get as much work for as little cost as possible.
So, when you charge hourly, it leaves open to negotiation how many hours a project should take to complete. You may think it'll take 10 hours, but your client thinks you should do it in 5.
By charging by project, there's very little open to negotiation: it costs $X, and the client can take it or leave it.


TF-IDF Scores:
10: 0.1244
charge: 0.2945
client: 0.6792
complete: 0.1244
cost: 0.1277
costs: 0.2945
going: 0.2099
hours: 0.2630
leave: 0.1244
little: 0.2489
open: 0.2240
possible: 0.1020
project: 0.1678
think: 0.0768
want: 0.1636
work: 0.0768

Termine con il punteggio TF-IDF più alto: client (0.6792)

----------------------------------------------------------------------------------------------------

Question 135:
Who in the software engineering and software development fields uses Twitter to tweet about relevant happenings in the field?


TF-IDF Scores:
development: 0.2458
engineering: 0.3981
field: 0.3836
relevant: 0.3286
software: 0.4871
twitter: 0.3981
uses: 0.3608

Termine con il punteggio TF-IDF più alto: software (0.4871)

Best Answer:
I'll probably get flamed for this but...
140 characters is hardly the format to get any real pearls of programming wisdom.  Most (but not all) programming concepts/thoughts/ideas require more space to be articulated. I would follow the blogs of the list of programmers that everyone is suggesting.


TF-IDF Scores:
characters: 0.3101
concepts: 0.3101
follow: 0.2737
format: 0.2988
hardly: 0.3239
list: 0.2275
probably: 0.2381
programmers: 0.2013
programming: 0.3147
real: 0.2381
require: 0.2464
space: 0.2893
wisdom: 0.2988

Termine con il punteggio TF-IDF più alto: hardly (0.3239)

----------------------------------------------------------------------------------------------------

Question 163:
Are there any great programming or software development books that are language agnostic?  Why should I read it?


TF-IDF Scores:
agnostic: 0.4861
books: 0.4096
development: 0.3001
great: 0.3795
language: 0.2708
programming: 0.2467
read: 0.3732
software: 0.2973

Termine con il punteggio TF-IDF più alto: agnostic (0.4861)

Best Answer:
The Pragmatic Programmer: From Journeyman to Master - Andrew Hunt and David Thomas
This book is all about how to write code that works and is maintainable. A key concept is being practical. Everything in the book is boiled down to 70 tips that are easy to remember that help you deliver better, higher-quality software.


TF-IDF Scores:
better: 0.1702
book: 0.4031
code: 0.1096
concept: 0.2366
deliver: 0.2537
easy: 0.1980
help: 0.1787
higher: 0.2366
key: 0.2537
maintainable: 0.2537
master: 0.2537
pragmatic: 0.2650
programmer: 0.1702
quality: 0.2137
remember: 0.2239
software: 0.1552
tips: 0.2366
works: 0.2366
write: 0.1581

Termine con il punteggio TF-IDF più alto: book (0.4031)

----------------------------------------------------------------------------------------------------

Question 188:
For the longest time in places like Java's IRC channel, SO, and other places I've been told something along the lines of "Worry about how the code looks and its readability/understandability now, and performance later if absolutely necessary". So for the longest time, I haven't really been OCD about performance for my small desktop or web apps, just removing the obviously inefficient.
Most responses are "What about scalability?". Thats a legitimate point, but if my app was only built to parse, say, files 10,000 lines long, should I make my code a mess for the small percentage of people that are going to shove in a 1,000,000 line file?
My main question is when should I trade the easy but somewhat inefficient ways of doing tasks for big giant complicated beasts that do things extremely quickly but destroy any possible ways of upgrading and make the code excessively difficult and prone to rewriting anyway by the next developer? 


TF-IDF Scores:
000: 0.4193
10: 0.1181
absolutely: 0.1338
app: 0.1128
apps: 0.1153
big: 0.1083
built: 0.1289
code: 0.1735
complicated: 0.1289
desktop: 0.1213
developer: 0.0942
difficult: 0.1213
easy: 0.1045
extremely: 0.1248
file: 0.1083
files: 0.1181
going: 0.0996
java: 0.0955
later: 0.1213
like: 0.0582
line: 0.1063
lines: 0.2497
long: 0.0908
looks: 0.1248
main: 0.1153
make: 0.1566
necessary: 0.1289
obviously: 0.1213
parse: 0.1398
people: 0.0723
performance: 0.2497
places: 0.2497
point: 0.0996
possible: 0.0968
question: 0.0834
quickly: 0.1213
readability: 0.1289
really: 0.0804
say: 0.0826
small: 0.2055
somewhat: 0.1289
tasks: 0.1128
things: 0.0764
time: 0.1436
told: 0.1338
ways: 0.2255
web: 0.0996

Termine con il punteggio TF-IDF più alto: 000 (0.4193)

Best Answer:
Worry about performance when it becomes a problem.
If you write a small app to process 10,000 line files and you get a 1,000,000 line file every 100th file, it probably doesn't matter that it takes longer to process that one file. However, if you are regularly getting files that are 5-10 times larger than initially and your application is taking too long to do its job, then you start profiling and optimizing.
Now, I said "too long to do its job". That is up to the user or sponsoring organization to decide. If I'm doing a task and it takes me 5 minutes to do something when it took me 3 without the software or with a different tool, I'd probably file a bug report or maintenance request to have that improved.
If you are the user, how long you want your software to take to do its job is up to you - only you can decide if you want it done faster or if you are willing to wait longer to have more readable code.


TF-IDF Scores:
000: 0.3586
10: 0.2021
app: 0.0964
application: 0.0879
bug: 0.0986
code: 0.0495
decide: 0.2206
different: 0.0828
faster: 0.1068
file: 0.3705
files: 0.2021
getting: 0.0926
initially: 0.1145
job: 0.2450
line: 0.1819
long: 0.2331
longer: 0.2289
matter: 0.1068
organization: 0.1068
performance: 0.1068
probably: 0.1758
problem: 0.0751
process: 0.1730
readable: 0.1195
report: 0.1103
request: 0.1195
said: 0.0894
small: 0.0879
software: 0.1400
start: 0.0817
takes: 0.1853
task: 0.0926
times: 0.0926
took: 0.1145
tool: 0.0986
user: 0.1679
wait: 0.1145
want: 0.1328
willing: 0.1145
write: 0.0714

Termine con il punteggio TF-IDF più alto: file (0.3705)

----------------------------------------------------------------------------------------------------

Question 192:
If I have some code that has 80% test coverage (all tests pass), is it fair to say that it's of higher quality than code with no test coverage?  
Or is it fair to say it's more maintainable?


TF-IDF Scores:
80: 0.2945
code: 0.2437
coverage: 0.5638
higher: 0.2630
maintainable: 0.2819
quality: 0.2376
say: 0.3481
test: 0.3971
tests: 0.2282

Termine con il punteggio TF-IDF più alto: coverage (0.5638)

Best Answer:
By one definition it's more maintainable, as any breaking change is more likely to be caught by the tests.
However, the fact that code passes the unit tests doesn't mean it's intrinsically of higher quality. The code might still be badly formatted with irrelevant comments and inappropriate data structures, but it can still pass the tests.
I know which code I'd prefer to maintain and extend.


TF-IDF Scores:
caught: 0.2219
change: 0.1537
code: 0.2755
comments: 0.1830
data: 0.1537
definition: 0.2124
fact: 0.1753
higher: 0.1982
irrelevant: 0.2124
know: 0.1174
likely: 0.1790
maintain: 0.2219
maintainable: 0.2124
mean: 0.1830
passes: 0.2219
prefer: 0.1982
quality: 0.1790
structures: 0.2124
tests: 0.5158
unit: 0.1688

Termine con il punteggio TF-IDF più alto: tests (0.5158)

----------------------------------------------------------------------------------------------------

Question 206:
Test driven development. I get it, like it.
But writing tests does require overhead. So should TDD be used universally throughout the code base, or are there areas where TDD provides a high ROI and other areas where the ROI is so low that it is not worth following.


TF-IDF Scores:
areas: 0.4495
base: 0.2248
code: 0.1008
development: 0.1440
driven: 0.2059
following: 0.2114
high: 0.2176
like: 0.1014
low: 0.2114
overhead: 0.2436
provides: 0.2436
require: 0.1853
tdd: 0.4227
test: 0.1643
tests: 0.1888
universally: 0.2332
used: 0.1365
worth: 0.1791
writing: 0.1664

Termine con il punteggio TF-IDF più alto: areas (0.4495)

Best Answer:
I'd say avoid TDD in places where the code is likely to change structurally a lot.  Ie, it's great to have a pile of tests for a method whose signature changes rarely but gets refactored internally more frequently, but it sucks to have to fix your tests every time a highly volatile interface changes dramatically.
The apps I've been working on recently have been data-driven webapps built on a Gui->Presenter->BusinessLogic->Data Access Layer-based architecture.  My data access layer is tested like nobody's business.  The business logic layer is pretty well tested.  The Presenters are only tested in the more stable areas, and the GUI, which is changing hourly, has almost no tests.


TF-IDF Scores:
access: 0.2309
apps: 0.1181
architecture: 0.1431
areas: 0.1320
avoid: 0.1155
based: 0.1109
built: 0.1320
business: 0.2361
change: 0.0991
changes: 0.2361
changing: 0.1370
code: 0.0592
data: 0.2973
driven: 0.1209
fix: 0.1155
frequently: 0.1209
gets: 0.1242
great: 0.1070
gui: 0.2641
interface: 0.1431
like: 0.0595
likely: 0.1155
logic: 0.1370
lot: 0.0909
method: 0.1242
places: 0.1278
pretty: 0.1036
rarely: 0.1431
recently: 0.1278
say: 0.0846
stable: 0.1431
tdd: 0.1242
tested: 0.4110
tests: 0.3327
time: 0.0735
working: 0.0941

Termine con il punteggio TF-IDF più alto: tested (0.4110)

----------------------------------------------------------------------------------------------------

Question 215:
Having taken a course in Operating Systems I'm interested in expanding my knowledge of the Linux kernel and practice working with a big system. What are some interesting but not overly difficult projects I can try my hand at? 
EDIT: a bit of background on what I did do with the kernel. 

Implemented a new scheduling policy
Implemented User Threads and a corresponding mutex library (not really kernel hacking but contained kernel related theory)



TF-IDF Scores:
background: 0.1494
big: 0.1334
bit: 0.1334
course: 0.1455
difficult: 0.1494
edit: 0.1389
hand: 0.1588
implemented: 0.2841
interested: 0.1420
interesting: 0.1334
kernel: 0.6887
knowledge: 0.1310
library: 0.1389
new: 0.0990
practice: 0.1455
projects: 0.1266
really: 0.0990
related: 0.1494
systems: 0.1588
taken: 0.1538
theory: 0.1648
threads: 0.1722
try: 0.1119
user: 0.1209
working: 0.1132

Termine con il punteggio TF-IDF più alto: kernel (0.6887)

Best Answer:
I've not done much work on kernels before (they scare me), but I've heard that http://kernelnewbies.org/ is a fantastic resource if you want to get involved in kernel work. As already mentioned SourceForge is a great place to look if you want to get involved in an open-source kernel-related project.
Also, a similar question has been asked on Stack Overflow before, so you may want to look here.
What are some interesting, small Linux kernel projects to help learn the source?


TF-IDF Scores:
asked: 0.1275
great: 0.1297
heard: 0.1466
help: 0.1170
http: 0.1549
interesting: 0.1344
involved: 0.3098
kernel: 0.5204
learn: 0.1141
look: 0.2472
mentioned: 0.1661
open: 0.1319
org: 0.1735
overflow: 0.1505
place: 0.1344
project: 0.0988
projects: 0.1275
question: 0.1035
related: 0.1505
resource: 0.1735
similar: 0.1370
small: 0.1275
source: 0.2639
stack: 0.1505
want: 0.2890
work: 0.1808

Termine con il punteggio TF-IDF più alto: kernel (0.5204)

----------------------------------------------------------------------------------------------------

Question 220:
How would someone implement Agile process concepts as a solo developer?  Agile seems useful for getting applications developed at a faster pace, but it also seems very team oriented...


TF-IDF Scores:
agile: 0.5631
applications: 0.2411
concepts: 0.2922
developer: 0.2058
faster: 0.2726
getting: 0.2365
implement: 0.2726
oriented: 0.2579
process: 0.2208
solo: 0.2922
team: 0.2113
useful: 0.2175

Termine con il punteggio TF-IDF più alto: agile (0.5631)

Best Answer:

By doing test-driven development
By developing in small sprints
By having a lot of contact with the customer

I remember reading a thesis about Cowboy Development, that is essentially Agile for solo developers. The thesis can be read here: Cowboy: An Agile Programming Methodology For a Solo Programmer (PDF)


TF-IDF Scores:
agile: 0.4618
customer: 0.2115
developers: 0.1758
developing: 0.2172
development: 0.2959
driven: 0.2115
essentially: 0.2396
lot: 0.1590
programmer: 0.1608
programming: 0.1216
read: 0.1840
reading: 0.1939
remember: 0.2115
small: 0.1840
solo: 0.4793
test: 0.1688

Termine con il punteggio TF-IDF più alto: solo (0.4793)

----------------------------------------------------------------------------------------------------

Question 221:

Possible Duplicate:
Using “Foo” and “Bar” in examples 

I know AT&T labs used them in their Unix days, but do they have even deeper histories?


TF-IDF Scores:
days: 0.4329
examples: 0.4226
know: 0.2711
possible: 0.3547
unix: 0.5123
used: 0.2869
using: 0.3000

Termine con il punteggio TF-IDF più alto: unix (0.5123)

Best Answer:
From the Jargon file:

When ‘foo’ is used in connection with ‘bar’ it has generally traced to the WWII-era Army slang acronym FUBAR (‘Fucked Up Beyond All Repair’ or ‘Fucked Up Beyond All Recognition’), later modified to foobar. Early versions of the Jargon File interpreted this change as a post-war bowdlerization, but it it now seems more likely that FUBAR was itself a derivative of ‘foo’ perhaps influenced by German furchtbar (terrible) — ‘foobar’ may actually have been the original form.
For, it seems, the word ‘foo’ itself had an immediate prewar history in comic strips and cartoons. The earliest documented uses were in the Smokey Stover comic strip published from about 1930 to about 1952. Bill Holman, the author of the strip, filled it with odd jokes and personal contrivances, including other nonsense phrases such as “Notary Sojac” and “1506 nix nix”. The word “foo” frequently appeared on license plates of cars, in nonsense sayings in the background of some frames (such as “He who foos last foos best” or “Many smoke but foo men chew”), and Holman had Smokey say “Where there's foo, there's fire”.



TF-IDF Scores:
actually: 0.1340
author: 0.1853
background: 0.1679
best: 0.1229
change: 0.1340
connection: 0.1728
documented: 0.1785
early: 0.1728
file: 0.2999
filled: 0.1935
form: 0.1785
frequently: 0.1635
generally: 0.1597
history: 0.1853
including: 0.1935
interpreted: 0.1935
later: 0.1679
license: 0.1935
likely: 0.1561
original: 0.1679
personal: 0.1561
post: 0.1785
published: 0.1935
say: 0.1144
terrible: 0.1935
used: 0.1084
uses: 0.1679
war: 0.1853
word: 0.3706

Termine con il punteggio TF-IDF più alto: word (0.3706)

----------------------------------------------------------------------------------------------------

Question 247:
Does learning COBOL still make sense?


TF-IDF Scores:
cobol: 0.6175
learning: 0.4530
make: 0.3612
sense: 0.5321

Termine con il punteggio TF-IDF più alto: cobol (0.6175)

Best Answer:
I don't think so, unless you are already in the niche market where COBOL is still maintained.


TF-IDF Scores:
cobol: 0.5433
market: 0.5433
think: 0.2959
unless: 0.5675

Termine con il punteggio TF-IDF più alto: unless (0.5675)

----------------------------------------------------------------------------------------------------

Question 252:
There is a widely accepted opinion that Singleton is an anti-pattern. As usual, there are always exceptions to the rule. Can you explain why Singleton is a bad choice in general and give an example of some valid use cases for it?


TF-IDF Scores:
accepted: 0.3265
bad: 0.2484
cases: 0.2693
choice: 0.2693
example: 0.1988
explain: 0.2293
general: 0.2833
opinion: 0.3012
pattern: 0.3012
rule: 0.3126
use: 0.1480
usual: 0.3265
valid: 0.3265

Termine con il punteggio TF-IDF più alto: accepted (0.3265)

Best Answer:
The two main criticisms of Singletons fall into two camps from what I've observed:

Singletons are misused and abused by less capable programmers and so everything becomes a singleton and you see code littered with Class::get_instance() references. Generally speaking there are only one or two resources (like a database connection for example) that qualify for use of the Singleton pattern.
Singletons are essentially static classes, relying on one or more static methods and properties. All things static present real, tangible problems when you try to do Unit Testing because they represent dead ends in your code that cannot be mocked or stubbed. As a result, when you test a class that relies on a Singleton (or any other static method or class) you are not only testing that class but also the static method or class.

As a result of both of these, a common approach is to use create a broad container object to hold a single instance of these classes and only the container object modifies these types of classes while many other classes can be granted access to them to use from the container object.


TF-IDF Scores:
access: 0.0841
approach: 0.0860
class: 0.4203
classes: 0.3845
code: 0.0862
common: 0.0732
connection: 0.0931
create: 0.0841
ends: 0.1042
essentially: 0.0998
example: 0.0634
generally: 0.0860
granted: 0.0998
like: 0.0434
main: 0.0860
method: 0.1808
methods: 0.0860
object: 0.2993
pattern: 0.0961
problems: 0.0823
programmers: 0.0648
real: 0.0766
references: 0.1042
represent: 0.1042
resources: 0.0998
result: 0.1808
single: 0.0904
speaking: 0.0998
static: 0.5210
test: 0.0703
testing: 0.1558
things: 0.0569
try: 0.0677
types: 0.0904
unit: 0.0793
use: 0.1417

Termine con il punteggio TF-IDF più alto: static (0.5210)

----------------------------------------------------------------------------------------------------

Question 262:
Will Java have the same importance it had in the past, or it will be less relevant than nowadays?


TF-IDF Scores:
importance: 0.6039
java: 0.4126
past: 0.4872
relevant: 0.4772

Termine con il punteggio TF-IDF più alto: importance (0.6039)

Best Answer:
Java is relevant and will continue to be relevant for many years in the Enterprise computing world.  
Whether it continues to be relevant in other areas depends a lot on what Oracle does.  If they inject some life (and resources) into ME, desktop applications and other areas, and if they press on with the evolution of the Java language, then Java will do well.  
But if Oracle cuts back on R&D and/or tries to stomp other players in the Java space, there's a good chance that someone / some company will develop a better (and more open) Java-like language.  If Oracle win their lawsuit against Google, I predict that the next generation of the Android platform will have a new language, just like happened with C#.  If Google get the openness right ... then, the game is on!


TF-IDF Scores:
android: 0.1518
applications: 0.1200
areas: 0.2801
better: 0.0975
chance: 0.1401
company: 0.1099
computing: 0.1454
depends: 0.1317
desktop: 0.1317
develop: 0.1356
enterprise: 0.1454
game: 0.1253
good: 0.0829
google: 0.2635
happened: 0.1401
java: 0.5187
language: 0.2430
life: 0.1317
like: 0.1263
lot: 0.0964
new: 0.0873
open: 0.1155
platform: 0.1454
relevant: 0.3599
resources: 0.1454
right: 0.1099
space: 0.1356
win: 0.1401
world: 0.1051
years: 0.1066

Termine con il punteggio TF-IDF più alto: java (0.5187)

----------------------------------------------------------------------------------------------------

Question 294:
I just started working a year ago, and I want to join an open source project for the same reasons as anyone else: help create something useful and develop my skills further.
My problem is, I don't know how to find a project where I'll fit in.
How can I find a beginner-friendly project?  What attributes should I be searching for?  What are warning signs that a project might not be the right fit?  Are there any tools out there to help match people with open source projects?
There's a similar question here, but that question has to do with employment and is limited to PHP/Drupal.


TF-IDF Scores:
ago: 0.1784
create: 0.1612
develop: 0.1784
help: 0.2695
know: 0.1058
limited: 0.1998
match: 0.1913
open: 0.3040
people: 0.1034
php: 0.1579
problem: 0.1255
project: 0.4555
projects: 0.1469
question: 0.2385
reasons: 0.1648
right: 0.1446
similar: 0.1579
skills: 0.1648
source: 0.3040
started: 0.1612
tools: 0.1612
useful: 0.1424
want: 0.1110
working: 0.1314
year: 0.1612

Termine con il punteggio TF-IDF più alto: project (0.4555)

Best Answer:
I suggest to start a project on your own on a topic that you're interested in. 
A lot can be learned by working on a project in general.  It is not needed to see how someone else codes to learn how to code better.  And sometimes you'll actually see what not to do as the other people are often no more experienced than you are.  
It usually helps to see other's code, but you will encounter other people's code in your own project just via the libraries and components you use.  
Experience will teach you what is good and bad practice.


TF-IDF Scores:
actually: 0.1565
bad: 0.1719
better: 0.1452
code: 0.2806
components: 0.2164
encounter: 0.2260
experience: 0.1505
experienced: 0.2164
general: 0.1961
good: 0.1234
helps: 0.2164
interested: 0.1864
learn: 0.1486
learned: 0.2085
libraries: 0.2085
lot: 0.1435
needed: 0.1961
people: 0.2339
practice: 0.1910
project: 0.3864
start: 0.1544
teach: 0.2260
use: 0.1024
usually: 0.1661
working: 0.1486

Termine con il punteggio TF-IDF più alto: project (0.3864)

----------------------------------------------------------------------------------------------------

Question 348:
Elite developers can be 10x more productive than an average developer. 
Clearly it's easier to find an elite developer around the whole world than in a company's backyard. 
If a company is not located in a programming hot spot, should they consider hiring people who work from home?


TF-IDF Scores:
clearly: 0.2815
company: 0.4415
consider: 0.2517
developer: 0.4115
developers: 0.2143
easier: 0.2647
hiring: 0.3051
home: 0.3051
people: 0.1579
productive: 0.2725
programming: 0.1482
work: 0.1590
world: 0.2113

Termine con il punteggio TF-IDF più alto: company (0.4415)

Best Answer:
Maybe.
Your benefits are:

Access to a wider pool of candidates (as you point out)
Access to people who want to work at home

Your costs are:

More difficult communication- you can't just pull someone into a free conference room.
No guarantee of instant communication- if you're blocked and waiting for Joe Remote, you can't just go over to his desk and ask him what's up.  If he's incommunicado, you're SOL.
Not all developers work well remotely.  Some need the structured environment to be productive.
There's often no guarantee of matching schedules- eg, a work-from-home person might sleep in, or a person in another time-zone might be awake and working at different times than you.

Atwood had a decent article about it.
Edit, from Atwood's article:

The minimum remote team size is two. Always have a buddy, even if your buddy is on another continent halfway across the world.
Only grizzled veterans who absolutely love to code need apply for remote development positions. Mentoring of newbies or casual programmers simply doesn't work at all remotely.
To be effective, remote teams need full autonomy and a leader (PM, if you will) who has a strong vision and the power to fully execute on that vision.



TF-IDF Scores:
absolutely: 0.1377
access: 0.2320
apply: 0.1438
article: 0.2754
ask: 0.1075
benefits: 0.1377
code: 0.0595
communication: 0.2569
costs: 0.1438
developers: 0.1010
development: 0.0850
different: 0.0996
difficult: 0.1248
edit: 0.1160
effective: 0.1284
environment: 0.1186
free: 0.1284
home: 0.2876
love: 0.1438
maybe: 0.1215
minimum: 0.1438
need: 0.2459
people: 0.0744
person: 0.2273
point: 0.1025
power: 0.1377
productive: 0.1284
programmers: 0.0894
room: 0.1438
simply: 0.1248
size: 0.1284
sleep: 0.1438
strong: 0.1327
team: 0.0996
teams: 0.1438
time: 0.0739
times: 0.1114
waiting: 0.1438
want: 0.0799
wider: 0.1438
work: 0.2999
working: 0.0946
world: 0.0996

Termine con il punteggio TF-IDF più alto: work (0.2999)

----------------------------------------------------------------------------------------------------

Question 368:
For a long time in SO and in other places Java has the reputation of being slow. From jokes to many comments in questions and answers, people still believe Java is slow based solely on experience with it in the 90s.
This is my issue: we have disproved (most) of the reasons that people believe Java is slow. Outside of small things, Java is pretty fast.
So why is it that people still refuse to believe Java is fast now? Is it part of their mindset that anything thats not C/C++ is slow? Is it because people don't check over time? Is it because people are just biased?


TF-IDF Scores:
answers: 0.1181
based: 0.1055
believe: 0.3647
check: 0.1076
comments: 0.1123
experience: 0.0906
fast: 0.2362
issue: 0.1055
java: 0.4650
long: 0.0885
outside: 0.1256
people: 0.3522
places: 0.1216
pretty: 0.0985
questions: 0.1001
reasons: 0.1123
slow: 0.5445
small: 0.1001
things: 0.0744
time: 0.1399

Termine con il punteggio TF-IDF più alto: slow (0.5445)

Best Answer:
It's the applications. As you note, we have proved, time and time again, that in contrived scenarios Java code can meet or even beat the performance of so-called "performant" languages like C, C++, Lisp, VB6, or JavaScript. And when presented with such evidence, most sane, open-minded opponents will hang their heads in shame and promise never again to spread such slander.
...but then, they fire up Eclipse, or NetBeans, or Guiffy, or enable the Java support in their browser, or try to run an app on their favorite feature phone. And they wait for it to become responsive...
...and wait...


...and wait...




...and wait...








...and wait...












...and...





...what did I promise never to do again? Sorry, must have dozed off...


TF-IDF Scores:
app: 0.1222
applications: 0.1197
called: 0.1450
code: 0.0627
evidence: 0.1397
favorite: 0.1515
feature: 0.1152
hang: 0.1515
java: 0.2069
javascript: 0.1314
languages: 0.0984
like: 0.0630
lisp: 0.1450
meet: 0.1515
note: 0.1397
open: 0.1152
performance: 0.1353
promise: 0.2900
run: 0.1280
scenarios: 0.1450
support: 0.1314
time: 0.1556
try: 0.0984
wait: 0.7250

Termine con il punteggio TF-IDF più alto: wait (0.7250)

----------------------------------------------------------------------------------------------------

Question 370:
I've been told that to be taken seriously as a job applicant, I should drop years of relevant experience off my résumé, remove the year I got my degree, or both. Or not even bother applying, because no one wants to hire programmers older than them.1
Or that I should found a company, not because I want to, or because I have a product I care about, but because that way I can get a job if/when my company is acquired.
Or that I should focus more on management jobs (which I've successfully done in the past) because… well, they couldn't really explain this one, except the implication was that over a certain age you're a loser if you're still writing code. But I like writing code.
Have you seen this? Is this only a local (Northern California) issue?
If you've ever hired programmers:2

Of the résumés you've received, how old was the eldest applicant?
What was the age of the oldest person you've interviewed?
How old (when hired) was the oldest person you hired?

How old is "too old" to employed as a programmer?
1 I'm assuming all applicants have equivalent applicable experience. This isn't about someone with three decades of COBOL applying for a Java guru job.
2 Yes, I know that (at least in the US) you aren't supposed to ask how old an applicant is. In my experience, though, you can get a general idea from a résumé.


TF-IDF Scores:
applicable: 0.1248
applying: 0.2496
ask: 0.0933
assuming: 0.1248
care: 0.1195
certain: 0.1115
cobol: 0.1195
code: 0.1033
company: 0.1806
decades: 0.1248
degree: 0.1195
drop: 0.1195
experience: 0.2493
explain: 0.0876
focus: 0.1248
general: 0.1083
got: 0.1029
hire: 0.1248
idea: 0.0986
issue: 0.0967
java: 0.0853
job: 0.2558
jobs: 0.1195
know: 0.0660
like: 0.0519
local: 0.1248
management: 0.0949
old: 0.4835
past: 0.1007
person: 0.1972
product: 0.1007
programmer: 0.0802
programmers: 0.1551
really: 0.0718
relevant: 0.0986
remove: 0.1248
seen: 0.0903
seriously: 0.1248
successfully: 0.1248
supposed: 0.1083
taken: 0.1115
told: 0.1195
want: 0.0693
wants: 0.1083
way: 0.0699
writing: 0.1705
year: 0.1007
years: 0.0876
yes: 0.0933

Termine con il punteggio TF-IDF più alto: old (0.4835)

Best Answer:
Having just got a new job at nearly 50 in the UK I can say that it's possible and you're never too old.
There are two approaches - both rely on your skills being relevant to the job.

Stick with what you know and become a guru. This is risky as the number of jobs requiring "old" technologies are becoming fewer and further between as each year passes. However, as people retire from such jobs there will be openings.
Keep refreshing your skills. I moved into Silverlight last year, which is what got me this job. That and my previous team leadership roles which my new employer saw as relevant.



TF-IDF Scores:
50: 0.1738
approaches: 0.1603
fewer: 0.1738
got: 0.2867
job: 0.3562
jobs: 0.3327
know: 0.0920
new: 0.1998
number: 0.1373
old: 0.2693
passes: 0.1738
people: 0.0899
possible: 0.1203
previous: 0.1552
relevant: 0.2746
rely: 0.1738
saw: 0.1738
say: 0.1027
skills: 0.2867
stick: 0.1738
team: 0.1203
technologies: 0.1603
year: 0.2804

Termine con il punteggio TF-IDF più alto: job (0.3562)

----------------------------------------------------------------------------------------------------

Question 404:
Joel Spolsky wrote a famous blog post "Human Task Switches considered harmful".
While I agree with the premise and it seems like common sense, I'm wondering if there are any studies or white papers on this to calculate the overhead on task switches, or is the evidence merely anecdotal? 


TF-IDF Scores:
agree: 0.2919
blog: 0.2723
common: 0.2141
considered: 0.2723
evidence: 0.2812
joel: 0.2723
like: 0.1268
overhead: 0.3049
post: 0.2812
sense: 0.2515
task: 0.4724
wrote: 0.3049

Termine con il punteggio TF-IDF più alto: task (0.4724)

Best Answer:
The abstract of a study that says 'maybe'
Another study [PDF] that says interruptions make things seem like they took longer.
A study[PDF] that says interruptions increase resumption lag time, but that cues seen in the task before the interruption can speed recovery time.
Task switching[PDF] takes a significant portion of our work week.
More reading on the psychology of interruptions than you can shake a stick at.


TF-IDF Scores:
like: 0.0937
longer: 0.2157
make: 0.1262
maybe: 0.1904
reading: 0.1746
seen: 0.1630
stick: 0.2253
study: 0.6759
takes: 0.1746
task: 0.3491
things: 0.1231
time: 0.2315
took: 0.2157
week: 0.2157
work: 0.1174

Termine con il punteggio TF-IDF più alto: study (0.6759)

----------------------------------------------------------------------------------------------------

Question 408:
"Regular" golf vs. code golf:
Both are competitions.  Both have a well-defined set of rules, which I'll leave out for simplicity.  Both have well-defined goals; in short, "use fewer hits/characters than your competitors."
To win matches, athletic golfers rely on

equipment

Some situations call for a sand wedge; others, a 9-iron.


techniques

The drive works better when your feet are about shoulder width apart and your arms are relaxed.


and strategies

Sure, you could take that direct shortcut to the hole... but do you really want to risk the water hazard or sand bunker when those trees are in the way and the wind is so strong?  It might be better to go around the long way.



What do code golfers have that's analagous to athletic golfers' equipment, techniques and strategies?
Sample answer to get this started: use the right club!  Choose GolfScript instead of C#.


TF-IDF Scores:
answer: 0.1163
apart: 0.1630
better: 0.2188
characters: 0.1630
code: 0.1409
defined: 0.3406
drive: 0.1703
fewer: 0.1703
golf: 0.3406
instead: 0.1273
leave: 0.1439
long: 0.1107
really: 0.0979
regular: 0.1703
rely: 0.1703
right: 0.1232
risk: 0.1630
rules: 0.1630
sample: 0.1630
set: 0.1252
short: 0.1521
situations: 0.1630
started: 0.1374
strong: 0.1571
sure: 0.1273
techniques: 0.3142
use: 0.1543
vs: 0.1521
want: 0.0946
way: 0.1908
win: 0.1571
works: 0.1521

Termine con il punteggio TF-IDF più alto: defined (0.3406)

Best Answer:
I'd say that thorough knowledge of the syntactical oddities of your language help. Here is one I found in Ruby when doing a bit of code golf:
Instead of
require "sequel"
require "nokogiri"
require "chronic"

You can do something like this:
 body_of_your_program if %w{sequel nokogiri chronic}.each{|i| require i}

With this kind of thing, you too can write incredibly elaborate Ruby one-liners!
In Ruby and Perl, you also get the magic variables like "$_" which can be used to do all sorts of magic with strings and regexes. Is your data not strings? Well, you might want to turn it into strings.
Obviously, in C, the preprocessor is your friend.


TF-IDF Scores:
bit: 0.1372
code: 0.0733
data: 0.1226
golf: 0.1771
help: 0.1194
incredibly: 0.1695
instead: 0.1323
kind: 0.1536
knowledge: 0.1347
language: 0.0944
like: 0.1473
magic: 0.3541
obviously: 0.1536
require: 0.5387
ruby: 0.4900
say: 0.1047
thing: 0.1323
turn: 0.1633
used: 0.0992
variables: 0.1771
want: 0.0983
write: 0.1057

Termine con il punteggio TF-IDF più alto: require (0.5387)

----------------------------------------------------------------------------------------------------

Question 487:
If you were to design a programming language, how would you do it? What features would you put in? What would you leave out? Statically or dynamically typed? Strongly or weakly typed? Compiled or interpreted? Justify your answers.


TF-IDF Scores:
answers: 0.2858
design: 0.2116
dynamically: 0.3294
features: 0.2603
interpreted: 0.3294
language: 0.1757
leave: 0.2784
programming: 0.1600
statically: 0.3294
typed: 0.5884

Termine con il punteggio TF-IDF più alto: typed (0.5884)

Best Answer:

I definitely think that functional programming languages will catch on, so my language will be functional. See Taming Effects with Functional Programming
I think the CPUs soon will have hundreads of cores, and threads will he a hell to manage. So the Actor Model is a must instead of threads. See Erlang - software for a concurrent world
I also think that OOP has failed, the communication between objects was assumed to be asynchronous. So I think we need message passing, with immutable messages. Send and Forget. As in the Actor model. See Object Oriented Programming: The Wrong Path?
I think that it would be good to have static typing, so errors are catched earlier in the development cycle. But I would use type inference as in Haskell, so that the developer don't need to write the type everywhere in the code as in C, C# and Java. See Learn You A Haskell for Great Good
I would also design a great UI library, with declarative layout, as in WPF and Android. But I would like to have it as in Functional Reactive Programming.

So my language would be like the concurrency in Erlang but with the typing as in Haskell and a GUI framework as in WPF.NET.


TF-IDF Scores:
android: 0.1121
code: 0.0464
communication: 0.1001
concurrency: 0.1121
concurrent: 0.1121
cycle: 0.1121
definitely: 0.1121
design: 0.0720
developer: 0.0756
development: 0.0662
earlier: 0.1034
effects: 0.1034
erlang: 0.2146
errors: 0.0924
failed: 0.1034
framework: 0.0852
functional: 0.3616
good: 0.1224
great: 0.1675
gui: 0.1034
haskell: 0.2917
instead: 0.0838
java: 0.0766
language: 0.1195
languages: 0.0728
learn: 0.0737
library: 0.0904
like: 0.0933
message: 0.1121
model: 0.1894
need: 0.1277
net: 0.0824
object: 0.1073
objects: 0.1073
oop: 0.1073
oriented: 0.0947
path: 0.1073
programming: 0.2178
software: 0.0656
soon: 0.1073
static: 0.1121
think: 0.2921
threads: 0.2241
type: 0.1771
typing: 0.2002
ui: 0.1034
use: 0.0508
world: 0.0776
wpf: 0.2241
write: 0.0669
wrong: 0.0904

Termine con il punteggio TF-IDF più alto: functional (0.3616)

----------------------------------------------------------------------------------------------------

Question 492:
Did you learn to touch-type when you were already working as a programmer?  If so how did it affect your productivity?  Or are you still unable to touch type and do you think it holds you back?
According to Steve Yegge it is essential,
Personally I did not notice much difference, possibly because I was spending less than 25% of my work time actually typing (I was working on a large legacy project at the time and I was spending more time on reading and debugging existing code.)


TF-IDF Scores:
actually: 0.1458
code: 0.0871
difference: 0.1943
existing: 0.1881
large: 0.1943
learn: 0.1385
legacy: 0.2106
notice: 0.2016
personally: 0.1699
possibly: 0.1780
productivity: 0.2106
programmer: 0.1353
project: 0.1200
reading: 0.1632
steve: 0.2106
think: 0.1098
time: 0.3245
touch: 0.3885
type: 0.3328
typing: 0.1881
unable: 0.2106
work: 0.1098
working: 0.2770

Termine con il punteggio TF-IDF più alto: touch (0.3885)

Best Answer:
The main benefit for me is the ability to work more ergonomically (no looking down and straining your neck and top back). I don't think it actually affects your speed though, except for comments, because of the excessive use of punctuation marks in programming languages. Touch Typing is really more suited for words... at least on a QWERTY keyboard. 
I think Steve Yegge is overreacting about this. We're not typists, we're problem solvers. At the end what's important is for your typing to not get in your way. If it's not causing you physical strain, and your typing speed is not disruptively behind your though speed, then you can type in whatever way you want, and trust me- it is possible to type fast without touch typing. 


TF-IDF Scores:
ability: 0.1530
actually: 0.1148
benefit: 0.1658
causing: 0.1658
comments: 0.1368
end: 0.1200
fast: 0.1438
important: 0.1182
keyboard: 0.1481
languages: 0.1077
looking: 0.1285
main: 0.1368
physical: 0.1658
possible: 0.1148
problem: 0.1042
programming: 0.0805
really: 0.0953
steve: 0.1658
suited: 0.1658
think: 0.1729
touch: 0.3059
trust: 0.1658
type: 0.2620
typing: 0.5923
use: 0.0751
want: 0.0921
way: 0.1857
words: 0.1530
work: 0.0864

Termine con il punteggio TF-IDF più alto: typing (0.5923)

----------------------------------------------------------------------------------------------------

Question 500:
Rather than slavishly pair program all the time, we use pair programming selectively on our team. I think it works best in the following circumstances:

Ramping up brand new team members on a project (instead of letting them wade through documentation or code on their own).
Having junior and senior people work together (helps to show some of the skills and tricks of the more experienced developers, plus it allows the old dogs to learn new tricks sometimes).
When someone is trying to track down a defect, it often helps to pair with a fresh set of eyes.

When to use pair program and why?
When to avoid pair programming? Why?


TF-IDF Scores:
allows: 0.1341
avoid: 0.1130
best: 0.0890
code: 0.0580
developers: 0.0984
documentation: 0.1216
experienced: 0.1341
eyes: 0.1341
following: 0.1216
helps: 0.2683
instead: 0.1047
learn: 0.0922
members: 0.1341
new: 0.1611
old: 0.1086
pair: 0.6463
people: 0.0725
plus: 0.1401
program: 0.2171
programming: 0.1362
project: 0.0799
senior: 0.1341
set: 0.1030
skills: 0.1156
team: 0.1941
think: 0.0730
time: 0.0720
track: 0.1293
tricks: 0.2585
trying: 0.0999
use: 0.1270
work: 0.0730
works: 0.1251

Termine con il punteggio TF-IDF più alto: pair (0.6463)

Best Answer:
I have never worked in a "Pair Programming" setup and yet I can claim to have been a part of the three circumstances you've listed. The scenario you mention seems more "regular programming" with phases of helping / training thrown in. Did we not do all of this before "pair programming" came into being? Pair Programming, I'd assume would require a more committed approach where the process of sharing within a team doesn't stop the minute you tackle the immediate task or problem at hand. But then this is what I "think" not what I "know".
Personally for Pair Programming I'd like to work in a team where I get a chance to learn and share my knowledge. An unbalanced team where everyone you work with is miles ahead of you, or then way below par can get quite uninteresting quite quickly. Also, I'd be afraid to work with people who are set in their beliefs and hard to convince.


TF-IDF Scores:
approach: 0.1172
assume: 0.1421
chance: 0.1311
claim: 0.1421
convince: 0.1421
hand: 0.1311
hard: 0.1101
know: 0.0752
knowledge: 0.1081
learn: 0.0934
like: 0.0591
mention: 0.1360
minute: 0.1421
pair: 0.5243
people: 0.0735
personally: 0.1146
problem: 0.0893
process: 0.1028
programming: 0.3451
quickly: 0.1233
quite: 0.2245
regular: 0.1421
require: 0.1081
set: 0.1044
share: 0.1311
sharing: 0.1421
stop: 0.1421
task: 0.1101
team: 0.2952
think: 0.0741
thrown: 0.1421
training: 0.1421
way: 0.0796
work: 0.2222
worked: 0.1146

Termine con il punteggio TF-IDF più alto: pair (0.5243)

----------------------------------------------------------------------------------------------------

Question 501:
No matter how much you love a programming language, there are always a few details in it that aren’t quite as nice as they could be.
In this question, I would like to specifically focus on syntax elements. In a programming language that you use frequently (perhaps your favourite programming language, or perhaps the one you are forced to use at work), which syntax element do you find most unreadable, unclear, inconvenient or unpleasant?


TF-IDF Scores:
details: 0.1930
elements: 0.2284
favourite: 0.2284
focus: 0.2284
forced: 0.2284
frequently: 0.1930
language: 0.3655
like: 0.0950
love: 0.2284
matter: 0.2040
nice: 0.1982
programming: 0.3329
question: 0.1363
quite: 0.1805
specifically: 0.2107
syntax: 0.4215
use: 0.2070
work: 0.1191

Termine con il punteggio TF-IDF più alto: syntax (0.4215)

Best Answer:
Semicolon insertion in JavaScript.
I haven't really been bitten by it often, but it's just such a phenomenally bad idea it makes my head spin.

Here's the rules (from ECMA-262 Section 7.9)

When the program contains a token that is not allowed by the formal grammar, then a semicolon is inserted if (a) there is a line break at that point, or (b) the unexpected token was a closing brace.
When the end of a file is reached, if the program cannot be parsed otherwise, then a semicolon is inserted.
When a "restricted production" is encountered and contains a line terminator in a place where the grammar contains the annotation "[no LineTerminator here]", then a semicolon is inserted. 


Example:
return 1; // returns 1

return
1; // returns undefined



TF-IDF Scores:
bad: 0.1396
break: 0.1693
contains: 0.5271
encountered: 0.1835
end: 0.1328
example: 0.1117
file: 0.1422
formal: 0.1693
head: 0.1757
idea: 0.1450
javascript: 0.1592
line: 0.2792
makes: 0.1328
place: 0.1422
point: 0.1308
production: 0.1835
program: 0.2844
reached: 0.1835
really: 0.1055
return: 0.3102
rules: 0.1757
section: 0.1757
unexpected: 0.1835

Termine con il punteggio TF-IDF più alto: contains (0.5271)

----------------------------------------------------------------------------------------------------

Question 502:
I think everyone has their own program or set of features beyond "Hello World!", that they use when trying out a new language.
Mine is a guessing game:
I'm thinking of a number 1-10, guess what it is!
Guess: 3
Nope, too low!
Guess: 7
Nope, too high!
Guess: 5
Yes, You win!
Play again (Y/N)? N

What do you write?


TF-IDF Scores:
10: 0.1646
features: 0.1539
game: 0.1607
guess: 0.7459
hello: 0.1948
high: 0.1740
language: 0.1039
low: 0.1690
new: 0.1120
number: 0.1539
play: 0.1740
program: 0.1509
set: 0.1432
think: 0.1015
thinking: 0.1646
trying: 0.1388
use: 0.0883
win: 0.1797
world: 0.1349
write: 0.1163
yes: 0.1456

Termine con il punteggio TF-IDF più alto: guess (0.7459)

Best Answer:
It usually goes like this:

Hello World
Hello [user inputted name]
A few problems from Project Euler
A linked list
A simple blog engine (either terminal or web-based, depending on what language)
And from there I dive into a project that I want to work on (but don't care if the design gets mangled as I learn my way through a new language).



TF-IDF Scores:
based: 0.1767
blog: 0.2037
care: 0.2184
depending: 0.2281
design: 0.1465
engine: 0.2184
euler: 0.2281
gets: 0.1979
goes: 0.2037
hello: 0.4562
language: 0.2433
learn: 0.1500
like: 0.0949
list: 0.1602
new: 0.1311
problems: 0.1802
project: 0.2600
simple: 0.1802
user: 0.1602
usually: 0.1677
want: 0.1267
way: 0.1277
web: 0.1625
work: 0.1189
world: 0.1579

Termine con il punteggio TF-IDF più alto: hello (0.4562)

----------------------------------------------------------------------------------------------------

Question 507:
I have seen this on the SO on many times. Whenever a question is vague and the question is asking some magical answer somebody or the other leaves a comment saying answer is 42. Even a book I am reading right now uses '42' as the number whenever it wants demonstrate some basic concept using an integer. So is there any history behind it or it is just a coincidence?


TF-IDF Scores:
answer: 0.3551
asking: 0.2097
basic: 0.2397
book: 0.1977
comment: 0.2599
concept: 0.2321
history: 0.2488
number: 0.2053
question: 0.3102
reading: 0.2014
right: 0.1880
saying: 0.2599
seen: 0.1880
times: 0.2014
uses: 0.2255
using: 0.1522
vague: 0.2599
wants: 0.2255

Termine con il punteggio TF-IDF più alto: answer (0.3551)

Best Answer:
It's the answer to Life, The Universe, and Everything from Douglas Adams' Hitchhiker's Guide to the Galaxy.


TF-IDF Scores:
answer: 0.4586
guide: 0.6712
life: 0.5824

Termine con il punteggio TF-IDF più alto: guide (0.6712)

----------------------------------------------------------------------------------------------------

Question 558:
I am a moderately capable web developer. I can put stuff where I want it to go and put some JQuery stuff in there if I need to. However, if I am making my own website (which I am starting to do) I have no idea how to design it. If someone was to sit next to me a point to the screen and say "put this picture there, text there" I can do that quite easily. But designing my own site with my choice of colours and text will look like a toddler has invented it.
Does anyone know any websites/books I can look at or has anyone got any tips on the basics of non-toddler web design?


TF-IDF Scores:
books: 0.1612
choice: 0.1649
design: 0.2568
developer: 0.1348
easily: 0.1734
got: 0.1649
idea: 0.1579
know: 0.1058
like: 0.0832
look: 0.2848
making: 0.1649
need: 0.1139
non: 0.1404
point: 0.1424
quite: 0.1579
say: 0.1181
screen: 0.1913
sit: 0.1998
site: 0.1689
starting: 0.1734
stuff: 0.3097
text: 0.3687
tips: 0.1785
want: 0.1110
web: 0.2848
website: 0.1734
websites: 0.1998

Termine con il punteggio TF-IDF più alto: text (0.3687)

Best Answer:
You have a few things to do.
Tips:
Learn to use Photoshop. (In particular, layer styles are excellent. Just note that they can be difficult effects to reimplement in CSS2) It goes a long way towards making good mockups. 
Look at professionally designed sites. What sites have you been to that look nice to you?  
Find sites that bother you and consider what could make it better. Look at product advertisements as well. Food packaging. Newspaper ads. You name it. 
Also, once you start getting the hang of it, practice, practice, practice. Graphics takes time to develop as a skill, especially from a programmer who has coding to consider. (Gradients vs "tileability") 
Tools:
(Photoshop is a personal favorite. Paint.NET is a good Windows alternative, but is not quite as powerful.)
Nathan Smith's 960 grid system. It has templates for many of the mainstream graphics programs. Check it out.
References:
Look at some of these sites: (I've seen more, I'll try to add as I come across them)

A List Apart
John McCain
BarackObama.com 
Hayon2010.com (Okay, I made this one, but I think that it's nice. edit: I'd appreciate comments on it too. ;-D)



TF-IDF Scores:
add: 0.1028
apart: 0.1134
better: 0.0761
check: 0.0936
coding: 0.0779
com: 0.2116
come: 0.0977
comments: 0.0977
consider: 0.1955
designed: 0.1093
develop: 0.1058
difficult: 0.1028
edit: 0.0956
effects: 0.1093
especially: 0.0977
excellent: 0.1185
favorite: 0.1185
getting: 0.0918
goes: 0.1058
good: 0.1294
graphics: 0.2268
hang: 0.1185
learn: 0.0779
list: 0.0832
long: 0.0770
look: 0.3377
mainstream: 0.1134
make: 0.0664
making: 0.0977
net: 0.0871
nice: 0.2056
note: 0.1093
particular: 0.0936
personal: 0.0956
powerful: 0.1093
practice: 0.3003
product: 0.0956
programmer: 0.0761
programs: 0.1001
quite: 0.0936
references: 0.1185
seen: 0.0857
sites: 0.4111
start: 0.0809
styles: 0.1093
takes: 0.0918
things: 0.0647
think: 0.0618
time: 0.0609
tips: 0.1058
tools: 0.0956
try: 0.0770
use: 0.0537
vs: 0.1058
way: 0.0664
windows: 0.1028

Termine con il punteggio TF-IDF più alto: sites (0.4111)

----------------------------------------------------------------------------------------------------

Question 566:
goto is almost universally discouraged. Is using this statement ever worthwhile?


TF-IDF Scores:
goto: 0.6653
universally: 0.6369
using: 0.3896

Termine con il punteggio TF-IDF più alto: goto (0.6653)

Best Answer:
This has been discussed several times on Stack Overflow, and Chris Gillum summarized the possible uses of goto:

Cleanly exiting a function
Often in a function, you may allocate resources and need to exit in multiple places.  Programmers can simplify their code by putting the resource cleanup code at the end of the function all all "exit points" of the function would goto the cleanup label.  This way, you don't have to write cleanup code at every "exit point" of the function.
Exiting nested loops
If you're in a nested loop and need to break out of all loops, a goto can make this much cleaner and simpler than break statements and if-checks.
Low-level performance improvements
This is only valid in perf-critical code, but goto statements execute very quickly and can give you a boost when moving through a function.  This is a double-edged sword, however, because a compiler typically cannot optimize code that contains gotos.

I'd argue, as many others would argue, that in all of these cases, the usage of goto is used as a means to get out of a corner one coded oneself into, and is generally a symptom of code that could be refactored.


TF-IDF Scores:
break: 0.2020
cases: 0.0903
code: 0.2718
compiler: 0.1048
contains: 0.1048
critical: 0.1095
end: 0.0792
function: 0.5551
generally: 0.0903
goto: 0.5474
level: 0.0848
low: 0.0950
make: 0.0613
means: 0.0865
moving: 0.1010
multiple: 0.0978
need: 0.1248
overflow: 0.0950
performance: 0.0978
places: 0.0978
point: 0.0780
points: 0.0925
possible: 0.0758
programmers: 0.0680
quickly: 0.0950
resource: 0.1095
resources: 0.1048
simpler: 0.1095
stack: 0.0950
times: 0.0848
usage: 0.1095
used: 0.0613
uses: 0.0950
valid: 0.1095
way: 0.0613
write: 0.0653

Termine con il punteggio TF-IDF più alto: function (0.5551)

----------------------------------------------------------------------------------------------------

Question 568:
Managed OSes like Microsoft Singularity and JNode are quite an interesting concept. Essentially, the OS is bootstrapped with code written in a low-level language (C/C++/Assembly), which essentially implements a virtual machine. The rest of the OS (and all userland apps) run on the virtual machine. There are some great things about this. For example, you suddenly make arbitrary pointers obsolete. And if well written, you get rid of a ton of legacy crud that most modern OSes currently have. 
However, as a disadvantage, you're that much farther away from the hardware, and as a developer, you lose the ability to drop down to a lower level of abstraction and get your hands dirty. 
What are your opinions on this?


TF-IDF Scores:
ability: 0.1670
apps: 0.1493
assembly: 0.1810
away: 0.1617
code: 0.0749
concept: 0.1617
currently: 0.1670
developer: 0.1221
drop: 0.1733
essentially: 0.3466
example: 0.1102
great: 0.1353
hands: 0.1810
hardware: 0.1670
interesting: 0.1403
language: 0.0966
legacy: 0.1810
level: 0.2805
like: 0.0753
low: 0.1570
lower: 0.1810
machine: 0.3466
make: 0.1014
managed: 0.1670
microsoft: 0.1493
modern: 0.1810
quite: 0.1430
run: 0.1530
things: 0.0989
written: 0.3233

Termine con il punteggio TF-IDF più alto: essentially (0.3466)

Best Answer:
I think that this is another case where "it depends".
If you're writing applications such as web browsers, word processors etc. where lightning fast performance is not necessarily an issue then this approach has it's merits. By using this approach you can offer your customers a safer, more controlled experience. Not only are you limiting the damage that can be done by malware, but you are also running in a more consistent environment.
It's like the difference between console games and PC games. The former know exactly what hardware they need to work with so can make use of that knowledge whereas the latter have to be able to cope with a wider variety of graphics cards, sound cards, hard disk speeds etc.
However, there will be applications (such as games!) that require the low level access and will still need to be run "natively".
Like managed languages you will have to use the appropriate tool for the job.


TF-IDF Scores:
able: 0.1262
access: 0.1205
applications: 0.2361
approach: 0.2465
browsers: 0.1494
cards: 0.2988
case: 0.1180
consistent: 0.1494
customers: 0.1378
depends: 0.1296
difference: 0.1378
environment: 0.1232
exactly: 0.1378
experience: 0.0995
fast: 0.1296
games: 0.4002
graphics: 0.1430
hard: 0.1157
hardware: 0.1378
issue: 0.1157
job: 0.1021
know: 0.0791
knowledge: 0.1136
languages: 0.0971
level: 0.1157
like: 0.1243
low: 0.1296
make: 0.0837
managed: 0.1378
necessarily: 0.1334
need: 0.1703
performance: 0.1334
require: 0.1136
run: 0.1262
running: 0.1378
sound: 0.1494
think: 0.0779
tool: 0.1232
use: 0.1354
using: 0.0875
web: 0.1065
wider: 0.1494
word: 0.1430
work: 0.0779
writing: 0.1021

Termine con il punteggio TF-IDF più alto: games (0.4002)

----------------------------------------------------------------------------------------------------

Question 570:
All but the most trivial programs are filled with bugs and so anything that promises to remove them is extremely alluring. At the moment, correctness proofs are code are extremely esoteric, mainly because of the difficultly of learning this and the extra effort it takes to prove a program correct. Do you think that code proving will ever take off?


TF-IDF Scores:
bugs: 0.2122
code: 0.2177
correct: 0.2282
effort: 0.2349
extra: 0.2426
extremely: 0.4697
filled: 0.2630
learning: 0.1847
moment: 0.2630
program: 0.2038
programs: 0.2222
prove: 0.2630
remove: 0.2630
takes: 0.2038
think: 0.1371
trivial: 0.2426

Termine con il punteggio TF-IDF più alto: extremely (0.4697)

Best Answer:
Not really in that sense, but pure functional programming is good in this domain. If you use Haskell, it's likely that your program is correct if the code compiles. Except from IO, a good type system is a good help.
Also programming to contract can be helpful. See Microsoft Code Contracts


TF-IDF Scores:
code: 0.2267
contract: 0.2622
correct: 0.2376
domain: 0.2622
functional: 0.2210
good: 0.4489
haskell: 0.2376
help: 0.1847
helpful: 0.2446
likely: 0.2210
microsoft: 0.2260
program: 0.2122
programming: 0.2661
really: 0.1575
sense: 0.2260
type: 0.2164
use: 0.1241

Termine con il punteggio TF-IDF più alto: good (0.4489)

----------------------------------------------------------------------------------------------------

Question 604:
on a widescreen monitor one can easily see more than 80 characters at a time, without scrollbars. even linus torvalds sees the 80 character limit as outdated.
so, is the 80 character limit still relevant in times of widescreen monitors?


TF-IDF Scores:
80: 0.7405
character: 0.4554
characters: 0.2363
easily: 0.2141
monitor: 0.2277
relevant: 0.1950
time: 0.1268
times: 0.1913

Termine con il punteggio TF-IDF più alto: 80 (0.7405)

Best Answer:
If I keep my lines to less than about 100 characters, I can have two editor windows side-by-side on a widescreen monitor.  It's very useful to have both the class header file and implementation both visible at the same time, or have code on one side that calls into the code on the other.  And, if I keep the lines short, I don't need a horizontal scrollbar on my editor windows, which gives me more vertical space.
80 characters may be outdated, but there's some merit in keeping things within reason.


TF-IDF Scores:
100: 0.1962
80: 0.2197
calls: 0.1962
characters: 0.4207
class: 0.1772
code: 0.1818
file: 0.1702
gives: 0.2197
implementation: 0.2103
lines: 0.3924
monitor: 0.2027
need: 0.1252
reason: 0.1642
short: 0.1962
space: 0.1962
things: 0.1200
time: 0.1129
useful: 0.1566
windows: 0.3812

Termine con il punteggio TF-IDF più alto: characters (0.4207)

----------------------------------------------------------------------------------------------------

Question 616:
When I am in a code or design rut, I tend to find a non-dev coworker to discuss the problem with. It forces me to explain the problem in great detail and I'll usually find something I missed in the process.
What are your "unsticking" methods?


TF-IDF Scores:
code: 0.1293
design: 0.2006
dev: 0.3123
discuss: 0.3123
explain: 0.2194
forces: 0.3123
great: 0.2335
methods: 0.2577
missed: 0.3123
non: 0.2194
problem: 0.3925
process: 0.2260
tend: 0.2790
usually: 0.2296

Termine con il punteggio TF-IDF più alto: problem (0.3925)

Best Answer:
Some of my tactics:

Explain the problem to someone, or even no one.  My girlfriend used to explain problems to a potato she kept.
Work on something else for a bit (if opportunity allows)- some other functionality or even another project.  Get your ming off the current project.  A lot of times problems that seem impossible at 4:30pm seem trivial at 9:30 am the next day.
Go to the pub (if possible).  Same principle as above.
Beat your head against it.  This isn't often that productive for solving the problem, but at least for me, I tend to learn a lot.  If my gridview isn't auto-sorting, I'll try and read everything I can about the problem.  It'll still take me 3 hours to solve a stupid error on my part, but by the end, I'll have learned everything there is to know about gridviews and how they bind to data- I'll be able to solve any number of similar problems in the future.
Get another input- preferably someone who knows at least something about the context of the project.  Most of my errors are stupid ones that only require a few minutes from a second set of eyes to solve where it would take me hours.
Isolate the problem.  I keep a folder labeled "proof of bugs" where I keep a pile of project that each reproduce a specific issue outside the overall context of the large, complex project.  This can be a little time consuming, but it allows you to narrow down the cause of the issue independent of the bazillion interfering factors of a large project.



TF-IDF Scores:
30: 0.1031
able: 0.0910
allows: 0.2061
bit: 0.0834
bugs: 0.0868
cause: 0.0934
complex: 0.0934
context: 0.1923
current: 0.0910
data: 0.0745
day: 0.0868
end: 0.0779
error: 0.0910
errors: 0.0888
explain: 0.1512
eyes: 0.1031
factors: 0.1076
functionality: 0.1031
head: 0.1031
hours: 0.1923
impossible: 0.1076
input: 0.0993
issue: 0.1668
kept: 0.1076
know: 0.0570
knows: 0.0961
large: 0.1986
learn: 0.0708
learned: 0.0993
little: 0.0910
lot: 0.1367
number: 0.0851
ones: 0.0934
opportunity: 0.0993
outside: 0.0993
overall: 0.1076
possible: 0.0745
principle: 0.1076
problem: 0.2705
problems: 0.2552
productive: 0.0961
project: 0.3681
read: 0.0791
reproduce: 0.1076
require: 0.0819
second: 0.0993
set: 0.0791
similar: 0.0851
solve: 0.2605
solving: 0.1031
specific: 0.0851
stupid: 0.2153
tend: 0.0961
time: 0.0553
times: 0.0834
trivial: 0.0993
try: 0.0700
used: 0.0603
work: 0.0561

Termine con il punteggio TF-IDF più alto: project (0.3681)

----------------------------------------------------------------------------------------------------

Question 648:
We, as programmers, are constantly being asked 'How long will it take'?
And you know, the situation is almost always like this:

The requirements are unclear. Nobody has done an in depth analysis of all the implications.
The new feature will probably break some assumptions you made in your code and you start thinking immediately of all the things you might have to refactor. 
You have other things to do from past assignments and you will have to come up with an estimate that takes that other work into account.
The 'done' definition is probably unclear: When will it be done? 'Done' as in just finished coding it, or 'done' as in "the users are using it"?
No matter how conscious you are of all these things, sometimes your "programmer's pride" makes you give/accept shorter times than you originally suppose it might take. Specially when you feel the pressure of deadlines and management expectations.

Many of these are organizational or cultural issues that are not simple and easy to solve, but in the end the reality is that you are being asked for an estimate and they expect you to give a reasonable answer. It's part of your job. You cannot simply say: I don't know. 
As a result, I always end up giving estimates that I later realize I cannot fulfill. It has happened countless of times, and I always promise it won't happen again. But it does.
What is your personal process for deciding and delivering an estimate? What techniques have you found useful?


TF-IDF Scores:
accept: 0.1278
account: 0.1232
analysis: 0.1335
answer: 0.0912
asked: 0.1963
break: 0.1232
code: 0.0553
coding: 0.0878
come: 0.1102
definition: 0.1278
easy: 0.0998
end: 0.1932
estimate: 0.4006
estimates: 0.1278
expectations: 0.1335
feature: 0.1016
feel: 0.1016
happen: 0.1102
happened: 0.1232
immediately: 0.1278
issues: 0.1232
job: 0.0912
know: 0.1413
later: 0.1158
like: 0.0556
long: 0.0868
makes: 0.0966
management: 0.1016
matter: 0.1192
new: 0.0768
organizational: 0.1335
originally: 0.1232
past: 0.1077
personal: 0.1077
probably: 0.1963
process: 0.0966
programmer: 0.0858
programmers: 0.0830
promise: 0.1278
reality: 0.1335
realize: 0.1278
requirements: 0.1128
result: 0.1158
say: 0.0789
simple: 0.1055
simply: 0.1158
situation: 0.1128
solve: 0.1077
start: 0.0912
suppose: 0.1335
takes: 0.1035
techniques: 0.1232
things: 0.2188
thinking: 0.1128
times: 0.2069
useful: 0.0952
users: 0.1016
using: 0.0782
work: 0.0696

Termine con il punteggio TF-IDF più alto: estimate (0.4006)

Best Answer:
From The Pragmatic Programmer: From Journeyman to Master:

What to Say When Asked for an Estimate
You say "I'll get back to you."
You almost always get better results if you slow the process down and spend some time going through the steps we describe in this section. Estimates given at the coffee machine will (like the coffee) come back to haunt you.

In the section, the authors recommend the following process:

Determine the accuracy that you need. Based on the duration, you can quote the estimate in different precision. Saying "5 to 6 months" is different than saying "150 days". If you slip a little into the 7th month, you're still pretty accurate. But if you slip into the 180th or 210th day, not so much.
Make sure you understand what is being asked. Determine the scope of the problem.
Model the system. A model might be a mental model, diagrams, or existing data records. Decompose this model and build estimates from the components. Assign values and error ranges (+/-) to each value.
Calculate the estimate based on your model.
Track your estimates. Record information about the problem you are estimating, your estimate, and the actual values.
Other things to include in your estimate are developing and documenting requirements or changes to requirements specifications, creating or updating design documents and specifications, testing (unit, integration, and acceptance), creating or updating user's manuals or READMEs with the changes. If 2 or more people working together, there's overhead of communication (phone calls, emails, meetings) and merging source code. If it's a long task, account for things like other work, time off (holidays, vacation, sick time), meetings, and other overhead tasks when picking a delivery date.



TF-IDF Scores:
account: 0.0777
actual: 0.0777
asked: 0.1239
authors: 0.0842
based: 0.1305
better: 0.0541
build: 0.0752
calls: 0.0752
changes: 0.1390
code: 0.0349
coffee: 0.1685
come: 0.0695
communication: 0.0752
components: 0.0806
creating: 0.1613
data: 0.0583
date: 0.0777
day: 0.0680
days: 0.0712
design: 0.0541
determine: 0.1613
developing: 0.0731
diagrams: 0.0842
different: 0.1167
emails: 0.0806
error: 0.0712
estimate: 0.4212
estimates: 0.2419
existing: 0.0752
following: 0.0731
given: 0.0731
going: 0.0600
include: 0.0731
information: 0.0653
integration: 0.0842
like: 0.0701
little: 0.0712
long: 0.0547
machine: 0.0806
make: 0.0472
master: 0.0806
meetings: 0.1613
model: 0.3559
month: 0.0806
need: 0.0480
overhead: 0.1685
people: 0.0436
pragmatic: 0.0842
pretty: 0.0610
problem: 0.1058
process: 0.1219
programmer: 0.0541
recommend: 0.0806
record: 0.0842
requirements: 0.1424
say: 0.0996
saying: 0.1685
scope: 0.0842
section: 0.1613
slow: 0.0842
source: 0.0641
spend: 0.0712
steps: 0.0731
sure: 0.0630
task: 0.0653
tasks: 0.0680
testing: 0.0630
things: 0.0920
time: 0.1298
track: 0.0777
understand: 0.0554
unit: 0.0641
user: 0.0592
value: 0.0712
values: 0.1685
work: 0.0439
working: 0.0554

Termine con il punteggio TF-IDF più alto: estimate (0.4212)

----------------------------------------------------------------------------------------------------

Question 678:
I know some people are massive proponents of test driven development. I have used unit tests in the past, but only to test operations that can be tested easily or which I believe will quite possibly be correct. Complete or near complete code coverage sounds like it would take a lot of time.

What projects do you use test-driven development for? Do you only use it for projects above a certain size?
Should I be using it or not? Convince me!



TF-IDF Scores:
believe: 0.1709
certain: 0.1709
code: 0.0792
complete: 0.3235
convince: 0.1914
correct: 0.1660
coverage: 0.1832
development: 0.2263
driven: 0.3235
easily: 0.1660
know: 0.1013
like: 0.0796
lot: 0.1216
operations: 0.1914
past: 0.1544
people: 0.0990
possibly: 0.1617
projects: 0.2814
quite: 0.1512
size: 0.1709
test: 0.3872
tested: 0.1832
tests: 0.1483
time: 0.0983
unit: 0.1456
use: 0.1735
used: 0.1072
using: 0.1121

Termine con il punteggio TF-IDF più alto: test (0.3872)

Best Answer:
Ok, some advantages to TDD:

It means you end up with more tests.  Everyone likes having tests, but few people like writing them.  Building test-writing into your development flow means you end up with more tests.
Writing to a test forces you to think about the testability of your design, and testable design is almost always better design.  It's not entirely clear to me why this happens to be the case, but my experience and that of most TDD evangelists seems to bear it out.
Here's a study saying that although TDD takes a bit longer to write, there's a good return on investment because you get higher quality code, and therefore fewer bugs to fix.
It gives you confidence in refactoring.  It's a great feeling to be able to change one system without worrying about breaking everything else because it's pretty well covered by unit tests.
You almost never get a repeat bug, since every one you find should get a test before it gets a fix.

You asked to be convinced, so these were benefits.  See this question for a more balanced view.


TF-IDF Scores:
able: 0.1052
advantages: 0.1245
asked: 0.0915
benefits: 0.1192
better: 0.0800
bit: 0.0965
bug: 0.1027
bugs: 0.1005
building: 0.1192
case: 0.0984
change: 0.0862
clear: 0.1149
code: 0.0515
covered: 0.1245
design: 0.2400
development: 0.0736
end: 0.1802
entirely: 0.1192
experience: 0.0829
feeling: 0.1245
fewer: 0.1245
fix: 0.2009
forces: 0.1245
gets: 0.1080
gives: 0.1245
good: 0.0680
great: 0.0931
happens: 0.1192
higher: 0.1112
like: 0.0518
longer: 0.1192
means: 0.1968
ok: 0.1245
people: 0.0644
pretty: 0.0901
quality: 0.1005
question: 0.0743
repeat: 0.1192
return: 0.1052
saying: 0.1245
study: 0.1245
takes: 0.0965
tdd: 0.3241
test: 0.2519
tests: 0.3859
think: 0.0649
unit: 0.0947
view: 0.1245
write: 0.0743
writing: 0.2552

Termine con il punteggio TF-IDF più alto: tests (0.3859)

----------------------------------------------------------------------------------------------------

Question 724:
When learning a new programming language you sometimes come across a language feature which 
makes you wish you had it in your other programming languages that you know.
What are some language feature which were at the time of learning very new to you and that you wish your other programming languages had.  
An example of this is generators in Python or C#.
Other examples may include list comprehensions in Python, template in C++ or LINQ in .NET or lazy evaluation in Haskell.
What other semi-unique language features have you come across which were completely new and enlightening to you?  Are there other features of older programming languages which were unique and have fallen out of fashion?


TF-IDF Scores:
come: 0.2728
completely: 0.1397
example: 0.1006
examples: 0.1364
feature: 0.2515
features: 0.2612
haskell: 0.1434
include: 0.1434
know: 0.0875
language: 0.3527
languages: 0.3223
learning: 0.2322
list: 0.1161
makes: 0.1196
net: 0.1215
new: 0.2852
programming: 0.3213
python: 0.2667
time: 0.0849
unique: 0.3307

Termine con il punteggio TF-IDF più alto: language (0.3527)

Best Answer:
Practically anything in Haskell

Monads. Yes - the big scary word that makes increadibly easy parsers, IO, operations on Lists and other things so easy (once you notice common pattern)
Arrows. The same for advanced users ;)
Standard stuff like lambdas etc. 
Currying functions
Algebraic data types
Pattern matching

And many more.
PS. Yes. I am Haskell fanboy if anyone asked.


TF-IDF Scores:
asked: 0.1564
big: 0.1648
common: 0.1494
data: 0.1473
easy: 0.3180
functions: 0.1962
haskell: 0.3691
like: 0.0885
lists: 0.2036
makes: 0.1539
notice: 0.2036
operations: 0.2127
pattern: 0.3924
practically: 0.2127
standard: 0.1618
stuff: 0.1648
things: 0.1162
types: 0.1845
users: 0.1618
word: 0.2036
yes: 0.3180

Termine con il punteggio TF-IDF più alto: pattern (0.3924)

----------------------------------------------------------------------------------------------------

Question 729:
As programmers we have a lot of inputs:

Ebooks 
Code snippets 
Interesting emails 
Documents
Web articles 
Blog posts
StackOverflow questions
Podcasts
...

Which tools do you use to store, organize, search and consult all of this stuff?
Is there a silver bullet solution to handle this huge amount of data? 


TF-IDF Scores:
articles: 0.2691
blog: 0.2510
code: 0.1163
data: 0.1946
emails: 0.2691
handle: 0.2811
huge: 0.2691
interesting: 0.2178
lot: 0.1785
organize: 0.2811
programmers: 0.1747
questions: 0.2066
search: 0.2593
solution: 0.2375
stackoverflow: 0.2811
stuff: 0.2178
tools: 0.2267
use: 0.1274
web: 0.2003

Termine con il punteggio TF-IDF più alto: handle (0.2811)

Best Answer:
I'm currently using OneNote from Microsoft to organize and keep record of most of my data, activities and notes. I'm using its online storage to have it automatically shared between my home desktop, personal notebook and office notebook. Unfortunately it has some limits (for example, no integration with eBooks) but it is the most comprehensive and powerful tool I've found.
I tried for a while also Evernote and, while its online sharing is quite better and it can be used on Android (my current mobile platform), it is not powerful as OneNote.


TF-IDF Scores:
android: 0.1927
better: 0.1238
current: 0.1628
currently: 0.1777
data: 0.1334
desktop: 0.1672
example: 0.1173
home: 0.1927
integration: 0.1927
microsoft: 0.1589
mobile: 0.1845
notes: 0.1927
office: 0.1927
online: 0.3853
organize: 0.1927
personal: 0.1554
platform: 0.1845
powerful: 0.3555
quite: 0.1522
record: 0.1927
sharing: 0.1927
tool: 0.1589
tried: 0.1721
unfortunately: 0.1927
used: 0.1079
using: 0.2257

Termine con il punteggio TF-IDF più alto: online (0.3853)

----------------------------------------------------------------------------------------------------

Question 739:
What is the recommended  User Account Control (UAC) setting when developing on Windows?
Even on Win7 I find it annoying enough to turn it off (because it makes me more productive with it off) but sometimes I feel bad because I know I'll find more problems in my code if I leave it on.


TF-IDF Scores:
account: 0.2824
annoying: 0.2824
bad: 0.2329
code: 0.1267
control: 0.2824
developing: 0.2656
feel: 0.2329
know: 0.1620
leave: 0.2587
makes: 0.2215
problems: 0.2419
productive: 0.2734
setting: 0.3061
turn: 0.2824
user: 0.2150
windows: 0.2656

Termine con il punteggio TF-IDF più alto: setting (0.3061)

Best Answer:
The recommendation (even from Microsoft) is to leave it ON, and also to run your IDE unelevated whenever possible.
First of all, it forces the programmer to live with the same "annoyances" a real world user will have (if you don't know it, would you program correctly around it?).
Then, disabling UAC and working as an administrator is as bad as in Unix to work as root (decades of common wisdom will tell you why that's bad).


TF-IDF Scores:
bad: 0.3823
common: 0.1765
correctly: 0.2318
decades: 0.2513
forces: 0.2513
ide: 0.2180
know: 0.1330
leave: 0.2124
live: 0.2318
microsoft: 0.2073
possible: 0.1740
program: 0.1947
programmer: 0.1614
real: 0.1847
run: 0.2124
tell: 0.1985
unix: 0.2513
user: 0.1765
wisdom: 0.2318
work: 0.1310
working: 0.1653
world: 0.1740

Termine con il punteggio TF-IDF più alto: bad (0.3823)

----------------------------------------------------------------------------------------------------

Question 745:
What methods do you use to stay awake and alert while working?
Personally I drink coffee non stop throughout the day.  But I've also heard of this thing called exercise that should help too.  Does anyone else have tips and tricks to stay more awake and alert while working?  Redbull? Maybe a magic pill that won't require me to sleep?


TF-IDF Scores:
called: 0.2244
coffee: 0.2344
day: 0.1891
exercise: 0.2094
heard: 0.1981
help: 0.1581
magic: 0.2344
maybe: 0.1981
methods: 0.1934
non: 0.1646
personally: 0.1891
require: 0.1783
sleep: 0.2344
stay: 0.4325
stop: 0.2344
thing: 0.1752
tips: 0.2094
tricks: 0.2163
use: 0.1062
working: 0.3083

Termine con il punteggio TF-IDF più alto: stay (0.4325)

Best Answer:
Caffeine is a major cause of the problem, not the solution.  It might seem to work in the short-term but it makes things worse overall by interfering with your sleep.
If you don't sleep properly you will be tired and unfocused.  If you try to solve that with a high caffeine intake you won't sleep properly.
Exercise, eat well, try to restrict the coffee to a couple of cups a day and don't work stupid long hours.


TF-IDF Scores:
cause: 0.1621
coffee: 0.1868
couple: 0.1723
day: 0.1507
exercise: 0.1668
high: 0.1668
hours: 0.1668
long: 0.1214
major: 0.1723
makes: 0.1352
overall: 0.1868
problem: 0.1174
properly: 0.3577
short: 0.1668
sleep: 0.5604
solution: 0.1579
solve: 0.1507
stupid: 0.1868
things: 0.1020
try: 0.2428
work: 0.1948
worse: 0.1788

Termine con il punteggio TF-IDF più alto: sleep (0.5604)

----------------------------------------------------------------------------------------------------

Question 750:
I'm freshly out of college, and starting university somewhere next week. We've seen unit tests, but we kinda not used them much; and everyone talks about them, so I figured maybe I should do some.
The problem is, I don't know what to test. Should I test the common case? The edge case? How do I know that a function is adequately covered?
I always have the terrible feeling that while a test will prove that a function works for a certain case, it's utterly useless to prove that the function works, period.


TF-IDF Scores:
adequately: 0.1618
case: 0.3835
certain: 0.1445
college: 0.1549
common: 0.1136
covered: 0.1618
edge: 0.1549
feeling: 0.1618
function: 0.4102
know: 0.1713
maybe: 0.1367
problem: 0.1016
prove: 0.3236
seen: 0.1171
starting: 0.1404
terrible: 0.1618
test: 0.3273
tests: 0.1254
unit: 0.1231
university: 0.1549
used: 0.0906
useless: 0.1549
week: 0.1549
works: 0.2890

Termine con il punteggio TF-IDF più alto: function (0.4102)

Best Answer:
My personal philosophy has thusfar been:

Test the common case of everything you can.  This will tell you when that code breaks after you make some change (which is, in my opinion, the single greatest benefit of automated unit testing).
Test the edge cases of a few unusually complex code that you think will probably have errors.
Whenever you find a bug, write a test case to cover it before fixing it
Add edge-case tests to less critical code whenever someone has time to kill.



TF-IDF Scores:
add: 0.1565
automated: 0.1804
benefit: 0.1804
breaks: 0.1727
bug: 0.1488
case: 0.4277
cases: 0.1488
change: 0.1250
code: 0.2240
common: 0.1267
complex: 0.1565
critical: 0.1804
edge: 0.3455
errors: 0.1488
fixing: 0.1804
make: 0.1011
opinion: 0.1665
personal: 0.1456
probably: 0.1326
single: 0.1565
tell: 0.1426
test: 0.3650
testing: 0.1349
tests: 0.1398
think: 0.0941
time: 0.0927
unit: 0.1372
write: 0.1077

Termine con il punteggio TF-IDF più alto: case (0.4277)

----------------------------------------------------------------------------------------------------

Question 756:
I'm trying to find places where I can hone my craft outside the context of school or work. Are there places online, or books available, where I can access lists of programming puzzles or challenges?


TF-IDF Scores:
access: 0.2367
available: 0.2479
books: 0.2367
challenges: 0.2808
context: 0.2620
lists: 0.2808
online: 0.2934
outside: 0.2706
places: 0.5240
programming: 0.1425
school: 0.2808
trying: 0.2091
work: 0.1529

Termine con il punteggio TF-IDF più alto: places (0.5240)

Best Answer:
Moderator note: this is intended to be a canonical list; please check to see if your suggestion has already been added to the answer. If it hasn't, edit the answer to add yours, preferably with an explanation or reason why you're suggesting it.
On Stack Exchange
Pick a tag, follow the new questions posted, and try to solve them. If you find a good one, bookmark it for later use:

Stack Overflow
Code Review Community Challenges
Programming Puzzles and Code Golf
Solve algorithmic and datatypes problems

Books

Algorithms for Interviews by Adnan Aziz
Cracking the Coding Interview (6th Edition) by Gayle Laakmann
Programming Challenges by Steven S. Skiena
The Art of Computer Programming by Donald E. Knuth

Communities and Blogs

Algorithm Geeks Google Group
CodeKata
LessThanDot's Programmer Puzzles forum
The Daily WTF's Bring Your Own Code series
/r/dailyprogrammer

Game sites and ongoing contests

Codingame - fun games (solo and multiplayer) to practice your coding skills. Supports 25+ programming languages.
CodeChef
Code Combat - Javascript and Python solo and multiplayer games in the style of a strategy game.
Hacker.org Challenge — "The hacker.org challenges are a series of puzzles, tricks, tests, and brainteasers designed to probe the depths your hacking skills. To master this series you will need to crack cryptography, write clever code, and dissect the impenetrable; and in the process you will enrich your understanding of the world of hacking."
Pex for fun — game from Microsoft research where you duel against other programmers
Rankk — "You start with the easy levels and progress to the intermediate and hard levels by solving the minimum number of required challenges at each level. The journey to the top is an arduous yet rewarding one. You need to be sufficiently determined and persevering to go far. Only a few are expected to reach the apex and attain Geb."
TopCoder
Google Code Jam—algorithmic puzzles

Language specific

4Clojure (Clojure) — "4Clojure is a resource to help fledgling clojurians learn the language through interactive problems. The first few problems are easy enough that even someone with no prior experience should find the learning curve forgiving. See 'Help' for more information."

Prolog Problems (Prolog) — "The purpose of this problem collection is to give you the opportunity to practice your skills in logic programming. Your goal should be to find the most elegant solution of the given problems. Efficiency is important, but logical clarity is even more crucial. Some of the (easy) problems can be trivially solved using built-in predicates. However, in these cases, you learn more if you try to find your own solution."

Python Challenge (Python) — "Python Challenge is a game in which each level can be solved by a bit of (Python) programming."

Ruby Quiz (Ruby) - "Ruby Quiz is a weekly programming challenge for Ruby programmers in the spirit of the Perl Quiz of the Week. A new Ruby Quiz is sent to the Ruby Talk mailing list each Friday."

IOCCC (C) - "A contest to write the most obscure/obfuscated C program. (Fun to try to understand the previous year's entries, or to submit a new one.)"

Underhanded C Contest (C) - "contest to turn out code that is malicious, but passes a rigorous inspection, and looks like an honest mistake. (Try to understand previous year's entries, and learn to find similar mistakes in other people's code)"

CheckiO - Python programming challenges. Custom "Missions" can be created by members.

109 Python Problems for CCPS 109 Python problems of various levels of difficulty, with an automated pseudorandom fuzz tester to verify that the functions are correct.


Online judges / automatic assessment

Codingbat has lots of coding challenges ranging from warm-ups to Harder recursion problems. It is available in Java and Python.
Cyber-dojo has a nice variety of katas and supports a good selection of languages. It is intended to support doing deliberate practice of TDD, but could be used for personal development too.
LeetCode
Peking University JudgeOnline for ACIP/ICPC
Sphere Online Judge
University of Valladolid Online Judge
Codewars — Training with code challenges.
Rosalind algorithms and bioinformatics
Quizful - interactive programming quizzes in "Duolingo style".
This site looks fun and has a good set of questions, at least in Java. Plus, as they say, it has adaptive learning algorithm, that makes learning more effective.
exercism - Challenges in more than 30 languages that will be evaluated automatically.

Problem lists and contest archives

ACM/ICPC Problem Index @ HIT — List of problems from the ACM International Collegiate Programming Contest
Algorithmist — Includes lists of algorithms and other puzzle sites
Career Cup — Collects community-subumitted interview questions from various tech companies
Educational Computing Organization of Ontairo's past computer programming puzzles
Engineering Puzzles at Facebook — Puzzles provided for the purposes of evaluating potential hires
Google Code Jam contest archives
Ninth Annual ICFP Programming Contest Task archive
Ponder this at IBM Research — Puzzles provided for the purposes of evaluating potential hires
Programming Praxis
Project Euler
Rosetta Code
TopCoder Match List
International Olympiad in Informatics - yearly contents for teams of students. (previous year's problem sets)

Security oriented

Smashthestack
gera's insecure programming challenges



TF-IDF Scores:
30: 0.0407
add: 0.0369
added: 0.0379
algorithm: 0.0814
algorithms: 0.1220
answer: 0.0581
automated: 0.0425
available: 0.0359
bit: 0.0329
books: 0.0343
bring: 0.0425
built: 0.0392
career: 0.0323
cases: 0.0351
challenges: 0.3661
check: 0.0336
code: 0.1934
coding: 0.0838
companies: 0.0379
computer: 0.0658
computing: 0.0407
correct: 0.0369
created: 0.0425
daily: 0.0392
designed: 0.0392
development: 0.0251
easy: 0.0953
edit: 0.0343
effective: 0.0379
engineering: 0.0407
euler: 0.0425
experience: 0.0283
far: 0.0343
follow: 0.0359
fun: 0.1568
functions: 0.0392
game: 0.1402
games: 0.0759
given: 0.0369
goal: 0.0392
golf: 0.0425
good: 0.0696
google: 0.1106
group: 0.0407
hard: 0.0329
help: 0.0573
important: 0.0303
information: 0.0329
interview: 0.0737
interviews: 0.0407
java: 0.0581
javascript: 0.0369
language: 0.0453
languages: 0.0828
later: 0.0369
learn: 0.0838
learning: 0.0895
level: 0.0658
like: 0.0177
list: 0.1194
lists: 0.0814
logic: 0.0407
logical: 0.0392
looks: 0.0759
lots: 0.0369
makes: 0.0307
master: 0.0407
match: 0.0407
members: 0.0407
microsoft: 0.0351
minimum: 0.0425
mistakes: 0.0425
need: 0.0484
new: 0.0733
nice: 0.0369
note: 0.0392
number: 0.0336
online: 0.1275
opportunity: 0.0392
org: 0.0850
organization: 0.0379
oriented: 0.0359
overflow: 0.0369
passes: 0.0425
past: 0.0343
people: 0.0220
personal: 0.0343
pick: 0.0379
plus: 0.0425
potential: 0.0759
practice: 0.1077
previous: 0.1138
prior: 0.0425
problem: 0.1068
problems: 0.3357
process: 0.0307
program: 0.0329
programmer: 0.0273
programmers: 0.0528
programming: 0.2890
project: 0.0242
provided: 0.0784
purpose: 0.0369
python: 0.3085
questions: 0.0937
reason: 0.0318
required: 0.0379
resource: 0.0425
review: 0.0407
ruby: 0.2352
say: 0.0251
security: 0.0379
set: 0.0312
similar: 0.0336
site: 0.0359
sites: 0.0737
skills: 0.1052
solo: 0.0814
solution: 0.0718
solve: 0.0686
solving: 0.0407
specific: 0.0336
stack: 0.0737
start: 0.0290
style: 0.0701
support: 0.0369
talk: 0.0392
task: 0.0329
tdd: 0.0369
teams: 0.0425
tester: 0.0392
tests: 0.0329
training: 0.0425
tricks: 0.0392
try: 0.1104
turn: 0.0392
understand: 0.0559
understanding: 0.0407
university: 0.0814
use: 0.0193
used: 0.0238
using: 0.0249
various: 0.0850
week: 0.0407
world: 0.0294
write: 0.0507
year: 0.1028

Termine con il punteggio TF-IDF più alto: challenges (0.3661)

----------------------------------------------------------------------------------------------------

Question 775:
On any team, you are going to have the need for more grizzled and grey developers and some young pups. Some reasons include:

Money. There are often tasks that don't require the same level of experience to deliver, so it makes sense not to pay top dollar to have those tasks fulfilled.
Energy. There's an energy and enthusiasm that new people can bring to a team that stops it from getting too stale and set in its ways. There's also calmness and wisdom that the more senior people can bring.
Knowledge transfer and career growth. Both in terms of the project and skills, it's useful and often fun to teach people and to learn new stuff. It's satisfying to help "bring on" new team members.

I realise there are some cutting edge projects where it may be important for there to be more senior people than junior, but in general, is there an ideal mix of experiences on a team, or is it totally dependent on the project?


TF-IDF Scores:
bring: 0.4023
career: 0.1020
cutting: 0.1341
deliver: 0.1284
dependent: 0.1341
developers: 0.0942
edge: 0.1284
experience: 0.0893
experiences: 0.1341
fun: 0.1237
general: 0.1163
getting: 0.1039
going: 0.0956
help: 0.0904
important: 0.0956
include: 0.1163
knowledge: 0.1020
learn: 0.0882
level: 0.1039
makes: 0.0970
members: 0.1284
money: 0.1198
need: 0.0764
new: 0.2313
pay: 0.1237
people: 0.2775
project: 0.1528
projects: 0.0986
reasons: 0.1106
require: 0.1020
senior: 0.2568
sense: 0.1106
set: 0.0986
skills: 0.1106
stuff: 0.1039
tasks: 0.2164
teach: 0.1341
team: 0.3714
terms: 0.1341
useful: 0.0956
ways: 0.1082
wisdom: 0.1237

Termine con il punteggio TF-IDF più alto: bring (0.4023)

Best Answer:
I really like what Eric Brechner has to say on this subject

Think of your team as a river instead
of a lake. A lake stagnates. There’s
no energy or impetus to change. The
same is true of groups that stagnate.
They cultivate mediocrity and
complacency; they abhor risk. A river
is always running and changing with
lots of great energy. You want a
river.
A river depends on the flow of water,
and your team depends on the flow of
people and information. You can think
of the people divided into three
groups: new blood, new leaders, and
elders ready for a new challenge.
Here’s how those groups should balance
and flow:

The largest group should be the new blood. Not all of them will become
technical or organizational leaders.

Sometimes you’ll have more new leaders than elders, sometimes the
reverse, but ideally you should
maintain a balance.

For flow, you want a steady stream of new blood becoming your new
leaders, and new leaders becoming
elders.

The key to flow is new blood coming in and elders moving out. For this to
work, you WANT your elders to transfer
before they clog the stream and
disrupt the flow of opportunitiesfor
others.


Not all technologies flow at the same
rate. Central engines, like the
Windows kernel, flow slowly, while
web-based services, like MSN Search,
flow quickly. You need to adjust for
your situation, but even the most
conservative technologies do change
and flow. How do you successfully
encourage and maintain a healthy flow?

Keep a constant supply of new people.

Instill information sharing as a way of life.

Shape the organization and roles to create growth opportunities.

Find new challenges for your elders.





TF-IDF Scores:
based: 0.0814
challenges: 0.1006
change: 0.1455
changing: 0.1006
coming: 0.1006
constant: 0.1051
create: 0.0848
depends: 0.1823
encourage: 0.0969
great: 0.0786
group: 0.1006
information: 0.1628
instead: 0.0786
kernel: 0.1051
key: 0.1006
life: 0.0912
like: 0.1312
lots: 0.0912
maintain: 0.2102
moving: 0.0969
need: 0.0599
new: 0.6647
organization: 0.0939
organizational: 0.1051
people: 0.1631
quickly: 0.0912
really: 0.0604
risk: 0.1006
running: 0.0969
say: 0.0621
search: 0.0969
sharing: 0.1051
situation: 0.0888
slowly: 0.1006
subject: 0.1006
successfully: 0.1051
team: 0.1455
technical: 0.0830
technologies: 0.1939
think: 0.1096
true: 0.0888
want: 0.1751
way: 0.0589
web: 0.0749
windows: 0.0912
work: 0.0548

Termine con il punteggio TF-IDF più alto: new (0.6647)

----------------------------------------------------------------------------------------------------

Question 778:
What question have you found especially valuable in interviewing software developers?  What is it about the question that has made it particularly useful?
I'm looking for a particular question you like to ask, not just an interviewing approach like "make them write code".


TF-IDF Scores:
approach: 0.2247
ask: 0.2036
code: 0.1127
developers: 0.1913
especially: 0.2247
interviewing: 0.5025
like: 0.2266
looking: 0.2110
make: 0.1525
particular: 0.2152
particularly: 0.2512
question: 0.4876
software: 0.1595
useful: 0.1941
write: 0.1625

Termine con il punteggio TF-IDF più alto: interviewing (0.5025)

Best Answer:
Take a look at this sample code and tell me how you'd improve it.


TF-IDF Scores:
code: 0.2778
look: 0.4783
sample: 0.6426
tell: 0.5303

Termine con il punteggio TF-IDF più alto: sample (0.6426)

----------------------------------------------------------------------------------------------------

Question 779:
It doesn't have to be programming or software development related, but just asked during an interview for an IT related job.
I know some "left field" questions are meant to see how the candidate copes with unexpected and novel situations, but here I'm looking for a question that appeared to be completely unrelated to the job they were interviewing you for, or something that made you think "what useful information could they possibly get from my answer to that question?".


TF-IDF Scores:
answer: 0.1534
asked: 0.1651
candidate: 0.2245
completely: 0.1897
development: 0.1327
field: 0.2071
information: 0.1740
interview: 0.1948
interviewing: 0.2071
job: 0.3068
know: 0.1188
left: 0.2245
looking: 0.1740
meant: 0.2245
possibly: 0.1897
programming: 0.1091
question: 0.2680
questions: 0.1651
related: 0.3896
situations: 0.2149
software: 0.1315
think: 0.1170
unexpected: 0.2245
useful: 0.1600

Termine con il punteggio TF-IDF più alto: related (0.3896)

Best Answer:

Where do you see yourself in 5 years?

Do they really think people are dumb enough to say that they want to do something completely different? Or don't want to work for them?
I guess it can be useful as an indicator of who not to hire but it's so stupid easy to fake that you can't use it as an indicator of who to hire in any way if they answer correctly.


TF-IDF Scores:
answer: 0.1878
completely: 0.2323
correctly: 0.2536
different: 0.1904
easy: 0.2055
guess: 0.2632
hire: 0.5498
people: 0.1423
really: 0.1581
say: 0.1625
stupid: 0.2749
think: 0.1433
use: 0.1246
useful: 0.1959
want: 0.3053
way: 0.1540
work: 0.1433
years: 0.1931

Termine con il punteggio TF-IDF più alto: hire (0.5498)

----------------------------------------------------------------------------------------------------

Question 811:
Literate programming has good ideals. Why do you think that this isn't mainstream? It is because it has failed to deliver?


TF-IDF Scores:
deliver: 0.5124
failed: 0.4938
good: 0.2924
mainstream: 0.5124
programming: 0.2600
think: 0.2790

Termine con il punteggio TF-IDF più alto: deliver (0.5124)

Best Answer:
I would blame the network effect.
For other people to edit your code and documentation, they must be able to understand it.  
This pushes people away from something like cweb/noweb, because using them would require you to learn TeX and the program-specific syntax on top of the programming language you are using for the project. This can be seen as a huge waste of time, especially if they don't need any of the math typesetting that is such a big draw for TeX in the first place. (And for many applications programmers, they really won't need it.) Instead they prefer something like Visual Studio's XML comments, because that's already popular and well-established. 
The places I have seen literate programming take off are in scientific/statistical computing, where most of the programmers have significant training (aka PhDs) in math, CS, or statistics, and thus are already famliiar with LaTeX. The documentation they write is more likely to include a lot of complicated formulae that are best written in TeX, and they are more likely to be programming in R. The proportion of R programmers who know about SWeave is definitely much higher than, say, the proportion of C programmers who know about cweb. 


TF-IDF Scores:
able: 0.1220
applications: 0.1140
away: 0.1289
best: 0.0917
big: 0.1118
code: 0.0597
comments: 0.1191
complicated: 0.1331
computing: 0.1382
definitely: 0.1443
documentation: 0.2504
draw: 0.1443
edit: 0.1164
especially: 0.1191
higher: 0.1289
huge: 0.1382
include: 0.1252
instead: 0.1079
know: 0.1528
language: 0.0770
learn: 0.0949
like: 0.1201
likely: 0.2329
lot: 0.0917
need: 0.1645
network: 0.1443
people: 0.1494
place: 0.1118
places: 0.1289
popular: 0.1331
prefer: 0.1289
program: 0.1118
programmers: 0.3588
programming: 0.2103
project: 0.0822
really: 0.0830
require: 0.1098
say: 0.0853
seen: 0.2089
specific: 0.1140
studio: 0.1331
syntax: 0.1331
time: 0.0741
training: 0.1443
understand: 0.0949
using: 0.1690
visual: 0.1289
write: 0.0861
written: 0.1289
xml: 0.1443

Termine con il punteggio TF-IDF più alto: programmers (0.3588)

----------------------------------------------------------------------------------------------------

Question 812:
I originally tried asking this on StackOverflow, but it was too subjective :-(. I am interested in methods of defining the power of programming languages. Turing completeness is one, but it is almost universally satisfied. What would be nice is to define a measure of power that discriminates among programming languages that are actually in used. For example, can anyone propose a non-subjective method that would discriminate between assembly and Java?
Turing completeness means that a language is maximally powerful in what it can output (which pretty much means it can do anything non-time based in the real world). So if we want to define a stronger measure of power, we need to take another approach. Shortness was suggested in the original question, but this is not easy to define at all. Does anyone have any other suggestions?


TF-IDF Scores:
actually: 0.1047
approach: 0.1247
asking: 0.1219
assembly: 0.1512
based: 0.1171
define: 0.4050
easy: 0.1130
example: 0.0920
interested: 0.1247
java: 0.1033
language: 0.0806
languages: 0.1965
means: 0.2389
measure: 0.3023
method: 0.1311
methods: 0.1247
need: 0.0861
nice: 0.1311
non: 0.2123
original: 0.1311
originally: 0.1394
output: 0.1512
power: 0.4341
powerful: 0.1394
pretty: 0.1094
programming: 0.1469
question: 0.0902
real: 0.1111
stackoverflow: 0.1512
time: 0.0776
tried: 0.1350
universally: 0.1447
used: 0.0847
want: 0.0839
world: 0.1047

Termine con il punteggio TF-IDF più alto: power (0.4341)

Best Answer:
If I understand your question correctly, you are nonetheless looking for something that is relatively measurable and not just a subjective judgement call. If so, I would personally favour the amount of time taken to solve any particular problem (averaged over all problems and all programmers). In this measure, you might need to consider not just the language itself but also the framework/API used with it. Succinct syntax is a very small factor: a much more important one is that the most commonly required functionality is easily accessible.
If you are looking for something more subjective, I’d say how fun it is. Programmers tend to be people who want problems solved, so a programming language that is fun for programmers to use is inevitably going to be the one that will solve the most problems. This measure takes into account that different people have different preferences on how to use things, so the “best” programming language will be the one that is most appealing to the widest range of programmers. However, you might need to consider not just the programming language and API here, but also the environment (IDE), which is of course what the programmer actually interacts with.


TF-IDF Scores:
account: 0.1228
actually: 0.0922
best: 0.0846
commonly: 0.1275
consider: 0.2197
correctly: 0.1228
course: 0.1125
different: 0.1844
easily: 0.1155
environment: 0.1098
framework: 0.1013
fun: 0.2456
functionality: 0.1275
going: 0.0949
ide: 0.1155
important: 0.0949
language: 0.2840
looking: 0.2063
measure: 0.2663
need: 0.1517
particular: 0.1052
people: 0.1378
personally: 0.1074
problem: 0.0836
problems: 0.3156
programmer: 0.0855
programmers: 0.3310
programming: 0.1940
question: 0.0795
required: 0.1189
say: 0.0787
small: 0.0979
solve: 0.2148
syntax: 0.1228
taken: 0.1189
takes: 0.1032
tend: 0.1189
things: 0.0727
time: 0.0684
understand: 0.0876
use: 0.1207
used: 0.0746
want: 0.0739

Termine con il punteggio TF-IDF più alto: programmers (0.3310)

----------------------------------------------------------------------------------------------------

Question 827:
For decades, the accepted degree to get to become a software developer was "Compter Science."
We've had a few questions already about whether that degree really prepares students to develop software.
Some schools have, in the last 8 years or so, started offering multiple distinct majors in programming.  Using the curriculum from my school:

Computer Science, which starts out with some intro programming courses in the first year, and then focuses on theoretical computer science, algorithms, and a bit of OS stuff.  Most classes involve several smaller projects and homeworks, done solo or in pairs.
Software Engineering, which starts out with the same intro programming courses, does a few classes of theory, and then goes into software development practices (testing, process methodologies, sofware metrics, requirements gathering) and software design (distributed system design, info system design, real-time/embedded design, subsystem design, etc)

Different schools do it differently, so the above is just a real-world example I'm familiar with.  What I ask is: Is there a need for distinct majors in programming?


TF-IDF Scores:
accepted: 0.1197
algorithms: 0.1146
ask: 0.0895
bit: 0.0928
classes: 0.2209
computer: 0.1855
decades: 0.1197
degree: 0.2292
design: 0.3845
develop: 0.1069
developer: 0.0807
development: 0.0708
different: 0.0829
differently: 0.1197
engineering: 0.1146
example: 0.0729
familiar: 0.1197
goes: 0.1069
multiple: 0.1069
need: 0.0682
practices: 0.0988
process: 0.0866
programming: 0.2326
projects: 0.0880
questions: 0.0880
real: 0.1760
really: 0.0688
requirements: 0.1012
school: 0.1146
schools: 0.2394
science: 0.3591
smaller: 0.1197
software: 0.3505
solo: 0.1146
started: 0.0966
stuff: 0.0928
testing: 0.0895
theory: 0.1146
time: 0.0615
using: 0.0701
world: 0.0829
year: 0.0966
years: 0.0841

Termine con il punteggio TF-IDF più alto: design (0.3845)

Best Answer:
Yes, they should be.
The relationship between computer science and software engineering is the same as the relationship between physics and mechanical engineering. One provides the theoretical background while the other takes those theories, along with good engineering principles, and applies them to the design and implementation of software.
You need both in order to produce new and better software. A good computer science education trains people to produce new and better algorithms, data structures, programming languages and paradigms, compilers, and a number of other things that can be used to enhance software systems. A good software engineering education, on the other hand, trains you to take these tools and knowledge obtained through a scientific study of computation, along with a knowledge of the software development lifecycle and process models to actually build the system that a customer wants and needs.


TF-IDF Scores:
actually: 0.0869
algorithms: 0.1202
background: 0.1089
better: 0.1613
build: 0.1121
computer: 0.1945
customer: 0.1061
data: 0.0869
design: 0.0806
development: 0.0742
engineering: 0.4807
good: 0.2057
hand: 0.1158
implementation: 0.1202
knowledge: 0.1910
languages: 0.0816
need: 0.0715
needs: 0.1089
new: 0.1443
number: 0.0992
paradigms: 0.1202
people: 0.0650
physics: 0.1255
process: 0.0908
produce: 0.2316
programming: 0.0610
provides: 0.1255
science: 0.2510
software: 0.4410
structures: 0.1202
study: 0.1255
systems: 0.1158
takes: 0.0973
things: 0.0686
tools: 0.1013
used: 0.0703
wants: 0.1089
yes: 0.0938

Termine con il punteggio TF-IDF più alto: engineering (0.4807)

----------------------------------------------------------------------------------------------------

Question 843:
I was instructed by my project manager that frequent deployment in PROD or to test server should be avoided. But I don't understand why? We roll our testing copy to PROD on every sprint end but suddenly client would ask a simple change to the existing application which would require a re-deployment. When every thing was well tested and QA approved. why should we avoid frequent deployment?
How it was done universally?


TF-IDF Scores:
application: 0.2014
ask: 0.2048
avoid: 0.2210
change: 0.1897
client: 0.2528
copy: 0.2528
end: 0.1983
existing: 0.2447
manager: 0.2528
project: 0.1561
qa: 0.2740
require: 0.2084
server: 0.2528
simple: 0.2165
test: 0.1848
tested: 0.2623
testing: 0.2048
thing: 0.2048
understand: 0.1802
universally: 0.2623

Termine con il punteggio TF-IDF più alto: qa (0.2740)

Best Answer:
If you are talking about a hosted web application, the users don't get a say-so in when they get upgrades. That is, they are forced to upgrade each time you do a push to production.
If your changes dramatically change the system rules or UI, you should definitely consider bundling your releases and doing it less frequently. It is very frustrating to users to have to continually re-learn how to use the tools they rely on and violates the UI principle of making them feel they are in control of their computer/software.


TF-IDF Scores:
application: 0.1597
change: 0.1504
changes: 0.1792
computer: 0.1683
consider: 0.1792
control: 0.2004
definitely: 0.2172
feel: 0.1652
forced: 0.2172
frequently: 0.1836
learn: 0.1429
making: 0.1792
principle: 0.2172
production: 0.2172
push: 0.2172
rely: 0.2172
rules: 0.2080
say: 0.1284
software: 0.1272
time: 0.1116
tools: 0.1752
ui: 0.4008
use: 0.0984
users: 0.3305
web: 0.1548

Termine con il punteggio TF-IDF più alto: ui (0.4008)

----------------------------------------------------------------------------------------------------

Question 866:
I know this is obviously not true for some games, minesweeper, card games, etc.  But what about any game involving simulating the real world environment.  Obviously these games have some form of a physics engineer powering the graphics. 
For someone like me who personally did not enjoy physics but loves video games, do I have a chance at ever getting involved in the development cycle of a video game such as this while disliking physics? 


TF-IDF Scores:
chance: 0.1530
cycle: 0.1658
development: 0.0980
environment: 0.1368
form: 0.1530
game: 0.2735
games: 0.5923
getting: 0.1285
graphics: 0.1587
involved: 0.1481
know: 0.0878
like: 0.0690
obviously: 0.2877
personally: 0.1338
physics: 0.4974
real: 0.1219
true: 0.1401
world: 0.1148

Termine con il punteggio TF-IDF più alto: games (0.5923)

Best Answer:
There are many aspects to game programing and you don't need to be an expert at all of them. 
If you're on a bigger team you may not even be doing the core game programming but just network communication for example. 
For core game programming I would think that above a sound physics understanding you would need a strong mathematical background.  Having a strong mathematical background will allow you to do things like modelling transformations, clippings, keyframe animation, ray tracing, image processing, texture mapping, etc.
Having a strong physics background may help you with coming up with new computer graphics methods, but it is not required if you want to become a game programmer. 


TF-IDF Scores:
allow: 0.1355
aspects: 0.1355
background: 0.3682
bigger: 0.1355
coming: 0.1355
communication: 0.1264
computer: 0.1096
core: 0.2830
example: 0.0861
expert: 0.1355
game: 0.4669
graphics: 0.1355
help: 0.0954
like: 0.0589
methods: 0.1167
need: 0.1613
network: 0.1415
new: 0.0813
physics: 0.2830
programmer: 0.0909
programming: 0.1375
required: 0.1264
sound: 0.1415
strong: 0.3916
team: 0.0980
things: 0.0773
think: 0.0738
understanding: 0.1355
want: 0.0786

Termine con il punteggio TF-IDF più alto: game (0.4669)

----------------------------------------------------------------------------------------------------

Question 870:
One per answer please. I'll add my favourite as an answer.


TF-IDF Scores:
add: 0.4560
answer: 0.7182
favourite: 0.5256

Termine con il punteggio TF-IDF più alto: answer (0.7182)

Best Answer:

Code Complete by Steve McConnell. I don't even think it needs explanation. It's the definitive book on software construction. Incredibly well written and covers all aspects of the practical (programming) side of creating software. 


TF-IDF Scores:
aspects: 0.3256
book: 0.2587
code: 0.1408
complete: 0.2874
creating: 0.3256
incredibly: 0.3256
needs: 0.2951
programming: 0.1652
software: 0.3984
steve: 0.3401
think: 0.1773
written: 0.3038

Termine con il punteggio TF-IDF più alto: software (0.3984)

----------------------------------------------------------------------------------------------------

Question 874:
In my current job it feels like we have a lot requirement changes. We are an "Agile" shop, so I get that we are supposed to adjust and what not, but sometime the change is large and nothing trivial. 
My question is, how do you effectively communicate the cost of the change? Because of being agile, if a change is big enough something will get dropped from the current sprint, but it usually just get added next time around. Since our model is SaaS, the end customer is effectively the business itself, and they know they will get the cut feature n weeks later.
I guess what I am trying to get at is the removal of a feature really isn't anything to use for communication as it was only delayed by n weeks. What other ways do you have to get the business to understand what a change costs?


TF-IDF Scores:
added: 0.1368
agile: 0.2827
big: 0.1187
business: 0.2528
change: 0.4244
changes: 0.1264
communication: 0.1368
cost: 0.1329
costs: 0.1532
current: 0.2589
customer: 0.1295
effectively: 0.2827
end: 0.1108
feature: 0.2331
feels: 0.1467
guess: 0.1467
job: 0.1047
know: 0.0811
large: 0.1413
later: 0.1329
like: 0.0637
lot: 0.0973
model: 0.1295
question: 0.0914
really: 0.0881
supposed: 0.1329
time: 0.0787
trivial: 0.1413
trying: 0.1092
understand: 0.1008
use: 0.0694
usually: 0.1126
ways: 0.1236
weeks: 0.3064

Termine con il punteggio TF-IDF più alto: change (0.4244)

Best Answer:
You could try setting a minimum age of a new addition / change (not applicable to bug fixes).  For example no new changes can be worked on until it is 3 weeks old.  
Having a minimum age of a task is nice because at the start, every task looks like it's extremely important, but if you wait some time then it's importance will often drop significantly.  Depending on your time interval it will give you at least that amount of time of stability in the tasks you're working on.
To track the age you would allow the tasks to be added to some list, but they wouldn't be considered as tasks to work on until that period has expired.


TF-IDF Scores:
added: 0.1515
allow: 0.1625
applicable: 0.1697
bug: 0.1400
change: 0.1175
changes: 0.1400
considered: 0.1515
depending: 0.1697
drop: 0.1625
example: 0.1033
extremely: 0.1515
importance: 0.1697
important: 0.1209
like: 0.0706
list: 0.1192
looks: 0.1515
minimum: 0.3394
new: 0.1951
nice: 0.1472
old: 0.1315
setting: 0.1697
start: 0.1159
task: 0.2630
tasks: 0.4107
time: 0.2615
track: 0.1565
try: 0.1103
wait: 0.1625
weeks: 0.1697
work: 0.0885
worked: 0.1369
working: 0.1116

Termine con il punteggio TF-IDF più alto: tasks (0.4107)

----------------------------------------------------------------------------------------------------

Question 937:
I know that they are implemented extremely unsafely in C/C++. Can't they be implemented in a safer way? Are the disadvantages of macros really bad enough to outweigh the massive power they provide?


TF-IDF Scores:
bad: 0.2905
extremely: 0.3411
implemented: 0.6301
know: 0.2021
power: 0.3656
provide: 0.3656
really: 0.2196
way: 0.2139

Termine con il punteggio TF-IDF più alto: implemented (0.6301)

Best Answer:
I think the main reason is that macros are lexical. This has several consequences:

The compiler has no way of checking that a macro is semantically closed, i.e. that it represents a “unit of meaning” like a function does. (Consider #define TWO 1+1 — what does TWO*TWO equal? 3.)
Macros are not typed like functions are. The compiler cannot check that the parameters and return type make sense. It can only check the expanded expression that uses the macro.
If the code doesn’t compile, the compiler has no way of knowing whether the error is in the macro itself or the place where the macro is used. The compiler will either report the wrong place half of the time, or it has to report both even though one of them is probably fine. (Consider #define min(x,y) (((x)<(y))?(x):(y)): What should the compiler do if the types of x and y don’t match or don’t implement operator<?)
Automated tools cannot work with them in semantically useful ways. In particular, you can’t have things like IntelliSense for macros that work like functions but expand to an expression. (Again, the min example.)
The side-effects of a macro are not as explicit as they are with functions, causing potential confusion for the programmer. (Consider again the min example: in a function call, you know that the expression for x is evaluated only once, but here you can’t know without looking at the macro.)

Like I said, these are all consequences of the fact that macros are lexical. When you try to turn them into something more proper, you end up with functions and constants.


TF-IDF Scores:
automated: 0.1029
causing: 0.1029
check: 0.1626
code: 0.0426
compile: 0.0985
compiler: 0.4924
consider: 0.2546
define: 0.1837
effects: 0.0949
end: 0.0744
equal: 0.1029
error: 0.0869
example: 0.1253
fact: 0.0813
fine: 0.1029
function: 0.1739
functions: 0.3796
half: 0.1029
implement: 0.0919
know: 0.1089
knowing: 0.0985
like: 0.2140
looking: 0.0797
main: 0.0849
make: 0.0576
match: 0.0985
operator: 0.1029
particular: 0.0813
place: 0.1594
potential: 0.0919
probably: 0.0756
programmer: 0.0661
proper: 0.0985
reason: 0.0769
report: 0.1898
return: 0.0869
said: 0.0769
sense: 0.0849
things: 0.0562
think: 0.0536
time: 0.0528
tools: 0.0830
try: 0.0669
turn: 0.0949
type: 0.0813
typed: 0.0919
types: 0.0892
unit: 0.0782
used: 0.0576
useful: 0.0733
uses: 0.0892
way: 0.1152
ways: 0.0830
work: 0.1073
wrong: 0.0830

Termine con il punteggio TF-IDF più alto: compiler (0.4924)

----------------------------------------------------------------------------------------------------

Question 940:
This is more a discussion question than an actual attempt to determine the "best", since that clearly varies by the needs of the organization. I'm more curious about the arguments in favor of different systems across categories (centralized vs distributed, open vs proprietary, etc).
So, what do you think is the best version control system?


TF-IDF Scores:
actual: 0.2367
arguments: 0.2565
attempt: 0.2456
best: 0.3259
clearly: 0.2367
control: 0.2367
determine: 0.2456
different: 0.1777
needs: 0.2226
open: 0.1951
organization: 0.2291
question: 0.1531
systems: 0.2367
think: 0.1337
version: 0.2456
vs: 0.4582

Termine con il punteggio TF-IDF più alto: vs (0.4582)

Best Answer:
Mercurial
Because of it's sophisticated ability to branch and merge code, it is the best I've used. The whole DVCS paradigm just makes so much sense. I've not used Git, but I suppose that it qualifies as well. 


TF-IDF Scores:
ability: 0.4174
best: 0.2874
code: 0.1872
makes: 0.3274
sense: 0.3733
suppose: 0.4525
used: 0.5068

Termine con il punteggio TF-IDF più alto: used (0.5068)

----------------------------------------------------------------------------------------------------

Question 966:
There are a lot of questions about what programming books should be on the programmer's bookshelf. How about non-programming related books that can help you become a better programmer or developer? It would also be interesting to know why they would help.
My first choice would be Sun Tzu's "Art of War" (however cliché), because it made it obvious that the success of any project depends on the strength of its weakest link (and warfare is a big project).


TF-IDF Scores:
better: 0.1603
big: 0.1934
books: 0.4027
choice: 0.2059
depends: 0.2165
developer: 0.1683
help: 0.3366
interesting: 0.1934
know: 0.1321
lot: 0.1585
non: 0.1753
obvious: 0.2302
programmer: 0.3206
programming: 0.2425
project: 0.2845
questions: 0.1835
related: 0.2165
war: 0.2389

Termine con il punteggio TF-IDF più alto: books (0.4027)

Best Answer:
The Design of Everyday Things by Donald Norman



TF-IDF Scores:
design: 0.7618
things: 0.6478

Termine con il punteggio TF-IDF più alto: design (0.7618)

----------------------------------------------------------------------------------------------------

Question 991:
What are the first 5 things you do before starting a new project?
Do you always spend a day researching new frameworks? Or, using similar or competing products?


TF-IDF Scores:
day: 0.3106
frameworks: 0.3254
new: 0.4428
products: 0.3851
project: 0.2194
similar: 0.3042
spend: 0.3254
starting: 0.3341
things: 0.2103
using: 0.2255

Termine con il punteggio TF-IDF più alto: new (0.4428)

Best Answer:
This is pretty project-dependent.  Is this a project I'm starting with the intent of selling, or a project for a specific customer?  Also, what constitutes "starting"? Is that before or after requirements gathering? A rough list, though:

Get a context for the project.  That is, figure out what your customer or potential user is trying to accomplish and why.  If you're building a hotel registration system, what's wrong with OTS options, for example.
Gather requirements.  Meet with stakeholders.  Meet with users.  Meet with anyone who has a say in the project, if you can.  Look at existing solutions that this project will replace, either that the customer is using or that exist in the market place.  From there, write it all down in a non-technical language as you can- a good reqs doc should describe what's to be done but not how to do it.  Then discuss this doc with the customer and iterate until they agree with it.  This step can be less formal for smaller projects (possibly even entirely verbal).
Start making technical decisions.  Pick languages, frameworks, ORMs, databases, etc that best solve the problem, whether this means sticking with something you know or learning something new.
Analyze the risks for this project.  If this is a government contract, you probably want a 100 page leather-bound risk report.  If it's a 3-man 4-month project, you might be fine with some notes in a text file or a spreadsheet.  Either way, you want to figure out what can go wrong with the project, how likely it is to happen, how much it'll hurt, and what you are going to do to prepare for it, handle it, and/or mitigate it's effects after the fact.  A common one, for example, is "One of the devs gets hit by a bus, quits, gets sick, etc."  So you might mitigate that by pair programming to share knowledge, using good source control practices to keep code centralized, etc.  Overall, the process of sitting and thinking about what could go wrong and being prepared for the possibilities is more important than actually writing out all the contingency plans.
Set up the technology.  It's the sort of thing that no one wants to do once you're in the thick of actually coding, so set up your repo, your build server, your build system, your wikis, your bug tracker, or whatever you intend to use for your project.



TF-IDF Scores:
100: 0.0741
actually: 0.1148
agree: 0.0794
best: 0.0527
bug: 0.0684
build: 0.1481
building: 0.0794
code: 0.0343
coding: 0.0545
common: 0.0582
constitutes: 0.0829
context: 0.0741
contract: 0.0794
control: 0.0765
customer: 0.2803
dependent: 0.0829
discuss: 0.0829
effects: 0.0765
entirely: 0.0794
example: 0.1010
exist: 0.0829
existing: 0.0741
fact: 0.0655
figure: 0.1658
file: 0.0642
fine: 0.0829
formal: 0.0765
frameworks: 0.0701
gets: 0.1439
going: 0.0591
good: 0.0906
handle: 0.0829
happen: 0.0684
important: 0.0591
intent: 0.0829
know: 0.0439
knowledge: 0.0631
language: 0.0442
languages: 0.0539
learning: 0.0582
likely: 0.0669
list: 0.0582
look: 0.0591
making: 0.0684
man: 0.0794
market: 0.0794
means: 0.0655
meet: 0.2488
month: 0.0794
new: 0.0477
non: 0.0582
notes: 0.0829
overall: 0.0829
page: 0.0794
pair: 0.0765
pick: 0.0741
place: 0.0642
possibly: 0.0701
potential: 0.0741
practices: 0.0684
prepare: 0.0794
prepared: 0.0829
pretty: 0.0600
probably: 0.0610
problem: 0.0521
process: 0.0600
programming: 0.0403
project: 0.4725
projects: 0.0610
replace: 0.0794
report: 0.0765
requirements: 0.1401
risk: 0.0794
rough: 0.0829
say: 0.0490
server: 0.0765
set: 0.1219
share: 0.0765
smaller: 0.0829
solve: 0.0669
sort: 0.0829
source: 0.0631
specific: 0.0655
start: 0.0566
starting: 0.1439
step: 0.0765
technical: 0.1310
text: 0.0765
thing: 0.0620
thinking: 0.0701
trying: 0.0591
use: 0.0376
user: 0.0582
users: 0.0631
using: 0.0971
want: 0.0921
wants: 0.0719
way: 0.0464
write: 0.0495
writing: 0.0566
wrong: 0.2007

Termine con il punteggio TF-IDF più alto: project (0.4725)

----------------------------------------------------------------------------------------------------

Question 1007:
Tester and blogger Lanette Creamer recently posted this question on Twitter:

If you are a professional software developer who works with testers, think of the best testers you know. What traits do they have in common?

I thought it would make an excellent question for here.
My thoughts are:

They want to remove ambiguity from requirements even if it means asking awkward questions.
They create new features by seeing the way software "should" work, rather than just how it's documented.
They demonstrate honesty and integrity and encourage but not demand it from those around them. In other words, they model behavior.

What are the traits of the best testers you've worked with?


TF-IDF Scores:
asking: 0.1419
best: 0.2235
common: 0.1236
create: 0.1419
developer: 0.1186
documented: 0.1623
encourage: 0.1623
excellent: 0.1759
features: 0.1390
know: 0.0931
make: 0.0985
means: 0.1390
model: 0.1487
new: 0.1012
professional: 0.1684
question: 0.2100
questions: 0.1293
recently: 0.1571
remove: 0.1759
requirements: 0.1487
seeing: 0.1759
software: 0.2061
tester: 0.1623
testers: 0.5278
think: 0.0917
thought: 0.1623
twitter: 0.1684
want: 0.0977
way: 0.0985
words: 0.1623
work: 0.0917
worked: 0.1419
works: 0.1571

Termine con il punteggio TF-IDF più alto: testers (0.5278)

Best Answer:
Some of the best testers I've worked with really understand how the users are going to use the software.  They understand what business function the software is supposed to play and how that software will effect the user's role/job/function.  It makes for a successful project when the tester has as much knowledge of the business as the developer and the business owner.


TF-IDF Scores:
best: 0.1304
business: 0.5082
developer: 0.1385
function: 0.3470
going: 0.1463
job: 0.1403
knowledge: 0.1562
makes: 0.1486
play: 0.1834
project: 0.1170
really: 0.1181
software: 0.3607
successful: 0.2053
supposed: 0.1781
tester: 0.1894
testers: 0.2053
understand: 0.2701
use: 0.0931
user: 0.1442
users: 0.1562
worked: 0.1657

Termine con il punteggio TF-IDF più alto: business (0.5082)

----------------------------------------------------------------------------------------------------

Question 1009:
I'd like to sell my software on the 'net but am not sure how to do the whole Merchant setup.  I have access to Commerce Server 2009, and I want to seem professional so a plain old PayPal account is out.
What do I need to know/do to sell a few things using ASP.NET, accept credit cards, and what not? 


TF-IDF Scores:
accept: 0.2432
access: 0.2049
account: 0.2344
asp: 0.2432
cards: 0.2540
know: 0.1345
like: 0.1057
need: 0.1448
net: 0.3735
old: 0.1968
professional: 0.2432
sell: 0.5081
server: 0.2344
software: 0.1488
sure: 0.1899
things: 0.1388
using: 0.1488
want: 0.1411

Termine con il punteggio TF-IDF più alto: sell (0.5081)

Best Answer:
You can use a simple checkout service like 2checkout.com, paypal, or Google Checkout.
Or you can use a service which has an affiliate network like regnow.  This will get your product onto hundreds and hundreds of sites, but it is extremely rare to ever have a sale on any of those sites.  In my experience 99.999% of sales came directly from my own company website.


TF-IDF Scores:
com: 0.2498
company: 0.2024
directly: 0.2797
experience: 0.1862
extremely: 0.2498
google: 0.2426
like: 0.2327
network: 0.2797
product: 0.2256
sales: 0.2678
simple: 0.2210
sites: 0.4853
use: 0.2535
website: 0.2426

Termine con il punteggio TF-IDF più alto: sites (0.4853)

----------------------------------------------------------------------------------------------------

Question 1025:
I'm considering learning iPhone development and Objective C but don't want to avoid developing something for the most saturated markets and app categories.
What categories should I avoid?  Are there too many dating applications, or should I just stick to coming up with a creative game or two?


TF-IDF Scores:
app: 0.2646
applications: 0.2591
avoid: 0.5292
coming: 0.3140
considering: 0.3140
developing: 0.2846
development: 0.1939
game: 0.2706
learning: 0.2303
stick: 0.3280
want: 0.1822

Termine con il punteggio TF-IDF più alto: avoid (0.5292)

Best Answer:
The iOS market has way to many apps in general. Try to make an iPad app. There are less iPad apps out than iPhone/iPod touch. 
Alternatively, try to make something for a particular (local) business.
That way you are guaranteed to get paid (by the business) and you get an app out there that is unique.
Games are always good, provided that the gameplay attracts people. Like the speakers at the WWDC 2010 said, watch play testers as they do their thing. It helps a lot with your game development.


TF-IDF Scores:
app: 0.3224
apps: 0.3297
business: 0.3297
development: 0.1181
game: 0.1648
games: 0.1785
general: 0.1734
good: 0.1092
helps: 0.1913
like: 0.0831
local: 0.1998
lot: 0.1269
make: 0.2238
market: 0.1913
particular: 0.1579
people: 0.1034
play: 0.1785
provided: 0.1843
said: 0.1494
testers: 0.1998
thing: 0.1494
touch: 0.1843
try: 0.2597
unique: 0.1998
way: 0.2238

Termine con il punteggio TF-IDF più alto: apps (0.3297)

----------------------------------------------------------------------------------------------------

Question 1058:
I'm not exactly sure when to use Enterprise Library, and when not to... and that is making me not learn it at all.  I feel that I have enough of a reason to start learning then perhaps one day I'll use it.
Are there times when I should use EntLib?
When shouldn't I use it?  


TF-IDF Scores:
day: 0.2463
enterprise: 0.2923
exactly: 0.2817
feel: 0.2323
learn: 0.2008
learning: 0.2145
library: 0.2463
making: 0.2519
reason: 0.2282
start: 0.2086
sure: 0.2282
times: 0.2366
use: 0.5535

Termine con il punteggio TF-IDF più alto: use (0.5535)

Best Answer:
I've used EntLib for many years (since they were indiviual App Blocks).  I've found that at times it can be pretty heavy as far as the size of the components, especially if you only need one block and it needs to be downloaded.  Often I'll use the Data and Logging components together and that feels like enough functionality to justify the size.  If your app is strictly on the server side then this really isn't too much of an issue.  One of the things that is nice about it is that if you need more than one block you don't have to go to multiple implementations from multiple vendors that are configured in different ways.  They also provide a tool to help with the configuration (that's a plus and a minus, a plus that they make it easy, a minus that they NEED a tool to help configure it).
I've had the pleasure of being invinted to a couple of Patterns and Practices workshops where I was working side by side with the team members who wrote EntLib.  The intent in creating EntLib was to implement Microsoft's Best Practices in common components that everyone needs that are not part of the base Framework.  They are very stable, provide very good performance and very good flexibility.
I would start by using some of the easier blocks, like Data and Logging.  They're not too hard to configure and get started with.  Then once you understand those it will be a bit easier to move on to some of the other blocks.  I have not found a situation where you shouldn't use them, other than when you don't need them.


TF-IDF Scores:
app: 0.1876
base: 0.1073
best: 0.0739
bit: 0.0901
common: 0.0817
components: 0.3340
couple: 0.1073
creating: 0.1113
data: 0.1611
different: 0.0805
easier: 0.2018
easy: 0.0869
especially: 0.0959
far: 0.0938
feels: 0.1113
framework: 0.0885
functionality: 0.1113
good: 0.1271
hard: 0.0901
help: 0.1568
implement: 0.1039
intent: 0.1163
issue: 0.0901
like: 0.0968
make: 0.0651
members: 0.1113
microsoft: 0.0959
multiple: 0.2077
need: 0.2651
needs: 0.2018
nice: 0.1009
performance: 0.1039
plus: 0.2326
practices: 0.1919
pretty: 0.0841
provide: 0.2227
really: 0.0669
server: 0.1073
situation: 0.0983
size: 0.2077
stable: 0.1163
start: 0.0794
started: 0.0938
strictly: 0.1163
team: 0.0805
things: 0.0635
times: 0.0901
tool: 0.1919
understand: 0.0765
use: 0.1054
used: 0.0651
using: 0.0681
ways: 0.0938
working: 0.0765
wrote: 0.1163
years: 0.0817

Termine con il punteggio TF-IDF più alto: components (0.3340)

----------------------------------------------------------------------------------------------------

Question 1059:
I have often heard it said that objects have not delivered in terms of code reuse. Do you agree? If you believe that they haven't, why not?


TF-IDF Scores:
agree: 0.4250
believe: 0.3964
code: 0.1837
heard: 0.3751
objects: 0.4250
said: 0.3318
terms: 0.4439

Termine con il punteggio TF-IDF più alto: terms (0.4439)

Best Answer:
No, not necessarily.
Objects deliver better semantics, organization of code/functionality and, possibly, ease-of-use.
Well designed libraries deliver on the promise of code reuse, not objects per se.


TF-IDF Scores:
better: 0.1688
code: 0.2175
deliver: 0.5032
designed: 0.2424
functionality: 0.2516
libraries: 0.2424
necessarily: 0.2347
objects: 0.5032
organization: 0.2347
possibly: 0.2221
promise: 0.2516
use: 0.1191

Termine con il punteggio TF-IDF più alto: deliver (0.5032)

----------------------------------------------------------------------------------------------------

Question 1060:
Aspect oriented programming promises to deal with cross cutting concerns, but I'm not completely sold on it yet. Have there been any other attempts to deal with this problem?


TF-IDF Scores:
completely: 0.3093
concerns: 0.3660
cutting: 0.3660
deal: 0.6754
oriented: 0.3093
problem: 0.2300
programming: 0.1778

Termine con il punteggio TF-IDF più alto: deal (0.6754)

Best Answer:
When possible, you can encapsulate cross-cutting concerns into separate modules that are then used throughout the app via dependency injection.  This allows you to somewhat decouple the cross-cutting concern implementation from it's use throughout the code.
This doesn't always work elegantly, though.  That's the reason people are trying to address the issue with things like AOP.


TF-IDF Scores:
allows: 0.2743
app: 0.2311
code: 0.1186
concerns: 0.2865
cutting: 0.5730
implementation: 0.2743
issue: 0.2220
like: 0.1192
people: 0.1482
possible: 0.1984
reason: 0.2142
somewhat: 0.2643
things: 0.1565
trying: 0.2042
use: 0.1298
used: 0.1605
work: 0.1494

Termine con il punteggio TF-IDF più alto: cutting (0.5730)

----------------------------------------------------------------------------------------------------

Question 1063:
I have often wondered if it would be possible to write a programming language that would work as a conversation. I would tell the computer that I want to store coordinates and it would ask what representation I would use. I would then ask to find the shortest path between points and it would ask if I want to use Djkstra's, brute force or use Floyd's? What research has been done towards producing a system like this?


TF-IDF Scores:
ask: 0.6276
computer: 0.2168
language: 0.1493
like: 0.1164
path: 0.2679
points: 0.2365
possible: 0.1938
programming: 0.1360
tell: 0.2211
use: 0.3805
want: 0.3109
work: 0.1459
write: 0.1670

Termine con il punteggio TF-IDF più alto: ask (0.6276)

Best Answer:
I think such a language would need an artificial intelligence in place, or at least a system that can learn.
The problem is that humans don't know what they want.
Also, even writing in classical imperative language we still make logical errors. Imagine trying telling a non-intelligent software what he has to do.


TF-IDF Scores:
errors: 0.2690
imperative: 0.3260
know: 0.1726
language: 0.3478
learn: 0.2144
logical: 0.3008
make: 0.1826
need: 0.1858
non: 0.2290
place: 0.2526
problem: 0.2048
software: 0.1909
telling: 0.3260
think: 0.1700
trying: 0.2324
want: 0.1811
writing: 0.2228

Termine con il punteggio TF-IDF più alto: language (0.3478)

----------------------------------------------------------------------------------------------------

Question 1065:
I'm comparing different STS's for claims based authentication and am trying when it's appropriate to use each one.  
It appears that ADFSv2 should be used in all Windows Environments.  Ping and Siteminder are more for the Unix side... although a sales rep said Ping was better for Windows, I didn't really understand "why"
Any comparative information is much appreciated!


TF-IDF Scores:
based: 0.2298
better: 0.1905
comparing: 0.2966
different: 0.2054
environments: 0.2966
information: 0.2298
really: 0.1705
said: 0.2217
sales: 0.2839
trying: 0.2114
understand: 0.1951
unix: 0.2966
use: 0.1344
used: 0.1661
windows: 0.5146

Termine con il punteggio TF-IDF più alto: windows (0.5146)

Best Answer:
We are in the middle of doing SSO where I'm at right now.  We couldn't get Site Minder to let us pay for a developer license; they literally didn't return the numerous calls we made begging to use their software (one of our clients was using it and we figured it would be the easiest path).
We went with Ping Identity's Pingfederate product (or is it the other way around)?
The documentation isn't amazing, but it's working for us.  When you can get past first-level support, they have been very helpful and getting us going.  Your application will be dependent upon their APIs, but your application will also support numerous open standards for SSO.  They also have consulting available to do the heavy lifting if you have the budget.


TF-IDF Scores:
apis: 0.2049
application: 0.3012
available: 0.1731
calls: 0.1830
clients: 0.2049
dependent: 0.2049
developer: 0.1382
documentation: 0.1778
getting: 0.1588
going: 0.1460
helpful: 0.1830
let: 0.1778
level: 0.1588
license: 0.2049
open: 0.1559
past: 0.1653
path: 0.1962
pay: 0.1890
product: 0.1653
return: 0.1731
right: 0.1483
site: 0.1731
software: 0.1200
standards: 0.1690
support: 0.3555
use: 0.0928
using: 0.1200
way: 0.1148
went: 0.1778
working: 0.1348

Termine con il punteggio TF-IDF più alto: support (0.3555)

----------------------------------------------------------------------------------------------------

Question 1070:
Dcpromo.exe is famous among MCSEs for being they only way to create a Windows Domain Controller (in other words an Active Directory Domain) ... which in turn is often used by the ASP.NET Membership system.
I'm trying to determine if I should put content on "www.dcpromo.com" geared for developers or more towards sysadmins.
To me, a logical extension of this "domain controller on the internet" is to use WIF for the ASP.NET Membership system.  We'd then have a website that will serve the developer's interests in the SSO, SAML, user managment and identity areas we all struggle with.
So my question is: 
Q:  Do programmers see a connection between the utility dcpromo.exe and ASP.NET Membership?  If so does it make sense to have a purpose of http://www.dcpromo.com  help developers in the areas of membership and cloud computing?  


TF-IDF Scores:
areas: 0.2605
asp: 0.4056
com: 0.2522
computing: 0.1352
connection: 0.1261
controller: 0.2824
create: 0.1139
determine: 0.1352
developer: 0.0952
developers: 0.1983
directory: 0.1412
domain: 0.4056
help: 0.0952
http: 0.1261
internet: 0.1303
logical: 0.1303
make: 0.0791
net: 0.3114
programmers: 0.0878
purpose: 0.1225
question: 0.0843
sense: 0.1165
trying: 0.1006
turn: 0.1303
use: 0.0640
used: 0.0791
user: 0.0992
utility: 0.1412
way: 0.0791
website: 0.1225
windows: 0.1225
words: 0.1303

Termine con il punteggio TF-IDF più alto: asp (0.4056)

Best Answer:
I've been a Microsoft developer for 11 years, mostly as a web developer.  Been coding since 1.1 and I've used .NET membership in many of my applications, and I've never heard of dcpromo.


TF-IDF Scores:
applications: 0.3192
coding: 0.2657
developer: 0.5449
heard: 0.3414
microsoft: 0.3333
net: 0.2970
used: 0.2263
web: 0.2879
years: 0.2838

Termine con il punteggio TF-IDF più alto: developer (0.5449)

----------------------------------------------------------------------------------------------------

Question 1090:
Language shortcuts can often be used to make code more concise.
For example, ternary and null coalescing operators can reduce the amount of code, but arguably to the detriment of readability:
In C#:
Person newGuy = new Person();
if (boss == null) {
    newGuy.Boss = GetDefaultBoss();
} else {
    newGuy.Boss = boss;
}

is functionally equivalent to:
Person newGuy = new Person();
newGuy.Boss = boss ?? GetDefaultBoss();

but obviously a lot more verbose.
Where do you draw the line when it comes to conciseness vs readability?


TF-IDF Scores:
arguably: 0.1291
boss: 0.7747
code: 0.1069
comes: 0.1191
draw: 0.1291
example: 0.0786
language: 0.0689
line: 0.0982
lot: 0.0820
make: 0.0723
new: 0.1485
obviously: 0.1120
operators: 0.1236
person: 0.4081
readability: 0.2382
reduce: 0.1291
used: 0.0723
vs: 0.1153

Termine con il punteggio TF-IDF più alto: boss (0.7747)

Best Answer:
Both.
Your first example is certainly more verbose, and arguably more explicit... but it also requires me to scan five lines instead of one. Worse, it deemphasizes its purpose - assigning a value to newGuy.Boss.
Your second example may cost me a second if I'm unfamiliar with the null coalescing operator, but there can be no doubt as to its purpose, and if I'm scanning through a larger routine looking for the source of a value, it will be much easier for me to pick this one out.
Now, contrast this:
if (boss == null) {
    newGuy.Boss = GetDefaultBoss();
    newGuy.IsTemp = true;
    newGuy.AddTask("orientation");
} else {
    newGuy.Boss = boss;
    newGuy.IsTemp = false;
}

...with:
newGuy.Boss = boss ?? GetDefaultBoss();
newGuy.IsTemp = boss == null;
if ( boss == null ) newGuy.AddTask("orientation");

The latter example is again much shorter, but now it obscures its purpose by making tasks triggered by the same test appear to be distinct. Here, I feel the verbosity of the former is justified.


TF-IDF Scores:
appear: 0.0945
arguably: 0.0945
boss: 0.8502
certainly: 0.0871
cost: 0.0820
easier: 0.0820
example: 0.1725
false: 0.0945
feel: 0.0719
instead: 0.0706
lines: 0.0844
looking: 0.0732
making: 0.0779
operator: 0.0945
pick: 0.0844
purpose: 0.2459
second: 0.1743
source: 0.0719
tasks: 0.0762
test: 0.0637
true: 0.0798
unfamiliar: 0.0945
value: 0.1597
worse: 0.0904

Termine con il punteggio TF-IDF più alto: boss (0.8502)

----------------------------------------------------------------------------------------------------

Question 1095:
I used ad-hoc MUML (made-up modeling language) to design and explain system fairly frequently.  It looks similar to UML and tends to be pretty well understood.
However, I've had a professor or two that harped on the use of strict, formal UML, as close to the spec as possible.  I always suspected that strict UML wasn't really as common as they claimed.  So, how 'bout it- how often do you actually draw out complete diagrams that use all the proper line endings, multiplicity, member type symbols, etc?


TF-IDF Scores:
actually: 0.1841
close: 0.2452
common: 0.1867
complete: 0.2246
design: 0.1707
diagrams: 0.2658
draw: 0.2658
explain: 0.1867
fairly: 0.2452
formal: 0.2452
frequently: 0.2246
language: 0.1418
line: 0.2022
looks: 0.2374
possible: 0.1841
pretty: 0.1923
proper: 0.2545
really: 0.1528
similar: 0.2100
type: 0.2100
use: 0.2409
used: 0.1489

Termine con il punteggio TF-IDF più alto: diagrams (0.2658)

Best Answer:
Never.
Heck, it's been years since I last created any UML. Line diagrams on whiteboards and scraps of paper don't count.
In fact, we just removed the sole UML question from the guide we use during interviews, because none of us really cared about the answers.


TF-IDF Scores:
answers: 0.3019
created: 0.3480
diagrams: 0.3480
fact: 0.2750
guide: 0.3480
interviews: 0.3332
line: 0.2647
paper: 0.3480
question: 0.2077
really: 0.2001
use: 0.1577
years: 0.2444

Termine con il punteggio TF-IDF più alto: created (0.3480)

----------------------------------------------------------------------------------------------------

Question 1106:
This goes back to a conversation I've had with my girlfriend. I tried to tell her that I simply don't feel adequate enough in my programming language (C++) to call myself good. She then asked me, "Well, when do you consider yourself good enough?"
That's an interesting question. I didn't know what to tell her. So I'm asking you.
For any programming language, framework or the like, when do you reach a point were you sit back, look at what you've done and say, "Hey, I'm actually pretty good at this."? How do you define "good" so that you can tell others, honestly, "Yeah, I'm good at X".
Additionally, do you reach these conclusions by comparing what others can do?
Additional Info
I have read the canonical paper on how it takes ten-thousand hours before you are an expert on the field. (Props to anybody that knows what this paper is called again)
I have also read various articles from Coding Horror about interviewing people. Some people, it was said, "Cannot function outside of a framework." So they may be "good" for that framework, but not otherwise in the language. Is this true? 


TF-IDF Scores:
actually: 0.0929
anybody: 0.1341
articles: 0.1284
asked: 0.0986
asking: 0.1082
called: 0.1284
coding: 0.0882
comparing: 0.1341
consider: 0.1106
define: 0.1198
expert: 0.1284
feel: 0.1020
field: 0.1237
framework: 0.3060
function: 0.1133
goes: 0.1198
good: 0.4396
hours: 0.1198
interesting: 0.1039
interviewing: 0.1237
know: 0.0710
knows: 0.1198
language: 0.2146
like: 0.0558
look: 0.0956
outside: 0.1237
paper: 0.2682
people: 0.1388
point: 0.0956
pretty: 0.0970
programming: 0.1303
question: 0.0800
read: 0.1972
said: 0.1002
say: 0.0793
simply: 0.1164
sit: 0.1341
takes: 0.1039
tell: 0.3179
tried: 0.1198
true: 0.1133
various: 0.1341

Termine con il punteggio TF-IDF più alto: good (0.4396)

Best Answer:
You can't call yourself good at X.  Only other people can.


TF-IDF Scores:
good: 0.7260
people: 0.6877

Termine con il punteggio TF-IDF più alto: good (0.7260)

----------------------------------------------------------------------------------------------------

Question 1135:
Planning Poker
Summary, in case you don't want to read the wiki article:

Get a list of tasks you want to do for the upcoming iteration
For each task:
2.1 Discuss with the group what it entails
2.2 Everyone writes down / selects an estimation of how much effort is required for the task
2.3 Everyone reveals their estimation
2.4 The highest and lowest outliers explain their reasoning
2.5 Repeat until a consensus is reached

Usually something similar to numbers from the Fibonacci sequence like 0, ½, 1, 2, 3, 5, 8, 13, 20, 40, 100 are the allowed values, so you don't get long arguments over close values like 23 vs 27.
Further, the numbers represent a unit-less value of effort, whose value is determined by a baseline task that everyone agrees equals about a 1, and all else is relative to that.
Ultimately, the goal is to get a good feel for a given team's "velocity", which is the number of these points that can be completed in a given iteration.  With that, it's possible to make reasonably accurate estimates of how long any given feature will take.

We did this at iteration planning meetings at one company I worked at, and I thought it was one of the few good things about that particular company.  So, what I'm wondering is, has anyone used this?  Do you think it's a useful tool for estimation?  Does it work in all situations, or does it lend itself to certain teams, projects, etc?


TF-IDF Scores:
100: 0.1097
20: 0.1229
arguments: 0.1229
article: 0.1176
case: 0.0971
certain: 0.1097
close: 0.1133
company: 0.1778
completed: 0.1229
discuss: 0.1229
effort: 0.2195
estimates: 0.1176
explain: 0.0863
feature: 0.0935
feel: 0.0935
given: 0.3198
goal: 0.1133
good: 0.1342
group: 0.1176
like: 0.1022
list: 0.0863
long: 0.1597
make: 0.0688
meetings: 0.1176
number: 0.0971
particular: 0.0971
planning: 0.2267
points: 0.1038
possible: 0.0851
projects: 0.0903
reached: 0.1229
read: 0.0903
reasonably: 0.1229
reasoning: 0.1229
repeat: 0.1176
represent: 0.1229
required: 0.1097
similar: 0.0971
situations: 0.1176
task: 0.2856
tasks: 0.0991
team: 0.0851
teams: 0.1229
things: 0.0671
think: 0.0640
thought: 0.1133
tool: 0.1014
ultimately: 0.1229
unit: 0.0935
used: 0.0688
useful: 0.0876
usually: 0.0903
value: 0.2077
values: 0.2457
vs: 0.1097
want: 0.1365
work: 0.0640
worked: 0.0991

Termine con il punteggio TF-IDF più alto: given (0.3198)

Best Answer:
We use it in our company for the project I'm involved in.  Some notes about planning poker are expressed in my recent blog post, and here's a bigger list of why it's cool:

It makes everyone agree.  People are not forced to accept any result; instead they're forced to make their own estimate!  The time to defend their own estimates is also allocated, if it's necessary.
It keeps everyone busy.  You can't slack during the meeting, while trying to show that you're so involved. Also, necessity of moving your hands constitutes a good physical exercise to keep you off of sleeping.
However, a downside of this is that sometimes you do need to do something else (for example, take some notes and write down the details of the agreement you've just reached).  
It keeps meetings faster.  There's no need for a constant involvement of a meeting leader to keep everything on pace.  The game with clear rules is way better for that.  Yes, you need to make some extra moves to put cards on, reveal them, et cetera, but these pay their way.
A lot of people just like to play cards, especially poker :-)  This increases motivation.

A company that sells decks of such cards accompanied their site with an article about Planning Poker, which is also worth reading.


TF-IDF Scores:
accept: 0.1169
agree: 0.1169
article: 0.1169
better: 0.0785
bigger: 0.1169
blog: 0.1091
cards: 0.3664
clear: 0.1127
company: 0.1767
constant: 0.1221
constitutes: 0.1221
details: 0.1032
especially: 0.1008
estimate: 0.1221
estimates: 0.1169
example: 0.0744
exercise: 0.1091
extra: 0.1127
faster: 0.1091
forced: 0.2443
game: 0.1008
good: 0.0667
hands: 0.1221
instead: 0.0913
involved: 0.2182
like: 0.0508
list: 0.0858
lot: 0.0776
make: 0.1368
makes: 0.0884
meeting: 0.2443
meetings: 0.1169
moving: 0.1127
necessary: 0.1127
need: 0.2088
notes: 0.2443
pay: 0.1127
people: 0.1264
physical: 0.1221
planning: 0.2253
play: 0.1091
post: 0.1127
project: 0.0696
reached: 0.1221
reading: 0.0946
result: 0.1060
rules: 0.1169
site: 0.1032
time: 0.0627
trying: 0.0870
use: 0.0553
way: 0.1368
worth: 0.0898
write: 0.0729
yes: 0.0913

Termine con il punteggio TF-IDF più alto: cards (0.3664)

----------------------------------------------------------------------------------------------------

Question 1180:
I've been in workplaces where, at the start of a project, the "Should we use VB.Net or C#" question has been raised.
Granted, it's probably less common to have to make that decision now than it was in the early days of .Net, particularly given the trend towards language convergence, but it can still be a heated debate.
So, between VB.Net and C#, Which language do you prefer and why?


TF-IDF Scores:
common: 0.1694
days: 0.2038
early: 0.2154
given: 0.2092
granted: 0.2309
language: 0.2572
make: 0.1351
net: 0.5318
particularly: 0.2225
prefer: 0.2154
probably: 0.1773
project: 0.1374
question: 0.1439
start: 0.1647
use: 0.1093
vb: 0.4617

Termine con il punteggio TF-IDF più alto: net (0.5318)

Best Answer:
I hate VB.NET. The days I still spend using it are the days I regret. That said, my tastes are a part of my situation and experience, and don't necessarily have any relevance to what you're doing... 
I think it is important, when comparing continually-evolving languages like C# and VB.NET, to look back at their history and see how they arrived at their current state:
The original advantages of BASIC on microcomputers included size and simplicity (small, easy-to-parse syntax made for small, reasonably fast interpreters and left room in memory for the actual program and data), an interactive environment that enabled experimentation, and a syntax that eschewed terse symbols and structures for a reasonably clear, English-like syntax. It was poorly-suited for large, structured programs however, and tended to encourage spaghetti code. Still, its availability and simplicity made it an excellent choice for an introduction to programming.
QuickBasic updated the syntax to allow for large more structured programs, and added compilation for faster execution.
VisualBasic provided a powerful, easy-to-use form builder to enable rapid construction of GUI applications, while adopting the QB syntax for use in scripting these UIs. It worked best when used to create UIs for low-level logic provided as pre-built components (usually written in some other language). Over time, the syntax became increasingly large and inconsistent as new features were tacked on. The focus on drawing up a UI first and then filling in bits of script worked well for small, UI-centered apps, but tended to encourage copy-paste programming and a variation on spaghetti code while discouraging re-use, complex data structures, and separation of concerns. In the minds of many, "VB code" became synonymous with "big ball of mud"; "VB programmer" with "inexperienced hack". 
VB.NET is a VB-like language on the .NET platform, an attempt (not entirely successful) to clean up and modernize the overgrown VB syntax. It was not perfectly compatible with existing VB code, and made no effort to provide compatibility with VB forms (arguably the most important part of VB) whatsoever. This left many VB product owners with the unpleasant choice of effectively re-writing their applications in VB.NET (dealing with subtle incompatibilities in every routine that wasn't carefully examined) or actually re-writing their applications in C# (dealing with an unfamiliar syntax in addition to the new runtime library and forms designer). Most VB.NET users were VB users who stuck with it for the syntax alone, many using it as a crutch while learning C#. As a result, it immediately took on a reputation as a haven for programmers who had become stuck in their ways, unwilling or unable to expand or improve their skills. 
At this point in time, VB.NET continues to evolve, slowly shedding baggage while picking up new and interesting syntax (LINQ, XML literals). Still, it retains almost none of the original advantages of BASIC: it is a large, complex language with a fairly steep learning curve and limited opportunity for interactive experimentation. 

For old programmers who have stuck with it over the past 30+ years, it's not a bad choice, provided they don't limit themselves to it.
For new programmers, the increasingly-vague resemblance of VB programs to English is hardly worth the bizarre nods to backwards compatibility and social stigma.
For new projects, VB.NET is a strange choice unless the project is heavily involved with one of the few tasks the language is optimized for: integration with poorly-typed COM components (Office...) (though C# 4.0 reduces this advantage considerably), or inline XML generation.



TF-IDF Scores:
30: 0.0390
actual: 0.0376
actually: 0.0282
added: 0.0364
advantages: 0.0815
allow: 0.0390
applications: 0.0965
apps: 0.0336
arguably: 0.0407
attempt: 0.0390
bad: 0.0310
basic: 0.0752
best: 0.0259
big: 0.0316
bits: 0.0407
built: 0.0376
choice: 0.1344
clear: 0.0376
code: 0.0674
com: 0.0364
comparing: 0.0407
complex: 0.0707
components: 0.0780
concerns: 0.0407
copy: 0.0376
create: 0.0329
current: 0.0344
data: 0.0564
days: 0.0688
dealing: 0.0815
easy: 0.0609
effectively: 0.0376
effort: 0.0364
encourage: 0.0752
english: 0.0752
entirely: 0.0390
environment: 0.0336
excellent: 0.0407
existing: 0.0364
experience: 0.0271
fairly: 0.0376
fast: 0.0353
faster: 0.0364
features: 0.0322
focus: 0.0407
form: 0.0376
gui: 0.0376
hardly: 0.0407
history: 0.0390
immediately: 0.0390
important: 0.0581
included: 0.0407
integration: 0.0407
interesting: 0.0316
involved: 0.0364
language: 0.0869
languages: 0.0265
large: 0.1503
learning: 0.0572
left: 0.0815
level: 0.0316
library: 0.0329
like: 0.0508
limited: 0.0407
logic: 0.0390
look: 0.0290
low: 0.0353
necessarily: 0.0364
net: 0.2396
new: 0.1171
office: 0.0407
old: 0.0316
opportunity: 0.0376
original: 0.0707
parse: 0.0407
past: 0.0329
platform: 0.0390
point: 0.0290
powerful: 0.0376
product: 0.0329
program: 0.0316
programmer: 0.0262
programmers: 0.0759
programming: 0.0396
programs: 0.1033
project: 0.0232
projects: 0.0299
provide: 0.0390
provided: 0.1127
reasonably: 0.0815
result: 0.0353
room: 0.0407
runtime: 0.0376
said: 0.0304
situation: 0.0344
size: 0.0364
skills: 0.0336
slowly: 0.0390
small: 0.0898
spend: 0.0344
state: 0.0390
structures: 0.0780
stuck: 0.1222
successful: 0.0407
suited: 0.0407
syntax: 0.3758
tasks: 0.0329
think: 0.0212
time: 0.0418
took: 0.0390
typed: 0.0364
ui: 0.0752
unable: 0.0407
unfamiliar: 0.0407
unless: 0.0407
updated: 0.0376
use: 0.0554
used: 0.0228
users: 0.0620
using: 0.0477
usually: 0.0299
vague: 0.0407
vb: 0.6629
ways: 0.0329
worked: 0.0657
worth: 0.0299
writing: 0.0557
written: 0.0364
xml: 0.0815
years: 0.0286

Termine con il punteggio TF-IDF più alto: vb (0.6629)

----------------------------------------------------------------------------------------------------

Question 1189:
By now I work with asp.net and C#. I have done a decent work in Java as well. I am planning my career in such a way I should be language-agnostic someday. What are the things that I need to learn? 
First would OOP paradigms as its speaks about the Class design. Are there any others?


TF-IDF Scores:
agnostic: 0.3042
asp: 0.3042
career: 0.2417
class: 0.2563
design: 0.2041
java: 0.2170
language: 0.1695
learn: 0.2089
need: 0.1811
net: 0.2336
oop: 0.3042
paradigms: 0.3042
planning: 0.2931
things: 0.1735
way: 0.1779
work: 0.3312

Termine con il punteggio TF-IDF più alto: work (0.3312)

Best Answer:
To be language agnostic you need to have experience in all of the common styles and types of languages.

An imperative language (You tell it what to do, step by step. Eg - C)
A declarative language (You tell it your goal, it figures out what to do. Eg - SQL/HTML/Prolog)

Also:

A functional language (Functions are key, avoiding state and side effects are the goals. Eg - Haskell/OCaml/Lisp/F#)
An object oriented language (Architecture where objects encapsulate related data and the methods that act on them). Eg - Java/C#)

Some typing styles:

A statically typed language (Data types are defined and checked at compile time. Eg - C#)
A dynamically typed language (Data types are checked at runtime. Eg - Python/Javascript)
Experience of strong vs. weak typing is also useful.

Some different runtime styles:

Something compiled (Eg - C++)
Something interpreted (Eg - PHP)
Something Managed (Eg - C#/Java)

Lower level stuff:

Something fairly low level (Eg - C)
Some dialect of assembly (Eg - NASM)

On top of that I would say you need experience of some concurrent programming and something event driven. You should probably also make sure you know something about the various domains such as web programming (client & server), rich client development/desktop, games. You might also want to learn about embedded programming, or dedicated hardware (like games consoles), and mobile development is becoming an increasingly relevant domain.
Others have also mentioned that it's worth getting some experience of Generic programming and Meta programming approaches.
When you learn these paradigms avoid just learning the syntax and writing in your old style. I've seen many C# devs write JavaScript as if it's statically typed. Don't do this, try to learn the language paradigms and embrace them.
If you've done all of this, the differences between languages will become largely syntactical so switching will become a fairly simple exercise of learning some new syntax.
Don't forget though that modern programming is almost always dependant on a framework, so familiarising yourself with the common and popular frameworks for each language you learn is also critical. Knowing C# is irrelevant without .net. 


TF-IDF Scores:
agnostic: 0.0724
approaches: 0.0698
architecture: 0.0756
assembly: 0.0756
avoid: 0.0610
client: 0.1395
common: 0.1062
compile: 0.0724
concurrent: 0.0756
critical: 0.0756
data: 0.1571
defined: 0.0756
desktop: 0.0656
development: 0.0894
different: 0.0524
domain: 0.0724
driven: 0.0639
dynamically: 0.0756
effects: 0.0698
event: 0.0724
exercise: 0.0675
experience: 0.2014
fairly: 0.1395
framework: 0.0575
frameworks: 0.0639
functional: 0.0610
functions: 0.0698
games: 0.1351
getting: 0.0586
goal: 0.0698
hardware: 0.0698
haskell: 0.0656
html: 0.0698
imperative: 0.0756
interpreted: 0.0756
irrelevant: 0.0724
java: 0.1033
javascript: 0.1312
key: 0.0724
know: 0.0400
knowing: 0.0724
language: 0.3630
languages: 0.0983
learn: 0.1989
learning: 0.1062
level: 0.1172
like: 0.0315
lisp: 0.0724
low: 0.0656
lower: 0.0756
make: 0.0424
managed: 0.0698
mentioned: 0.0724
methods: 0.0624
mobile: 0.0724
modern: 0.0756
need: 0.0862
net: 0.0556
new: 0.0435
object: 0.0724
objects: 0.0724
old: 0.0586
oriented: 0.0639
paradigms: 0.1448
php: 0.0597
popular: 0.0698
probably: 0.0556
programming: 0.2204
python: 0.0610
related: 0.0656
relevant: 0.0597
runtime: 0.1395
say: 0.0447
seen: 0.0547
server: 0.0698
simple: 0.0597
sql: 0.0756
state: 0.0724
statically: 0.1512
step: 0.1395
strong: 0.0698
stuff: 0.0586
style: 0.0624
styles: 0.2093
sure: 0.0565
syntax: 0.1395
tell: 0.1195
time: 0.0388
try: 0.0491
typed: 0.2026
types: 0.1968
typing: 0.1351
useful: 0.0539
various: 0.0756
vs: 0.0675
want: 0.0420
web: 0.0539
worth: 0.0556
write: 0.0451
writing: 0.0517

Termine con il punteggio TF-IDF più alto: language (0.3630)

----------------------------------------------------------------------------------------------------

Question 1200:
Coming from a procedural/OO programming background, I tend to write Scheme programs in a procedural fashion. I would be intersted in learning Scheme or Lisp in a functional way from the ground up, to kind of reset my programmer's mind.
Is there a tutorial or book out there that's the de-facto standard for describing best practices, design methodologies, and other helpful information on functional programming concepts? What about that book makes it special?


TF-IDF Scores:
background: 0.2038
best: 0.1492
book: 0.3574
coming: 0.2249
concepts: 0.2249
design: 0.1509
functional: 0.3791
helpful: 0.2098
information: 0.1820
kind: 0.2038
learning: 0.1650
lisp: 0.2249
makes: 0.1700
mind: 0.2249
practices: 0.1938
programmer: 0.1509
programming: 0.2283
programs: 0.1985
standard: 0.1787
tend: 0.2098
way: 0.1316
write: 0.1402

Termine con il punteggio TF-IDF più alto: functional (0.3791)

Best Answer:
Use it.
If you do functional programming daily, maybe smaller applications or exercises from books, then you will be better on it.
I have used it since the first programming lecture in university. At the beginning it was very hard, because it is so different, but now I prefer it to imperative programming.
If you are looking for a good book, I would recommend Real World Functional Programming: With Examples in F# and C# by Tomas Petricek and Jon Skeet


TF-IDF Scores:
applications: 0.1811
better: 0.1472
book: 0.1743
books: 0.1849
daily: 0.2114
different: 0.1587
examples: 0.1891
functional: 0.3698
good: 0.1252
hard: 0.1776
imperative: 0.2292
looking: 0.1776
maybe: 0.1937
prefer: 0.2047
programming: 0.4454
real: 0.1685
recommend: 0.2194
smaller: 0.2292
university: 0.2194
use: 0.1039
used: 0.1284
world: 0.1587

Termine con il punteggio TF-IDF più alto: programming (0.4454)

----------------------------------------------------------------------------------------------------

Question 1217:
I think we’ve all seen this. Beginners ask questions on Stack Overflow that follow the basic outline...

I’m trying to do (very vague description of the goal) but it doesn’t work/I get an error/exception. Please help!

Isn’t it bizarre that so many of them seem to consider it unnecessary to paste the error message?
I wonder what the psychology of this is. What is it about error messages that makes people initially assume that they are useless and not worth paying any attention to?
The answer I’m looking for is not “they don’t understand the error message”. That doesn’t explain why they wouldn’t consider telling anyone else who might understand it.


TF-IDF Scores:
answer: 0.1100
ask: 0.1204
assume: 0.1610
attention: 0.1610
basic: 0.1485
consider: 0.2657
error: 0.5443
exception: 0.1610
explain: 0.1131
follow: 0.1361
goal: 0.1485
help: 0.1086
initially: 0.1542
looking: 0.1248
makes: 0.1165
message: 0.3220
overflow: 0.1397
paying: 0.1610
people: 0.0833
questions: 0.1184
seen: 0.1165
stack: 0.1397
telling: 0.1610
think: 0.0839
trying: 0.1147
understand: 0.2118
useless: 0.1542
vague: 0.1610
wonder: 0.1542
work: 0.0839
worth: 0.1184

Termine con il punteggio TF-IDF più alto: error (0.5443)

Best Answer:
I think if it is a true beginner there's a good chance they don't know there is an error message at all.  They only know it doesn't run and that there is an error.  For example in Visual studio they may not see that part of the screen.  
Basically they don't know which part of the information they have available is useful to figure out what the problem is.  If they did there would be a better chance they could fix it themselves and not ask about it in the first place. 


TF-IDF Scores:
ask: 0.1665
available: 0.1882
better: 0.1431
chance: 0.4110
error: 0.3765
example: 0.1356
figure: 0.2227
fix: 0.1797
good: 0.1217
information: 0.1726
know: 0.3537
message: 0.2227
place: 0.1726
problem: 0.1399
run: 0.1882
screen: 0.2132
studio: 0.2055
think: 0.1161
true: 0.1882
useful: 0.1587
visual: 0.1989

Termine con il punteggio TF-IDF più alto: chance (0.4110)

----------------------------------------------------------------------------------------------------

Question 1224:
I've never found the ideal way to perform code reviews and yet often my customers require them. Each customer seems to do them in a different way and I've never felt satisfied in any of them. 
What has been the most effective way for you to perform code reviews?
For example:

Is one person regarded as the gatekeeper for quality and reviews the code, or do the team own the standard?  
Do you do review code as a team exercise using a projector?
Is it done in person, via email or using a tool? 
Do you eschew reviews and use things like pair programming and collective code ownership to ensure code quality?



TF-IDF Scores:
code: 0.4800
customer: 0.1634
customers: 0.1783
different: 0.1339
effective: 0.1726
email: 0.1783
example: 0.1177
exercise: 0.1726
like: 0.0804
pair: 0.1783
person: 0.3055
programming: 0.0939
quality: 0.3119
require: 0.1470
review: 0.1851
standard: 0.1470
team: 0.2677
things: 0.1056
tool: 0.1595
use: 0.0876
using: 0.2264
way: 0.3248

Termine con il punteggio TF-IDF più alto: code (0.4800)

Best Answer:
I like code reviews, though they can be a pain.  The reason I like them is that they get more eyes on the code and a different perspective.  I believe that even with pair programming, code should be reviewed.  It's easy enough for two people working on the same code to collectively make the same mistake that a different set of eyes may not miss.
If done as a group with a projector, it really should be reviewed individually before the meeting.  Otherwise, it is just an annoying waste of time.  
I've only done code reviews via email and in a group.  Generally speaking, I don't think they should be done in person.  You feel a little more pressure to rush through the code with someone looking over your shoulder.  I do believe that a tool designed for code reviewing would be a good asset, as it can help with some of the mundane aspects and it should make it easier to flag problem bits of code then it is via email.
The problem with having one person do all code reviews is that it can be a bottleneck.  With well documented and designed coding standards it should not be necessary.  Depending on the environment/release-schedule it may be a good idea to always have someone as a standby code reviewer.
I do believe that code ownership is a good idea as this person can make it their priority to understand that code and potentially play a gatekeeper role.


TF-IDF Scores:
annoying: 0.1002
aspects: 0.1040
believe: 0.2910
bits: 0.1086
code: 0.5394
coding: 0.0714
depending: 0.1086
designed: 0.2004
different: 0.1504
documented: 0.1002
easier: 0.0942
easy: 0.0812
email: 0.2004
environment: 0.0896
eyes: 0.2080
feel: 0.0826
generally: 0.0896
good: 0.1780
group: 0.2080
help: 0.0732
idea: 0.1716
like: 0.0904
little: 0.0918
looking: 0.0842
make: 0.1825
meeting: 0.1086
necessary: 0.1002
pair: 0.1002
people: 0.0562
person: 0.2574
play: 0.0970
problem: 0.1365
programming: 0.0528
really: 0.0624
reason: 0.0812
release: 0.0970
schedule: 0.1086
set: 0.0798
speaking: 0.1040
standards: 0.0896
think: 0.0566
time: 0.0558
tool: 0.0896
understand: 0.0714
working: 0.0714

Termine con il punteggio TF-IDF più alto: code (0.5394)

----------------------------------------------------------------------------------------------------

Question 1262:
I'm considering whether I should start using VIM again instead of an IDE. What are the most useful features of VIM that aren't standard in an IDE?


TF-IDF Scores:
considering: 0.3617
features: 0.2985
ide: 0.6555
instead: 0.2824
standard: 0.2874
start: 0.2581
useful: 0.2692
using: 0.2212

Termine con il punteggio TF-IDF più alto: ide (0.6555)

Best Answer:
I don't think its necessarily the advanced features of VIM that make it so powerful. Its the fact that you never have to take your hands off the keyboard to do anything. Finding something in a huge file is as simple as a couple of keystrokes. Opening and closing multiple files in the same window is incredibly fast as well.
While it may not seem intuitive at first, its well worth your time. Even if you don't use it as your standard IDE (I generally use Visual Studio or Eclipse, for example), you'll find your self using VIM to quickly open and edit files because it becomes way faster than waiting for the IDE to load.
Invest the time to learn how to use VIM well and you'll never regret it. I'd say its comparable to learning to touch-type.


TF-IDF Scores:
couple: 0.1645
edit: 0.1439
example: 0.1086
fact: 0.1409
fast: 0.1547
faster: 0.1593
features: 0.1409
file: 0.1382
files: 0.3015
generally: 0.1471
hands: 0.1784
huge: 0.1708
ide: 0.3095
incredibly: 0.1708
keyboard: 0.1593
learn: 0.1173
learning: 0.1253
load: 0.1708
make: 0.0999
multiple: 0.1593
necessarily: 0.1593
open: 0.1357
powerful: 0.1645
quickly: 0.1547
say: 0.1054
simple: 0.1409
standard: 0.1357
studio: 0.1645
think: 0.0930
time: 0.1832
touch: 0.1645
type: 0.1409
use: 0.2425
using: 0.1044
visual: 0.1593
waiting: 0.1784
way: 0.0999
worth: 0.1311

Termine con il punteggio TF-IDF più alto: ide (0.3095)

----------------------------------------------------------------------------------------------------

Question 1280:
What best practices should be undertaken for a website that needs to "scale out" to handle capacity?  This is especially relevant now that people are considering the cloud, but may be missing out on the fundamentals.
I'm interested in hearing about anything you consider a best practice from development-level tasks, to infrastructure, to management.


TF-IDF Scores:
best: 0.3739
consider: 0.2428
considering: 0.2818
development: 0.1740
especially: 0.2428
handle: 0.2943
interested: 0.2428
level: 0.2281
management: 0.2239
needs: 0.2554
people: 0.1523
practice: 0.2487
practices: 0.2428
relevant: 0.2326
tasks: 0.2374
website: 0.2554

Termine con il punteggio TF-IDF più alto: best (0.3739)

Best Answer:
Design for Concurrency
That is, as you're coding, plan around having multiple threads going.  Plan the shared state (often just the db).  Plan for multiple processes. Plan for physical distribution.
This allows you to distribute your system across multiple machines, and across multiple processes with load balancing.  It allows you to have redundant processes running in case of failure, and in case you need to modify the system in-place, you don't have to kill all service to do so.


TF-IDF Scores:
allows: 0.2890
case: 0.2385
coding: 0.0993
concurrency: 0.1509
design: 0.0970
going: 0.1076
load: 0.1445
modify: 0.1509
multiple: 0.5392
need: 0.0860
physical: 0.1509
place: 0.1170
plan: 0.6038
running: 0.1393
state: 0.1445
threads: 0.1509

Termine con il punteggio TF-IDF più alto: plan (0.6038)

----------------------------------------------------------------------------------------------------

Question 1323:
I recently saw that Microsoft released a coding standards document (All-In-One Code Framework Coding Standards) and it got me thinking...  The company that I work for has no formal coding standards at all.  There are only a few developers and we have been together long enough to have evolved into similar styles and its never been an issue.
Does the company you work for have a documented coding standards?  If no, why not?  Does having a standard make a difference?  Is it worth writing a standard from scratch or should you adopt another standard as your own (ie. make Microsoft's standards yours)?


TF-IDF Scores:
code: 0.0592
coding: 0.3766
company: 0.2072
developers: 0.1005
difference: 0.1321
document: 0.1432
documented: 0.1321
formal: 0.1321
framework: 0.1089
got: 0.1181
issue: 0.1109
long: 0.0930
make: 0.1604
microsoft: 0.2362
recently: 0.1279
released: 0.1432
saw: 0.1432
similar: 0.1131
standard: 0.3267
standards: 0.5905
styles: 0.1321
thinking: 0.1210
work: 0.1493
worth: 0.1052
writing: 0.0978

Termine con il punteggio TF-IDF più alto: standards (0.5905)

Best Answer:
It's important for a team to have a single coding standard for each language to avoid several problems:

A lack of standards can make your code unreadable.
Disagreement over standards can cause check-in wars between developers.
Seeing different standards in the same class can be extremely irritating.

I'm a big fan of what Uncle Bob has to say about standards:


Let them evolve during the first few iterations.
Let them be team specific instead of company specific.
Don't write them down if you can avoid it. Rather, let the code be
  the way the standards are captured.
Don't legislate good design. (e.g. don't tell people not to use goto)
Make sure everyone knows that the standard is about communication, and
  nothing else.
After the first few iterations, get the team together to decide.




TF-IDF Scores:
avoid: 0.2191
big: 0.1052
cause: 0.1178
check: 0.1073
class: 0.1096
code: 0.1124
coding: 0.0893
communication: 0.1213
company: 0.0983
decide: 0.1253
design: 0.0872
developers: 0.0954
different: 0.0940
extremely: 0.1213
good: 0.0742
goto: 0.1358
important: 0.0968
instead: 0.1015
knows: 0.1213
lack: 0.1253
language: 0.0724
let: 0.3535
make: 0.1521
people: 0.0703
problems: 0.1073
say: 0.0803
seeing: 0.1358
single: 0.1178
specific: 0.2146
standard: 0.2066
standards: 0.5601
sure: 0.1015
team: 0.2821
tell: 0.1073
use: 0.0615
way: 0.0761
write: 0.0811

Termine con il punteggio TF-IDF più alto: standards (0.5601)

----------------------------------------------------------------------------------------------------

Question 1338:
Have you ever had to work to coding standards that:

Greatly decreased your productivity?
Were originally included for good reasons but were kept long after the original concern became irrelevant?
Were in a list so long that it was impossible to remember them all?
Made you think the author was just trying to leave their mark rather than encouraging good coding practice?
You had no idea why they were included?

If so, what is your least favorite rule and why?

Some examples here


TF-IDF Scores:
author: 0.1983
coding: 0.2724
examples: 0.1708
favorite: 0.2071
good: 0.2262
idea: 0.1636
impossible: 0.2071
included: 0.4142
irrelevant: 0.1983
kept: 0.2071
leave: 0.1750
list: 0.1454
long: 0.2692
original: 0.1797
originally: 0.1910
practice: 0.1750
productivity: 0.2071
reasons: 0.1708
remember: 0.1750
rule: 0.1983
standards: 0.1708
think: 0.1080
trying: 0.1476
work: 0.1080

Termine con il punteggio TF-IDF più alto: included (0.4142)

Best Answer:
Had a professor once who demanded we have at least one comment for each line of code.
//Set x to 3
var x = 3;

//if x is greater than 2
if(x>2){

    //Print x
    Print(x);
}

It was pretty ridiculous.


TF-IDF Scores:
code: 0.2467
comment: 0.5961
line: 0.4535
pretty: 0.4313
set: 0.4383

Termine con il punteggio TF-IDF più alto: comment (0.5961)

----------------------------------------------------------------------------------------------------

Question 1371:
Having worked on a failed project is one of the few things that most programmers have in common, regardless of language used, industry or experience.
These projects can be great learning experiences, soul-crushing disasters (or both!), and can occur for a multitude of reasons:

upper management change of heart
under-skilled / under-resourced team
emergence of superior competitor during dev cycle
over/under management

Once you've worked on a couple of such projects, is it possible to recognise at an early stage exactly when a project is doomed to fail? 
For me, a big sign is having a hard & fast external deadline combined with feature creep. I've seen projects which were well planned out and proceeding right on schedule go horribly off the rails once the late feature requests started to roll in and get added to the final "deliverable". The proposers of these requests earned the nickname of Columbo, due to rarely leaving the room without asking for "just one more thing".
What are the warning signs you look out for that set off the alarm bells of impending doom in your head?


TF-IDF Scores:
added: 0.1419
asking: 0.1282
big: 0.1231
change: 0.1101
common: 0.1116
couple: 0.1466
cycle: 0.1589
dev: 0.1589
early: 0.1419
exactly: 0.1466
experience: 0.1058
experiences: 0.1589
fail: 0.1521
failed: 0.1466
fast: 0.1379
feature: 0.2418
great: 0.1188
hard: 0.1231
head: 0.1521
horribly: 0.1589
industry: 0.1521
language: 0.0848
learning: 0.1116
look: 0.1133
management: 0.2418
possible: 0.1101
programmers: 0.0988
project: 0.1811
projects: 0.3505
rarely: 0.1589
reasons: 0.1311
right: 0.1150
room: 0.1589
schedule: 0.1589
seen: 0.1150
set: 0.1168
stage: 0.1589
started: 0.1282
team: 0.1101
thing: 0.1188
things: 0.0868
used: 0.0890
worked: 0.2564

Termine con il punteggio TF-IDF più alto: projects (0.3505)

Best Answer:
Heroic Coding
Coding late into the night, working long hours, and clocking lots of overtime are a sure sign that something went wrong.  Further, my experience is that if you see someone working late at any point in the project, it only ever gets worse.  He might be doing it just to get his one feature back on schedule, and he might succeed; however, cowboy coding like that is almost always the result of a planning failure that will inevitably cause more of it soon.  So, the earlier in the project you see it, the worse it will eventually become.


TF-IDF Scores:
cause: 0.1805
coding: 0.4105
earlier: 0.1919
eventually: 0.2081
experience: 0.1385
feature: 0.1583
gets: 0.1805
hours: 0.1858
like: 0.0866
long: 0.1352
lots: 0.1805
planning: 0.1919
point: 0.1483
project: 0.2371
result: 0.1805
schedule: 0.2081
soon: 0.1992
sure: 0.1555
went: 0.1805
working: 0.2737
worse: 0.3984
wrong: 0.1678

Termine con il punteggio TF-IDF più alto: coding (0.4105)

----------------------------------------------------------------------------------------------------

Question 1376:
I have a tester that while testing will have an error occur (ok so far), but then he frequently reports it right away.  We (the developers) then later find that the tester has not tried to reproduce the issue and (when asked) cannot find a way to make it happen again.
Now these are still bugs, I don't want to ignore them.  But without repro steps I am kind of stuck.  Sometimes there is a stack trace (though frequently it is not useful because this is compact framework and there are no line numbers).  But when there is one I can take the stack trace and crack open the code and start guessing, but that does not lead to testable "fixes".
What do you do in scenarios like this?


TF-IDF Scores:
asked: 0.1407
away: 0.1709
bugs: 0.1544
code: 0.0792
developers: 0.1344
error: 0.1618
far: 0.1544
framework: 0.1456
frequently: 0.3235
happen: 0.1579
issue: 0.1483
kind: 0.1661
later: 0.1661
lead: 0.1766
like: 0.0796
line: 0.1456
make: 0.1072
ok: 0.1914
open: 0.1456
reproduce: 0.1914
right: 0.1385
scenarios: 0.1832
stack: 0.3321
start: 0.1308
steps: 0.1661
stuck: 0.1914
tester: 0.3532
testing: 0.1431
tried: 0.1709
useful: 0.1364
want: 0.1063
way: 0.1072

Termine con il punteggio TF-IDF più alto: tester (0.3532)

Best Answer:
A bug without context is not a bug, it's a fluke. The problem could be your code, it could be a third party library, it could be the hardware, or it could be solar radiation causing a single bit to flip on it's own. If you can't reproduce it with at least some regularity (even if only "it happens once every 10 or 20 times I do X"), it's not much better than your tester telling you "Something somewhere went wrong somehow - fix it".
You may have to explain to your tester that his job is not to just generate input until something breaks. If it were, you could replace him with a random number generator. Part of his job is to identify bugs, which entails identifying how to produce them.


TF-IDF Scores:
10: 0.1593
20: 0.1885
better: 0.1211
bit: 0.1461
breaks: 0.1805
bug: 0.3111
bugs: 0.1521
causing: 0.1885
code: 0.0780
context: 0.1684
explain: 0.1324
fix: 0.1521
generate: 0.1885
happens: 0.1805
hardware: 0.1739
input: 0.1739
job: 0.2576
library: 0.1521
number: 0.1490
party: 0.1805
problem: 0.1184
produce: 0.1739
replace: 0.1805
reproduce: 0.1885
single: 0.1636
telling: 0.1885
tester: 0.3479
times: 0.1461
went: 0.1636
wrong: 0.1521

Termine con il punteggio TF-IDF più alto: tester (0.3479)

----------------------------------------------------------------------------------------------------

Question 1380:
We are starting a push for code coverage here at my work, and it has got me to thinking.... How much code coverage is enough?
When do you get to the point of diminishing returns on code coverage?  What is the sweet spot between good coverage and not enough?  Does it vary by the type of project your are making (ie WPF, WCF, Mobile, ASP.NET)  (These are C# classes we are writing.)


TF-IDF Scores:
asp: 0.1851
classes: 0.1784
code: 0.2400
coverage: 0.7404
good: 0.1056
got: 0.1595
making: 0.1595
mobile: 0.1851
net: 0.1421
point: 0.1378
project: 0.1102
push: 0.1933
starting: 0.1677
thinking: 0.1634
type: 0.1528
work: 0.1008
wpf: 0.1933
writing: 0.1321

Termine con il punteggio TF-IDF più alto: coverage (0.7404)

Best Answer:
I'm of the opinion that code coverage alone is a poor metric.  It's easy to produce tons of useless tests that cover the code, but don't adequately check the output, or don't test edge cases, for example.  Covering code just means it doesn't throw an exception, not that it's right.  You need quality tests- the quantity isn't that important.


TF-IDF Scores:
adequately: 0.2317
cases: 0.1911
check: 0.1830
code: 0.2876
coverage: 0.2218
easy: 0.1732
edge: 0.2218
example: 0.1410
exception: 0.2317
important: 0.1651
means: 0.1830
need: 0.1320
opinion: 0.2137
output: 0.2317
poor: 0.2317
produce: 0.2137
quality: 0.1869
right: 0.1676
test: 0.1562
tests: 0.3590
throw: 0.2218
useless: 0.2218

Termine con il punteggio TF-IDF più alto: tests (0.3590)

----------------------------------------------------------------------------------------------------

Question 1386:
Sometimes I feel like a musician who can't play live shows. Programming is a pretty cool skill, and a very broad world, but a lot of it happens "off camera"- in your head, in your office, away from spectators. 
You can of course talk about programming with other programmers, and there is peer programming, and you do get to create something that you can show to people, but when it comes to explaining to non programmers what is it that you do, or how was your day at work, it's sort of tricky. 
How do you get the non programmers in your life to understand what is it that you do? 
NOTE: this is not a repeat of Getting non-programmers to understand the development process, because that question was about managing client expectations. 


TF-IDF Scores:
away: 0.1502
client: 0.1551
comes: 0.1551
course: 0.1421
create: 0.1356
day: 0.1356
development: 0.0994
expectations: 0.1681
explaining: 0.1681
feel: 0.1279
getting: 0.1303
happens: 0.1610
head: 0.1610
life: 0.1459
like: 0.0700
live: 0.1551
lot: 0.1068
non: 0.3543
note: 0.1551
office: 0.1681
people: 0.0870
play: 0.1502
pretty: 0.1217
process: 0.1217
programmers: 0.4180
programming: 0.2451
question: 0.1004
repeat: 0.1610
shows: 0.1681
sort: 0.1681
talk: 0.1551
understand: 0.2212
work: 0.0877
world: 0.1164

Termine con il punteggio TF-IDF più alto: programmers (0.4180)

Best Answer:
I don't even try. If they aren't tech oriented enough to have at least a basic understanding of programming, I am only going to bore them with the details. Usually I just go with something very high level like "I create web sites" or "I write computer programs to do X"


TF-IDF Scores:
basic: 0.2909
computer: 0.2443
create: 0.2544
details: 0.2665
going: 0.2247
high: 0.2816
level: 0.2443
like: 0.1312
oriented: 0.2665
programming: 0.1532
programs: 0.2665
sites: 0.2736
try: 0.2049
understanding: 0.3019
usually: 0.2318
web: 0.2247
write: 0.1882

Termine con il punteggio TF-IDF più alto: understanding (0.3019)

----------------------------------------------------------------------------------------------------

Question 1474:
I've read Peopleware in 2009. It was one of the best book I ever read.
But this book is a little old. I'd like to know, in your opinion, what is and what is not relevant in this book?


TF-IDF Scores:
best: 0.1914
book: 0.6876
know: 0.1595
like: 0.1254
little: 0.2546
old: 0.2334
opinion: 0.2780
read: 0.4430
relevant: 0.2381

Termine con il punteggio TF-IDF più alto: book (0.6876)

Best Answer:
It's been a while since I read it, but I don't remember anything in the book that wasn't relevant to someone.
What stood out the most was the discussion of process improvement using CMM and CMMI, and no mention of agile processes (although the second edition was printed in 1999, which is a few years before the Manifesto for Agile Software Development and agile development went mainstream). But the book is about people, and people haven't changed that much since the first printing of the book in 1987.


TF-IDF Scores:
agile: 0.5854
book: 0.4826
development: 0.2501
mainstream: 0.2025
mention: 0.2025
people: 0.2189
process: 0.1530
read: 0.1555
relevant: 0.1671
remember: 0.1787
second: 0.1951
software: 0.1239
using: 0.1239
went: 0.1835
years: 0.1485

Termine con il punteggio TF-IDF più alto: agile (0.5854)

----------------------------------------------------------------------------------------------------

Question 1483:
I've heard it said (by coworkers) that everyone "codes in English" regardless of where they're from. I find that difficult to believe, however I wouldn't be surprised if, for most programming languages, the supported character set is relatively narrow.
Have you ever worked in a country where English is not the primary language?
If so, what did their code look like?


TF-IDF Scores:
believe: 0.2685
character: 0.2773
code: 0.1244
difficult: 0.2608
english: 0.5547
heard: 0.2541
language: 0.1603
languages: 0.1954
like: 0.1251
look: 0.2142
primary: 0.3006
programming: 0.1461
said: 0.2247
set: 0.2210
worked: 0.2425

Termine con il punteggio TF-IDF più alto: english (0.5547)

Best Answer:
I'm Italian and always use English, for names and comments. But many other Italian programmers use Italian language, or more often a strange English-Italian mix (something like IsUtenteCopy).
A real life code sample:
// Trovo la foto collegata al verbale
tblVerbali rsVerbale;
hr = rsVerbale.OpenByID(GetDBConn(), m_idVerbale);
if( FAILED(hr) )
    throw CErrorHR(hr);
hr = rsVerbale.MoveFirst();
if( S_OK != hr )
    throw CError(_T("Record del verbale non trovato."));


By the way, the Visual Studio MFC wizard creates a skeleton application with localized comments:
BOOL CMainFrame::PreCreateWindow(CREATESTRUCT& cs)
{
    if( !CMDIFrameWndEx::PreCreateWindow(cs) )
        return FALSE;
    // TODO: modificare la classe o gli stili Window modificando 
    //  la struttura CREATESTRUCT

    return TRUE;
}



TF-IDF Scores:
application: 0.1493
code: 0.0840
comments: 0.3350
english: 0.3746
failed: 0.1873
false: 0.2030
language: 0.1083
life: 0.1762
like: 0.0845
names: 0.2030
non: 0.1426
programmers: 0.1262
real: 0.1493
record: 0.2030
return: 0.3432
sample: 0.1944
studio: 0.1873
throw: 0.3888
true: 0.1716
use: 0.1840
visual: 0.1813
way: 0.1137

Termine con il punteggio TF-IDF più alto: throw (0.3888)

----------------------------------------------------------------------------------------------------

Question 1516:
A few years ago I considered myself somewhat of a web developer, knowing the basic 3 languages (HTML, CSS, JS) and lots of PHP. Moving on from simple text to actual websites was a pain because of the so called "standards" out there, which at the time were ridiculously complicated for me. It pretty much boiled down to this (minus the IE related stuff):

Standards are there to replace old ways of doing things in a simpler way. However when trying to actually implement some of the stuff (Entirely CSS based layout for example), it took me 10x longer to actually do it then if I did the simpler and still working solution. If it rendered the same, then why should I use the more complicated example that takes 10x longer and breaks once you change browsers? This sparked many long religious debates in ##php, ##css, and ##js in Freenode IRC and actually got me banned from ##css because I messed with their little world over there.
My question: Should I follow every single standard and coding conventions even if they take me 10x longer but get me the same result as the simple one?

For the poll tag, those of you who have websites of any size (huge or small), do you follow all the standards? 


TF-IDF Scores:
actual: 0.0979
actually: 0.2204
ago: 0.0948
based: 0.0822
basic: 0.0979
breaks: 0.1016
browsers: 0.1061
called: 0.1016
change: 0.0735
coding: 0.0698
complicated: 0.1958
considered: 0.0948
css: 0.4244
developer: 0.0715
entirely: 0.1016
example: 0.1292
follow: 0.1793
got: 0.0875
html: 0.0979
huge: 0.1016
implement: 0.0948
knowing: 0.1016
languages: 0.0690
little: 0.0897
long: 0.0690
longer: 0.3047
lots: 0.0921
moving: 0.0979
old: 0.0822
php: 0.1677
pretty: 0.0768
question: 0.0633
related: 0.0921
replace: 0.1016
result: 0.0921
simple: 0.1677
simpler: 0.2122
single: 0.0921
size: 0.0948
small: 0.0780
solution: 0.0897
somewhat: 0.0979
standard: 0.0807
standards: 0.2626
stuff: 0.1644
takes: 0.0822
text: 0.0979
things: 0.0580
time: 0.0545
took: 0.1016
trying: 0.0756
use: 0.0481
way: 0.0594
ways: 0.0856
web: 0.0756
websites: 0.2122
working: 0.0698
world: 0.0735
years: 0.0745

Termine con il punteggio TF-IDF più alto: css (0.4244)

Best Answer:
Product first, then polish.
Get your site/application/game doing what it's supposed to do. Get it up and running, and get people interested.
Then, when you have the time, go back and polish it up. But only because you care, not because anybody else does.
Of course, if the non-compliance issues mean people can't view it, or it's unreadably ugly, or it takes a month to load, or it's hard to maintain, or it crashes the browser, this is a major problem. But it would still be a major problem even if you were standards-compliant.
Ordinary users do not look at the source for a website that isn't loading and go, "Well, it's not displaying the pictures, but it's completely W3C-compliant". They simply browse to another website and never return.
Bottom line, standards are there to make writing browsers easier, and to close up potential security holes. Amazon, Penny-Arcade and Stack Overflow do not make their money from running a standard-compliant website. And unless you're in a website-writing competition, neither will you.


TF-IDF Scores:
anybody: 0.1351
application: 0.0993
browsers: 0.1351
care: 0.1293
close: 0.1246
completely: 0.1141
course: 0.1141
easier: 0.1172
game: 0.1114
hard: 0.1046
interested: 0.1114
issues: 0.1246
line: 0.1027
load: 0.1293
look: 0.0962
maintain: 0.1351
major: 0.2492
make: 0.1513
mean: 0.1114
money: 0.1206
month: 0.1293
non: 0.0949
ordinary: 0.1351
overflow: 0.1172
people: 0.1398
potential: 0.1206
problem: 0.1697
product: 0.1090
return: 0.1141
running: 0.2492
security: 0.1206
simply: 0.1172
site: 0.1141
source: 0.1027
stack: 0.1172
standard: 0.1027
standards: 0.2228
supposed: 0.1172
takes: 0.1046
time: 0.0694
unless: 0.1351
users: 0.1027
view: 0.1351
website: 0.4687
writing: 0.1845

Termine con il punteggio TF-IDF più alto: website (0.4687)

----------------------------------------------------------------------------------------------------

Question 1533:
If you're developer (Senior or Lead Developer) and you'd rather stay with code/design than pursue a management career, what are the available career paths at your company, or any you've heard of? How far can you go?
Is it possible to continue being a geek until you bite the dust or is that too naive?
Are people like Uncle Bob for example still considered developers, as they claim?


TF-IDF Scores:
available: 0.2251
career: 0.4052
claim: 0.2663
code: 0.1102
company: 0.1927
considered: 0.2378
design: 0.1711
developer: 0.3592
developers: 0.1870
example: 0.1621
far: 0.2149
heard: 0.2251
lead: 0.2457
like: 0.1108
management: 0.2026
people: 0.1378
possible: 0.1844
senior: 0.2550
stay: 0.2457

Termine con il punteggio TF-IDF più alto: career (0.4052)

Best Answer:
At my company, the management and individual contributor tracks are separate and mostly parallel.  Individual contributors can rise very high in the company (up to Technical Fellow) without being a people manager.  It helps to partially avoid the Peter Principle, though never completely.


TF-IDF Scores:
avoid: 0.2768
company: 0.4965
completely: 0.2899
helps: 0.3285
high: 0.3064
management: 0.2610
manager: 0.3165
people: 0.1775
principle: 0.3431
technical: 0.2711

Termine con il punteggio TF-IDF più alto: company (0.4965)

----------------------------------------------------------------------------------------------------

Question 1588:
Use of desktops are decreasing day by day in daily life but for coding purpose are there any reasons for using desktop over laptop? 


TF-IDF Scores:
coding: 0.2422
daily: 0.3397
day: 0.5942
desktop: 0.3195
life: 0.3195
purpose: 0.3195
reasons: 0.3038
use: 0.1669
using: 0.2157

Termine con il punteggio TF-IDF più alto: day (0.5942)

Best Answer:
Assuming you have an external monitor and keyboard to connect to your laptop the difference is small. 
It is always better to work in a desktop like setting (bigger screen realestate, more ergonomic environment), but you can't take your work with you without a laptop. So if portability is important, get a laptop and a good external screen and keyboard to connect it to. Otherwise you might as well stay with a desktop. 


TF-IDF Scores:
assuming: 0.2292
better: 0.1472
bigger: 0.2194
desktop: 0.3977
difference: 0.2114
environment: 0.1891
good: 0.1252
important: 0.1633
keyboard: 0.4094
like: 0.0954
monitor: 0.2114
screen: 0.4388
setting: 0.2292
small: 0.1685
stay: 0.2114
work: 0.2390

Termine con il punteggio TF-IDF più alto: screen (0.4388)

----------------------------------------------------------------------------------------------------

Question 1620:
I am excited about the changes in PHP 6 previewed in PHP 5.3+. However, I wonder why it takes so long to release PHP 6? Books about it have been published since 2008, and announcements on it since 2007, but I am yet to hear about an alpha or a beta. Why does it take so long to release it? Or is that the way it goes with all languages when they transition to a major release where I guess it takes around 4-5 years to release?


TF-IDF Scores:
alpha: 0.1781
beta: 0.1781
books: 0.1437
changes: 0.1470
goes: 0.1591
guess: 0.1705
languages: 0.1158
long: 0.2315
major: 0.1643
php: 0.4222
published: 0.1781
release: 0.6364
takes: 0.2760
way: 0.0998
wonder: 0.1705
years: 0.1251

Termine con il punteggio TF-IDF più alto: release (0.6364)

Best Answer:
The release timetable is not unusual for languages, and it's not even that unusual for PHP: 5.0 was released in 2004, but 4.0 was released in 2000. 
Compare this to the last stable releases for C (2000), Fortran (2003), or C++ (2003).
One other thing to keep in mind is that 5.3 was a major release in all but name. It adds a lot of stuff that was originally destined for PHP 6. Due to development problems with unicode support (a major part of PHP 6), it was decided to release what was stable at the time as a 5.x branch.


TF-IDF Scores:
development: 0.1080
languages: 0.1188
lot: 0.1161
major: 0.3372
mind: 0.1750
originally: 0.1686
php: 0.4332
problems: 0.1444
release: 0.4896
released: 0.3655
stable: 0.3655
stuff: 0.1416
support: 0.1585
thing: 0.1366
time: 0.0939

Termine con il punteggio TF-IDF più alto: release (0.4896)

----------------------------------------------------------------------------------------------------

Question 1674:
i wonder apart from those very simple hello world apps, what other programs should i try developing for learning. i am entering uni next year and wonder what kind of programs will be developed in that environment. 
this is not really a language specific thing, but if you want to know what i use currently mainly

windows: C#/WPF - i studied java/vb etc in poly but i think C# is the way to go, maybe even F#
web: PHP/MySQL, Zend Framework/Doctrine, + HTML/CSS/JS(jQuery) of course. looking to try google app engine with python too. 

for now, i am thinking of 

todo lists
apps that integrate with api eg. twitter/tumblr which i use
text editor - i am currently trying to develop a text editor that uses markdown and generates html files for viewing (link to blog entry). not very pratical after i started developing it. cos when editing theres no formatting and in HTML format, i cannot edit directly 
blog software (for web)



TF-IDF Scores:
apart: 0.1214
app: 0.1023
apps: 0.2092
blog: 0.2265
course: 0.1072
css: 0.1268
currently: 0.2340
develop: 0.1133
developing: 0.2200
directly: 0.1268
edit: 0.1023
engine: 0.1214
environment: 0.1046
files: 0.1072
format: 0.1170
framework: 0.0965
google: 0.1100
hello: 0.1268
html: 0.3510
java: 0.0866
kind: 0.1100
know: 0.0671
language: 0.0676
learning: 0.0891
lists: 0.1214
looking: 0.0983
maybe: 0.1072
php: 0.1002
programs: 0.2143
python: 0.1023
really: 0.0729
simple: 0.1002
software: 0.0743
specific: 0.1002
started: 0.1023
text: 0.2340
thing: 0.0948
think: 0.0661
thinking: 0.1072
try: 0.1648
trying: 0.0904
twitter: 0.1214
use: 0.1149
uses: 0.1100
vb: 0.1214
want: 0.0704
way: 0.0710
web: 0.1807
windows: 0.1100
wonder: 0.2428
world: 0.0878
wpf: 0.1268
year: 0.1023

Termine con il punteggio TF-IDF più alto: html (0.3510)

Best Answer:
Have a look at Project Euler.  There's nothing else like it for sharpening your foundational programming skills.


TF-IDF Scores:
euler: 0.5850
like: 0.2434
look: 0.4169
programming: 0.2842
project: 0.3334
skills: 0.4826

Termine con il punteggio TF-IDF più alto: euler (0.5850)

----------------------------------------------------------------------------------------------------

Question 1701:
I am currently reading the recently published Being Geek by Michael "Rands" Lopp and I can't get enough of it.

Is there any other career guidance books aimed directly or indirectly at programmers that are worth reading?


TF-IDF Scores:
books: 0.2816
career: 0.2655
currently: 0.3220
directly: 0.3491
programmers: 0.2170
published: 0.3491
reading: 0.5410
recently: 0.3118
worth: 0.2566

Termine con il punteggio TF-IDF più alto: reading (0.5410)

Best Answer:
Joel on Software blog contains tons of invaluable information which can help you to be successful programmer. A lot of the things can be easily reflected to non-software development professions. If you prefer to read books, there are several books which compile all the wisdom of Joel's articles.


TF-IDF Scores:
articles: 0.2278
blog: 0.2125
books: 0.3839
compile: 0.2278
contains: 0.2278
development: 0.1406
easily: 0.2064
help: 0.1604
information: 0.1843
joel: 0.4250
lot: 0.1511
non: 0.1671
prefer: 0.2125
programmer: 0.1528
read: 0.1749
software: 0.2786
successful: 0.2379
things: 0.1300
wisdom: 0.2195

Termine con il punteggio TF-IDF più alto: joel (0.4250)

----------------------------------------------------------------------------------------------------

Question 1719:
In chapter one of "The Pragmatic Programmer" the first learning goal is:

Learn at least one new language every year. Different languages solve the same problems in different ways. By learning several different approaches, you can help broaden your thinking and avoid getter struck in a rut. [...]

To achieve this over a career, the list of languages is likely to get quite long (particularly if you do not want to "progress" into management). Clearly the education of a programmer (or whatever form) is going to get you started with a core of commercially useful languages (the usual list from job posting: C, C++, Ruby, Python, JavaScript, C#, Java, VB, ...). Additionally a formal or informal learning programme is likely to have covered functional approaches (via something like Haskell, LISP or an ML derived language)
But once a reasonable subset of that list is learned- what's next, and why?


TF-IDF Scores:
approaches: 0.2565
avoid: 0.1121
career: 0.1057
clearly: 0.1282
core: 0.1390
covered: 0.1390
different: 0.2888
form: 0.1282
formal: 0.1282
functional: 0.1121
goal: 0.1282
going: 0.0991
haskell: 0.1206
help: 0.0937
java: 0.0950
javascript: 0.1206
job: 0.0950
language: 0.1483
languages: 0.2710
learn: 0.0914
learned: 0.1282
learning: 0.2929
like: 0.0578
likely: 0.2243
lisp: 0.1331
list: 0.2929
long: 0.0903
management: 0.1057
new: 0.0799
particularly: 0.1282
posting: 0.1331
pragmatic: 0.1390
problems: 0.1098
programmer: 0.1786
python: 0.1121
quite: 0.1098
ruby: 0.1282
solve: 0.1121
started: 0.1121
thinking: 0.1175
useful: 0.0991
usual: 0.1390
vb: 0.1331
want: 0.0772
ways: 0.1121
year: 0.1121

Termine con il punteggio TF-IDF più alto: learning (0.2929)

Best Answer:
Make it interesting and spend each year writing an interpreter or compiler for your own programming language that fills up a niche you've never used a programming language for. Each year, write your next compiler/interpreter using the language you wrote the previous year.


TF-IDF Scores:
compiler: 0.4521
interesting: 0.1830
language: 0.3779
make: 0.1323
previous: 0.2109
programming: 0.2294
spend: 0.1996
used: 0.1323
using: 0.1383
write: 0.1409
writing: 0.1613
wrote: 0.2361
year: 0.5715

Termine con il punteggio TF-IDF più alto: year (0.5715)

----------------------------------------------------------------------------------------------------

Question 1745:
To put it another way... What is the most commonly held and frustrating misunderstanding about programming, you have encountered?
Which widespread and longstanding myths/misconceptions do you find hard for programmers to dispel/correct.
Please, explain why this is a myth.


TF-IDF Scores:
commonly: 0.4417
correct: 0.4002
encountered: 0.4613
explain: 0.3240
hard: 0.3574
programmers: 0.2867
programming: 0.2241
way: 0.2584

Termine con il punteggio TF-IDF più alto: encountered (0.4613)

Best Answer:
That because you're a programmer, you know how to fix [person]'s virus ridden machine.


TF-IDF Scores:
fix: 0.4093
know: 0.2685
machine: 0.4858
person: 0.4009
programmer: 0.3259
virus: 0.5074

Termine con il punteggio TF-IDF più alto: virus (0.5074)

----------------------------------------------------------------------------------------------------

Question 1750:
I work for a company that supports several languages: COBOL, VB6, C#, and Java. I use those languages for my primary work, but I often find myself coding some minor programs (e.g. scripts) in Python because I find it to be the best tool for that type of task.
For example: an analyst gives me a complex CSV file to populate some DB tables, so I use Python to parse it and create a DB script.
What's the problem?
The main problem I see is that a few parts of these quick and dirty scripts are slowly gaining importance and:

My company does not support Python
They're not version controlled (I back them up in another way)
My coworkers do not know Python

The analysts have even started to reference them in emails ("launch the script that exports..."), so they are needed more often than I initially thought.
I should add that these scripts are just utilities that are not part of the main project; they simply help to get trivial tasks done in less time. For my own small tasks they help a lot.
In short, if I were a lottery winner to be in a accident, my coworkers would need to keep the project alive without those scripts; they would spend more time fixing CSV errors by hand, for example.
Is this a common scenario? Am I doing something wrong? What should I do?


TF-IDF Scores:
add: 0.1164
best: 0.0852
cobol: 0.1284
coding: 0.0882
common: 0.0942
company: 0.1941
complex: 0.1164
create: 0.1082
emails: 0.1284
errors: 0.1106
example: 0.1633
file: 0.1039
fixing: 0.1341
gives: 0.1341
hand: 0.1237
help: 0.1809
importance: 0.1341
initially: 0.1284
java: 0.0916
know: 0.0710
languages: 0.1743
lot: 0.0852
main: 0.2213
need: 0.0764
needed: 0.1164
parse: 0.1341
primary: 0.1341
problem: 0.1685
programs: 0.1133
project: 0.1529
python: 0.4328
short: 0.1198
simply: 0.1164
slowly: 0.1284
small: 0.0986
spend: 0.1133
started: 0.1082
support: 0.1164
task: 0.1039
tasks: 0.2164
thought: 0.1237
time: 0.1378
tool: 0.1106
trivial: 0.1237
type: 0.1060
use: 0.1216
version: 0.1284
way: 0.0751
work: 0.1398
wrong: 0.1082

Termine con il punteggio TF-IDF più alto: python (0.4328)

Best Answer:
You need to get the situation formalised as it shouldn't really have got to this point. However, these things happen so you need to explain to your boss that you created these scripts for personal use, but they've "escaped" into wider circulation. Admit (if necessary) that you were at fault for not bringing this to his attention sooner.
At the very least the scripts should be put under source control "just in case" - then at least if you aren't available (for what ever reason) your co-workers will have access to the scripts.
Then you either need to convince your boss that Python is the way to go for these or accept that you are going to have to re-write them in a supported language. If the cost of documenting the scripts and educating your co-workers in Python is lower than that of the re-write you might even win the argument.


TF-IDF Scores:
accept: 0.1779
access: 0.1499
attention: 0.1858
available: 0.1570
boss: 0.3716
case: 0.1468
control: 0.1714
convince: 0.1858
cost: 0.1612
created: 0.1858
explain: 0.1305
going: 0.1324
got: 0.1533
happen: 0.1533
language: 0.0991
lower: 0.1858
necessary: 0.1714
need: 0.3177
personal: 0.1499
point: 0.1324
python: 0.2998
really: 0.1068
reason: 0.1389
situation: 0.1570
source: 0.1413
things: 0.1015
use: 0.0842
way: 0.1041
wider: 0.1858
win: 0.1714
write: 0.2218

Termine con il punteggio TF-IDF più alto: boss (0.3716)

----------------------------------------------------------------------------------------------------

Question 1752:
In fact this question is about cautions to be taken to enhance quality user experience and reduce avoidable support calls.


TF-IDF Scores:
calls: 0.3672
experience: 0.2737
fact: 0.3248
quality: 0.3317
question: 0.2454
reduce: 0.4111
support: 0.3567
taken: 0.3672
user: 0.2888

Termine con il punteggio TF-IDF più alto: reduce (0.4111)

Best Answer:
A lack of proper input validation is one of those things which tends to lead quite quickly to users doing "bad" things with your application, when it should really be handled by the programmer.
I've seen legacy apps where users have been trained to:

not enter apostrophes in names
not enter any symbol other than a-z0-9,
ensure there are no spaces before or after the text they've entered
check that a correctly formatted email address is being entered in to the email field, otherwise subsequent mailings to that user will use whatever's in the field and will fail
make sure "http://" is put before web addresses

etc etc
All of the above issues are ones which should be handled by an application developer. When your input validation is essentially "make sure the user knows what format this field should be in and trust what they've entered is right", then unexpected things are bound to find their way in to the app. Aside from the obvious security implications, users make mistakes. As programmers we often produce our best products by bending over backwards to make sure that the user can't get it wrong, no matter how hard they try!


TF-IDF Scores:
app: 0.0943
application: 0.1719
apps: 0.0964
bad: 0.0889
best: 0.0743
check: 0.0924
correctly: 0.1079
developer: 0.0788
email: 0.2157
essentially: 0.1119
fail: 0.1119
field: 0.3236
format: 0.1079
handled: 0.2338
hard: 0.0906
http: 0.1044
input: 0.2157
issues: 0.1079
knows: 0.1044
lack: 0.1079
lead: 0.1079
legacy: 0.1169
make: 0.2619
matter: 0.1044
mistakes: 0.1169
names: 0.1169
obvious: 0.1079
ones: 0.1014
produce: 0.1079
products: 0.1169
programmer: 0.0751
programmers: 0.0727
proper: 0.1119
quickly: 0.1014
quite: 0.0924
really: 0.0672
right: 0.0846
security: 0.1044
seen: 0.0846
spaces: 0.1169
sure: 0.2622
text: 0.1079
things: 0.1916
trust: 0.1169
try: 0.0760
unexpected: 0.1169
use: 0.0530
user: 0.2463
users: 0.2668
way: 0.0655
web: 0.0833
wrong: 0.0943

Termine con il punteggio TF-IDF più alto: field (0.3236)

----------------------------------------------------------------------------------------------------

Question 1785:
Please, stay on technical issues, avoid behavior, cultural, career or political issues.


TF-IDF Scores:
avoid: 0.3264
career: 0.3078
issues: 0.7465
stay: 0.3732
technical: 0.3197

Termine con il punteggio TF-IDF più alto: issues (0.7465)

Best Answer:

The bug is in your code, not the compiler or the runtime libraries.
If you see a bug that cannot possibly happen, check that you have correctly built and deployed your program.  (Especially if you are using a complicated IDE or build framework that tries to hide the messy details from you ... or if your build involves lots of manual steps.)
Concurrent / multi-threaded programs are hard to write and harder to properly test.  It is best to delegate as much as you can to concurrency libraries and frameworks.
Writing the documentation is part of your job as a programmer.  Don't leave it for "someone else" to do.

EDIT
Yes, my point #1 is overstated.  Even the best engineered application platforms do have their share of bugs, and some of the less well engineered ones are rife with them.  But even so, you should always suspect your code first, and only start blaming compiler / library bugs when you have clear evidence that your code is not at fault.  
Back in the days when I did C / C++ development, I remember cases where supposed optimizer "bugs" turned out to be a due to me / some other programmer having done things that the language spec says have undefined results.  This applies even for supposedly safe languages like Java; e.g. take a long hard look at the Java memory model (JLS chapter 17).


TF-IDF Scores:
application: 0.0951
best: 0.1643
bug: 0.2134
bugs: 0.3130
build: 0.2310
built: 0.1193
cases: 0.1067
check: 0.1022
clear: 0.1193
code: 0.1606
compiler: 0.2476
complicated: 0.1193
concurrency: 0.1293
concurrent: 0.1293
correctly: 0.1193
days: 0.1093
details: 0.1093
development: 0.0765
documentation: 0.1122
edit: 0.1043
especially: 0.1067
evidence: 0.1193
framework: 0.0984
frameworks: 0.1093
happen: 0.1067
hard: 0.2004
ide: 0.1122
java: 0.1767
job: 0.0884
language: 0.0690
languages: 0.0841
leave: 0.1093
libraries: 0.2386
library: 0.1043
like: 0.0538
long: 0.0841
look: 0.0922
lots: 0.1122
model: 0.1093
ones: 0.1122
point: 0.0922
possibly: 0.1093
program: 0.1002
programmer: 0.1662
programs: 0.1093
properly: 0.1238
remember: 0.1093
runtime: 0.1193
share: 0.1193
start: 0.0884
steps: 0.1122
supposed: 0.1122
suspect: 0.1293
test: 0.0872
things: 0.0707
using: 0.0757
write: 0.0772
writing: 0.0884
yes: 0.0967

Termine con il punteggio TF-IDF più alto: bugs (0.3130)

----------------------------------------------------------------------------------------------------

Question 1849:
If you've always loved unit testing, good for you! But for the unfortunate ones who weren't born with a liking for it, how have you managed to make this task more enjoyable ? 
This is not a "what is the right way to unit test" question. I simply want to know little personal tricks that reduce the boredom (dare I say) of writing unit tests.


TF-IDF Scores:
good: 0.1357
know: 0.1315
little: 0.2099
make: 0.1391
managed: 0.2292
ones: 0.2155
personal: 0.2004
question: 0.1483
reduce: 0.2484
right: 0.1797
say: 0.1468
simply: 0.2155
task: 0.1925
test: 0.1675
testing: 0.1857
tests: 0.1925
tricks: 0.2292
unit: 0.5669
want: 0.1380
way: 0.1391
writing: 0.1697

Termine con il punteggio TF-IDF più alto: unit (0.5669)

Best Answer:
Smug superiority.
I'm only half-joking.  "Look at me, cultivating good programming habits!  This 'unit testing' stuff is something Me From Ten Years Ago never would have done -- what a fool!  And just think of all the bugs I'm going to catch as a result of this boring, tedious work I'm doing right now -- my code will be awesome!  I'll get a raise for sure!*"
* -- No, I won't.
I find it's like working out or eating healthy; until the tangible benefits actually kick in ("Holy balls, I really AM catching a crap-ton of regression errors that would have snuck into production!"), the moral pride of knowing that you're doing The Right Thing can help carry you through.


TF-IDF Scores:
actually: 0.1716
ago: 0.2213
benefits: 0.2372
bugs: 0.1999
code: 0.1025
errors: 0.2044
going: 0.1766
good: 0.1353
half: 0.2477
help: 0.1671
knowing: 0.2372
like: 0.1031
look: 0.1766
production: 0.2477
programming: 0.1204
really: 0.1424
result: 0.2149
right: 0.3585
stuff: 0.1920
sure: 0.1852
testing: 0.1852
thing: 0.1852
think: 0.1292
unit: 0.1884
work: 0.1292
working: 0.1629
years: 0.1740

Termine con il punteggio TF-IDF più alto: right (0.3585)

----------------------------------------------------------------------------------------------------

Question 1877:
As an example, say there's an interface that contains a table/grid of information that is periodically updated.  The table is meant to represent an event that has happened, perhaps the date and time of a stock price change.
The actual frequency of these events could be dozens of events per second.  This is obviously too much information for a user to process/understand, so I'm trying to find out how much information a user COULD process in a given amount of time so that we can throttle the data and come up with an alternate display.
I know some studies have been done on this, but I can't seem to find an authoritative source.


TF-IDF Scores:
actual: 0.1835
change: 0.1377
come: 0.1641
contains: 0.1904
data: 0.1377
date: 0.1835
event: 0.1904
example: 0.1211
given: 0.1726
happened: 0.1835
information: 0.4623
interface: 0.1989
know: 0.1053
meant: 0.1989
obviously: 0.1726
process: 0.2878
represent: 0.1989
say: 0.1176
second: 0.1835
source: 0.1513
time: 0.2043
trying: 0.1417
understand: 0.1308
updated: 0.1835
user: 0.2794

Termine con il punteggio TF-IDF più alto: information (0.4623)

Best Answer:
This depends on a lot of factors:

Is the table as a whole updating (eg, every row changes), or is it just one row at a time?
If it's a row at a time, is it an arbitrary row that a user has to jump their eyes to, or is it always a new row at the top? The former would require more spacing between updates than the latter.
How much data is on each row?
Is most of it unimportant, and only the outliers are important to the user (in which case they're probably skimming the data, so you can put it out a lot faster)?  Or does all the data need to be read and mentally processed.

My (admittedly minimal- a couple college classes worth) experience with calculating user experience metrics (like data processed per second) has lead me to believe that the field is pretty immature, and that you're better off doing empirical measurement.  If you really want to try to optimize a specific UI, nothing beats usability testing.


TF-IDF Scores:
believe: 0.1513
better: 0.1088
case: 0.1338
changes: 0.1397
classes: 0.1562
college: 0.1621
couple: 0.1562
data: 0.4691
depends: 0.1469
experience: 0.2255
eyes: 0.1621
factors: 0.1694
faster: 0.1513
field: 0.1562
important: 0.1207
lead: 0.1562
like: 0.0705
lot: 0.2151
need: 0.0965
new: 0.0974
pretty: 0.1225
probably: 0.1245
read: 0.1245
really: 0.0974
require: 0.1288
second: 0.1562
specific: 0.1338
testing: 0.1266
time: 0.1740
try: 0.1101
ui: 0.1562
user: 0.3568
want: 0.0941
worth: 0.1245

Termine con il punteggio TF-IDF più alto: data (0.4691)

----------------------------------------------------------------------------------------------------

Question 1885:
As programmers I think we are the most inclined to use new technologies and things that are not so mainstream.
I absolutely love OpenId's ability to log in with credentials you already have, but I always use a provider that I already use and that is the fastest to log in, like google. God knows I'd never used it if i had to type in the whole "https://www.google.com/accounts/o8/id" I like to click on the google button and then just say yes (the first time, then its just clicking the button).
Does any of you ever uses the Generic "Enter your own provider" OpenId?
Do you think its worth to even offer it to more casual end users?


TF-IDF Scores:
ability: 0.1964
absolutely: 0.2039
com: 0.1902
end: 0.1541
google: 0.5542
knows: 0.1902
like: 0.1772
love: 0.2129
mainstream: 0.2039
new: 0.1224
programmers: 0.1324
say: 0.1259
technologies: 0.1964
things: 0.1163
think: 0.2220
time: 0.1094
type: 0.1682
use: 0.2895
used: 0.1193
users: 0.1620
uses: 0.1847
worth: 0.1565
yes: 0.1592

Termine con il punteggio TF-IDF più alto: google (0.5542)

Best Answer:
Yes. I set up delegation on my own site, so I just use one of my own URLs. Easy to remember, and doesn't tie me to a provider.


TF-IDF Scores:
easy: 0.4120
remember: 0.4658
set: 0.4052
site: 0.4658
use: 0.2498
yes: 0.4120

Termine con il punteggio TF-IDF più alto: remember (0.4658)

----------------------------------------------------------------------------------------------------

Question 1890:
What is the best practice, most commonly accepted naming conventions for private variables in C#?

private int myInteger;
private int MyInteger;
private int mMyInteger;
private int _myInteger;
private int _MyInteger;
Mysterious other option

Which do you use and why?  (My company is fairly new to C# and I would like to pick the most "industry accepted" method to try and get into our coding standard.)


TF-IDF Scores:
accepted: 0.3202
best: 0.1017
coding: 0.1053
commonly: 0.1533
company: 0.1158
fairly: 0.1477
industry: 0.1533
int: 0.8005
like: 0.0666
method: 0.1389
new: 0.0920
option: 0.1601
pick: 0.1430
practice: 0.1353
standard: 0.1218
try: 0.1040
use: 0.0725
variables: 0.1601

Termine con il punteggio TF-IDF più alto: int (0.8005)

Best Answer:
The MSDN class design guidlines http://msdn.microsoft.com/en-us/library/ta31s3bc.aspx recommends option 1 - myInteger. 
I have always used this style. I have a personal dislike for the _ character.


TF-IDF Scores:
character: 0.3372
class: 0.2948
com: 0.3264
design: 0.2348
http: 0.3264
library: 0.2948
microsoft: 0.3015
option: 0.3655
personal: 0.2948
style: 0.3015
used: 0.2047

Termine con il punteggio TF-IDF più alto: option (0.3655)

----------------------------------------------------------------------------------------------------

Question 1947:

Possible Duplicate:
Really “wow” them in the interview 

Let's say I appear for an interview. What questions could I expect and how do I prepare?


TF-IDF Scores:
appear: 0.3681
interview: 0.6387
let: 0.3194
possible: 0.2549
prepare: 0.3524
questions: 0.2706
really: 0.2117
say: 0.2176

Termine con il punteggio TF-IDF più alto: interview (0.6387)

Best Answer:
Programming Interviews Exposed is also helpful.

This classic book uncovers what
  interviews are really like at
  America's top software and computer
  companies and provides you with the
  tools to succeed in any situation. The
  authors take you step-by-step through
  new problems and complex brainteasers
  they were asked during recent
  technical interviews.
50 interview scenarios are presented
  along with in-depth analysis of the
  possible solutions. The
  problem-solving process is clearly
  illustrated so you'll be able to
  easily apply what you've learned
  during crunch time. You'll also find
  expert tips on what questions to ask,
  how to approach a problem, and how to
  recover if you become stuck.

I've used it in preparing for my last round of interviews and while I didn't end up needing it, reading through it certainly made me feel more confident and prepared. The book also has a section on non-programming questions such as salary negotiation, which I found very helpful.


TF-IDF Scores:
50: 0.1336
able: 0.1129
analysis: 0.1336
apply: 0.1336
approach: 0.1102
ask: 0.0999
asked: 0.0982
authors: 0.1336
book: 0.2033
certainly: 0.1233
clearly: 0.1233
companies: 0.1194
complex: 0.1159
computer: 0.1035
easily: 0.1159
end: 0.0967
expert: 0.1279
feel: 0.1017
helpful: 0.2387
interview: 0.1159
interviews: 0.5118
learned: 0.1233
like: 0.0556
new: 0.0768
non: 0.0939
possible: 0.0925
prepared: 0.1336
problem: 0.1679
problems: 0.1056
process: 0.0967
programming: 0.1299
provides: 0.1336
questions: 0.1965
reading: 0.1035
really: 0.0768
scenarios: 0.1279
section: 0.1279
situation: 0.1129
software: 0.0783
solving: 0.1279
step: 0.2466
stuck: 0.1336
technical: 0.1056
time: 0.0686
tips: 0.1194
tools: 0.1078
used: 0.0748

Termine con il punteggio TF-IDF più alto: interviews (0.5118)

----------------------------------------------------------------------------------------------------

Question 1969:
I'm posting this here since programmers write viruses, and AV software.  They also have the best knowledge of heuristics and how AV systems work (cloaking etc).
The EICAR test file was used to functionally test an antivirus system.  As it stands today almost every AV system will flag EICAR as being a "test" virus.  For more information on this historic test virus please click here.
Currently the EICAR test file is only good for testing the presence of an AV solution, but it doesn't check for engine file or DAT file up-to-dateness. In other words, why do a functional test of a system that could have definition files that are more than 10 years old.  With the increase of zero day threats it doesn't make much sense to functionally test your system using EICAR.
That being said, I think EICAR needs to be updated/modified to be effective test that works in conjunction with an AV management solution.
This question is about real world testing, without using live viruses... which is the intent of the original EICAR.
That being said I'm proposing a new EICAR file format with the appendage of an XML blob that will conditionally cause the Antivirus engine to respond.
X5O!P%@AP[4\PZX54(P^)7CC)7}$EICAR-EXTENDED-ANTIVIRUS-TEST-FILE!$H+H*
<?xml version="1.0"?>
<engine-valid-from>2010-1-1Z</engine-valid-from>
<signature-valid-from>2010-1-1Z</signature-valid-from>
<authkey>MyTestKeyHere</authkey> 

In this sample, the antivirus engine would only alert on the EICAR file if both the signature  or engine file is equal to or newer than the valid-from date. Also there is a passcode that will protect the usage of EICAR to the system administrator.
If you have a backgound in "Test Driven Design" TDD for software you may get that all I'm doing is applying the principals of TDD to my infrastructure.  
Based on your experience and contacts how can I make this idea happen?


TF-IDF Scores:
10: 0.0604
applying: 0.0714
based: 0.0553
best: 0.0454
cause: 0.0620
check: 0.0564
currently: 0.0659
date: 0.0659
day: 0.0576
definition: 0.0684
design: 0.0459
driven: 0.0604
effective: 0.0638
engine: 0.4102
equal: 0.0714
experience: 0.0475
file: 0.4427
files: 0.0604
format: 0.0659
functional: 0.0576
good: 0.0390
happen: 0.0589
idea: 0.0564
information: 0.0553
intent: 0.0714
knowledge: 0.0543
live: 0.0659
make: 0.0800
management: 0.0543
needs: 0.0620
new: 0.0411
old: 0.0553
original: 0.0620
posting: 0.0684
programmers: 0.0444
question: 0.0426
real: 0.0525
said: 0.1068
sample: 0.0684
sense: 0.0589
software: 0.0836
solution: 0.1207
systems: 0.0659
tdd: 0.1239
test: 0.4816
testing: 0.1068
think: 0.0372
updated: 0.0659
usage: 0.0714
used: 0.0400
using: 0.0836
valid: 0.3571
version: 0.0684
virus: 0.1428
words: 0.0659
work: 0.0372
works: 0.0638
world: 0.0495
write: 0.0426
xml: 0.1428
years: 0.0502

Termine con il punteggio TF-IDF più alto: test (0.4816)

Best Answer:
As you said in the question, it would have to work in conjunction with an AV solution.  In order for that to happen you would either need to write an AV engine, or become involved with an existing AV vendor.
If such a thing did exist... Where does the benefit come in?  Just thinking devil's advocate here..  Couldn't the AV engine just report when it's database was updated?


TF-IDF Scores:
advocate: 0.2567
benefit: 0.2567
come: 0.2117
engine: 0.4915
exist: 0.2567
existing: 0.2292
happen: 0.2117
involved: 0.2292
need: 0.1463
question: 0.1532
report: 0.2368
said: 0.1919
solution: 0.2169
thing: 0.1919
thinking: 0.2169
updated: 0.2368
work: 0.1338
write: 0.1532

Termine con il punteggio TF-IDF più alto: engine (0.4915)

----------------------------------------------------------------------------------------------------

Question 1997:
People make mistakes, even in the real life... Which should we, geeky programmers, avoid?


TF-IDF Scores:
avoid: 0.4079
life: 0.4387
make: 0.2832
mistakes: 0.5056
people: 0.2616
programmers: 0.3142
real: 0.3717

Termine con il punteggio TF-IDF più alto: mistakes (0.5056)

Best Answer:
Learn that what constitutes "An acceptable degree of precision" to you is "Annoying goddamn nitpicking" to most of the world.


TF-IDF Scores:
annoying: 0.4809
constitutes: 0.5213
degree: 0.4991
learn: 0.3429
world: 0.3610

Termine con il punteggio TF-IDF più alto: constitutes (0.5213)

----------------------------------------------------------------------------------------------------

Question 2042:
I've been working in the enterprise space for the past 4½ years and have noticed that generally speaking, enterprises are not conducive environments for the test-first style of development. Projects are usually fixed-cost, fixed-timeline and waterfall style. Any unit testing, if done at all, usually comes after development in the QA phase and done by another team.
Prior to working for an enterprise, I consulted for many small to medium sized companies, and none of them were willing to pay for a test-first style of development project. They usually wanted development started immediately, or after a short design stint: i.e., something more akin to Agile, though some clients wanted everything mapped out similar to waterfall.
With what types of shops, companies, and clients does test-driven development work
best? What types of projects tend to be conducive to TDD?


TF-IDF Scores:
agile: 0.1130
best: 0.0778
clients: 0.2449
comes: 0.1130
companies: 0.2187
cost: 0.1062
design: 0.0787
development: 0.3620
driven: 0.1035
enterprise: 0.2345
enterprises: 0.1225
environments: 0.1225
fixed: 0.2345
generally: 0.1010
immediately: 0.1172
past: 0.0988
pay: 0.1130
phase: 0.1130
prior: 0.1225
project: 0.0698
projects: 0.1801
qa: 0.1225
short: 0.1094
similar: 0.0968
small: 0.0900
space: 0.1094
speaking: 0.1172
started: 0.0988
style: 0.3031
tdd: 0.1062
team: 0.0848
tend: 0.1094
test: 0.2477
testing: 0.0915
types: 0.2125
unit: 0.0932
usually: 0.2701
willing: 0.1172
work: 0.0638
working: 0.1611
years: 0.0860

Termine con il punteggio TF-IDF più alto: development (0.3620)

Best Answer:
Every line of code I write is using test driven development.  If management isn't on board with writing tests first then I don't tell management about it.  I feel that strongly that test driven development is a better process.


TF-IDF Scores:
better: 0.1779
code: 0.1146
development: 0.3274
driven: 0.4680
feel: 0.2106
line: 0.2106
management: 0.4212
process: 0.2004
tell: 0.2188
test: 0.3734
tests: 0.2145
using: 0.1621
write: 0.1653
writing: 0.1892

Termine con il punteggio TF-IDF più alto: driven (0.4680)

----------------------------------------------------------------------------------------------------

Question 2051:
See title, but I am asking from a technical perspective, not 

Take my 40 year old virgin niece on a date or you're fired.



TF-IDF Scores:
asking: 0.4390
date: 0.5020
old: 0.4216
technical: 0.4299
year: 0.4390

Termine con il punteggio TF-IDF più alto: date (0.5020)

Best Answer:
To market Neal Stephenson's sci-fi thriller Snow Crash, I was asked to write a "benign" computer virus. It would "benignly" pretend to take over the user's computer and replace the screen with snow, a.k.a., a "snow crash." After a minute or so of snow, the snow would fade out and be replaced by an advertisement for the book. This would be "benign," you see. The virus would spread through normal means, but nobody would mind because after taking over their computer "you'd just get a fun ad and then be relieved that nothing bad happened to your computer."
I was actually told to do this at a major worldwide corporation. I had to write a memo explaining all the laws this would break and all 17 bad things that could happen if they really made me implement this.


TF-IDF Scores:
actually: 0.1204
asked: 0.1278
bad: 0.2645
book: 0.1323
break: 0.1604
computer: 0.5389
explaining: 0.1739
fun: 0.1604
happen: 0.1434
happened: 0.1604
implement: 0.1553
major: 0.1604
market: 0.1665
means: 0.1374
mind: 0.1665
minute: 0.1739
normal: 0.1665
really: 0.1000
replace: 0.1665
screen: 0.1665
things: 0.0950
told: 0.1665
user: 0.1221
virus: 0.3478
write: 0.2076

Termine con il punteggio TF-IDF più alto: computer (0.5389)

----------------------------------------------------------------------------------------------------

Question 2086:
When writing or using an algorithm, should the Big Oh complexity be mentioned?


TF-IDF Scores:
algorithm: 0.5316
big: 0.4302
mentioned: 0.5316
using: 0.3252
writing: 0.3794

Termine con il punteggio TF-IDF più alto: algorithm (0.5316)

Best Answer:
If you can back it up with real analysis, then yes, absolutely.
@Casebash test != analysis.  If it should always be documented then just start throwing
 // this algorithm is O(n!) on every function.  I've worked with people who would say things like 'This function is O(1) because there are no loops', and then I would point to the call $(someHugeList).each(function(//...


TF-IDF Scores:
absolutely: 0.2296
algorithm: 0.2296
analysis: 0.4797
documented: 0.2213
function: 0.6081
like: 0.0998
people: 0.1241
point: 0.1709
real: 0.1763
say: 0.1418
start: 0.1639
test: 0.1617
things: 0.1310
worked: 0.1935
yes: 0.1793

Termine con il punteggio TF-IDF più alto: function (0.6081)

----------------------------------------------------------------------------------------------------

Question 2164:
So I'm sure everyone has run into this person at one point or another, someone catches wind of your project or idea and initially shows some interest. You get to talking about some of your methods and usually around this time they interject stating how you should use method X instead, or just use library Y. But not as a friendly suggestion, but bordering on a commandment. Often repeating the same advice over and over like a overzealous parrot.
Personally, I like to reinvent the wheel when I'm learning, or even just for fun, even if it turns out worse than what's been done before. But this person apparently cannot fathom recreating ANY utility for such purposes, or possibly try something that doesn't strictly follow traditional OOP practices, and will settle for nothing except their sense of perfection, and thus naturally heave their criticism sludge down my ears full force. To top it off, they eventually start justifying their advice (retardation) by listing all the incredibly complex things they've coded single-handedly (usually along the lines of "trust me, I've made/used program X for a long time, blah blah blah").
Now, I'm far from being a programming master, I'm probably not even that good, and as such I value advice and critique, but I think advice/critique has a time and place. There is also a big difference between being helpful and being narcissistic. In the past I probably would have used a somewhat stronger George Carlin style dismissal, but I don't think burning bridges is the best approach anymore.
Do you have any advice on how to deal with this kind of verbal flogging?


TF-IDF Scores:
advice: 0.5855
apparently: 0.1171
approach: 0.0966
best: 0.0744
big: 0.0907
complex: 0.1016
deal: 0.1080
difference: 0.1080
eventually: 0.1171
far: 0.0945
follow: 0.0990
fun: 0.1080
good: 0.0640
helpful: 0.1046
idea: 0.0925
incredibly: 0.1121
initially: 0.1121
instead: 0.0875
kind: 0.1016
learning: 0.0822
library: 0.0945
like: 0.0974
lines: 0.1046
long: 0.0761
master: 0.1121
method: 0.1016
methods: 0.0966
oop: 0.1121
past: 0.0945
person: 0.1850
personally: 0.0945
place: 0.0907
point: 0.0835
possibly: 0.0990
practices: 0.0966
probably: 0.1722
program: 0.0907
programming: 0.0569
project: 0.0667
run: 0.0990
sense: 0.0966
shows: 0.1171
single: 0.1016
somewhat: 0.1080
start: 0.0800
strictly: 0.1171
style: 0.0966
sure: 0.0875
things: 0.0640
think: 0.1221
time: 0.1805
trust: 0.1171
try: 0.0761
use: 0.1061
used: 0.1312
usually: 0.1722
utility: 0.1171
value: 0.0990
worse: 0.1121

Termine con il punteggio TF-IDF più alto: advice (0.5855)

Best Answer:
Don't just let them talk. Get them in front of a keyboard. The phrase "ok, show me" should do it. My experience is most blow hards aren't that great, and when they actually try to do what they say it doesn't work and things get real quiet.


TF-IDF Scores:
actually: 0.2662
experience: 0.2560
great: 0.2874
keyboard: 0.3434
let: 0.3336
ok: 0.3845
real: 0.2826
say: 0.2273
talk: 0.3547
things: 0.2100
try: 0.2499
work: 0.2004

Termine con il punteggio TF-IDF più alto: ok (0.3845)

----------------------------------------------------------------------------------------------------

Question 2185:
When should a project be released to alpha, beta and to the public?
Is it a good idea to extend the alpha and beta phases when it is needed?
When in a later phase (eg. beta), is it wise to go back to an early phase (eg. alpha) if it didn't work out?


TF-IDF Scores:
alpha: 0.5749
beta: 0.5749
early: 0.1712
good: 0.1047
idea: 0.1514
later: 0.1663
needed: 0.1663
phase: 0.3536
project: 0.1092
public: 0.1916
released: 0.1916
work: 0.0999

Termine con il punteggio TF-IDF più alto: alpha (0.5749)

Best Answer:
The right time is when the product is ready for each stage.
It's up to you and the customer to define "ready". This might be when a certain number of bugs have been found and fixed or how much documentation has been completed. It all depends on the application and what the customer is expecting.
I'll ignore the alpha phase for now.
A beta phase is usually when you think you're feature complete for this release and require feedback on the fine details of your application. This is often seen as public testing, but that depends on your application. A small scale application will be beta tested by a few select users, a large application (like Visual Studio, or Stack Overflow) will be beta tested by anybody and everybody willing to help.
The official release is when you (and your customers/users) are confident that your product can do the job it's designed for. It might not have all it's features, but those you implemented for this release will be.
Alpha testing is more nebulous. It means different things to different people. You might release an early version that not feature complete because you need more user feedback on one particular aspect. You might also need to get something "out there" to meet a specific demand and can't afford to wait.


TF-IDF Scores:
alpha: 0.2022
anybody: 0.1011
application: 0.3716
beta: 0.3033
bugs: 0.0816
certain: 0.0903
complete: 0.1709
completed: 0.1011
customer: 0.1709
customers: 0.0933
define: 0.0903
depends: 0.1754
designed: 0.0933
details: 0.0854
different: 0.1400
documentation: 0.0877
early: 0.0903
feature: 0.1538
features: 0.0799
fine: 0.1011
fixed: 0.0968
help: 0.0682
implemented: 0.0834
job: 0.0691
large: 0.0933
like: 0.0421
means: 0.0799
meet: 0.1011
need: 0.1152
number: 0.0799
overflow: 0.0877
particular: 0.0799
people: 0.0523
phase: 0.1865
product: 0.1631
public: 0.1011
release: 0.3612
require: 0.0769
right: 0.0732
seen: 0.0732
select: 0.1011
small: 0.0743
specific: 0.0799
stack: 0.0877
stage: 0.1011
studio: 0.0933
tested: 0.1936
testing: 0.1511
things: 0.0552
think: 0.0527
time: 0.0519
user: 0.0710
users: 0.1538
usually: 0.0743
version: 0.0968
visual: 0.0903
wait: 0.0968
willing: 0.0968

Termine con il punteggio TF-IDF più alto: application (0.3716)

----------------------------------------------------------------------------------------------------

Question 2192:
What things tend to slow a developer down?
Please try to refrain from posting answers that:

are slow now but useful in the feature. (TDD, Refactoring, ...)
list a distraction.



TF-IDF Scores:
answers: 0.2747
developer: 0.2135
feature: 0.2408
list: 0.2224
posting: 0.3031
slow: 0.6333
tdd: 0.2747
tend: 0.2828
things: 0.1730
try: 0.2058
useful: 0.2256

Termine con il punteggio TF-IDF più alto: slow (0.6333)

Best Answer:
Oh this ones easy:

Meetings
More Meetings
Meetings about the last meeting
Meetings to prepare for the upcoming meeting
Developing a power point presentation for a meeting
Developing a power point presentation for a meeting discussing features that haven't been implemented, shouldn't be implemented, and for whatever reason that guy from sales will jump all over.  I can't predict what document you want displayed in the app based upon your current location without an internet connection or access to your hard-drive.  No really, just give up asking for it too.



TF-IDF Scores:
access: 0.1092
app: 0.1092
asking: 0.1092
based: 0.1049
connection: 0.1209
current: 0.1144
developing: 0.2349
document: 0.1354
drive: 0.1354
easy: 0.1012
features: 0.1069
hard: 0.1049
implemented: 0.2233
internet: 0.1249
meeting: 0.5414
meetings: 0.5184
ones: 0.1174
point: 0.1929
power: 0.2592
prepare: 0.1296
really: 0.0778
reason: 0.1012
sales: 0.1296
want: 0.0752

Termine con il punteggio TF-IDF più alto: meeting (0.5414)

----------------------------------------------------------------------------------------------------

Question 2204:
What steps and measures can I take to prevent deep indentations in my code?


TF-IDF Scores:
code: 0.4305
steps: 0.9026

Termine con il punteggio TF-IDF più alto: steps (0.9026)

Best Answer:
The best thing you can do is extract methods:
int Step1(int state)
{
    if (state == 100)
    {
        return Step2(state);
    }
    else
    {
        return Step3(state);
    }
}

int Step2(int state)
{
    if (state != 100)
    {
        throw new InvalidStateException(2, state);
    }

    // ....
}



TF-IDF Scores:
100: 0.2137
best: 0.0760
int: 0.4786
methods: 0.0987
new: 0.0688
return: 0.2022
state: 0.8019
thing: 0.0894
throw: 0.1146

Termine con il punteggio TF-IDF più alto: state (0.8019)

----------------------------------------------------------------------------------------------------

Question 2226:
In an earlier question, I asked for career advice for new software engineers who did well before and during college.  But what about people who weren't fortunate enough to go to MIT or Yale, for whatever reason?  What if you went to what Joel Spolsky calls a JavaSchool?
What can/should JavaSchool alumni do to develop their skills and make up for the things they missed in college?  (Or, was Joel wrong about those schools being disadvantageous?)


TF-IDF Scores:
advice: 0.2359
asked: 0.1734
calls: 0.2107
career: 0.1794
college: 0.4516
develop: 0.2107
earlier: 0.2176
joel: 0.4213
make: 0.1321
missed: 0.2359
new: 0.1356
people: 0.1221
question: 0.1408
reason: 0.1763
schools: 0.2359
skills: 0.1946
software: 0.1381
things: 0.1288
went: 0.2046
wrong: 0.1903

Termine con il punteggio TF-IDF più alto: college (0.4516)

Best Answer:
Despite the claims made by Joel in that article- and he concedes the point himself- a lot of the subject areas that may be missed by a "JavaSchool" are not necessary of many jobs.
I attended something that I suppose resembles a JavaSchool in that we spend most of our time focusing on high level languages like C# and Java, but that doesn't change the fact that "Algorithms & Data Structures" is still part of the required class list- not to mention all of the other theory-oriented classes. Granted not all "JavaSchools" are the same, but that isn't the point.
In my opinion, more important than an understanding of some of the grittier development topics is being able to problem solve effectively when unique challenges arise. As software engineers we do the vast majority of our learning on the job and as such, two of the biggest aspects of our job description are being able to problem solve and being able to pick up unfamiliar concepts. If, during an interview, one is unable to make a discernible and logical attempt at solving a problem which is new to them, then their incompatibility for a given position will likely reveal itself.
Obviously, when hiring someone for a position that requires constant exposure to and use of some intricate topic that may be missed by a JavaSchool, it is often the logical choice to go with someone who has a prior understanding, but lack of experience shouldn't always preclude job eligibility. 
More than likely, the 50 year old Java guy at your company that has been there for as long as anyone can remember did not have any understanding of Java until his job (current or previous) asked him to learn it- and he did so. Strictly speaking, it's bad practice to fire "the old guy" so that a younger and more "up-to-date" candidate can take his place; that being said, if the job description for any employee young or old changes, it is the responsibility of that employee to get caught up or find a new job. Just because an individual (especially a programmer with past experience) doesn't understand some concept, doesn't mean they are unwilling or incapable of learning it. In fact, if they are unwilling to learn then they probably do not belong at any job- much less yours.
It's fair to say that some "JavaSchools" are better than others, and that fact should certainly be considered when selecting a candidate for a position, but there are a lot more important personal traits than just where someone went to school.
It is our aptitude to tackle a problem and find a solution that defines us as engineers, most everything else is secondary.


TF-IDF Scores:
50: 0.0802
able: 0.2034
algorithms: 0.0768
areas: 0.0740
article: 0.0768
asked: 0.0590
aspects: 0.0768
attempt: 0.0768
bad: 0.0610
better: 0.0515
candidate: 0.1604
caught: 0.0802
certainly: 0.0740
challenges: 0.0768
change: 0.0555
changes: 0.0662
choice: 0.0662
class: 0.0647
classes: 0.0740
company: 0.0580
concept: 0.0716
concepts: 0.0768
considered: 0.0716
constant: 0.0802
current: 0.0678
data: 0.0555
date: 0.0740
development: 0.0474
effectively: 0.0740
especially: 0.0662
experience: 0.1068
fact: 0.1901
given: 0.0696
granted: 0.0768
high: 0.0716
hiring: 0.0802
important: 0.1143
interview: 0.0696
java: 0.1644
job: 0.3836
jobs: 0.0768
joel: 0.0716
lack: 0.0740
languages: 0.0521
learn: 0.1055
learning: 0.1127
level: 0.0621
like: 0.0334
likely: 0.1294
list: 0.0563
logical: 0.1480
long: 0.0521
lot: 0.1019
make: 0.0449
mean: 0.0662
mention: 0.0768
missed: 0.1604
necessary: 0.0740
new: 0.0922
obviously: 0.0696
old: 0.1864
opinion: 0.0740
oriented: 0.0678
past: 0.0647
personal: 0.0647
pick: 0.0716
place: 0.0621
point: 0.1143
position: 0.2406
practice: 0.0678
previous: 0.0716
prior: 0.0802
probably: 0.0590
problem: 0.2016
programmer: 0.0515
remember: 0.0678
required: 0.0716
said: 0.0600
say: 0.0474
school: 0.0768
software: 0.0470
solution: 0.0678
solve: 0.1294
solving: 0.0768
speaking: 0.0768
spend: 0.0678
strictly: 0.0802
structures: 0.0768
subject: 0.0768
suppose: 0.0802
theory: 0.0768
time: 0.0412
unable: 0.0802
understand: 0.0528
understanding: 0.2304
unfamiliar: 0.0802
unique: 0.0802
use: 0.0363
went: 0.0696
year: 0.0647

Termine con il punteggio TF-IDF più alto: job (0.3836)

----------------------------------------------------------------------------------------------------

Question 2247:
How can I track that I'm developing software more or less productive than the previous days? 


TF-IDF Scores:
days: 0.4096
developing: 0.4205
previous: 0.4329
productive: 0.4329
software: 0.2839
track: 0.4472

Termine con il punteggio TF-IDF più alto: track (0.4472)

Best Answer:
There's a simple answer: you can't. And moreover, you shouldn't.
You want to measure your own productivity, but you can generalize: how can you measure productivity of programmers? First of all you have to define what you mean for "productivity": amount of code produced? Amount of design (or specification) implemented? Number of issues fixed? Quality of produced code? (Yes, quality is a productivity counter, you can produce a lot of bad code or few good code, what has been more productive?). All these values can hardly be mapped to a daily base, and any attempt to track daily productivity is dangerous for the project, for the company, and for the programmer.
My advice is to clearly define what you mean as "productivity", then define a measure unit, and apply it on a weekly and monthly base.


TF-IDF Scores:
advice: 0.1089
answer: 0.0744
apply: 0.1089
attempt: 0.1043
bad: 0.0829
base: 0.2010
clearly: 0.1005
code: 0.1803
company: 0.0788
daily: 0.2010
define: 0.2919
design: 0.0700
fixed: 0.1043
good: 0.0595
hardly: 0.1089
implemented: 0.0899
issues: 0.1005
lot: 0.0692
mean: 0.1797
measure: 0.3268
number: 0.0861
produce: 0.1005
productive: 0.0973
productivity: 0.6536
programmer: 0.0700
programmers: 0.0677
project: 0.0621
quality: 0.1758
simple: 0.0861
track: 0.1005
unit: 0.0829
values: 0.1089
want: 0.0605
yes: 0.0814

Termine con il punteggio TF-IDF più alto: productivity (0.6536)

----------------------------------------------------------------------------------------------------

Question 2252:
I've been asked this in a few interviews. And it always catches me off guard.My professional and academic background are already in the resumé, which the interviewer has obviously looked at. What more to tell him/her? Should I start with my hobbies? I like gardening, or looking at NSFW pictures on reddit in my free time?
What and how do you answer to this specific question? Do you have a prepared answer for it? Am I wrong if I think this question is a bit silly?
UPDATE There have been a lot of great answers to this question. I'm in pickle which to choose as the 'correct' answer, because most of them are very insightful. I found a great writing on this subject matter. It's a bit crazy for my taste, but it's interesting:
How To Introduce Yourself… I Mean Practically


TF-IDF Scores:
answer: 0.3821
answers: 0.1618
asked: 0.1371
background: 0.1618
bit: 0.2889
correct: 0.1618
free: 0.1665
great: 0.2787
interesting: 0.1445
interviews: 0.1785
like: 0.0776
looking: 0.1445
lot: 0.1184
matter: 0.1665
mean: 0.1538
obviously: 0.1618
practically: 0.1865
prepared: 0.1865
professional: 0.1785
question: 0.3338
specific: 0.1473
start: 0.1274
subject: 0.1785
tell: 0.1473
think: 0.0972
time: 0.0958
update: 0.1865
writing: 0.1274
wrong: 0.1504

Termine con il punteggio TF-IDF più alto: answer (0.3821)

Best Answer:
Don't assume the interviewer knows your resumé inside out. Often, they'll be interviewing several people for the position and may have just had a cursory glance over your resumé before starting the interview.
With that in mind, and assuming this question comes early on in the interview, use this question as an opportunity to give a brief history of your career and why you are applying for the job, as well as what your stand-out skills or attributes are. 
Your answer can effectively steer the course of the interview, giving the interviewer some "jumping off" points that could change what questions you get asked next. Focusing on your strengths with this answer means that it will be more natural to talk about what makes you great in answers to subsequent questions and not as something you have to try to shoehorn in to some other answer.


TF-IDF Scores:
answer: 0.3488
answers: 0.1476
applying: 0.1702
asked: 0.1251
assume: 0.1702
assuming: 0.1702
career: 0.1295
change: 0.1179
comes: 0.1570
course: 0.1438
early: 0.1520
effectively: 0.1570
great: 0.1272
history: 0.1629
interview: 0.4429
interviewing: 0.1570
job: 0.1163
knows: 0.1520
makes: 0.1231
means: 0.1345
mind: 0.1629
opportunity: 0.1570
people: 0.0881
points: 0.1438
position: 0.1702
question: 0.2031
questions: 0.2502
skills: 0.1404
starting: 0.1476
talk: 0.1570
try: 0.1106
use: 0.0771

Termine con il punteggio TF-IDF più alto: interview (0.4429)

----------------------------------------------------------------------------------------------------

Question 2259:
Sometimes, one creates a exploratory prototype and forgets about structure in the directories...
What are good tips on dividing the programming files over (several levels of) directories?


TF-IDF Scores:
files: 0.5908
good: 0.3819
programming: 0.3396
tips: 0.6243

Termine con il punteggio TF-IDF più alto: tips (0.6243)

Best Answer:
If your language is OOP and package based (Eg Java), then you should probably keep each package in its own folder (eg my/package/name) to keep with the convention.
If your language isn't package based (Eg PHP), then organize by what each file does. Here's an example

Does this do utility functions? Goes in /util
Is this a 3rd party plugin? Goes in /plugin
Is this part of the admin panel? Goes in /admin, along with ALL supporting files
Is this Javascript? Goes in /javascript
Is this CSS? Goes in /css
Is this a template? Goes in /templates/templateName
etc

Language agnostic, Most people have a /src directory for all source files, a /lib directory for libraries, and a /bin or /dist directory for builds. 


TF-IDF Scores:
agnostic: 0.1212
based: 0.1961
css: 0.2531
directory: 0.3796
example: 0.0770
file: 0.0981
files: 0.2139
functions: 0.1167
goes: 0.6781
java: 0.0865
javascript: 0.2196
language: 0.2025
libraries: 0.1167
oop: 0.1212
organize: 0.1265
party: 0.1212
people: 0.0655
php: 0.1000
probably: 0.0930
source: 0.0963
utility: 0.1265

Termine con il punteggio TF-IDF più alto: goes (0.6781)

----------------------------------------------------------------------------------------------------

Question 2329:
Google sometimes come up with irrelevant links, not everything is available on SO, there are cases where the local documentation is also annoying to look through... Are there other efficient ways you use to search?


TF-IDF Scores:
annoying: 0.3153
available: 0.2888
cases: 0.2819
come: 0.2819
documentation: 0.2965
google: 0.2965
irrelevant: 0.3272
local: 0.3417
look: 0.2435
search: 0.3153
use: 0.1549
ways: 0.2757

Termine con il punteggio TF-IDF più alto: local (0.3417)

Best Answer:
Practise your Google-fu. Google is pretty awesome, but it's not magic. Sometimes you'll need to use search operators to get better answers, especially on some code phrases that can be difficult to search. Check out the Google Guide, for example.
If I know where the answer is, I might use the site: operator, or if I need something citable I often use inurl:edu. Google Code is handy for finding examples, and I use it to search for APIs sometimes.


TF-IDF Scores:
answer: 0.1136
answers: 0.1443
apis: 0.1663
better: 0.1068
check: 0.1314
code: 0.1377
difficult: 0.1443
especially: 0.1372
example: 0.1013
examples: 0.1372
google: 0.5772
guide: 0.1663
know: 0.0880
magic: 0.1663
need: 0.1896
operator: 0.1663
operators: 0.1592
pretty: 0.1203
search: 0.4603
site: 0.1406
use: 0.3015

Termine con il punteggio TF-IDF più alto: google (0.5772)

----------------------------------------------------------------------------------------------------

Question 2331:
Please, explain why and list which languages have the (mis)feature implemented As far you know.
Post what you consider a harmful feature, not what you dislike.


TF-IDF Scores:
consider: 0.3148
explain: 0.2680
far: 0.3079
feature: 0.5806
implemented: 0.3148
know: 0.2020
languages: 0.2480
list: 0.2680
post: 0.3521

Termine con il punteggio TF-IDF più alto: feature (0.5806)

Best Answer:
Register Globals in PHP
Information : http://php.net/manual/en/security.globals.php
This is by far the worst feature to be ever implemented for readability reasons and security reasons. Basicly all the GET parameter received are transformed into variables.
For example with this URL : /index.php?value=foobar
You can do the following :
<?php
echo $value; // return foobar
?>

When you are reading code, it is very confusing to know where the variable comes from.
Also if the feature is misused, it can lead to security hole. Here's a code example from php.net that shows how it can be misused :
<?php
// define $authorized = true only if user is authenticated
if (authenticated_user()) {
    $authorized = true;
}

// Because we didn't first initialize $authorized as false, this might be
// defined through register_globals, like from GET auth.php?authorized=1
// So, anyone can be seen as authenticated!
if ($authorized) {
    include "/highly/sensitive/data.php";
}
?>



TF-IDF Scores:
code: 0.0884
comes: 0.0985
data: 0.0740
define: 0.0954
defined: 0.1068
example: 0.1300
false: 0.1068
far: 0.0862
feature: 0.1625
following: 0.0927
http: 0.0954
implemented: 0.0881
include: 0.0927
information: 0.0827
know: 0.0565
lead: 0.0985
like: 0.0444
net: 0.1570
php: 0.7594
readability: 0.0985
reading: 0.0827
reasons: 0.1762
return: 0.0903
security: 0.2861
seen: 0.0773
shows: 0.1068
true: 0.1805
user: 0.0750
value: 0.1805
variables: 0.1068

Termine con il punteggio TF-IDF più alto: php (0.7594)

----------------------------------------------------------------------------------------------------

Question 2410:
I am referring to explaining to the non-programmer what programming is. I made sure to search for similar questions before creating this one, but the few ones I did find seemed to dodge the question, and I specifically would like to see some metaphors or analogies. I personally find it easier to explain something technical to someone through the use of metaphors or analogies.
The reason I'm interested in this is because many people encounter the work of a programmer on a daily basis, but if you ask the average person what a programmer is or does, they don't really know. This leads to certain situations of misunderstanding (ex. "[...] but I thought you were good with computers!")
I really would like to find the best one out there. I would like to be able to easily explain to someone what my career choice is about. Of course, at least the general idea.
I personally don't have a solid one, but I have long thought about it and I have usually gravitated towards the 'language' metaphor, where we happen to know a language that computers understand, and therefore we are able to tell computers what to do, or "teach" them, to solve our problems.
For example:

Imagine that in an alternate reality, humanoid robots with artificial intelligence exist, and some people are able to communicate with them through a common language, which is a variation of English. These people who can communicate with the robots are able to teach them how to solve certain problems or do certain tasks, like doing our chores.
Well, although robots like that don't exist yet, programmers of our time are like those people, but instead of communicating with the robots, they communicate with computers. Programmers "teach" the computers how to perform certain tasks or solve certain problems by means of software which they create by using this "common language".
Programmers and this "common language" are what give us things like email, websites, video games, word processors, smart phones (to put it simply), and many other things which we use on a daily basis.

I don't mean to put programming on the throne or anything, it's just the best metaphor I could come up with.
I'm sure someone will find some issue with this one, it's probably a bit contrived, but then again that's why I'm asking this question.


TF-IDF Scores:
able: 0.2815
ask: 0.0622
asking: 0.0672
best: 0.1058
bit: 0.0645
career: 0.0633
certain: 0.3718
choice: 0.0687
come: 0.0687
common: 0.1755
course: 0.0704
create: 0.0672
creating: 0.0797
daily: 0.1536
easier: 0.0722
easily: 0.0722
email: 0.0768
encounter: 0.0833
english: 0.0768
example: 0.0507
exist: 0.1665
explain: 0.1170
explaining: 0.0833
games: 0.0744
general: 0.0722
good: 0.0455
happen: 0.0687
idea: 0.0658
instead: 0.0622
interested: 0.0687
issue: 0.0645
know: 0.0881
language: 0.2221
like: 0.2425
long: 0.0541
mean: 0.0687
means: 0.0658
non: 0.0585
ones: 0.0722
people: 0.1724
person: 0.0658
personally: 0.1344
probably: 0.0612
problems: 0.1974
programmer: 0.1605
programmers: 0.1553
programming: 0.0809
question: 0.0994
questions: 0.0612
reality: 0.0833
really: 0.0958
reason: 0.0622
search: 0.0768
similar: 0.0658
simply: 0.0722
situations: 0.0797
software: 0.0488
solve: 0.2015
specifically: 0.0768
sure: 0.1245
tasks: 0.1344
teach: 0.2498
technical: 0.0658
tell: 0.0658
things: 0.0910
thought: 0.1536
time: 0.0428
understand: 0.0548
use: 0.0755
using: 0.0488
usually: 0.0612
websites: 0.0833
word: 0.0797
work: 0.0434

Termine con il punteggio TF-IDF più alto: certain (0.3718)

Best Answer:
I write very, very detailed instructions for a very, very dumb machine. 


TF-IDF Scores:
machine: 0.8486
write: 0.5290

Termine con il punteggio TF-IDF più alto: machine (0.8486)

----------------------------------------------------------------------------------------------------

Question 2497:
How useful are infix operators in a programming language? Are they worth the extra complexity they provide? Can you provide any examples where infix operators are better suited to the problem that can't be handled by just overloading the normal operators?


TF-IDF Scores:
better: 0.1484
examples: 0.1906
extra: 0.2131
handled: 0.2310
language: 0.1232
normal: 0.2212
operators: 0.6635
problem: 0.1451
programming: 0.1122
provide: 0.4423
suited: 0.2310
useful: 0.1646
worth: 0.1698

Termine con il punteggio TF-IDF più alto: operators (0.6635)

Best Answer:
I think infix operators stem from mathematics.
This:
2 + 3 * 4

is more readable to most people, than
(+ 2 (* 3 4))

because most people are familiar with mathematics.
Interesting enough in Haskell you can hop between infix and prefix.
This is using the same funtion "(+)":
(+) 1 2
1 + 2

and this is using the same function "elem":
elem 42 [1,2,42]
42 `elem` [1,2,42]



TF-IDF Scores:
familiar: 0.3604
function: 0.3046
haskell: 0.3127
interesting: 0.2793
operators: 0.3451
people: 0.3730
readable: 0.3604
think: 0.1879
using: 0.4221

Termine con il punteggio TF-IDF più alto: using (0.4221)

----------------------------------------------------------------------------------------------------

Question 2654:
In response to This Question, I ask:   What are the best parts of your coding standard?
What are the best practices that help with code quality, reliability, maintainability, readability, etc.
Please include the language, the item from the standard, and the reason it improves your code.


TF-IDF Scores:
ask: 0.2341
best: 0.3979
code: 0.2592
coding: 0.2060
help: 0.2112
include: 0.2717
language: 0.1671
practices: 0.2584
quality: 0.2527
question: 0.1869
readability: 0.2889
reason: 0.2341
standard: 0.4765

Termine con il punteggio TF-IDF più alto: standard (0.4765)

Best Answer:
Just one public class must be put in each file, no more.


TF-IDF Scores:
class: 0.5377
file: 0.5164
public: 0.6665

Termine con il punteggio TF-IDF più alto: public (0.6665)

----------------------------------------------------------------------------------------------------

Question 2682:
We’re working on a .Net framework which ultimately amounts to a single DLL.  We intend to charge for commercial use of the framework, but make it free for open source/non-commercial use.  The rough plan at the moment is to administer this through some form of fairly simple licence which will be issued whether you’re using it for free or paying.
We’re debating whether to make the source code available.  It’s our perception (and our own preference) that it’s far more appealing to use something where you have access to the source code.
I’m interested in whether people think making the source code available will damage our ability to make money from the framework, or whether it will encourage more usage and enough “good” people will arrange to pay for the correct licence if using it commercially.
My feeling is that, generally, commercial operations don’t mess about on the licencing front and so making the source code available will only encourage usage and therefore ultimately generate more revenue, but I’d be interested in others views/experience.


TF-IDF Scores:
ability: 0.0998
access: 0.0873
available: 0.2744
charge: 0.1082
code: 0.1792
commercial: 0.3247
correct: 0.0939
encourage: 0.1997
experience: 0.0721
fairly: 0.0998
far: 0.0873
feeling: 0.1082
form: 0.0998
framework: 0.2470
free: 0.1933
generally: 0.0893
generate: 0.1082
good: 0.0591
interested: 0.1786
make: 0.1819
making: 0.1786
moment: 0.1082
money: 0.0967
net: 0.0796
non: 0.0760
open: 0.0823
operations: 0.1082
pay: 0.0998
paying: 0.1082
people: 0.1120
plan: 0.1082
rough: 0.1082
simple: 0.0855
single: 0.0939
source: 0.4116
think: 0.0564
ultimately: 0.2165
usage: 0.2165
use: 0.1471
using: 0.1268
views: 0.1082
working: 0.0712

Termine con il punteggio TF-IDF più alto: source (0.4116)

Best Answer:
If it is a managed .NET framework, people can use Reflector to look at the source code anyway.
I've seen a number of companies that appear to work this dual-licensing model successfully.  Having access to the source code doesn't necessarily mean that people will steal the code. Personally, I would rather be properly licensed, as has any company I have ever worked for.  But having access to the source code can encourage people to try your product out.  
There's something about having access to the source that feels like a security blanket; you know that you will probably never need it, but if you spend many man-hours worth of effort committing to a third-party library, it's good to know you can dig into the code and fix something if you ever get into a bind, or the original author of the code gets thrown under a bus.


TF-IDF Scores:
access: 0.3388
appear: 0.1400
author: 0.1340
code: 0.3476
companies: 0.1250
company: 0.1013
effort: 0.1250
encourage: 0.1291
feels: 0.1340
fix: 0.1129
framework: 0.1065
gets: 0.1215
good: 0.0765
hours: 0.1250
know: 0.1482
library: 0.1129
like: 0.0582
look: 0.0998
man: 0.1340
managed: 0.1291
mean: 0.1155
model: 0.1183
necessarily: 0.1250
need: 0.0798
net: 0.1029
number: 0.1106
original: 0.1215
party: 0.1340
people: 0.2173
personally: 0.1129
probably: 0.1029
product: 0.1129
properly: 0.1340
security: 0.1250
seen: 0.1013
source: 0.4259
spend: 0.1183
successfully: 0.1400
thrown: 0.1400
try: 0.0910
use: 0.0634
work: 0.0730
worked: 0.1129
worth: 0.1029

Termine con il punteggio TF-IDF più alto: source (0.4259)

----------------------------------------------------------------------------------------------------

Question 2699:
This is a "Share the Knowledge" question. I am interested in learning from your successes and/or failures.
Information that might be helpful...
Background:

Context: Language, Application,
Environment, etc.
How was the bug identified ?
Who or what identified the bug ?
How complex was reproducing the bug ? 

The Hunting.

What was your plan  ?
What difficulties did you encounter ?
How was the offending code finally found ?

The Killing.

How complex was the fix ?
How did you determine the scope of the fix ?
How much code was involved in the fix ?

Postmortem.

What was the root cause technically ? buffer overrun, etc.
What was the root cause from 30,000 ft ?
How long did the process ultimately take ?
Were there any features adversely effected by the fix ?
What methods, tools, motivations did you find particularly helpful ? ...horribly useless ?
If you could do it all again
?............

These examples are general, not applicable in every situation and possibly useless. Please season as needed.


TF-IDF Scores:
000: 0.1364
30: 0.1306
applicable: 0.1364
application: 0.1003
background: 0.1184
bug: 0.3377
cause: 0.2368
code: 0.1129
complex: 0.2368
context: 0.1219
determine: 0.1306
encounter: 0.1364
environment: 0.1126
examples: 0.1126
features: 0.1078
fix: 0.4403
general: 0.1184
helpful: 0.2437
horribly: 0.1364
information: 0.1057
interested: 0.1126
involved: 0.1219
knowledge: 0.1038
language: 0.0728
learning: 0.0958
long: 0.0887
methods: 0.1126
needed: 0.1184
particularly: 0.1259
plan: 0.1364
possibly: 0.1153
process: 0.0987
question: 0.0814
scope: 0.1364
share: 0.1259
situation: 0.1153
tools: 0.1101
ultimately: 0.1364
useless: 0.2613

Termine con il punteggio TF-IDF più alto: fix (0.4403)

Best Answer:
It was actually in a 3rd party image viewer sub-component of our application. 
We found that there were 2-3 of the users of our application would frequently have the image viewer component throw an exception and die horribly. However, we had dozens of other users who never saw the issue despite using the application for the same task for most of the work day. Also there was one user in particular who got it a lot more frequently than the rest of them.
We tried the usual steps: 
(1) Had them switch computers with another user who never had the problem to rule out the computer/configuration. - The problem followed them.
(2) Had them log into the application and work as a user that never saw the problem. - The problem STILL followed them.
(3) Had the user report which image they were viewing and set up a test harness to repeat viewing that image thousands of times in quick succession. The problem did not present itself in the harness.  
(4) Had a developer sit with the users and watch them all day. They saw the errors, but didn't notice them doing anything out of the ordinary to cause them.
We struggled with this for weeks trying to figure out what the "Error Users" had in common that the other users didn't. I have no idea how, but the developer in step (4) had a eureka moment on the drive in to work one day worthy of Encyclopedia Brown.
He realized that all the "Error Users" were left handed, and confirmed this fact. Only left-handed users got the errors, never Righties. But how could being left handed cause a bug?
We had him sit down and watch the left-handers again specifically paying attention to anything they might be doing differently, and that's how we found it.
It turned out that the bug only happened if you moved the mouse to rightmost column of pixels in the image viewer while it was loading a new image (overflow error because the vendor had a 1-off calculation for mouseover event). 
Apparently, while waiting for the next image to load, the users all naturally moved their hand (and thus the mouse)  towards the keyboard. 
The one user who happened to get the error most frequently was one of those ADD types that compulsively moved her mouse around a lot impatiently while waiting for the next page to load, thus she was moving the mouse to the right much more quickly and hitting the timing just right so she did it when the load event happened. Until we got a fix from the vendor, we told her just to let go of the mouse after clicking (next document) and not touch it until it loaded. 
It was henceforth known in legend on the dev team as "The Left Handed Bug"


TF-IDF Scores:
actually: 0.0467
add: 0.0585
apparently: 0.0674
application: 0.1981
attention: 0.0674
bug: 0.1667
cause: 0.1169
common: 0.0473
computer: 0.0522
day: 0.1631
dev: 0.0674
developer: 0.0909
differently: 0.0674
document: 0.0674
drive: 0.0674
error: 0.2277
errors: 0.1112
event: 0.1290
exception: 0.0674
fact: 0.0532
figure: 0.0674
fix: 0.0544
frequently: 0.1708
got: 0.1667
hand: 0.0622
happened: 0.1865
horribly: 0.0674
idea: 0.0532
issue: 0.0522
keyboard: 0.0602
known: 0.0674
left: 0.3369
let: 0.0585
load: 0.1935
lot: 0.0856
moment: 0.0674
moving: 0.0622
new: 0.0387
notice: 0.0645
ordinary: 0.0674
overflow: 0.0585
page: 0.0645
particular: 0.0532
party: 0.0645
paying: 0.0674
problem: 0.2116
quickly: 0.0585
repeat: 0.0645
report: 0.0622
right: 0.0975
rule: 0.0645
saw: 0.2021
set: 0.0495
sit: 0.1347
specifically: 0.0622
step: 0.0622
steps: 0.0585
task: 0.0522
team: 0.0467
test: 0.0454
throw: 0.0645
times: 0.0522
told: 0.0645
touch: 0.0622
tried: 0.0602
trying: 0.0480
types: 0.0585
user: 0.2366
users: 0.4100
using: 0.0395
usual: 0.0674
waiting: 0.1347
weeks: 0.0674
work: 0.1054

Termine con il punteggio TF-IDF più alto: users (0.4100)

----------------------------------------------------------------------------------------------------

Question 2700:
I have had a few that I am proud of and some of them were written by myself few years ago. It doesn't have to be necessarily buggy, just bad code. 


TF-IDF Scores:
ago: 0.4684
bad: 0.3989
code: 0.2170
necessarily: 0.4684
written: 0.4684
years: 0.3683

Termine con il punteggio TF-IDF più alto: ago (0.4684)

Best Answer:
I don't know about being proud of the fix because it was so obvious, but the most horrible code I remember fixing was this.
if (userName=="John O'Reily") { userName= "John O''Reily";}
if (userName=="Stacy O'Neil") { userName= "Stacy O''Neil";}
if (userName=="Finnegan O'Connor") { userName= "Finnegan O''Connor";}
...
someSQL = "SELECT * from Users where UserName='" + userName + "'";

Apparently the previous developer just kept adding new lines every time a new (usually Irish) user started getting errors in the application.
I'll leave it as an exercise for the class as to how it was fixed.


TF-IDF Scores:
apparently: 0.2393
application: 0.1759
class: 0.1930
code: 0.0990
developer: 0.1613
errors: 0.1974
exercise: 0.2137
fix: 0.1930
fixed: 0.2291
fixing: 0.2393
getting: 0.1854
kept: 0.2393
know: 0.1266
leave: 0.2022
lines: 0.2137
new: 0.2752
obvious: 0.2207
previous: 0.2137
remember: 0.2022
select: 0.2393
started: 0.1930
time: 0.1229
user: 0.1680
users: 0.1820
usually: 0.1759

Termine con il punteggio TF-IDF più alto: new (0.2752)

----------------------------------------------------------------------------------------------------

Question 2715:
Should curly braces be on their own line or not? What do you think about it?
if (you.hasAnswer()) {
    you.postAnswer();
} else {
    you.doSomething();
}

or should it be
if (you.hasAnswer())
{
    you.postAnswer();
}
else
{
    you.doSomething();
}

or even
if (you.hasAnswer())
    you.postAnswer();
else
    you.doSomething();

Please be constructive! Explain why, share experiences, back it up with facts and references.


TF-IDF Scores:
braces: 0.4388
experiences: 0.4388
explain: 0.3081
line: 0.3337
references: 0.4388
share: 0.4048
think: 0.2287

Termine con il punteggio TF-IDF più alto: braces (0.4388)

Best Answer:
For a long time I argued that they were of equal worth, or so very close to equal that the possible gain by making the right choice was far, far, below the cost of arguing about it. 
Being consistent is important, though. So I said let's flip a coin and get on to writing code.
I've seen programmers resist change like this before. Get over it! I've switched many times in my career. I even use different styles in my C# than in my PowerShell. 
A few years ago I was working on a team (~20 developers) that decided to ask for input, and then make a decision, and then enforce that across all the code base. We'd have 1 week to decide.
Lots of groans & eye-rolling. Lots of "I like my way, because it's better" but no substance. 
As we were studying the finer points of the question, someone asked how to deal with this issue in brace-on-the-same-line style:
void MyFunction(
    int parameterOne,
    int parameterTwo) {
    int localOne,
    int localTwo
}

Note that it's not immediately obvious where the parameter list ends, and the body begins. Compare to:
void MyFunction(
    int parameterOne,
    int parameterTwo) 
{
    int localOne,
    int localTwo
}

We did some reading on how folks around the world had dealt with this problem, and found the pattern of adding a blank line after the open brace:
void MyFunction(
    int parameterOne,
    int parameterTwo) {

    int localOne,
    int localTwo
}

If you're going to make a visual break, you may as well do it with a brace. Then your visual breaks become consistent, too.
Edit: Two alternatives to the 'extra blank line' solution when using K&R:
1/ Indent the function arguments differently from the function body
2/ Put the first argument on the same line as the function name and align further arguments on new lines to that first argument
Examples:
1/
void MyFunction(
        int parameterOne,
        int parameterTwo) {
    int localOne,
    int localTwo
}

2/
void MyFunction(int parameterOne,
                int parameterTwo) {
    int localOne,
    int localTwo
}

/Edit
I still argue that consistency is more important than other considerations, but if we don't have an established precedent, then brace-on-next-line is the way to go.


TF-IDF Scores:
20: 0.0450
ago: 0.0402
arguments: 0.0901
ask: 0.0337
asked: 0.0331
base: 0.0415
better: 0.0289
body: 0.0901
break: 0.0415
breaks: 0.0431
career: 0.0343
change: 0.0312
choice: 0.0371
close: 0.0415
code: 0.0373
consistency: 0.0450
consistent: 0.0901
cost: 0.0391
deal: 0.0415
decide: 0.0415
developers: 0.0316
different: 0.0312
differently: 0.0450
edit: 0.0727
ends: 0.0450
equal: 0.0901
examples: 0.0371
extra: 0.0415
far: 0.0727
function: 0.1142
going: 0.0321
immediately: 0.0431
important: 0.0642
indent: 0.0450
input: 0.0415
int: 0.9006
issue: 0.0349
let: 0.0391
like: 0.0375
line: 0.1713
lines: 0.0402
list: 0.0316
long: 0.0293
lots: 0.0781
make: 0.0504
making: 0.0371
new: 0.0259
note: 0.0415
obvious: 0.0415
open: 0.0343
pattern: 0.0415
points: 0.0381
possible: 0.0312
problem: 0.0283
programmers: 0.0280
question: 0.0269
reading: 0.0349
right: 0.0326
said: 0.0337
seen: 0.0326
solution: 0.0381
style: 0.0371
styles: 0.0415
team: 0.0312
time: 0.0231
times: 0.0349
use: 0.0204
using: 0.0264
visual: 0.0804
way: 0.0504
week: 0.0431
working: 0.0296
world: 0.0312
worth: 0.0331
writing: 0.0308
years: 0.0316

Termine con il punteggio TF-IDF più alto: int (0.9006)

----------------------------------------------------------------------------------------------------

Question 2756:
Coding standards are common in any software development organization, but how important are they to follow?  I can understand the need for some consistency, but when dealing with simple things like the position of braces, line length, etc., I'm not sure excessively strict standards contribute much to software development.
Isn't it more important that your code is readable, not that it conforms to a predefined standard?  It seems they're more like... guidelines anyway.


TF-IDF Scores:
braces: 0.2281
code: 0.0944
coding: 0.1500
common: 0.1602
consistency: 0.2281
dealing: 0.2281
development: 0.2697
follow: 0.1928
important: 0.3251
like: 0.1898
line: 0.1735
need: 0.1300
organization: 0.2037
position: 0.2281
readable: 0.2281
simple: 0.1802
software: 0.2671
standard: 0.1735
standards: 0.3763
sure: 0.1705
things: 0.1246
understand: 0.1500

Termine con il punteggio TF-IDF più alto: standards (0.3763)

Best Answer:
Asking everyone to 100% adhere to the same standard code formatting guideline is like asking everyone to collaborate separately on writing a 100 page paper with the same writing style.  
Hopefully everyone will write the paper in English (or same language), but different styles will be apparent.  Some will write it well, others not.  Some will use contractions, some will spell the words out fully (example: it's verus it is).  Etc.
I think you touched on the most important points: 

It's a guideline
Readability

If you want the code to adhere to the same formatting, like a paper to be in the same writing style, it'll need editing and revising.  The code will need to be cleaned up, reviewed, re-factored, etc.
I've never been in a shop where I was completely happy with another developer's coding style or formatting (at minimal because it's not exactly like mine).  But I'll be content if I can read/understand it and if it's consistent.  Everything else is the sugar on the syntactic sugar.
So to answer your question: somewhat important, but it's certainly not the end of the world if they don't.


TF-IDF Scores:
100: 0.2566
answer: 0.0981
asking: 0.2318
certainly: 0.1325
code: 0.1783
coding: 0.0945
completely: 0.1214
consistent: 0.1436
developer: 0.0969
different: 0.0995
end: 0.1039
english: 0.1325
exactly: 0.1325
example: 0.0875
important: 0.2047
language: 0.0766
like: 0.1793
need: 0.1637
page: 0.1375
paper: 0.4309
points: 0.1214
question: 0.0857
read: 0.1056
readability: 0.1325
somewhat: 0.1325
standard: 0.1093
style: 0.3555
styles: 0.1325
think: 0.0749
understand: 0.0945
use: 0.0651
want: 0.0798
words: 0.1325
world: 0.0995
write: 0.1715
writing: 0.2944

Termine con il punteggio TF-IDF più alto: paper (0.4309)

----------------------------------------------------------------------------------------------------

Question 2776:
The Joel Test is a well known test for determining how good your team is. What do you think about the points? Do you disagree with any of them? Is there anything that you would add?


TF-IDF Scores:
add: 0.3503
good: 0.2206
joel: 0.3606
known: 0.4038
points: 0.3412
team: 0.2796
test: 0.5446
think: 0.2105

Termine con il punteggio TF-IDF più alto: test (0.5446)

Best Answer:
Jeff Atwood has The Programmer's Bill of Rights.
From the post:


Every programmer shall have two monitors
Every programmer shall have a fast PC
Every programmer shall have their choice of mouse and keyboard
Every programmer shall have a comfortable chair
Every programmer shall have a fast internet connection
Every programmer shall have quiet working conditions


This seems to have some items that I'd like to see on Joel's list.  Specifically in the area of hardware (dual monitor, fast PC, mouse/keyboard, comfortable chair, fast connection).  
The only thing not mentioned is having a comfortable and adjustable desk.
This could all be added by changing:
Current #9: Do you use the best tools money can buy?
to 
Improved #9: Do you use the best tools and equipment money can buy?


TF-IDF Scores:
added: 0.1177
best: 0.1674
changing: 0.1261
choice: 0.1087
connection: 0.2353
current: 0.1113
fast: 0.4572
hardware: 0.1215
internet: 0.1215
joel: 0.1177
keyboard: 0.2353
like: 0.0548
list: 0.0925
mentioned: 0.1261
money: 0.2353
monitor: 0.1215
post: 0.1215
programmer: 0.5924
specifically: 0.1215
thing: 0.0985
tools: 0.2126
use: 0.1194
working: 0.0866

Termine con il punteggio TF-IDF più alto: programmer (0.5924)

----------------------------------------------------------------------------------------------------

Question 2777:
I have heard a lot of people mention Code Complete as a book worthwhile reading. Unfortunately, I am so busy that I don't have time to read it, so can anyone tell me what the key points of the book are?


TF-IDF Scores:
book: 0.4772
code: 0.1298
complete: 0.2651
heard: 0.2651
key: 0.3003
lot: 0.1993
mention: 0.3003
people: 0.1623
points: 0.2651
read: 0.2306
reading: 0.2431
tell: 0.2479
time: 0.1611
unfortunately: 0.3137

Termine con il punteggio TF-IDF più alto: book (0.4772)

Best Answer:
It's an intermediate book, a potpourri of software development best practices.
If you're a beginning programmer you won't understand a lot of the material, and if you are experienced, the book will only confirm what you already know.  Consequently, the book might be of most value to intermediate programmers, who already have a bit of programming knowledge, but need a book of best practices to tie it all together.
Several pages are spent on how to format code blocks, and the relative merits of each approach.  Personally, I think the great debate on where to put your curly braces is over. (or is it?)


TF-IDF Scores:
approach: 0.1693
best: 0.2606
bit: 0.1590
book: 0.6243
braces: 0.2052
code: 0.0849
development: 0.1213
experienced: 0.1964
format: 0.1893
great: 0.1534
know: 0.1086
knowledge: 0.1561
lot: 0.1303
need: 0.1169
personally: 0.1655
practices: 0.3385
programmer: 0.1318
programmers: 0.1275
programming: 0.0997
software: 0.1201
think: 0.1070
understand: 0.1349
value: 0.1734

Termine con il punteggio TF-IDF più alto: book (0.6243)

----------------------------------------------------------------------------------------------------

Question 2806:
There's around a zillion "PHP frameworks". And most of them bill themselves as following the MVC pattern. While it's welcome to overcome osCommerce coding style (processing logic heavily intermixed with SQL and HTML), there are certainly simpler and easier to follow approaches to get a maintainable application design.
The original MVC concept was targetted at GUI applications. And for Gtk/Python it seems feasible to follow it accordingly. But PHP web apps don't operate on live Views (GUI elements) and a persistent Controller runtime. It's quite certainly a misnomer if it just describes the used code + directory grouping or class naming.
"MVC" seems to be used like a buzzword for PHP frameworks. And I've actually seen one or two mature PHP frameworks admit it, but redefining the phrase anyway to match interna.
So is it generally snake oil? Why isn't better terminology used, and a more sensible concept for maintainable PHP propagated?
Some elaborative reasoning
Why I suspect that PHP implementations don't follow the real MVC pattern:
Models: in theory, Models should be fat and contain business logic, and controllers should be thin handlers (input->output). In reality the PHP frameworks advocate shallow Models. CI and Symfony for example equate Model == ORM. Even HTTP input is handled by the controller, isn't treated as model.
Views: workarounds with AJAX discounted, there can't be Views on web pages. PHP frameworks still pump out pages. The interface still effectively follows the ordinary HTTP model, there's no advantage over non-MVC applications. (And lastly, none of the widespread php frameworks can factually output to GUI Views instead of HTML. I've seen a PHP library that can operate Gtk/Console/Web, but the frameworks don't.)
Controller: I'm unsure. Controllers probably don't need to be long-running and persistently active in the MVC model. In PHP framework context, they're however mostly request handlers. Not really something to get argumentative about, but it just feels slightly buzzwordish.
Would there be better descriptors? I've seen acronyms like PMVC or HMVC thrown around. Though descriptions get more ambigous there, maybe these would describe the current web frameworks less hokey?


TF-IDF Scores:
actually: 0.0430
advocate: 0.0621
application: 0.0456
applications: 0.0981
approaches: 0.0573
apps: 0.0512
better: 0.0797
business: 0.0512
certainly: 0.1145
class: 0.0501
code: 0.0257
coding: 0.0408
concept: 0.1109
context: 0.0554
controller: 0.1862
current: 0.0525
design: 0.0399
directory: 0.0621
easier: 0.0538
effectively: 0.0573
elements: 0.0621
example: 0.0378
feels: 0.0594
follow: 0.1574
following: 0.0538
framework: 0.0472
frameworks: 0.4196
generally: 0.0512
gui: 0.1718
handled: 0.0621
html: 0.1145
http: 0.1109
input: 0.1145
instead: 0.0464
interface: 0.0621
library: 0.0501
like: 0.0516
live: 0.0573
logic: 0.1188
long: 0.0403
maintainable: 0.1188
match: 0.0594
maybe: 0.0525
model: 0.2098
need: 0.0354
non: 0.0436
ordinary: 0.0621
original: 0.0538
output: 0.1241
pattern: 0.1145
php: 0.5394
probably: 0.0456
python: 0.0501
quite: 0.0490
real: 0.0456
reality: 0.0621
really: 0.0357
reasoning: 0.0621
request: 0.0621
running: 0.0573
runtime: 0.0573
seen: 0.1347
simpler: 0.0621
sql: 0.0621
style: 0.0512
suspect: 0.0621
theory: 0.0594
thrown: 0.0621
used: 0.1043
views: 0.2483
web: 0.1769

Termine con il punteggio TF-IDF più alto: php (0.5394)

Best Answer:

But PHP web apps don't operate on live Views (GUI elements) and a persistent Controller runtime. 

No, they sure do!
Think of AJAX applications, then the view asks something to the controller and gets a partial view back,
this view or data is then filled in somewhere in the page and thus live updated.
The Controller is also persistent because you can use cookies/sessions.

"MVC" seems to be used like a buzzword for PHP frameworks.

MVC is a Software Architecture, some frameworks might use it as a buzz, but others do it properly...
See a list of some frameworks on Wikipedia.

is MVC just the SEO of php programming?

MVC and SEO are two things apart, but yes... MVC is getting more popular.


TF-IDF Scores:
apart: 0.1336
applications: 0.1103
apps: 0.1152
architecture: 0.1396
controller: 0.4188
data: 0.0967
elements: 0.1396
filled: 0.1396
frameworks: 0.3539
gets: 0.1211
getting: 0.1082
gui: 0.1288
like: 0.0581
list: 0.0980
live: 0.2576
page: 0.1336
php: 0.3309
popular: 0.1288
programming: 0.0678
properly: 0.1336
runtime: 0.1288
software: 0.0817
sure: 0.1043
things: 0.0763
think: 0.0728
updated: 0.1288
use: 0.1265
used: 0.0782
view: 0.4188
views: 0.1396
web: 0.0995
yes: 0.1043

Termine con il punteggio TF-IDF più alto: controller (0.4188)

----------------------------------------------------------------------------------------------------

Question 2829:
I originally thought of creative commons when while reading a book about wordpress (professional wordpress), I learned that I should also specify that the product is provided 

... WITHOUT ANY WARRANTY; without even the
  implied warranty of MERCHANTABILITY or
  FITNESS FOR A PARTICULAR PURPOSE

and they recommend GNU GPL.  How do I write a license or select 1?
btw, what does MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE mean actually? Isn't without warranty enough? 


TF-IDF Scores:
actually: 0.1726
book: 0.1896
learned: 0.2300
license: 0.2493
mean: 0.2056
originally: 0.2300
particular: 0.3939
product: 0.2011
professional: 0.2387
provided: 0.2300
purpose: 0.4326
reading: 0.1932
recommend: 0.2387
select: 0.2493
thought: 0.2300
write: 0.1488

Termine con il punteggio TF-IDF più alto: purpose (0.4326)

Best Answer:
For small bits of code, I generally release them under the X11 licence. The problem with the GPL is that it's far too complicated for code that you don't really care enough about to protect. If you really don't want people using your code in commercial products, you would need to monitor for infringement and fight it out in court, which isn't really worth the time or the effort for small, free, open-source projects.

Copyright (c)  
Permission is hereby granted, free of charge, to any person obtaining a copy
   of this software and associated documentation files (the "Software"), to deal
   in the Software without restriction, including without limitation the rights
   to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   copies of the Software, and to permit persons to whom the Software is
   furnished to do so, subject to the following conditions:
The above copyright notice and this permission notice shall be included in
   all copies or substantial portions of the Software.
THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   THE SOFTWARE. 

EDIT: If the body of code is more substantial, and you feel that you've invested enough time in it that you would be willing to protect it, by all means use the GPL to protect it.


TF-IDF Scores:
authors: 0.1071
bits: 0.1071
body: 0.1071
care: 0.1026
charge: 0.1071
claim: 0.1071
code: 0.1773
commercial: 0.1071
complicated: 0.0988
connection: 0.0957
contract: 0.1026
copy: 0.1976
deal: 0.0988
documentation: 0.0929
edit: 0.0864
effort: 0.0957
event: 0.1026
far: 0.0864
feel: 0.0815
files: 0.0905
following: 0.0929
free: 0.1913
generally: 0.0884
granted: 0.1026
included: 0.1071
including: 0.2142
kind: 0.0929
limited: 0.1071
means: 0.0846
modify: 0.1071
monitor: 0.0988
need: 0.0610
notice: 0.2051
open: 0.0815
particular: 0.0846
people: 0.0554
person: 0.0846
problem: 0.0673
products: 0.1071
projects: 0.0787
provided: 0.0988
purpose: 0.0929
really: 0.1848
release: 0.0957
sell: 0.1071
small: 0.1575
software: 0.5646
source: 0.0815
subject: 0.1026
time: 0.1100
use: 0.1456
using: 0.0627
want: 0.0595
willing: 0.1026
worth: 0.0787

Termine con il punteggio TF-IDF più alto: software (0.5646)

----------------------------------------------------------------------------------------------------

