Question 177:
The Actor Model which is used by Erlang seems to be a very different way to do concurrent programming. What are your thoughts about the Actor Model? Will it be a popular solution for concurrency?


----------------------------------------------------------------------------------------------------

Question 568:
Managed OSes like Microsoft Singularity and JNode are quite an interesting concept. Essentially, the OS is bootstrapped with code written in a low-level language (C/C++/Assembly), which essentially implements a virtual machine. The rest of the OS (and all userland apps) run on the virtual machine. There are some great things about this. For example, you suddenly make arbitrary pointers obsolete. And if well written, you get rid of a ton of legacy crud that most modern OSes currently have. 
However, as a disadvantage, you're that much farther away from the hardware, and as a developer, you lose the ability to drop down to a lower level of abstraction and get your hands dirty. 
What are your opinions on this?


----------------------------------------------------------------------------------------------------

Question 267291:
Very often I have to review pull requests of fellow programmers and I face the problem - what should I do when the code is not as good as I would expect? Should I reject the pull request or accept/merge even though I don't like the code? Of course, I reject when I see errors, but I can't keep rejecting again and again. This annoys my colleagues and they ask me to close my eyes and move on. But if I accept the changes I don't like - what code review is for? What can you recommend?


----------------------------------------------------------------------------------------------------

Question 267333:
I'm trying to make a service that's polymorphic based upon what mode is specified in the URL. If the char param in the route is set to 'p', I want to use a PresentMode service. If the char param is set to 'n', I want to use a NoteMode service. Each of these present the same interface, but I want to choose one at a time.
So far the best solution I've come up with is something like this:
var mod = angular.module('modeModule', []);

mod.service('modeService', function($routeParams, presentMode, noteMode) {
  if ($routeParams.char === 'p') {
    this.mode = presentMode;
  } else if ($routeParams.char === 'n') {
    this.mode = noteMode;
  }
}

mod.service('presentMode', function() {});
mod.service('noteMode', function() {});

This works, but it requires that I append .mode to the end of every access (eg modeService.mode.blah(). Is there a better way to do this?


----------------------------------------------------------------------------------------------------

Question 267444:
I currently have one separate project for my models, and one separate project for a API application that consumes this model. The intention of the separation is to avoid any outgoing dependencies from the core model to consumers like the API project, enabling me to have a nice layered structure of responsibility.
In this case though, the API can not use the model as-is, as it requires the classes to be decorated with attributes related to the serialization of the data. Since this is exactly the kind of dependencies from the model that I want to avoid, I can only see my only option being intermediate DTO's that the core model gets mapped upon.
This preserves the decoupling of the model to it's consumers, but obviously introduces some nasty redundancies where I not only manually have to create all the DTO's, but also maintain them to match an eventually changing core model. Even if AutoMapper can take care of the actual mapping.
This feels quite nasty, but since the model project is using an EDMX to define and auto generate code for the model, I'm thinking to change the t4-templates to generate an interface for every class, and using this in the consumer to put a contract on the DTO's and even let the IDE auto-implement them from the interface.
This seems quite reasonable for my, but I wonder if this would be considered a good approach for enterprise-level projects, or if I'm missing something. I guess that the extra layer of intermediate DTO's even could be seen as a good artefact in concreting a separation of the core model contract and the API contract. And if so, maybe the use of model-generated interface would conflict with this separation, even if it has some neat benefits? But in that case, maybe it would be a productive strategy to use the auto-generated interfaces where we do have an 1-to-1 mapping, and create a separate set of DTO's where the contracts actually differs?
So to be clear, I'm striving for a well partitioned and coherent architecture in order to increase general static code qualities like maintainability and cohesion. Above I gave a specific example of the partitioning of the core model from it's consumers that I try to do while rationalizing about it, and my question is whether the approach suggested could generally be considered good or not. Or could this be too specific to fit any generalized answer?


----------------------------------------------------------------------------------------------------

Question 267521:
Are there succesful ways (i.e. non spammed by 1000 bots per second!) to propose some user interaction on a website such as :

Voting up / Voting down / Liking posts
Posting comments

but without account registration and without captcha ?

I have read that filtering by IP is not relevant, for many reasons (people may have the same public IP, if they work in the same company for example, and may want to vote on the same post, without being a bot).
[I have tried solutions with honeypots HTML items that bot may fill, and normal users would not fill, but I don't think this is enough to prevent spam to come.]


----------------------------------------------------------------------------------------------------

Question 267549:
I am developing a small project to sell and I have used several Java libraries, mostly with LGPL or Apache 2.
And I have one question, for example, I am using jasypt, wich is an Apache 2 license library, but this requires the commons collections library, also Apache 2. 
Do I need to put in my license form the common collections library?.
Apache 2.0 License
Used in  Apache Commons Codec version 1.10 , Joda-Time version 2.6 , Xerial Sqlite JDBC version 3.8.7 and Jasypt version 1.9.2

<LICENSE GOES HERE>

BSD License
Used in  MigLayout version Swing 4.2 and JDatePicker version 1.3.4

<LICENSE GOES HERE>

LGPL 2.1 LICENSE
Used in PortableRXTX and RXTX version 2.2-pre2

<LICENSE GOES HERE>

Also the LGPL and the Apache force me to put the source code and the modifications, but if I have used the binaries without compiling or modifiying anything, Do I need to include the source? If I need could I post a link to githubs repos with the latest version of the library?


----------------------------------------------------------------------------------------------------

Question 267552:
I have recently joined a team in which the developers were able to work completely in live production to produce business intelligence products for customers.
Recently, management, at the advice of SAP, have moved the team to a 3 stage environment 

Develop
Test
Production

which require transports between each layer.  
The team have accepted this new constraint begrudgingly and no firm business case has been explained to them as to the benefits.  
Can anyone articulate the advantages of the 3 stage environment or point me to a white paper/case study they recommend?


----------------------------------------------------------------------------------------------------

